; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Channel.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > `RTTI Type Descriptor'
PUBLIC	??_R4thread_data_base@detail@boost@@6B@		; boost::detail::thread_data_base::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_data_base@detail@boost@@8		; boost::detail::thread_data_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_data_base@detail@boost@@8		; boost::detail::thread_data_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_data_base@detail@boost@@8	; boost::detail::thread_data_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUthread_data_base@detail@boost@@@8	; boost::detail::thread_data_base `RTTI Type Descriptor'
PUBLIC	??_R4thread_resource_error@boost@@6B@		; boost::thread_resource_error::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_resource_error@boost@@8		; boost::thread_resource_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_resource_error@boost@@8		; boost::thread_resource_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_resource_error@boost@@8	; boost::thread_resource_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4thread_exception@boost@@6B@		; boost::thread_exception::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_exception@boost@@8			; boost::thread_exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_exception@boost@@8			; boost::thread_exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_exception@boost@@8		; boost::thread_exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DRAMsimWSSoapHttp@@6B@			; DRAMsimWSSoapHttp::`RTTI Complete Object Locator'
PUBLIC	??_R3DRAMsimWSSoapHttp@@8			; DRAMsimWSSoapHttp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DRAMsimWSSoapHttp@@8			; DRAMsimWSSoapHttp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8		; DRAMsimWSSoapHttp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDRAMsimWSSoapHttp@@@8			; DRAMsimWSSoapHttp `RTTI Type Descriptor'
PUBLIC	??_R4_ns2__submitEpochResultResponseElement@@6B@ ; _ns2__submitEpochResultResponseElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__submitEpochResultResponseElement@@8	; _ns2__submitEpochResultResponseElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__submitEpochResultResponseElement@@8	; _ns2__submitEpochResultResponseElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__submitEpochResultResponseElement@@@8 ; _ns2__submitEpochResultResponseElement `RTTI Type Descriptor'
PUBLIC	??_R4_ns2__submitEpochResultElement@@6B@	; _ns2__submitEpochResultElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__submitEpochResultElement@@8		; _ns2__submitEpochResultElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__submitEpochResultElement@@8		; _ns2__submitEpochResultElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8	; _ns2__submitEpochResultElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__submitEpochResultElement@@@8	; _ns2__submitEpochResultElement `RTTI Type Descriptor'
PUBLIC	?moveToTime@Channel@DRAMsimII@@UAEX_J@Z		; DRAMsimII::Channel::moveToTime
PUBLIC	?nextTick@Channel@DRAMsimII@@UBE_JXZ		; DRAMsimII::Channel::nextTick
PUBLIC	?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::earliestExecuteTimeLog
PUBLIC	?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::earliestExecuteTime
PUBLIC	?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::minProtocolGap
PUBLIC	?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ ; DRAMsimII::Channel::readNextCommand
PUBLIC	??_R4Channel@DRAMsimII@@6B@			; DRAMsimII::Channel::`RTTI Complete Object Locator'
PUBLIC	??_R3Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Channel@DRAMsimII@@8		; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVChannel@DRAMsimII@@@8			; DRAMsimII::Channel `RTTI Type Descriptor'
PUBLIC	??_R4Event@DRAMsimII@@6B@			; DRAMsimII::Event::`RTTI Complete Object Locator'
PUBLIC	??_R3Event@DRAMsimII@@8				; DRAMsimII::Event::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Event@DRAMsimII@@8				; DRAMsimII::Event::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Event@DRAMsimII@@8		; DRAMsimII::Event::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVEvent@DRAMsimII@@@8			; DRAMsimII::Event `RTTI Type Descriptor'
PUBLIC	??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@ ; `string'
PUBLIC	??_C@_03LOIFCCKL@ns2?$AA@			; `string'
PUBLIC	??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@ ; `string'
PUBLIC	??_C@_03JFKIHBGI@ns1?$AA@			; `string'
PUBLIC	??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@ ; `string'
PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@ ; `string'
PUBLIC	??_C@_03CHBGNADK@xsd?$AA@			; `string'
PUBLIC	??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@ ; `string'
PUBLIC	??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@ ; `string'
PUBLIC	??_C@_03JCLIKOHH@xsi?$AA@			; `string'
PUBLIC	??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@ ; `string'
PUBLIC	??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_08HIKNMPCP@SOAP?9ENC?$AA@			; `string'
PUBLIC	??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@ ; `string'
PUBLIC	??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_08EPBICJDL@SOAP?9ENV?$AA@			; `string'
PUBLIC	?setRankID@Rank@DRAMsimII@@QAEXI@Z		; DRAMsimII::Rank::setRankID
PUBLIC	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	??0?$allocator@_J@std@@QAE@XZ			; std::allocator<__int64>::allocator<__int64>
PUBLIC	??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z ; std::_Iter_cat<__int64 *>
PUBLIC	??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z ; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
PUBLIC	?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Ufill
PUBLIC	?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Construct_n
PUBLIC	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>
PUBLIC	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
PUBLIC	??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
PUBLIC	??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy
PUBLIC	?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n
PUBLIC	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
PUBLIC	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve
PUBLIC	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >
PUBLIC	??0?$allocator@_J@std@@QAE@ABV01@@Z		; std::allocator<__int64>::allocator<__int64>
PUBLIC	??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>
PUBLIC	??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
PUBLIC	??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
PUBLIC	??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill
PUBLIC	?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n
PUBLIC	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
PUBLIC	??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
PUBLIC	??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >
PUBLIC	??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy
PUBLIC	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop
PUBLIC	??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >
PUBLIC	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >
PUBLIC	?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Tidy
PUBLIC	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
PUBLIC	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy
PUBLIC	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> >::deallocate
PUBLIC	??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z ; std::_Destroy<std::pair<unsigned int,__int64> *>
PUBLIC	?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z ; std::allocator<std::pair<unsigned int,__int64> *>::destroy
PUBLIC	?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back
PUBLIC	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
PUBLIC	??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
PUBLIC	??_GChannel@DRAMsimII@@UAEPAXI@Z		; DRAMsimII::Channel::`scalar deleting destructor'
PUBLIC	?getArrivalTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getArrivalTime
PUBLIC	?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size
PUBLIC	?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>
PUBLIC	??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
PUBLIC	??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
PUBLIC	?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin
PUBLIC	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
PUBLIC	??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
PUBLIC	?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front
PUBLIC	?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front
PUBLIC	??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z ; std::_Destroy<std::pair<unsigned int,__int64> >
PUBLIC	?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z ; std::allocator<std::pair<unsigned int,__int64> >::destroy
PUBLIC	?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty
PUBLIC	?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front
PUBLIC	?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop
PUBLIC	??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z		; std::_Min_element<__int64 const *>
PUBLIC	?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base
PUBLIC	??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>
PUBLIC	??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ ; DRAMsimII::Transaction::getOriginalTransaction
PUBLIC	?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Command::removeHost
PUBLIC	??0?$pair@I_J@std@@QAE@ABIAB_J@Z		; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>
PUBLIC	??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,__int64> >
PUBLIC	?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> >::allocate
PUBLIC	??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >
PUBLIC	?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z ; std::allocator<std::pair<unsigned int,__int64> >::construct
PUBLIC	?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate
PUBLIC	??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z ; std::_Allocate<std::pair<unsigned int,__int64> *>
PUBLIC	?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocate
PUBLIC	?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int,__int64> >::max_size
PUBLIC	?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size
PUBLIC	?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
PUBLIC	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
PUBLIC	?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push
PUBLIC	?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Event::setEnqueueTime
PUBLIC	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
PUBLIC	?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front
PUBLIC	?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert
PUBLIC	?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull
PUBLIC	?isRead@Transaction@DRAMsimII@@QBE_NXZ		; DRAMsimII::Transaction::isRead
PUBLIC	?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm
PUBLIC	?getEpoch@SystemConfiguration@DRAMsimII@@QBEIXZ	; DRAMsimII::SystemConfiguration::getEpoch
PUBLIC	?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size
PUBLIC	??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@I@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::size
PUBLIC	??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[]
PUBLIC	?getRowReduction@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@XZ ; DRAMsimII::Statistics::getRowReduction
PUBLIC	?getHitRate@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@XZ ; DRAMsimII::Statistics::getHitRate
PUBLIC	?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ ; DRAMsimII::Bank::accumulateAndResetCounts
PUBLIC	?getRASCount@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::getRASCount
PUBLIC	?getReadCycles@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getReadCycles
PUBLIC	?getWriteCycles@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getWriteCycles
PUBLIC	?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ	; DRAMsimII::Rank::resetCycleCounts
PUBLIC	?getVDD@PowerConfig@DRAMsimII@@QBEMXZ		; DRAMsimII::PowerConfig::getVDD
PUBLIC	?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ ; DRAMsimII::PowerConfig::getLastCalculation
PUBLIC	?getPdsACT_STBY@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsACT_STBY
PUBLIC	?getPdsACT_PDN@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsACT_PDN
PUBLIC	?getPdsPRE_STBY@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsPRE_STBY
PUBLIC	?getPdsPRE_PDN@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsPRE_PDN
PUBLIC	?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsACT
PUBLIC	?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ		; DRAMsimII::PowerConfig::getPdsRD
PUBLIC	?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ		; DRAMsimII::PowerConfig::getPdsWR
PUBLIC	?gettRC@PowerConfig@DRAMsimII@@QBEIXZ		; DRAMsimII::PowerConfig::gettRC
PUBLIC	?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ ; DRAMsimII::PowerConfig::getDevicesPerRank
PUBLIC	?getIDD1@PowerConfig@DRAMsimII@@QBEHXZ		; DRAMsimII::PowerConfig::getIDD1
PUBLIC	?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ; DRAMsimII::PowerConfig::getVoltageScaleFactor
PUBLIC	?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ; DRAMsimII::PowerConfig::getFrequencyScaleFactor
PUBLIC	?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z ; DRAMsimII::PowerConfig::setLastCalculation
PUBLIC	?getChannelID@Channel@DRAMsimII@@QBEIXZ		; DRAMsimII::Channel::getChannelID
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$allocator@N@std@@QAE@XZ			; std::allocator<double>::allocator<double>
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::end
PUBLIC	??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
PUBLIC	?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::begin
PUBLIC	?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::capacity
PUBLIC	??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<double *,double *,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
PUBLIC	??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
PUBLIC	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
PUBLIC	??$_Fill@PANN@std@@YAXPAN0ABN@Z			; std::_Fill<double *,double>
PUBLIC	??$fill@PANN@std@@YAXPAN0ABN@Z			; std::fill<double *,double>
PUBLIC	??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ; std::_Iter_random<double *,double *>
PUBLIC	??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ; std::_Move_cat<double *>
PUBLIC	??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ; stdext::_Unchecked_move_backward<double *,double *>
PUBLIC	?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-
PUBLIC	??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+
PUBLIC	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
PUBLIC	??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ; std::_Iter_cat<double *>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<double *>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPAN@Z		; std::_Checked_base<double *>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z	; stdext::unchecked_fill_n<double *,unsigned int,double>
PUBLIC	??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ; std::vector<double,std::allocator<double> >::_Ufill
PUBLIC	?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z ; std::vector<double,std::allocator<double> >::push_back
PUBLIC	?size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::size
PUBLIC	??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[]
PUBLIC	??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>
PUBLIC	??0?$value@N@_bi@boost@@QAE@ABN@Z		; boost::_bi::value<double>::value<double>
PUBLIC	??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
PUBLIC	??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
PUBLIC	??0?$value@_J@_bi@boost@@QAE@AB_J@Z		; boost::_bi::value<__int64>::value<__int64>
PUBLIC	??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >
PUBLIC	??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >
PUBLIC	??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >
PUBLIC	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??0noncopyable@noncopyable_@boost@@IAE@XZ	; boost::noncopyable_::noncopyable::noncopyable
PUBLIC	?initialize@basic_timed_mutex@detail@boost@@QAEXXZ ; boost::detail::basic_timed_mutex::initialize
PUBLIC	??0mutex@boost@@QAE@XZ				; boost::mutex::mutex
PUBLIC	??1noncopyable@noncopyable_@boost@@IAE@XZ	; boost::noncopyable_::noncopyable::~noncopyable
PUBLIC	?destroy@basic_timed_mutex@detail@boost@@QAEXXZ	; boost::detail::basic_timed_mutex::destroy
PUBLIC	??1mutex@boost@@QAE@XZ				; boost::mutex::~mutex
PUBLIC	?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z ; intrusive_ptr_add_ref
PUBLIC	??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>
PUBLIC	??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z ; boost::detail::heap_delete<boost::detail::thread_data_base>
PUBLIC	?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z ; intrusive_ptr_release
PUBLIC	??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
PUBLIC	??0bad_alloc@std@@QAE@XZ			; std::bad_alloc::bad_alloc
PUBLIC	?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z ; boost::detail::allocate_raw_heap_memory
PUBLIC	?free_raw_heap_memory@detail@boost@@YAXPAX@Z	; boost::detail::free_raw_heap_memory
PUBLIC	??_Gthread_resource_error@boost@@UAEPAXI@Z	; boost::thread_resource_error::`scalar deleting destructor'
PUBLIC	??0thread_resource_error@boost@@QAE@ABV01@@Z	; boost::thread_resource_error::thread_resource_error
PUBLIC	??_Gthread_exception@boost@@UAEPAXI@Z		; boost::thread_exception::`scalar deleting destructor'
PUBLIC	??0thread_exception@boost@@QAE@ABV01@@Z		; boost::thread_exception::thread_exception
PUBLIC	?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z ; boost::detail::win32::create_anonymous_event
PUBLIC	??0handle_manager@win32@detail@boost@@QAE@PAX@Z	; boost::detail::win32::handle_manager::handle_manager
PUBLIC	??0thread_data_base@detail@boost@@QAE@XZ	; boost::detail::thread_data_base::thread_data_base
PUBLIC	??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
PUBLIC	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
PUBLIC	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??0list0@_bi@boost@@QAE@XZ			; boost::_bi::list0::list0
PUBLIC	?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap
PUBLIC	?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ ; boost::_bi::value<DRAMsimII::Channel *>::get
PUBLIC	??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>
PUBLIC	?get@?$value@N@_bi@boost@@QAEAANXZ		; boost::_bi::value<double>::get
PUBLIC	??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z ; boost::_bi::list0::operator[]<double>
PUBLIC	?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get
PUBLIC	??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >
PUBLIC	?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get
PUBLIC	??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >
PUBLIC	?get@?$value@_J@_bi@boost@@QAEAA_JXZ		; boost::_bi::value<__int64>::get
PUBLIC	??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z ; boost::_bi::list0::operator[]<__int64>
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
PUBLIC	??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int const *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??0?$allocator@N@std@@QAE@ABV01@@Z		; std::allocator<double>::allocator<double>
PUBLIC	??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
PUBLIC	?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@NHPBNABN@std@@QAE@XZ		; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
PUBLIC	??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
PUBLIC	?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::end
PUBLIC	??$_Allocate@N@std@@YAPANIPAN@Z			; std::_Allocate<double>
PUBLIC	?allocate@?$allocator@N@std@@QAEPANI@Z		; std::allocator<double>::allocate
PUBLIC	?max_size@?$allocator@N@std@@QBEIXZ		; std::allocator<double>::max_size
PUBLIC	?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::max_size
PUBLIC	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
PUBLIC	?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ; std::vector<double,std::allocator<double> >::_Buy
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>
PUBLIC	??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<double const *,double *,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z ; boost::get_pointer<DRAMsimII::Channel>
PUBLIC	??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>
PUBLIC	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
PUBLIC	??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator()
PUBLIC	?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run
PUBLIC	?cleanup@handle_manager@win32@detail@boost@@AAEXXZ ; boost::detail::win32::handle_manager::cleanup
PUBLIC	??1handle_manager@win32@detail@boost@@QAE@XZ	; boost::detail::win32::handle_manager::~handle_manager
PUBLIC	??_Gthread_data_base@detail@boost@@UAEPAXI@Z	; boost::detail::thread_data_base::`scalar deleting destructor'
PUBLIC	??1thread_data_base@detail@boost@@UAE@XZ	; boost::detail::thread_data_base::~thread_data_base
PUBLIC	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >
PUBLIC	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >
PUBLIC	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor'
PUBLIC	??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
PUBLIC	??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; DRAMsimII::SystemConfiguration::getSessionID
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@HHPBHABH@std@@QAE@XZ		; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ; std::_Iter_cat<float *>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z	; stdext::unchecked_fill_n<float *,unsigned int,float>
PUBLIC	??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ; std::vector<float,std::allocator<float> >::_Ufill
PUBLIC	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::capacity
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@MHPBMABM@std@@QAE@XZ		; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
PUBLIC	??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
PUBLIC	??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
PUBLIC	?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ; std::vector<float,std::allocator<float> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
PUBLIC	??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
PUBLIC	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase
PUBLIC	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear
PUBLIC	??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ; std::_Iter_random<float *,float *>
PUBLIC	??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z	; stdext::unchecked_copy<float *,float *>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<float *>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAM@Z		; std::_Checked_base<float *>
PUBLIC	??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<float *,float *,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
PUBLIC	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
PUBLIC	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$allocator@M@std@@QAE@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??0_ns2__submitEpochResultElement@@QAE@XZ	; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ; std::_Ptr_cat<float *,float *>
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?soap_type@_ns2__submitEpochResultElement@@UBEHXZ ; _ns2__submitEpochResultElement::soap_type
PUBLIC	??_G_ns2__submitEpochResultElement@@UAEPAXI@Z	; _ns2__submitEpochResultElement::`scalar deleting destructor'
PUBLIC	??1_ns2__submitEpochResultElement@@UAE@XZ	; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
PUBLIC	??0_ns2__submitEpochResultResponseElement@@QAE@XZ ; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement
PUBLIC	?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ ; _ns2__submitEpochResultResponseElement::soap_type
PUBLIC	??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor'
PUBLIC	??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
PUBLIC	??0DRAMsimWSSoapHttp@@QAE@XZ			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp
PUBLIC	?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__getSessionID
PUBLIC	?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__getSettingsFile
PUBLIC	??_GDRAMsimWSSoapHttp@@UAEPAXI@Z		; DRAMsimWSSoapHttp::`scalar deleting destructor'
PUBLIC	??1DRAMsimWSSoapHttp@@UAE@XZ			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
PUBLIC	?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__submitEpochResult
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
PUBLIC	?deallocate@?$allocator@N@std@@QAEXPANI@Z	; std::allocator<double>::deallocate
PUBLIC	??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ; std::_Ptr_cat<double *,double *>
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ; std::vector<double,std::allocator<double> >::_Destroy
PUBLIC	?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ; std::vector<double,std::allocator<double> >::_Tidy
PUBLIC	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
PUBLIC	?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::size
PUBLIC	??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ; std::vector<double,std::allocator<double> >::operator[]
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z ; std::_Iter_cat<unsigned int>
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z		; std::_Checked_base<int *>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n
PUBLIC	??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>
PUBLIC	??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>
PUBLIC	?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
PUBLIC	?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getDecodeWindow
PUBLIC	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove
PUBLIC	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
PUBLIC	?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBufferDelay
PUBLIC	?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ ; DRAMsimII::SystemConfiguration::getRefreshPolicy
PUBLIC	?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tREFI
PUBLIC	??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
PUBLIC	??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
PUBLIC	??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??_GEvent@DRAMsimII@@UAEPAXI@Z			; DRAMsimII::Event::`scalar deleting destructor'
PUBLIC	??1Event@DRAMsimII@@UAE@XZ			; DRAMsimII::Event::~Event
PUBLIC	??1Transaction@DRAMsimII@@UAE@XZ		; DRAMsimII::Transaction::~Transaction
PUBLIC	?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z	; DRAMsimII::PowerConfig::resetToTime
PUBLIC	??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*
PUBLIC	??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*
PUBLIC	??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	?setBank@Address@DRAMsimII@@QAEXI@Z		; DRAMsimII::Address::setBank
PUBLIC	?isRefresh@Transaction@DRAMsimII@@QBE_NXZ	; DRAMsimII::Transaction::isRefresh
PUBLIC	?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Transaction::setDecodeTime
PUBLIC	?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z	; DRAMsimII::Bank::push
PUBLIC	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ	; DRAMsimII::Bank::back
PUBLIC	?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ	; DRAMsimII::Bank::freeCommandSlots
PUBLIC	?isFull@Bank@DRAMsimII@@QBE_NXZ			; DRAMsimII::Bank::isFull
PUBLIC	?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy
PUBLIC	?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ		; DRAMsimII::Bank::pop
PUBLIC	?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::depth
PUBLIC	?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Bank::isHighUtilization
PUBLIC	??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
PUBLIC	??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
PUBLIC	??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
PUBLIC	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
PUBLIC	??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
PUBLIC	?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
PUBLIC	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z	; DRAMsimII::Bank::read
PUBLIC	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
PUBLIC	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ	; DRAMsimII::Bank::front
PUBLIC	?size@Bank@DRAMsimII@@QBEIXZ			; DRAMsimII::Bank::size
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	?getStartTime@Event@DRAMsimII@@QBE_JXZ		; DRAMsimII::Event::getStartTime
PUBLIC	?getCompletionTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getCompletionTime
PUBLIC	?setStartTime@Event@DRAMsimII@@QAEX_J@Z		; DRAMsimII::Event::setStartTime
PUBLIC	?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Event::setCompletionTime
PUBLIC	?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ ; DRAMsimII::Command::getHost
PUBLIC	?setHit@Command@DRAMsimII@@QAEX_N@Z		; DRAMsimII::Command::setHit
PUBLIC	?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ	; DRAMsimII::Statistics::reportTFawCommand
PUBLIC	?isActivated@Bank@DRAMsimII@@QBE_NXZ		; DRAMsimII::Bank::isActivated
PUBLIC	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	?setLastBankID@Rank@DRAMsimII@@QAEXI@Z		; DRAMsimII::Rank::setLastBankID
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
PUBLIC	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
PUBLIC	??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
PUBLIC	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
PUBLIC	??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	?getRankID@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getRankID
PUBLIC	?getLastCASLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getLastCASLength
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
PUBLIC	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
PUBLIC	?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty
PUBLIC	??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
PUBLIC	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRRD
PUBLIC	?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tFAW
PUBLIC	?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRFC
PUBLIC	?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRTRS
PUBLIC	?tOST@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tOST
PUBLIC	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastRASTime
PUBLIC	?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastCASTime
PUBLIC	?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastCASWTime
PUBLIC	?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastPrechargeTime
PUBLIC	?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::front
PUBLIC	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
PUBLIC	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastRefreshTime
PUBLIC	?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Rank::getLastCASTime
PUBLIC	?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastCASWTime
PUBLIC	?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getOtherLastCASTime
PUBLIC	?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getOtherLastCASWTime
PUBLIC	?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastPrechargeTime
PUBLIC	?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getLastCASWLength
PUBLIC	?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getOtherLastCASLength
PUBLIC	?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getOtherLastCASWLength
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?getRank@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getRank
PUBLIC	?getColumn@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getColumn
PUBLIC	?isActivate@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isActivate
PUBLIC	?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ ; DRAMsimII::SystemConfiguration::getDatarate
PUBLIC	?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin
PUBLIC	?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>
PUBLIC	??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==
PUBLIC	??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=
PUBLIC	??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
PUBLIC	?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::deallocate
PUBLIC	??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::Transaction *>
PUBLIC	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
PUBLIC	?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity
PUBLIC	?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Transaction *>::max_size
PUBLIC	?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy
PUBLIC	??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::Transaction * *>
PUBLIC	??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill
PUBLIC	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
PUBLIC	??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
PUBLIC	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
PUBLIC	??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Transaction * *>
PUBLIC	??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::Transaction * *>
PUBLIC	??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::Transaction * *>
PUBLIC	??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
PUBLIC	??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
PUBLIC	??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
PUBLIC	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
PUBLIC	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
PUBLIC	??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
PUBLIC	??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=
PUBLIC	?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::capacity
PUBLIC	?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
PUBLIC	?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::end
PUBLIC	??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >
PUBLIC	?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==
PUBLIC	??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=
PUBLIC	?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ; std::vector<__int64,std::allocator<__int64> >::erase
PUBLIC	?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear
PUBLIC	??$_Allocate@_J@std@@YAPA_JIPA_J@Z		; std::_Allocate<__int64>
PUBLIC	?allocate@?$allocator@_J@std@@QAEPA_JI@Z	; std::allocator<__int64>::allocate
PUBLIC	?max_size@?$allocator@_J@std@@QBEIXZ		; std::allocator<__int64>::max_size
PUBLIC	?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::max_size
PUBLIC	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
PUBLIC	?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ; std::vector<__int64,std::allocator<__int64> >::_Buy
PUBLIC	??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<__int64> >
PUBLIC	??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z ; std::_Destroy_range<std::allocator<__int64> >
PUBLIC	?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy
PUBLIC	??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z ; std::_Iter_random<__int64 *,__int64 *>
PUBLIC	??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ; stdext::unchecked_copy<__int64 *,__int64 *>
PUBLIC	??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<__int64 *>
PUBLIC	??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z	; std::_Checked_base<__int64 *>
PUBLIC	??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z ; std::_Ptr_cat<__int64 *,__int64 *>
PUBLIC	??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
PUBLIC	??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::operator=
PUBLIC	?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::deallocate
PUBLIC	?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity
PUBLIC	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
PUBLIC	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
PUBLIC	??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
PUBLIC	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
PUBLIC	?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase
PUBLIC	?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear
PUBLIC	??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z ; std::_Allocate<DRAMsimII::Rank>
PUBLIC	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
PUBLIC	?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Rank>::max_size
PUBLIC	?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size
PUBLIC	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
PUBLIC	?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
PUBLIC	??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy
PUBLIC	??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Rank *>
PUBLIC	??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z ; std::_Checked_base<DRAMsimII::Rank *>
PUBLIC	??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>
PUBLIC	?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z ; std::allocator<DRAMsimII::Rank>::construct
PUBLIC	?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity
PUBLIC	?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z	; std::allocator<__int64>::deallocate
PUBLIC	?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate
PUBLIC	?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
PUBLIC	??$_Destroy@_J@std@@YAXPA_J@Z			; std::_Destroy<__int64>
PUBLIC	?destroy@?$allocator@_J@std@@QAEXPA_J@Z		; std::allocator<__int64>::destroy
PUBLIC	?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item
PUBLIC	??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>
PUBLIC	?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content
PUBLIC	?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy
PUBLIC	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
PUBLIC	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::deallocate
PUBLIC	??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>
PUBLIC	??1Bank@DRAMsimII@@QAE@XZ			; DRAMsimII::Bank::~Bank
PUBLIC	??_GBank@DRAMsimII@@QAEPAXI@Z			; DRAMsimII::Bank::`scalar deleting destructor'
PUBLIC	??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z ; std::_Destroy<DRAMsimII::Bank>
PUBLIC	?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z ; std::allocator<DRAMsimII::Bank>::destroy
PUBLIC	??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
PUBLIC	??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
PUBLIC	?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy
PUBLIC	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy
PUBLIC	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??1Rank@DRAMsimII@@QAE@XZ			; DRAMsimII::Rank::~Rank
PUBLIC	??_GRank@DRAMsimII@@QAEPAXI@Z			; DRAMsimII::Rank::`scalar deleting destructor'
PUBLIC	??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z ; std::_Destroy<DRAMsimII::Rank>
PUBLIC	?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z ; std::allocator<DRAMsimII::Rank>::destroy
PUBLIC	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
PUBLIC	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=
PUBLIC	?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size
PUBLIC	??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
PUBLIC	?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::read
PUBLIC	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
PUBLIC	??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
PUBLIC	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
PUBLIC	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
PUBLIC	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>
PUBLIC	??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >
PUBLIC	?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::end
PUBLIC	?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ; std::operator==<__int64,std::allocator<__int64> >
PUBLIC	??0?$arg@$05@boost@@QAE@XZ			; boost::arg<6>::arg<6>
PUBLIC	??0?$arg@$02@boost@@QAE@XZ			; boost::arg<3>::arg<3>
PUBLIC	??0?$arg@$06@boost@@QAE@XZ			; boost::arg<7>::arg<7>
PUBLIC	??0?$arg@$01@boost@@QAE@XZ			; boost::arg<2>::arg<2>
PUBLIC	??0?$arg@$03@boost@@QAE@XZ			; boost::arg<4>::arg<4>
PUBLIC	??0?$arg@$08@boost@@QAE@XZ			; boost::arg<9>::arg<9>
PUBLIC	??0?$arg@$04@boost@@QAE@XZ			; boost::arg<5>::arg<5>
PUBLIC	??0?$arg@$00@boost@@QAE@XZ			; boost::arg<1>::arg<1>
PUBLIC	??0?$arg@$07@boost@@QAE@XZ			; boost::arg<8>::arg<8>
PUBLIC	?value@?$is_empty_impl@X@detail@boost@@2_NB	; boost::detail::is_empty_impl<void>::value
PUBLIC	?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const >::value
PUBLIC	?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void volatile >::value
PUBLIC	?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const volatile >::value
PUBLIC	?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
PUBLIC	?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
PUBLIC	?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@_J@detail@boost@@2_NB ; boost::detail::is_pointer_helper<__int64>::value
PUBLIC	?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
PUBLIC	?value@?$is_pointer_impl@_J@detail@boost@@2_NB	; boost::detail::is_pointer_impl<__int64>::value
PUBLIC	?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<__int64>::value
PUBLIC	?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
PUBLIC	??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@ ; `string'
PUBLIC	?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
PUBLIC	_namespaces
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_weekday>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_month>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_year>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_month>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_year>::value
PUBLIC	?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB ; boost::date_time::time_resolution_traits<boost::date_time::time_resolution_traits_adapted64_impl,5,1000000,6,long>::ticks_per_second
PUBLIC	?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB ; boost::posix_time::millisec_posix_time_system_config::tick_per_second
PUBLIC	??_R0?AVthread_resource_error@boost@@@8		; boost::thread_resource_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVthread_exception@boost@@@8		; boost::thread_exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
PUBLIC	__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
PUBLIC	__CTA3?AVthread_resource_error@boost@@
PUBLIC	__TI3?AVthread_resource_error@boost@@
PUBLIC	?max_non_infinite_wait@timeout@detail@boost@@2KB ; boost::detail::timeout::max_non_infinite_wait
PUBLIC	?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB ; boost::detail::basic_timed_mutex::lock_flag_bit
PUBLIC	?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB ; boost::detail::basic_timed_mutex::event_set_flag_bit
PUBLIC	?lock_flag_value@basic_timed_mutex@detail@boost@@2JB ; boost::detail::basic_timed_mutex::lock_flag_value
PUBLIC	?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB ; boost::detail::basic_timed_mutex::event_set_flag_value
PUBLIC	?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> &>::value
PUBLIC	?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::thread &>::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_04KBKDJEAE@rrd?5?$AA@			; `string'
PUBLIC	??_C@_04NCDEHMFO@?$HN?5mJ?$AA@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0BE@HJDEMIMJ@?$HN?5mW?5EsysAdjusted?5?$HL?$AA@ ; `string'
PUBLIC	??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@		; `string'
PUBLIC	??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_04CNFIBAEC@?$HN?5mW?$AA@			; `string'
PUBLIC	??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_05NHLFMAO@?$HN?5mW?5?$AA@			; `string'
PUBLIC	??_C@_0BI@HAJENKCA@?$HN?5mW?5Psys?$CIRD?$CJadjusted?5?$HL?$AA@ ; `string'
PUBLIC	??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@	; `string'
PUBLIC	??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@	; `string'
PUBLIC	?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@ ; `string'
PUBLIC	??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@ ; `string'
PUBLIC	??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@ ; `string'
PUBLIC	??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@ ; `string'
PUBLIC	??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@ ; `string'
PUBLIC	??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ ; `string'
PUBLIC	??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@	; `string'
PUBLIC	??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@ ; `string'
PUBLIC	??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@		; `string'
PUBLIC	??_C@_04HFDGOAGB@nop?$CI?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_02OACLCCCA@?0?7?$AA@			; `string'
PUBLIC	??_C@_07CNLIACOE@read?7?7?$CI?$AA@		; `string'
PUBLIC	??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@	; `string'
PUBLIC	??_C@_08JDIKLHND@write?7?7?$CI?$AA@		; `string'
PUBLIC	??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@		; `string'
PUBLIC	??_C@_02LJALELK@?$CJ?$DL?$AA@			; `string'
PUBLIC	??_C@_08MCOFLILF@refresh?$CI?$AA@		; `string'
PUBLIC	??_C@_0M@EJENEINP@precharge?7?$CI?$AA@		; `string'
PUBLIC	??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@		; `string'
PUBLIC	??_C@_02DCEECEBO@T?$FL?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7Event@DRAMsimII@@6B@			; DRAMsimII::Event::`vftable'
PUBLIC	??_7Channel@DRAMsimII@@6B@			; DRAMsimII::Channel::`vftable'
PUBLIC	??_7_ns2__submitEpochResultElement@@6B@		; _ns2__submitEpochResultElement::`vftable'
PUBLIC	??_7_ns2__submitEpochResultResponseElement@@6B@	; _ns2__submitEpochResultResponseElement::`vftable'
PUBLIC	??_7DRAMsimWSSoapHttp@@6B@			; DRAMsimWSSoapHttp::`vftable'
PUBLIC	??_7thread_exception@boost@@6B@			; boost::thread_exception::`vftable'
PUBLIC	??_7thread_resource_error@boost@@6B@		; boost::thread_resource_error::`vftable'
PUBLIC	??_7thread_data_base@detail@boost@@6B@		; boost::detail::thread_data_base::`vftable'
PUBLIC	??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vftable'
EXTRN	??_EChannel@DRAMsimII@@UAEPAXI@Z:PROC		; DRAMsimII::Channel::`vector deleting destructor'
EXTRN	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z:PROC	; std::setprecision
EXTRN	??1thread@boost@@QAE@XZ:PROC			; boost::thread::~thread
EXTRN	?start_thread@thread@boost@@AAEXXZ:PROC		; boost::thread::start_thread
EXTRN	??0exception@std@@QAE@ABQBDH@Z:PROC		; std::exception::exception
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	??0thread_resource_error@boost@@QAE@XZ:PROC	; boost::thread_resource_error::thread_resource_error
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	?what@thread_resource_error@boost@@UBEPBDXZ:PROC ; boost::thread_resource_error::what
EXTRN	??1thread_resource_error@boost@@UAE@XZ:PROC	; boost::thread_resource_error::~thread_resource_error
EXTRN	??_Ethread_resource_error@boost@@UAEPAXI@Z:PROC	; boost::thread_resource_error::`vector deleting destructor'
EXTRN	??1thread_exception@boost@@UAE@XZ:PROC		; boost::thread_exception::~thread_exception
EXTRN	??_Ethread_exception@boost@@UAEPAXI@Z:PROC	; boost::thread_exception::`vector deleting destructor'
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__purecall:PROC
EXTRN	??_Ethread_data_base@detail@boost@@UAEPAXI@Z:PROC ; boost::detail::thread_data_base::`vector deleting destructor'
EXTRN	??_E?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z:PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vector deleting destructor'
EXTRN	??_EDRAMsimWSSoapHttp@@UAEPAXI@Z:PROC		; DRAMsimWSSoapHttp::`vector deleting destructor'
EXTRN	_atexit:PROC
EXTRN	??_EEvent@DRAMsimII@@UAEPAXI@Z:PROC		; DRAMsimII::Event::`vector deleting destructor'
EXTRN	_exit:PROC
;	COMDAT ??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
CONST	SEGMENT
??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ DD FLAT:??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vftable'
	DD	FLAT:??_E?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z
	DD	FLAT:?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
rdata$r	SEGMENT
??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ DD 00H ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8
	DD	FLAT:??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD 00H ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD FLAT:??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD FLAT:??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8
_DATA	SEGMENT
??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsim'
	DB	'II@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allo'
	DB	'cator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChann'
	DB	'el@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vect'
	DB	'or@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allo'
	DB	'cator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@'
	DB	'@@detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_7thread_data_base@detail@boost@@6B@
CONST	SEGMENT
??_7thread_data_base@detail@boost@@6B@ DD FLAT:??_R4thread_data_base@detail@boost@@6B@ ; boost::detail::thread_data_base::`vftable'
	DD	FLAT:??_Ethread_data_base@detail@boost@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4thread_data_base@detail@boost@@6B@
rdata$r	SEGMENT
??_R4thread_data_base@detail@boost@@6B@ DD 00H		; boost::detail::thread_data_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUthread_data_base@detail@boost@@@8
	DD	FLAT:??_R3thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R3thread_data_base@detail@boost@@8 DD 00H		; boost::detail::thread_data_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R2thread_data_base@detail@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_data_base@detail@boost@@8 ; boost::detail::thread_data_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_data_base@detail@boost@@8 DD FLAT:??_R0?AUthread_data_base@detail@boost@@@8 ; boost::detail::thread_data_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUthread_data_base@detail@boost@@@8
_DATA	SEGMENT
??_R0?AUthread_data_base@detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::detail::thread_data_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUthread_data_base@detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_7thread_resource_error@boost@@6B@
CONST	SEGMENT
??_7thread_resource_error@boost@@6B@ DD FLAT:??_R4thread_resource_error@boost@@6B@ ; boost::thread_resource_error::`vftable'
	DD	FLAT:??_Ethread_resource_error@boost@@UAEPAXI@Z
	DD	FLAT:?what@thread_resource_error@boost@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4thread_resource_error@boost@@6B@
rdata$r	SEGMENT
??_R4thread_resource_error@boost@@6B@ DD 00H		; boost::thread_resource_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVthread_resource_error@boost@@@8
	DD	FLAT:??_R3thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R3thread_resource_error@boost@@8 DD 00H		; boost::thread_resource_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R2thread_resource_error@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_resource_error@boost@@8 ; boost::thread_resource_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@thread_exception@boost@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_resource_error@boost@@8 DD FLAT:??_R0?AVthread_resource_error@boost@@@8 ; boost::thread_resource_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_7thread_exception@boost@@6B@
CONST	SEGMENT
??_7thread_exception@boost@@6B@ DD FLAT:??_R4thread_exception@boost@@6B@ ; boost::thread_exception::`vftable'
	DD	FLAT:??_Ethread_exception@boost@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4thread_exception@boost@@6B@
rdata$r	SEGMENT
??_R4thread_exception@boost@@6B@ DD 00H			; boost::thread_exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVthread_exception@boost@@@8
	DD	FLAT:??_R3thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_exception@boost@@8
rdata$r	SEGMENT
??_R3thread_exception@boost@@8 DD 00H			; boost::thread_exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_exception@boost@@8
rdata$r	SEGMENT
??_R2thread_exception@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_exception@boost@@8 ; boost::thread_exception::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_exception@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_exception@boost@@8 DD FLAT:??_R0?AVthread_exception@boost@@@8 ; boost::thread_exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_7DRAMsimWSSoapHttp@@6B@
CONST	SEGMENT
??_7DRAMsimWSSoapHttp@@6B@ DD FLAT:??_R4DRAMsimWSSoapHttp@@6B@ ; DRAMsimWSSoapHttp::`vftable'
	DD	FLAT:??_EDRAMsimWSSoapHttp@@UAEPAXI@Z
	DD	FLAT:?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z
	DD	FLAT:?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z
	DD	FLAT:?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z
CONST	ENDS
;	COMDAT ??_R4DRAMsimWSSoapHttp@@6B@
rdata$r	SEGMENT
??_R4DRAMsimWSSoapHttp@@6B@ DD 00H			; DRAMsimWSSoapHttp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDRAMsimWSSoapHttp@@@8
	DD	FLAT:??_R3DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R3DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R3DRAMsimWSSoapHttp@@8 DD 00H			; DRAMsimWSSoapHttp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R2DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R2DRAMsimWSSoapHttp@@8 DD FLAT:??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8 ; DRAMsimWSSoapHttp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8 DD FLAT:??_R0?AVDRAMsimWSSoapHttp@@@8 ; DRAMsimWSSoapHttp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDRAMsimWSSoapHttp@@@8
_DATA	SEGMENT
??_R0?AVDRAMsimWSSoapHttp@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimWSSoapHttp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDRAMsimWSSoapHttp@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__submitEpochResultResponseElement@@6B@
CONST	SEGMENT
??_7_ns2__submitEpochResultResponseElement@@6B@ DD FLAT:??_R4_ns2__submitEpochResultResponseElement@@6B@ ; _ns2__submitEpochResultResponseElement::`vftable'
	DD	FLAT:?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__submitEpochResultResponseElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__submitEpochResultResponseElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__submitEpochResultResponseElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__submitEpochResultResponseElement@@6B@ DD 00H	; _ns2__submitEpochResultResponseElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__submitEpochResultResponseElement@@@8
	DD	FLAT:??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R3_ns2__submitEpochResultResponseElement@@8 DD 00H	; _ns2__submitEpochResultResponseElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R2_ns2__submitEpochResultResponseElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 DD FLAT:??_R0?AV_ns2__submitEpochResultResponseElement@@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__submitEpochResultResponseElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__submitEpochResultResponseElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__submitEpochResultResponseElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__submitEpochResultResponseElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__submitEpochResultElement@@6B@
CONST	SEGMENT
??_7_ns2__submitEpochResultElement@@6B@ DD FLAT:??_R4_ns2__submitEpochResultElement@@6B@ ; _ns2__submitEpochResultElement::`vftable'
	DD	FLAT:?soap_type@_ns2__submitEpochResultElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__submitEpochResultElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__submitEpochResultElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__submitEpochResultElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__submitEpochResultElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__submitEpochResultElement@@6B@ DD 00H		; _ns2__submitEpochResultElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__submitEpochResultElement@@@8
	DD	FLAT:??_R3_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R3_ns2__submitEpochResultElement@@8 DD 00H		; _ns2__submitEpochResultElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R2_ns2__submitEpochResultElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8 ; _ns2__submitEpochResultElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8 DD FLAT:??_R0?AV_ns2__submitEpochResultElement@@@8 ; _ns2__submitEpochResultElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__submitEpochResultElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__submitEpochResultElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__submitEpochResultElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__submitEpochResultElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7Channel@DRAMsimII@@6B@
CONST	SEGMENT
??_7Channel@DRAMsimII@@6B@ DD FLAT:??_R4Channel@DRAMsimII@@6B@ ; DRAMsimII::Channel::`vftable'
	DD	FLAT:?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ
	DD	FLAT:?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:??_EChannel@DRAMsimII@@UAEPAXI@Z
	DD	FLAT:?nextTick@Channel@DRAMsimII@@UBE_JXZ
	DD	FLAT:?moveToTime@Channel@DRAMsimII@@UAEX_J@Z
CONST	ENDS
;	COMDAT ??_R4Channel@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4Channel@DRAMsimII@@6B@ DD 00H			; DRAMsimII::Channel::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChannel@DRAMsimII@@@8
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Channel@DRAMsimII@@8 DD 00H			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Channel@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Channel@DRAMsimII@@8 ; DRAMsimII::Channel::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Channel@DRAMsimII@@8 DD FLAT:??_R0?AVChannel@DRAMsimII@@@8 ; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChannel@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVChannel@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::Channel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChannel@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_7Event@DRAMsimII@@6B@
CONST	SEGMENT
??_7Event@DRAMsimII@@6B@ DD FLAT:??_R4Event@DRAMsimII@@6B@ ; DRAMsimII::Event::`vftable'
	DD	FLAT:??_EEvent@DRAMsimII@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Event@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4Event@DRAMsimII@@6B@ DD 00H			; DRAMsimII::Event::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEvent@DRAMsimII@@@8
	DD	FLAT:??_R3Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Event@DRAMsimII@@8 DD 00H				; DRAMsimII::Event::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Event@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Event@DRAMsimII@@8 ; DRAMsimII::Event::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Event@DRAMsimII@@8 DD FLAT:??_R0?AVEvent@DRAMsimII@@@8 ; DRAMsimII::Event::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEvent@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVEvent@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@	; DRAMsimII::Event `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEvent@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCEECEBO@T?$FL?$AA@
CONST	SEGMENT
??_C@_02DCEECEBO@T?$FL?$AA@ DB 'T[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@ DB '] ch[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJENEINP@precharge?7?$CI?$AA@
CONST	SEGMENT
??_C@_0M@EJENEINP@precharge?7?$CI?$AA@ DB 'precharge', 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MCOFLILF@refresh?$CI?$AA@
CONST	SEGMENT
??_C@_08MCOFLILF@refresh?$CI?$AA@ DB 'refresh(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LJALELK@?$CJ?$DL?$AA@
CONST	SEGMENT
??_C@_02LJALELK@?$CJ?$DL?$AA@ DB ');', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@
CONST	SEGMENT
??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@ DB 'activate', 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JDIKLHND@write?7?7?$CI?$AA@
CONST	SEGMENT
??_C@_08JDIKLHND@write?7?7?$CI?$AA@ DB 'write', 09H, 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@
CONST	SEGMENT
??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@ DB ',', 09H, '0,', 09H, '1'
	DB	'0); //', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNLIACOE@read?7?7?$CI?$AA@
CONST	SEGMENT
??_C@_07CNLIACOE@read?7?7?$CI?$AA@ DB 'read', 09H, 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OACLCCCA@?0?7?$AA@
CONST	SEGMENT
??_C@_02OACLCCCA@?0?7?$AA@ DB ',', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFDGOAGB@nop?$CI?$AA@
CONST	SEGMENT
??_C@_04HFDGOAGB@nop?$CI?$AA@ DB 'nop(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
CONST	SEGMENT
??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@ DB '); //', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@
CONST	SEGMENT
??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@ DB 'Unsupported c'
	DB	'ommand encountered.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@
CONST	SEGMENT
??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@ DB 'Unknown command type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
CONST	SEGMENT
??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ DB 'This configur'
	DB	'ation and algorithm combination is not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@
CONST	SEGMENT
??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@ DB 'warn: unhand'
	DB	'led command type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@
CONST	SEGMENT
??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@ DB 'error: row '
	DB	'activate command not followed by a column command.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@
CONST	SEGMENT
??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@ DB 'warn: Unha'
	DB	'ndled command type.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@
CONST	SEGMENT
??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@ DB 'error: Fo'
	DB	'und a row activate not followed by a column command.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
CONST	SEGMENT
??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@ DB 'Unhandled ro'
	DB	'w buffer management policy', 00H		; `string'
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>::value
CONST	ENDS
;	COMDAT ??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@ DB '-Psys(WR) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@ DB '-Psys(RD) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HAJENKCA@?$HN?5mW?5Psys?$CIRD?$CJadjusted?5?$HL?$AA@
CONST	SEGMENT
??_C@_0BI@HAJENKCA@?$HN?5mW?5Psys?$CIRD?$CJadjusted?5?$HL?$AA@ DB '} mW P'
	DB	'sys(RD)adjusted {', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NHLFMAO@?$HN?5mW?5?$AA@
CONST	SEGMENT
??_C@_05NHLFMAO@?$HN?5mW?5?$AA@ DB '} mW ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@ DB '-Psys(PRE_STBY'
	DB	') ch[', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@ DB '-Psys(ACT) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
CONST	SEGMENT
??_C@_04CNFIBAEC@?$HN?5mW?$AA@ DB '} mW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@ DB '-Psys(ACT_STBY'
	DB	') ch[', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
CONST	SEGMENT
??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@ DB '] {', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HJDEMIMJ@?$HN?5mW?5EsysAdjusted?5?$HL?$AA@
CONST	SEGMENT
??_C@_0BE@HJDEMIMJ@?$HN?5mW?5EsysAdjusted?5?$HL?$AA@ DB '} mW EsysAdjuste'
	DB	'd {', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCDEHMFO@?$HN?5mJ?$AA@
CONST	SEGMENT
??_C@_04NCDEHMFO@?$HN?5mJ?$AA@ DB '} mJ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBKDJEAE@rrd?5?$AA@
CONST	SEGMENT
??_C@_04KBKDJEAE@rrd?5?$AA@ DB 'rrd ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@
CONST	SEGMENT
??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@ DB 'Unknown trans'
	DB	'action ordering algorithm.', 00H		; `string'
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_basic_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::thread &>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> &>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB
CONST	SEGMENT
?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB DD 040000000H ; boost::detail::basic_timed_mutex::event_set_flag_value
CONST	ENDS
;	COMDAT ?lock_flag_value@basic_timed_mutex@detail@boost@@2JB
CONST	SEGMENT
?lock_flag_value@basic_timed_mutex@detail@boost@@2JB DD 080000000H ; boost::detail::basic_timed_mutex::lock_flag_value
CONST	ENDS
;	COMDAT ?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB
CONST	SEGMENT
?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB DB 01eH ; boost::detail::basic_timed_mutex::event_set_flag_bit
CONST	ENDS
;	COMDAT ?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB
CONST	SEGMENT
?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB DB 01fH ; boost::detail::basic_timed_mutex::lock_flag_bit
CONST	ENDS
;	COMDAT ?max_non_infinite_wait@timeout@detail@boost@@2KB
CONST	SEGMENT
?max_non_infinite_wait@timeout@detail@boost@@2KB DD 0fffffffeH ; boost::detail::timeout::max_non_infinite_wait
CONST	ENDS
;	COMDAT __TI3?AVthread_resource_error@boost@@
xdata$x	SEGMENT
__TI3?AVthread_resource_error@boost@@ DD 00H
	DD	FLAT:??1thread_resource_error@boost@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVthread_resource_error@boost@@
xdata$x	ENDS
;	COMDAT __CTA3?AVthread_resource_error@boost@@
xdata$x	SEGMENT
__CTA3?AVthread_resource_error@boost@@ DD 03H
	DD	FLAT:__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
	DD	FLAT:__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
xdata$x	SEGMENT
__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16 DD 00H
	DD	FLAT:??_R0?AVthread_exception@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0thread_exception@boost@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
xdata$x	SEGMENT
__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16 DD 00H
	DD	FLAT:??_R0?AVthread_resource_error@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0thread_resource_error@boost@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVthread_exception@boost@@@8
_DATA	SEGMENT
??_R0?AVthread_exception@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::thread_exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVthread_exception@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVthread_resource_error@boost@@@8
_DATA	SEGMENT
??_R0?AVthread_resource_error@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::thread_resource_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVthread_resource_error@boost@@', 00H
_DATA	ENDS
;	COMDAT ?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB
CONST	SEGMENT
?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB DQ 00000000000f4240H ; boost::posix_time::millisec_posix_time_system_config::tick_per_second
CONST	ENDS
;	COMDAT ?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB
CONST	SEGMENT
?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB DQ 00000000000f4240H ; boost::date_time::time_resolution_traits<boost::date_time::time_resolution_traits_adapted64_impl,5,1000000,6,long>::ticks_per_second
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_year>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_month>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_year>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_month>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_weekday>::value
CONST	ENDS
;	COMDAT ?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B
CONST	SEGMENT
?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B DD FLAT:??_C@_08EPBICJDL@SOAP?9ENV?$AA@ ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
	DD	FLAT:??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
	DD	00H
	DD	FLAT:??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
	DD	FLAT:??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
	DD	00H
	DD	FLAT:??_C@_03JCLIKOHH@xsi?$AA@
	DD	FLAT:??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
	DD	00H
	DD	FLAT:??_C@_03CHBGNADK@xsd?$AA@
	DD	FLAT:??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
	DD	00H
	DD	FLAT:??_C@_03JFKIHBGI@ns1?$AA@
	DD	FLAT:??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03LOIFCCKL@ns2?$AA@
	DD	FLAT:??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
CONST	SEGMENT
??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@ DB 'http://DRA'
	DB	'MsimReporter/types/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOIFCCKL@ns2?$AA@
CONST	SEGMENT
??_C@_03LOIFCCKL@ns2?$AA@ DB 'ns2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
CONST	SEGMENT
??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@ DB 'http://DRAMsimRep'
	DB	'orter/', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFKIHBGI@ns1?$AA@
CONST	SEGMENT
??_C@_03JFKIHBGI@ns1?$AA@ DB 'ns1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
CONST	SEGMENT
??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@ DB 'http:'
	DB	'//www.w3.org/*/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@ DB 'http://ww'
	DB	'w.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHBGNADK@xsd?$AA@
CONST	SEGMENT
??_C@_03CHBGNADK@xsd?$AA@ DB 'xsd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
CONST	SEGMENT
??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@ DB 'http:'
	DB	'//www.w3.org/*/XMLSchema-instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
CONST	SEGMENT
??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@ DB 'http://ww'
	DB	'w.w3.org/2001/XMLSchema-instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JCLIKOHH@xsi?$AA@
CONST	SEGMENT
??_C@_03JCLIKOHH@xsi?$AA@ DB 'xsi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
CONST	SEGMENT
??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@ DB 'http:'
	DB	'//www.w3.org/*/soap-encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/encoding/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
CONST	SEGMENT
??_C@_08HIKNMPCP@SOAP?9ENC?$AA@ DB 'SOAP-ENC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
CONST	SEGMENT
??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@ DB 'http:'
	DB	'//www.w3.org/*/soap-envelope', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/envelope/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPBICJDL@SOAP?9ENV?$AA@
CONST	SEGMENT
??_C@_08EPBICJDL@SOAP?9ENV?$AA@ DB 'SOAP-ENV', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@
CONST	SEGMENT
??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@ DB 'http://id'
	DB	'2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort', 00H ; `string'
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB DD 01H ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB DB 01H ; boost::detail::is_arithmetic_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<__int64>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_const
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@X@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void>::value
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_namespaces DD	FLAT:??_C@_08EPBICJDL@SOAP?9ENV?$AA@
	DD	FLAT:??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
	DD	00H
	DD	FLAT:??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
	DD	FLAT:??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
	DD	00H
	DD	FLAT:??_C@_03JCLIKOHH@xsi?$AA@
	DD	FLAT:??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
	DD	00H
	DD	FLAT:??_C@_03CHBGNADK@xsd?$AA@
	DD	FLAT:??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
	DD	00H
	DD	FLAT:??_C@_03JFKIHBGI@ns1?$AA@
	DD	FLAT:??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03LOIFCCKL@ns2?$AA@
	DD	FLAT:??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\get_pointer.hpp
;	COMDAT ??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z
_TEXT	SEGMENT
??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z PROC ; boost::get_pointer<DRAMsimII::Channel>, COMDAT
; _p$ = eax

; 20   :     return p;
; 21   : }

	ret	0
??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z ENDP ; boost::get_pointer<DRAMsimII::Channel>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@9
	push	esi
	npad	7
$LL3@Fill_n@9:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@9
	pop	esi
$LN1@Fill_n@9:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@10
$LL3@Fill_n@10:

; 3198 : 		*_First = _Val;

	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@10
$LN1@Fill_n@10:

; 3199 : 	}

	ret	0
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@11
	push	esi
	npad	7
$LL3@Fill_n@11:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@11
	pop	esi
$LN1@Fill_n@11:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	eax, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN1@Fill_n@12
	push	esi
	npad	7
$LL3@Fill_n@12:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL3@Fill_n@12
	pop	esi
$LN1@Fill_n@12:

; 3199 : 	}

	ret	0
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@13
$LL3@Fill_n@13:

; 3198 : 		*_First = _Val;

	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL3@Fill_n@13
$LN1@Fill_n@13:

; 3199 : 	}

	ret	0
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@14
	push	esi
	npad	7
$LL3@Fill_n@14:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@14
	pop	esi
$LN1@Fill_n@14:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ?get@?$value@_J@_bi@boost@@QAEAA_JXZ
_TEXT	SEGMENT
?get@?$value@_J@_bi@boost@@QAEAA_JXZ PROC		; boost::_bi::value<__int64>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@_J@_bi@boost@@QAEAA_JXZ ENDP		; boost::_bi::value<__int64>::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ
_TEXT	SEGMENT
?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ
_TEXT	SEGMENT
?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@N@_bi@boost@@QAEAANXZ
_TEXT	SEGMENT
?get@?$value@N@_bi@boost@@QAEAANXZ PROC			; boost::_bi::value<double>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@N@_bi@boost@@QAEAANXZ ENDP			; boost::_bi::value<double>::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ
_TEXT	SEGMENT
?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ PROC ; boost::_bi::value<DRAMsimII::Channel *>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ ENDP ; boost::_bi::value<DRAMsimII::Channel *>::get
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z
_TEXT	SEGMENT
??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z PROC ; boost::_bi::list0::operator[]<__int64>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z ENDP ; boost::_bi::list0::operator[]<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
_TEXT	SEGMENT
??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z PROC ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ENDP ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
_TEXT	SEGMENT
??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z PROC ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ENDP ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z
_TEXT	SEGMENT
??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z PROC	; boost::_bi::list0::operator[]<double>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z ENDP	; boost::_bi::list0::operator[]<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z
_TEXT	SEGMENT
??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z PROC ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z ENDP ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z PROC ; std::_Iter_cat<DRAMsimII::Transaction * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ENDP ; std::_Iter_cat<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z
_TEXT	SEGMENT
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z PROC ; std::_Iter_cat<float *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ENDP ; std::_Iter_cat<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z PROC ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z ENDP ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z
_TEXT	SEGMENT
??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z PROC ; std::_Iter_cat<__int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z ENDP ; std::_Iter_cat<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z
_TEXT	SEGMENT
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z PROC ; std::_Iter_cat<double *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ENDP ; std::_Iter_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>, COMDAT
; __Last1$ = edx
; __First2$ = ecx

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	mov	eax, DWORD PTR __First1$[esp-4]
	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	eax, edx
	je	SHORT $LN2@Equal@3
	npad	7
$LL4@Equal@3:

; 2993 : 		if (!(*_First1 == *_First2))

	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN8@Equal@3
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN8@Equal@3
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL4@Equal@3
$LN2@Equal@3:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
$LN8@Equal@3:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z
_TEXT	SEGMENT
?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z PROC ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap, COMDAT
; _f$ = eax

; 148  :         return f;
; 149  :     }

	ret	0
?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z ENDP ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Transaction * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::pair<unsigned int,__int64> * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<double const *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<double const *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int const *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int const *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Rank *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<__int64 *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z
_TEXT	SEGMENT
?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base, COMDAT
; _this$ = eax
; __Base$ = ecx

; 52   : 		this->_Myptr = const_cast<_Tptr>(_Base);

	mov	DWORD PTR [eax+4], ecx

; 53   : 	}

	ret	0
?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z PROC ; std::_Move_cat<DRAMsimII::Transaction * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ENDP ; std::_Move_cat<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z PROC ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill@4
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ENDP ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Transaction * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z PROC ; std::_Move_cat<double *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ENDP ; std::_Move_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z
_TEXT	SEGMENT
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z PROC ; std::_Iter_random<double *,double *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ENDP ; std::_Iter_random<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::_Fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, ecx
	je	SHORT $LN1@Fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	movsd	xmm0, QWORD PTR [edx]
	npad	4
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@5
$LN1@Fill@5:

; 3160 : 	}

	ret	0
??$_Fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::_Fill<double *,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPAN@Z
_TEXT	SEGMENT
??$_Checked_base@PAN@std@@YAPANAAPAN@Z PROC		; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAN@std@@YAPANAAPAN@Z ENDP		; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@6
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill@6
$LN1@Fill@6:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z PROC ; std::_Checked_base<std::pair<unsigned int,__int64> * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z ENDP ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z PROC ; std::_Ptr_cat<double *,double *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ENDP ; std::_Ptr_cat<double *,double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<__int64> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@11
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@11:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z PROC ; std::_Ptr_cat<float *,float *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ENDP ; std::_Ptr_cat<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z
_TEXT	SEGMENT
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z PROC ; std::_Iter_random<float *,float *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ENDP ; std::_Iter_random<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAM@Z
_TEXT	SEGMENT
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z PROC		; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z ENDP		; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAH@Z
_TEXT	SEGMENT
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z PROC		; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z ENDP		; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@12
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@12:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Rank *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z PROC ; std::_Ptr_cat<__int64 *,__int64 *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z ENDP ; std::_Ptr_cat<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z
_TEXT	SEGMENT
??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z PROC ; std::_Iter_random<__int64 *,__int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z ENDP ; std::_Iter_random<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z
_TEXT	SEGMENT
??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z PROC		; std::_Checked_base<__int64 *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z ENDP		; std::_Checked_base<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z PROC	; std::_Iter_cat<unsigned int>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 955  : 	}

	pop	ecx
	ret	0
??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z ENDP	; std::_Iter_cat<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z
_TEXT	SEGMENT
??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z PROC ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>, COMDAT
; __Dest$ = edx
; __Src$ = eax

; 1174 : 		_Dest._Checked_iterator_assign_from_base(_Src);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 1175 : 	}

	ret	0
??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z ENDP ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z
_TEXT	SEGMENT
??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z PROC		; std::_Min_element<__int64 const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4437 : 	_DEBUG_RANGE(_First, _Last);
; 4438 : 	_FwdIt _Found = _First;

	mov	eax, ecx

; 4439 : 	if (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN2@Min_elemen

; 4440 : 		for (; ++_First != _Last; )

	add	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN2@Min_elemen
	push	esi
	npad	2
$LL3@Min_elemen:

; 4441 : 			if (_DEBUG_LT(*_First, *_Found))

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LN1@Min_elemen
	jl	SHORT $LN8@Min_elemen
	mov	esi, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [eax]
	jae	SHORT $LN1@Min_elemen
$LN8@Min_elemen:

; 4442 : 				_Found = _First;

	mov	eax, ecx
$LN1@Min_elemen:

; 4440 : 		for (; ++_First != _Last; )

	add	ecx, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Min_elemen
	pop	esi
$LN2@Min_elemen:

; 4443 : 	return (_Found);
; 4444 : 	}

	ret	0
??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z ENDP		; std::_Min_element<__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
_TEXT	ENDS
;	COMDAT ??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z PROC ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >, COMDAT
; _this$ = eax

; 42   :     explicit storage1( A1 a1 ): a1_( a1 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z ENDP ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z PROC ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >, COMDAT
; _this$ = eax

; 80   :     storage2( A1 a1, A2 a2 ): storage1<A1>( a1 ), a2_( a2 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	edx, DWORD PTR _a2$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _a2$[esp]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	ret	12					; 0000000cH
??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z ENDP ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z PROC ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >, COMDAT
; _this$ = eax

; 129  :     storage3( A1 a1, A2 a2, A3 a3 ): storage2<A1, A2>( a1, a2 ), a3_( a3 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	edx, DWORD PTR _a2$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _a2$[esp]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR _a3$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR _a3$[esp]
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	ret	20					; 00000014H
??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z ENDP ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0?$value@_J@_bi@boost@@QAE@AB_J@Z
_TEXT	SEGMENT
??0?$value@_J@_bi@boost@@QAE@AB_J@Z PROC		; boost::_bi::value<__int64>::value<__int64>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$value@_J@_bi@boost@@QAE@AB_J@Z ENDP		; boost::_bi::value<__int64>::value<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@N@_bi@boost@@QAE@ABN@Z
_TEXT	SEGMENT
??0?$value@N@_bi@boost@@QAE@ABN@Z PROC			; boost::_bi::value<double>::value<double>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax]
	ret	0
??0?$value@N@_bi@boost@@QAE@ABN@Z ENDP			; boost::_bi::value<double>::value<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z
_TEXT	SEGMENT
??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z PROC ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z ENDP ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>
_TEXT	ENDS
PUBLIC	?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
;	COMDAT ??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z
_TEXT	SEGMENT
??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT
; _this$ = eax

; 772  :     explicit BOOST_MEM_FN_NAME(cmf6)(F f): f_(f) {}

	mov	DWORD PTR [eax], OFFSET ?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
	ret	0
??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@_J@std@@YAXPA_J@Z
_TEXT	SEGMENT
??$_Destroy@_J@std@@YAXPA_J@Z PROC			; std::_Destroy<__int64>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@_J@std@@YAXPA_J@Z ENDP			; std::_Destroy<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z PROC ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill@3:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@3
$LN11@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ENDP ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@13
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@13:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z
_TEXT	SEGMENT
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	movsd	xmm0, QWORD PTR [edx]
	npad	4
$LL13@fill@4:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL13@fill@4
$LN11@fill@4:

; 3188 : 	}

	ret	0
??$fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::fill<double *,double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z
_TEXT	SEGMENT
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill@5:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@5
$LN11@fill@5:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z PROC ; std::_Destroy<std::pair<unsigned int,__int64> *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z PROC ; std::_Destroy<std::pair<unsigned int,__int64> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@14
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@14:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z
_TEXT	SEGMENT
??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>, COMDAT
; _this$ = edx
; _p$ = eax

; 1981 :         if (++p == m_end)

	add	DWORD PTR [eax], 8
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN1@increment@2

; 1982 :             p = m_buff;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN1@increment@2:

; 1983 :     }

	ret	0
??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z
_TEXT	SEGMENT
??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z PROC ; std::_Destroy_range<std::allocator<__int64> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z ENDP ; std::_Destroy_range<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z PROC ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@3:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z ENDP ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z PROC	; stdext::unchecked_copy<float *,float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@15
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@15:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z ENDP	; stdext::unchecked_copy<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@16
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@16:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@4:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z
_TEXT	SEGMENT
??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z PROC	; stdext::unchecked_copy<__int64 *,__int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@17
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@17:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ENDP	; stdext::unchecked_copy<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z PROC ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; ___$ReturnUdt$ = eax

; 4449 : 	_ASSIGN_FROM_BASE(_First,

	mov	edx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	edx, esi
	je	SHORT $LN16@min_elemen
	lea	ecx, DWORD PTR [edx+8]
	cmp	ecx, esi
	je	SHORT $LN16@min_elemen
	push	edi
$LL17@min_elemen:
	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	jg	SHORT $LN15@min_elemen
	jl	SHORT $LN26@min_elemen
	mov	edi, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [edx]
	jae	SHORT $LN15@min_elemen
$LN26@min_elemen:
	mov	edx, ecx
$LN15@min_elemen:
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL17@min_elemen
	pop	edi
$LN16@min_elemen:

; 4450 : 		_Min_element(_CHECKED_BASE(_First), _CHECKED_BASE(_Last)));
; 4451 : 	return (_First);

	mov	ecx, DWORD PTR __First$[esp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 4452 : 	}

	ret	0
??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z ENDP ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int,__int64> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int,__int64> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@_J@std@@QAEXPA_J@Z
_TEXT	SEGMENT
?destroy@?$allocator@_J@std@@QAEXPA_J@Z PROC		; std::allocator<__int64>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@_J@std@@QAEXPA_J@Z ENDP		; std::allocator<__int64>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@N@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@N@std@@QBEIXZ PROC		; std::allocator<double>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@N@std@@QBEIXZ ENDP		; std::allocator<double>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z PROC	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size, COMDAT

; 729  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 730  : 		}

	ret	0
?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Rank>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 10129639				; 009a90e7H

; 167  : 		}

	ret	0
?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Rank>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z
_TEXT	SEGMENT
?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item, COMDAT

; 2054 :         m_alloc.destroy(p);
; 2055 : #if BOOST_CB_ENABLE_DEBUG
; 2056 :         invalidate_iterators(iterator(this, p));
; 2057 :         ::memset(p, cb_details::UNINITIALIZED, sizeof(value_type));
; 2058 : #endif
; 2059 :     }

	ret	0
?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = eax

; 752  :     size_type size() const { return m_size; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_J@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_J@std@@QBEIXZ PROC		; std::allocator<__int64>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@_J@std@@QBEIXZ ENDP		; std::allocator<__int64>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Transaction *>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Transaction *>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@N@std@@QAEXPANI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@N@std@@QAEXPANI@Z PROC		; std::allocator<double>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@N@std@@QAEXPANI@Z ENDP		; std::allocator<double>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty, COMDAT
; _this$ = ecx

; 734  : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 735  : 		}

	ret	0
?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 10129639				; 009a90e7H

; 732  : 		}

	ret	0
?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Bank>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Bank>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ
_TEXT	SEGMENT
?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content, COMDAT
; _this$ = eax

; 2069 :         for (size_type ii = 0; ii < size(); ++ii, increment(m_first))

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN1@destroy_co
$LL6@destroy_co:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN12@destroy_co
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN12@destroy_co:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL6@destroy_co
$LN1@destroy_co:

; 2070 :             destroy_item(m_first);
; 2071 :     }

	ret	0
?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity, COMDAT
; _this$ = ecx

; 827  :     capacity_type capacity() const { return m_end - m_buff; }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	ret	0
?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Transaction *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ PROC ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ ENDP ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@9
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@9:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
__Dest$ = 12						; size = 8
__Val$ = 20						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Fill$ = edx

; 1105 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	fld	QWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1106 : 		}

	ret	20					; 00000014H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 5

; 727  : 		}

	ret	0
?size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@ABV01@@Z PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@N@std@@QAE@ABV01@@Z ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@XZ PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@N@std@@QAE@XZ ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ PROC	; std::vector<double,std::allocator<double> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@12

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@12:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ENDP	; std::vector<double,std::allocator<double> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@10
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@10:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@M@std@@QAE@XZ ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@11
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@11:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@12
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@12:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front, COMDAT
; _this$ = eax

; 820  : 
; 821  :  #if _HAS_ITERATOR_DEBUGGING
; 822  : 		if (empty())
; 823  : 			_DEBUG_ERROR("deque empty before pop");
; 824  : 		else
; 825  : 			{	// something to erase, do it
; 826  : 			_Orphan_off(_Myoff);
; 827  : 
; 828  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 829  : 		if (!empty())

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN1@pop_front

; 830  : 			{	// something to erase, do it
; 831  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 832  : 
; 833  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 834  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);
; 835  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	inc	DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+24]
	cmp	DWORD PTR [eax+20], edx
	ja	SHORT $LN2@pop_front

; 836  : 				_Myoff = 0;

	mov	DWORD PTR [eax+24], 0
$LN2@pop_front:

; 837  : 			if (--_Mysize == 0)

	add	ecx, -1
	mov	DWORD PTR [eax+28], ecx
	jne	SHORT $LN1@pop_front

; 838  : 				_Myoff = 0;

	mov	DWORD PTR [eax+24], 0
$LN1@pop_front:

; 839  : 			}
; 840  : 			}

	ret	0
?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size, COMDAT
; _this$ = eax

; 724  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 725  : 		}

	ret	0
?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Rank>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Rank>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z PROC	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN3@capacity@13

; 636  : 		}

	ret	0
$LN3@capacity@13:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, eax
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z PROC	; std::allocator<__int64>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z ENDP	; std::allocator<__int64>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@_J@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@_J@std@@QAE@ABV01@@Z PROC		; std::allocator<__int64>::allocator<__int64>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@_J@std@@QAE@ABV01@@Z ENDP		; std::allocator<__int64>::allocator<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@_J@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_J@std@@QAE@XZ PROC			; std::allocator<__int64>::allocator<__int64>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_J@std@@QAE@XZ ENDP			; std::allocator<__int64>::allocator<__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@14
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@14:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z
_TEXT	SEGMENT
??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 5
	cmp	edi, eax
	jb	SHORT $LN1@operator@25
	call	__invalid_parameter_noinfo
$LN1@operator@25:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	shl	eax, 5
	add	eax, DWORD PTR [esi+12]

; 771  : 		}

	ret	0
??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC	; std::vector<double,std::allocator<double> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP	; std::vector<double,std::allocator<double> >::size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\arg.hpp
_TEXT	ENDS
;	COMDAT ??0?$arg@$08@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$08@boost@@QAE@XZ PROC				; boost::arg<9>::arg<9>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$08@boost@@QAE@XZ ENDP				; boost::arg<9>::arg<9>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$07@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$07@boost@@QAE@XZ PROC				; boost::arg<8>::arg<8>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$07@boost@@QAE@XZ ENDP				; boost::arg<8>::arg<8>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$06@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$06@boost@@QAE@XZ PROC				; boost::arg<7>::arg<7>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$06@boost@@QAE@XZ ENDP				; boost::arg<7>::arg<7>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$05@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$05@boost@@QAE@XZ PROC				; boost::arg<6>::arg<6>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$05@boost@@QAE@XZ ENDP				; boost::arg<6>::arg<6>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$04@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$04@boost@@QAE@XZ PROC				; boost::arg<5>::arg<5>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$04@boost@@QAE@XZ ENDP				; boost::arg<5>::arg<5>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$03@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$03@boost@@QAE@XZ PROC				; boost::arg<4>::arg<4>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$03@boost@@QAE@XZ ENDP				; boost::arg<4>::arg<4>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$02@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$02@boost@@QAE@XZ PROC				; boost::arg<3>::arg<3>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$02@boost@@QAE@XZ ENDP				; boost::arg<3>::arg<3>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$01@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$01@boost@@QAE@XZ PROC				; boost::arg<2>::arg<2>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$01@boost@@QAE@XZ ENDP				; boost::arg<2>::arg<2>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$00@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$00@boost@@QAE@XZ PROC				; boost::arg<1>::arg<1>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$00@boost@@QAE@XZ ENDP				; boost::arg<1>::arg<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z
_TEXT	SEGMENT
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z PROC	; std::vector<float,std::allocator<float> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@26
	call	__invalid_parameter_noinfo
$LN1@operator@26:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ENDP	; std::vector<float,std::allocator<float> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@I_J@std@@QAE@ABIAB_J@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
??0?$pair@I_J@std@@QAE@ABIAB_J@Z PROC			; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>, COMDAT
; _this$ = eax
; __Val2$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], ecx

; 51   : 		}

	ret	4
??0?$pair@I_J@std@@QAE@ABIAB_J@Z ENDP			; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
_TEXT	ENDS
;	COMDAT ?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop, COMDAT
; _this$ = eax

; 76   : 		c.pop_front();

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN3@pop
	inc	DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+24]
	cmp	DWORD PTR [eax+20], edx
	ja	SHORT $LN4@pop
	mov	DWORD PTR [eax+24], 0
$LN4@pop:
	add	ecx, -1
	mov	DWORD PTR [eax+28], ecx
	jne	SHORT $LN3@pop
	mov	DWORD PTR [eax+24], 0
$LN3@pop:

; 77   : 		}

	ret	0
?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size, COMDAT
; _this$ = eax

; 46   : 		return (c.size());

	mov	eax, DWORD PTR [eax+28]

; 47   : 		}

	ret	0
?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@27
	call	__invalid_parameter_noinfo
$LN1@operator@27:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR [esi+12]

; 786  : 		}

	ret	0
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@28
	call	__invalid_parameter_noinfo
$LN1@operator@28:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR [esi+12]

; 771  : 		}

	ret	0
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ
_TEXT	SEGMENT
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::back, COMDAT
; _this$ = eax

; 490  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 491  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@back
	mov	eax, DWORD PTR [eax+4]
	add	eax, -8					; fffffff8H

; 492  :     }

	ret	0
$LN3@back:

; 490  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 491  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	lea	eax, DWORD PTR [ecx-8]

; 492  :     }

	ret	0
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ
_TEXT	SEGMENT
?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::front, COMDAT
; _this$ = eax

; 472  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (front element not available)
; 473  :         return *m_first;

	mov	eax, DWORD PTR [eax+8]

; 474  :     }

	ret	0
?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ
_TEXT	SEGMENT
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::back, COMDAT
; _this$ = eax

; 454  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 455  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@back@2
	mov	eax, DWORD PTR [eax+4]
	add	eax, -8					; fffffff8H

; 456  :     }

	ret	0
$LN3@back@2:

; 454  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 455  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	lea	eax, DWORD PTR [ecx-8]

; 456  :     }

	ret	0
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@29
	call	__invalid_parameter_noinfo
$LN1@operator@29:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]

; 771  : 		}

	ret	0
??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC	; std::vector<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP	; std::vector<__int64,std::allocator<__int64> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z
_TEXT	SEGMENT
??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@30
	call	__invalid_parameter_noinfo
$LN1@operator@30:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@I@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@31
	call	__invalid_parameter_noinfo
$LN1@operator@31:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]

; 771  : 		}

	ret	0
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@I@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty, COMDAT
; _this$ = ecx

; 375  : 			return (count == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 376  : 		}

	ret	0
?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull, COMDAT
; _this$ = eax

; 369  : 			return (entry.size() == count);

	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [eax+24]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax]
	sete	dl
	mov	al, dl

; 370  : 		}

	ret	0
?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::size, COMDAT
; _this$ = eax

; 244  : 			return count;

	mov	eax, DWORD PTR [eax]

; 245  : 		}

	ret	0
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
_TEXT	ENDS
PUBLIC	?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextCommandExecuteTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ PROC	; DRAMsimII::Channel::nextCommandExecuteTime
; _this$ = esi

; 324  : 	// then check to see when the next command occurs
; 325  : 	if (const Command *tempCommand = readNextCommand())

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN2@nextComman

; 326  : 	{
; 327  : 		tick tempCommandExecuteTime = earliestExecuteTime(tempCommand);

	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 340  : }

	ret	0
$LN2@nextComman:

; 328  : #ifndef NDEBUG
; 329  : 		int tempGap = minProtocolGap(tempCommand);
; 330  : 
; 331  : 		if (time + tempGap != tempCommandExecuteTime)
; 332  : 			cerr << time << " " << tempGap << " " << tempCommandExecuteTime << " " << tempCommand->getCommandType() << " " << tempCommand->getAddress() << endl;
; 333  : 		;
; 334  : 		assert(time + tempGap == tempCommandExecuteTime);
; 335  : #endif
; 336  : 		return tempCommandExecuteTime;
; 337  : 	}
; 338  : 	else
; 339  : 		return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 340  : }

	ret	0
?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ ENDP	; DRAMsimII::Channel::nextCommandExecuteTime
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0list0@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??0list0@_bi@boost@@QAE@XZ PROC				; boost::_bi::list0::list0, COMDAT
; _this$ = eax

; 168  :     list0() {}

	ret	0
??0list0@_bi@boost@@QAE@XZ ENDP				; boost::_bi::list0::list0
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\basic_timed_mutex.hpp
_TEXT	ENDS
;	COMDAT ?destroy@basic_timed_mutex@detail@boost@@QAEXXZ
_TEXT	SEGMENT
?destroy@basic_timed_mutex@detail@boost@@QAEXXZ PROC	; boost::detail::basic_timed_mutex::destroy, COMDAT
; _this$ = ecx

; 42   : #ifdef BOOST_MSVC
; 43   : #pragma warning(push)
; 44   : #pragma warning(disable:4312)
; 45   : #endif
; 46   :                 void* const old_event=BOOST_INTERLOCKED_EXCHANGE_POINTER(&event,0);

	xor	eax, eax
	add	ecx, 4
	xchg	DWORD PTR [ecx], eax

; 47   : #ifdef BOOST_MSVC
; 48   : #pragma warning(pop)
; 49   : #endif
; 50   :                 if(old_event)

	test	eax, eax
	je	SHORT $LN1@destroy@2

; 51   :                 {
; 52   :                     win32::CloseHandle(old_event);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN1@destroy@2:

; 53   :                 }
; 54   :             }

	ret	0
?destroy@basic_timed_mutex@detail@boost@@QAEXXZ ENDP	; boost::detail::basic_timed_mutex::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?initialize@basic_timed_mutex@detail@boost@@QAEXXZ
_TEXT	SEGMENT
?initialize@basic_timed_mutex@detail@boost@@QAEXXZ PROC	; boost::detail::basic_timed_mutex::initialize, COMDAT
; _this$ = ecx

; 36   :                 active_count=0;

	mov	DWORD PTR [ecx], 0

; 37   :                 event=0;

	mov	DWORD PTR [ecx+4], 0

; 38   :             }

	ret	0
?initialize@basic_timed_mutex@detail@boost@@QAEXXZ ENDP	; boost::detail::basic_timed_mutex::initialize
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z PROC ; intrusive_ptr_add_ref, COMDAT

; 49   :                 BOOST_INTERLOCKED_INCREMENT(&p->count);

	mov	eax, DWORD PTR _p$[esp-4]
	add	eax, 4
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx

; 50   :             }

	ret	0
?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z ENDP ; intrusive_ptr_add_ref
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ?free_raw_heap_memory@detail@boost@@YAXPAX@Z
_TEXT	SEGMENT
_heap_memory$ = 8					; size = 4
?free_raw_heap_memory@detail@boost@@YAXPAX@Z PROC	; boost::detail::free_raw_heap_memory, COMDAT

; 70   :             BOOST_VERIFY(detail::win32::HeapFree(detail::win32::GetProcessHeap(),0,heap_memory)!=0);

	mov	eax, DWORD PTR _heap_memory$[esp-4]
	push	eax
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12

; 71   :         }

	ret	0
?free_raw_heap_memory@detail@boost@@YAXPAX@Z ENDP	; boost::detail::free_raw_heap_memory
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
_TEXT	ENDS
;	COMDAT ??0handle_manager@win32@detail@boost@@QAE@PAX@Z
_TEXT	SEGMENT
_handle_to_manage_$ = 8					; size = 4
??0handle_manager@win32@detail@boost@@QAE@PAX@Z PROC	; boost::detail::win32::handle_manager::handle_manager, COMDAT
; _this$ = ecx

; 235  :                 {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _handle_to_manage_$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0handle_manager@win32@detail@boost@@QAE@PAX@Z ENDP	; boost::detail::win32::handle_manager::handle_manager
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?cleanup@handle_manager@win32@detail@boost@@AAEXXZ
_TEXT	SEGMENT
?cleanup@handle_manager@win32@detail@boost@@AAEXXZ PROC	; boost::detail::win32::handle_manager::cleanup, COMDAT
; _this$ = ecx

; 226  :                     if(handle_to_manage && handle_to_manage!=invalid_handle_value)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@cleanup
	cmp	eax, -1
	je	SHORT $LN1@cleanup

; 227  :                     {
; 228  :                         BOOST_VERIFY(CloseHandle(handle_to_manage));

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN1@cleanup:

; 229  :                     }
; 230  :                 }

	ret	0
?cleanup@handle_manager@win32@detail@boost@@AAEXXZ ENDP	; boost::detail::win32::handle_manager::cleanup
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gthread_exception@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_exception@boost@@UAEPAXI@Z PROC		; boost::thread_exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1thread_exception@boost@@UAE@XZ	; boost::thread_exception::~thread_exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_exception@boost@@UAEPAXI@Z ENDP		; boost::thread_exception::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gthread_resource_error@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_resource_error@boost@@UAEPAXI@Z PROC		; boost::thread_resource_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1thread_resource_error@boost@@UAE@XZ	; boost::thread_resource_error::~thread_resource_error
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_resource_error@boost@@UAEPAXI@Z ENDP		; boost::thread_resource_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0thread_exception@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0thread_exception@boost@@QAE@ABV01@@Z PROC		; boost::thread_exception::thread_exception, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7thread_exception@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0thread_exception@boost@@QAE@ABV01@@Z ENDP		; boost::thread_exception::thread_exception
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0thread_resource_error@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0thread_resource_error@boost@@QAE@ABV01@@Z PROC	; boost::thread_resource_error::thread_resource_error, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7thread_exception@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7thread_resource_error@boost@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0thread_resource_error@boost@@QAE@ABV01@@Z ENDP	; boost::thread_resource_error::thread_resource_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z
_TEXT	SEGMENT
$T327295 = -20						; size = 16
_type$ = 8						; size = 4
_state$ = 12						; size = 4
?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z PROC ; boost::detail::win32::create_anonymous_event, COMDAT

; 173  : #if !defined(BOOST_NO_ANSI_APIS)  
; 174  :                 handle const res=win32::CreateEventA(0,type,state,0);

	mov	eax, DWORD PTR _state$[esp-4]
	mov	ecx, DWORD PTR _type$[esp-4]
	sub	esp, 20					; 00000014H
	push	0
	push	eax
	push	ecx
	push	0
	call	DWORD PTR __imp__CreateEventA@16

; 175  : #else
; 176  :                 handle const res=win32::CreateEventW(0,type,state,0);
; 177  : #endif                
; 178  :                 if(!res)

	test	eax, eax
	jne	SHORT $LN2@create_ano

; 179  :                 {
; 180  :                     throw thread_resource_error();

	lea	ecx, DWORD PTR $T327295[esp+20]
	call	??0thread_resource_error@boost@@QAE@XZ	; boost::thread_resource_error::thread_resource_error
	push	OFFSET __TI3?AVthread_resource_error@boost@@
	lea	edx, DWORD PTR $T327295[esp+24]
	push	edx
	call	__CxxThrowException@8
$LN5@create_ano:
$LN2@create_ano:

; 181  :                 }
; 182  :                 return res;
; 183  :             }

	add	esp, 20					; 00000014H
	ret	0
$LN4@create_ano:
?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z ENDP ; boost::detail::win32::create_anonymous_event
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1_ns2__submitEpochResultResponseElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__submitEpochResultResponseElement@@UAE@XZ PROC	; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement, COMDAT
; _this$ = ecx

; 285  : 	virtual ~_ns2__submitEpochResultResponseElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	ret	0
??1_ns2__submitEpochResultResponseElement@@UAE@XZ ENDP	; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__submitEpochResultResponseElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__submitEpochResultResponseElement@@QAE@XZ PROC	; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement, COMDAT
; _this$ = ecx

; 284  : 	_ns2__submitEpochResultResponseElement() : result((bool)0), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	mov	BYTE PTR [eax+4], cl
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__submitEpochResultResponseElement@@QAE@XZ ENDP	; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ PROC ; _ns2__submitEpochResultResponseElement::soap_type, COMDAT
; _this$ = ecx

; 277  : 	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns2__submitEpochResultResponseElement */

	mov	eax, 24					; 00000018H
	ret	0
?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ ENDP ; _ns2__submitEpochResultResponseElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__submitEpochResultElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__submitEpochResultElement@@UBEHXZ PROC	; _ns2__submitEpochResultElement::soap_type, COMDAT
; _this$ = ecx

; 256  : 	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns2__submitEpochResultElement */

	mov	eax, 23					; 00000017H
	ret	0
?soap_type@_ns2__submitEpochResultElement@@UBEHXZ ENDP	; _ns2__submitEpochResultElement::soap_type
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.h
_TEXT	ENDS
;	COMDAT ?getChannelID@Channel@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getChannelID@Channel@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Channel::getChannelID, COMDAT
; _this$ = eax

; 101  : 		unsigned getChannelID() const { return channelID; }			///< return the ordinal of this channel

	mov	eax, DWORD PTR [eax+392]
	ret	0
?getChannelID@Channel@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Channel::getChannelID
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\powerconfig.h
_TEXT	ENDS
;	COMDAT ?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_lastTime$ = 8						; size = 8
?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z PROC ; DRAMsimII::PowerConfig::setLastCalculation, COMDAT
; _this$ = eax

; 126  : 		void setLastCalculation(const tick lastTime) { lastCalculation = lastTime; }

	mov	ecx, DWORD PTR _lastTime$[esp-4]
	mov	edx, DWORD PTR _lastTime$[esp]
	mov	DWORD PTR [eax+200], ecx
	mov	DWORD PTR [eax+204], edx
	ret	8
?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z ENDP ; DRAMsimII::PowerConfig::setLastCalculation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_newTime$ = 8						; size = 8
?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::PowerConfig::resetToTime, COMDAT
; _this$ = eax

; 123  : 		void resetToTime(const tick newTime) { lastCalculation = newTime; }

	mov	ecx, DWORD PTR _newTime$[esp-4]
	mov	edx, DWORD PTR _newTime$[esp]
	mov	DWORD PTR [eax+200], ecx
	mov	DWORD PTR [eax+204], edx
	ret	8
?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::PowerConfig::resetToTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ PROC ; DRAMsimII::PowerConfig::getFrequencyScaleFactor, COMDAT
; _this$ = eax

; 122  : 		double getFrequencyScaleFactor() const { return frequencyScaleFactor; }

	movsd	xmm0, QWORD PTR [eax+112]
	ret	0
?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ENDP ; DRAMsimII::PowerConfig::getFrequencyScaleFactor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ PROC ; DRAMsimII::PowerConfig::getVoltageScaleFactor, COMDAT
; _this$ = eax

; 121  : 		double getVoltageScaleFactor() const { return voltageScaleFactor;}

	movsd	xmm0, QWORD PTR [eax+104]
	ret	0
?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ENDP ; DRAMsimII::PowerConfig::getVoltageScaleFactor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getIDD1@PowerConfig@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?getIDD1@PowerConfig@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::PowerConfig::getIDD1, COMDAT
; _this$ = eax

; 111  : 		int getIDD1() const { return IDD1; }

	mov	eax, DWORD PTR [eax+12]
	ret	0
?getIDD1@PowerConfig@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::PowerConfig::getIDD1
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::PowerConfig::getDevicesPerRank, COMDAT
; _this$ = eax

; 109  : 		unsigned getDevicesPerRank() const { return DQperRank; }

	mov	eax, DWORD PTR [eax+172]
	ret	0
?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::PowerConfig::getDevicesPerRank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gettRC@PowerConfig@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?gettRC@PowerConfig@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::PowerConfig::gettRC, COMDAT
; _this$ = eax

; 105  : 		unsigned gettRC() const { return tRC; }

	mov	eax, DWORD PTR [eax+188]
	ret	0
?gettRC@PowerConfig@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::PowerConfig::gettRC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsWR, COMDAT
; _this$ = eax

; 102  : 		double getPdsWR() const { return PdsWR; }

	movsd	xmm0, QWORD PTR [eax+96]
	ret	0
?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsWR
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsRD, COMDAT
; _this$ = eax

; 101  : 		double getPdsRD() const { return PdsRD; }

	movsd	xmm0, QWORD PTR [eax+88]
	ret	0
?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsRD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsACT, COMDAT
; _this$ = eax

; 98   : 		double getPdsACT() const { return PdsACT; }

	movsd	xmm0, QWORD PTR [eax+48]
	ret	0
?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsACT
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsPRE_PDN@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsPRE_PDN@PowerConfig@DRAMsimII@@QBENXZ PROC	; DRAMsimII::PowerConfig::getPdsPRE_PDN, COMDAT
; _this$ = eax

; 97   : 		double getPdsPRE_PDN() const { return PdsPRE_PDN; }

	movsd	xmm0, QWORD PTR [eax+80]
	ret	0
?getPdsPRE_PDN@PowerConfig@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::PowerConfig::getPdsPRE_PDN
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsPRE_STBY@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsPRE_STBY@PowerConfig@DRAMsimII@@QBENXZ PROC	; DRAMsimII::PowerConfig::getPdsPRE_STBY, COMDAT
; _this$ = eax

; 96   : 		double getPdsPRE_STBY() const { return PdsPRE_STBY; }

	movsd	xmm0, QWORD PTR [eax+64]
	ret	0
?getPdsPRE_STBY@PowerConfig@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::PowerConfig::getPdsPRE_STBY
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsACT_PDN@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsACT_PDN@PowerConfig@DRAMsimII@@QBENXZ PROC	; DRAMsimII::PowerConfig::getPdsACT_PDN, COMDAT
; _this$ = eax

; 95   : 		double getPdsACT_PDN() const { return PdsACT_PDN; }

	movsd	xmm0, QWORD PTR [eax+72]
	ret	0
?getPdsACT_PDN@PowerConfig@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::PowerConfig::getPdsACT_PDN
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsACT_STBY@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsACT_STBY@PowerConfig@DRAMsimII@@QBENXZ PROC	; DRAMsimII::PowerConfig::getPdsACT_STBY, COMDAT
; _this$ = eax

; 94   : 		double getPdsACT_STBY() const { return PdsACT_STBY; }

	movsd	xmm0, QWORD PTR [eax+56]
	ret	0
?getPdsACT_STBY@PowerConfig@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::PowerConfig::getPdsACT_STBY
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::PowerConfig::getLastCalculation, COMDAT
; _this$ = ecx

; 93   : 		tick getLastCalculation() const { return lastCalculation; }

	mov	eax, DWORD PTR [ecx+200]
	mov	edx, DWORD PTR [ecx+204]
	ret	0
?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::PowerConfig::getLastCalculation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getVDD@PowerConfig@DRAMsimII@@QBEMXZ
_TEXT	SEGMENT
?getVDD@PowerConfig@DRAMsimII@@QBEMXZ PROC		; DRAMsimII::PowerConfig::getVDD, COMDAT
; _this$ = eax

; 89   : 		float getVDD() const { return VDD; }

	movss	xmm0, DWORD PTR [eax]
	ret	0
?getVDD@PowerConfig@DRAMsimII@@QBEMXZ ENDP		; DRAMsimII::PowerConfig::getVDD
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.h
_TEXT	ENDS
;	COMDAT ?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Rank::resetCycleCounts, COMDAT
; _this$ = eax

; 125  : 		void resetCycleCounts() { CASLength = CASWLength = 0; }

	xor	ecx, ecx
	mov	DWORD PTR [eax+132], ecx
	mov	DWORD PTR [eax+128], ecx
	ret	0
?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Rank::resetCycleCounts
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setLastBankID@Rank@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setLastBankID@Rank@DRAMsimII@@QAEXI@Z PROC		; DRAMsimII::Rank::setLastBankID, COMDAT
; _this$ = eax
; _value$ = ecx

; 123  : 		void setLastBankID(const unsigned value) { lastBankID = value; }

	mov	DWORD PTR [eax+140], ecx
	ret	0
?setLastBankID@Rank@DRAMsimII@@QAEXI@Z ENDP		; DRAMsimII::Rank::setLastBankID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setRankID@Rank@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setRankID@Rank@DRAMsimII@@QAEXI@Z PROC			; DRAMsimII::Rank::setRankID, COMDAT
; _this$ = eax
; _value$ = ecx

; 122  : 		void setRankID(const unsigned value) { rankID = value; }

	mov	DWORD PTR [eax+136], ecx
	ret	0
?setRankID@Rank@DRAMsimII@@QAEXI@Z ENDP			; DRAMsimII::Rank::setRankID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getWriteCycles@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getWriteCycles@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getWriteCycles, COMDAT
; _this$ = eax

; 117  : 		unsigned getWriteCycles() const { return CASWLength; }

	mov	eax, DWORD PTR [eax+132]
	ret	0
?getWriteCycles@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getWriteCycles
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getReadCycles@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getReadCycles@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getReadCycles, COMDAT
; _this$ = eax

; 116  : 		unsigned getReadCycles() const { return CASLength; }

	mov	eax, DWORD PTR [eax+128]
	ret	0
?getReadCycles@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getReadCycles
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::Rank::getOtherLastCASWLength, COMDAT
; _this$ = eax

; 115  : 		unsigned getOtherLastCASWLength() const { return otherLastCASWLength; }

	mov	eax, DWORD PTR [eax+124]
	ret	0
?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::Rank::getOtherLastCASWLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::Rank::getOtherLastCASLength, COMDAT
; _this$ = eax

; 114  : 		unsigned getOtherLastCASLength() const { return otherLastCASLength; }

	mov	eax, DWORD PTR [eax+120]
	ret	0
?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::Rank::getOtherLastCASLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getLastCASWLength, COMDAT
; _this$ = eax

; 113  : 		unsigned getLastCASWLength() const { return lastCASWLength; }

	mov	eax, DWORD PTR [eax+116]
	ret	0
?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getLastCASWLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLastCASLength@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getLastCASLength, COMDAT
; _this$ = eax

; 112  : 		unsigned getLastCASLength() const { return lastCASLength; }

	mov	eax, DWORD PTR [eax+112]
	ret	0
?getLastCASLength@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getLastCASLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 110  : 		tick getLastPrechargeTime() const { return lastPrechargeAnyBankTime; }

	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
	ret	0
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getOtherLastCASWTime, COMDAT
; _this$ = ecx

; 109  : 		tick getOtherLastCASWTime() const { return otherLastCASWTime; }

	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+52]
	ret	0
?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getOtherLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getOtherLastCASTime, COMDAT
; _this$ = ecx

; 108  : 		tick getOtherLastCASTime() const { return otherLastCASTime; }

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	ret	0
?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getOtherLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASWTime, COMDAT
; _this$ = ecx

; 107  : 		tick getLastCASWTime() const { return lastCASWTime; }

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	ret	0
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASTime, COMDAT
; _this$ = ecx

; 106  : 		tick getLastCASTime() const { return lastCASTime; }

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]
	ret	0
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastRefreshTime, COMDAT
; _this$ = ecx

; 105  : 		tick getLastRefreshTime() const { return lastRefreshTime; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	ret	0
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastRefreshTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRankID@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRankID@Rank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Rank::getRankID, COMDAT
; _this$ = eax

; 102  : 		unsigned getRankID() const { return rankID; }		

	mov	eax, DWORD PTR [eax+136]
	ret	0
?getRankID@Rank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Rank::getRankID
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?getRASCount@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRASCount@Bank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Bank::getRASCount, COMDAT
; _this$ = eax

; 98   : 		unsigned getRASCount() const { return RASCount; }

	mov	eax, DWORD PTR [eax+136]
	ret	0
?getRASCount@Bank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Bank::getRASCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isActivated@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isActivated@Bank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Bank::isActivated, COMDAT
; _this$ = eax

; 95   : 		bool isActivated() const { return activated; }

	mov	al, BYTE PTR [eax+132]
	ret	0
?isActivated@Bank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Bank::isActivated
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Bank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 89   : 		tick getLastPrechargeTime() const { return lastPrechargeTime; }

	mov	eax, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [ecx+84]
	ret	0
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Bank::getLastPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASWTime, COMDAT
; _this$ = ecx

; 87   : 		tick getLastCASWTime() const {return lastCASWTime; }

	mov	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR [ecx+76]
	ret	0
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASTime, COMDAT
; _this$ = ecx

; 86   : 		tick getLastCASTime() const { return lastCASTime; }

	mov	eax, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR [ecx+68]
	ret	0
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastRASTime, COMDAT
; _this$ = ecx

; 85   : 		tick getLastRASTime() const { return lastRASTime; }

	mov	eax, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR [ecx+60]
	ret	0
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastRASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Bank::accumulateAndResetCounts, COMDAT
; _this$ = eax

; 80   : 		void accumulateAndResetCounts() { totalRASCount += RASCount; totalCASCount += CASCount; totalCASWCount += CASWCount; RASCount = CASWCount = CASCount = 0; }

	mov	ecx, DWORD PTR [eax+136]
	add	DWORD PTR [eax+140], ecx
	mov	ecx, DWORD PTR [eax+152]
	mov	edx, DWORD PTR [eax+144]
	add	DWORD PTR [eax+156], ecx
	add	DWORD PTR [eax+148], edx
	xor	ecx, ecx
	mov	DWORD PTR [eax+144], ecx
	mov	DWORD PTR [eax+152], ecx
	mov	DWORD PTR [eax+136], ecx
	ret	0
?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Bank::accumulateAndResetCounts
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ?getHitRate@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
?getHitRate@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@XZ PROC ; DRAMsimII::Statistics::getHitRate, COMDAT
; _this$ = eax

; 164  : 		const std::vector<std::vector<std::pair<std::pair<uint64_t, uint64_t>, std::pair<uint64_t, uint64_t> > > > &getHitRate() const { return hitRate; }

	add	eax, 580				; 00000244H
	ret	0
?getHitRate@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@XZ ENDP ; DRAMsimII::Statistics::getHitRate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRowReduction@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@XZ
_TEXT	SEGMENT
?getRowReduction@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@XZ PROC ; DRAMsimII::Statistics::getRowReduction, COMDAT
; _this$ = eax

; 161  : 		const std::vector<std::vector<unsigned> >& getRowReduction() const { return rasReduction;}

	add	eax, 80					; 00000050H
	ret	0
?getRowReduction@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@XZ ENDP ; DRAMsimII::Statistics::getRowReduction
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Statistics::reportTFawCommand, COMDAT
; _this$ = eax

; 155  : 		inline void reportTFawCommand() { issuedAtTFAW++; }

	inc	DWORD PTR [eax+104]
	ret	0
?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Statistics::reportTFawCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\systemconfiguration.h
_TEXT	ENDS
;	COMDAT ?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getDecodeWindow, COMDAT
; _this$ = eax

; 113  : 		unsigned getDecodeWindow() const { return decodeWindow; }

	mov	eax, DWORD PTR [eax+376]
	ret	0
?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getDecodeWindow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; DRAMsimII::SystemConfiguration::getSessionID, COMDAT
; _this$ = eax

; 112  : 		const std::string &getSessionID() const { return sessionID; }

	add	eax, 400				; 00000190H
	ret	0
?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; DRAMsimII::SystemConfiguration::getSessionID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::SystemConfiguration::isReadWriteGrouping, COMDAT
; _this$ = eax

; 107  : 		bool isReadWriteGrouping() const { return readWriteGrouping; }

	mov	al, BYTE PTR [eax+345]
	ret	0
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ
_TEXT	SEGMENT
?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ PROC ; DRAMsimII::SystemConfiguration::getRefreshPolicy, COMDAT
; _this$ = eax

; 104  : 		RefreshPolicy getRefreshPolicy() const { return refreshPolicy; }

	mov	eax, DWORD PTR [eax+304]
	ret	0
?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getRefreshPolicy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ PROC	; DRAMsimII::SystemConfiguration::getDatarate, COMDAT
; _this$ = eax

; 103  : 		double getDatarate() const { return datarate; }

	movsd	xmm0, QWORD PTR [eax+336]
	ret	0
?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::SystemConfiguration::getDatarate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getEpoch@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getEpoch@SystemConfiguration@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::SystemConfiguration::getEpoch, COMDAT
; _this$ = eax

; 102  : 		unsigned getEpoch() const { return epoch; }

	mov	eax, DWORD PTR [eax+380]
	ret	0
?getEpoch@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::SystemConfiguration::getEpoch
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ
_TEXT	SEGMENT
?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ PROC ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm, COMDAT
; _this$ = eax

; 91   : 		TransactionOrderingAlgorithm getTransactionOrderingAlgorithm() const { return transactionOrderingAlgorithm; }

	mov	eax, DWORD PTR [eax+292]
	ret	0
?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ
_TEXT	SEGMENT
?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ PROC ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy, COMDAT
; _this$ = eax

; 88   : 		RowBufferPolicy getRowBufferManagementPolicy() const { return rowBufferManagementPolicy; }

	mov	eax, DWORD PTR [eax+328]
	ret	0
?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_TEXT	ENDS
;	COMDAT ?tOST@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tOST@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tOST, COMDAT
; _this$ = eax

; 83   : 		int tOST() const { return t_ost; }

	mov	eax, DWORD PTR [eax+68]
	ret	0
?tOST@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tOST
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRTRS, COMDAT
; _this$ = eax

; 81   : 		int tRTRS() const { return t_rtrs; }

	mov	eax, DWORD PTR [eax+56]
	ret	0
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRTRS
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRFC, COMDAT
; _this$ = eax

; 79   : 		int tRFC() const { return t_rfc; }

	mov	eax, DWORD PTR [eax+40]
	ret	0
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRFC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tFAW, COMDAT
; _this$ = eax

; 78   : 		int tFAW() const { return t_faw; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tFAW
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRRD, COMDAT
; _this$ = eax

; 77   : 		int tRRD() const { return t_rrd; }

	mov	eax, DWORD PTR [eax+48]
	ret	0
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRRD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tREFI, COMDAT
; _this$ = eax

; 74   : 		int tREFI() const { return t_refi; }

	mov	eax, DWORD PTR [eax+80]
	ret	0
?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tREFI
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ PROC ; DRAMsimII::TimingSpecification::tBufferDelay, COMDAT
; _this$ = eax

; 72   : 		int tBufferDelay() const { return t_buffer_delay; }

	mov	eax, DWORD PTR [eax+76]
	ret	0
?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ ENDP ; DRAMsimII::TimingSpecification::tBufferDelay
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?setHit@Command@DRAMsimII@@QAEX_N@Z
_TEXT	SEGMENT
?setHit@Command@DRAMsimII@@QAEX_N@Z PROC		; DRAMsimII::Command::setHit, COMDAT
; _this$ = eax
; _value$ = ecx

; 95   : 		void setHit(bool value) { hit = value; }

	mov	BYTE PTR [eax+92], cl
	ret	0
?setHit@Command@DRAMsimII@@QAEX_N@Z ENDP		; DRAMsimII::Command::setHit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ
_TEXT	SEGMENT
?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ PROC ; DRAMsimII::Command::removeHost, COMDAT
; _this$ = ecx

; 93   : 		Transaction *removeHost() { Transaction* host = hostTransaction; hostTransaction = NULL; return host; }

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [ecx+84], 0
	ret	0
?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Command::removeHost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isActivate@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isActivate@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isActivate, COMDAT
; _this$ = eax

; 83   : 		bool isActivate() const { return ((commandType == ACTIVATE) || (commandType == ACTIVATE_ALL)); }

	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN3@isActivate
	cmp	eax, 8
	je	SHORT $LN3@isActivate
	xor	eax, eax
	ret	0
$LN3@isActivate:
	mov	eax, 1
	ret	0
?isActivate@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isActivate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ
_TEXT	SEGMENT
?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ PROC	; DRAMsimII::Command::getHost, COMDAT
; _this$ = eax

; 81   : 		Transaction *getHost() const { return hostTransaction; }

	mov	eax, DWORD PTR [eax+84]
	ret	0
?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ ENDP	; DRAMsimII::Command::getHost
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\transaction.h
_TEXT	ENDS
;	COMDAT ?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Transaction::setDecodeTime, COMDAT
; _this$ = eax

; 71   : 		void setDecodeTime(const tick value) { decodeTime = value; }

	mov	ecx, DWORD PTR _value$[esp-4]
	mov	edx, DWORD PTR _value$[esp]
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+92], edx
	ret	8
?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Transaction::setDecodeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isRefresh@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRefresh@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isRefresh, COMDAT
; _this$ = ecx

; 68   : 		bool isRefresh() const { return (type == AUTO_REFRESH_TRANSACTION); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 4
	sete	al
	ret	0
?isRefresh@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isRefresh
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isRead@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRead@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isRead, COMDAT
; _this$ = eax

; 66   : 		bool isRead() const { return ((type == IFETCH_TRANSACTION) || (type == READ_TRANSACTION) || (type == PREFETCH_TRANSACTION)); }

	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN3@isRead
	cmp	eax, 2
	je	SHORT $LN3@isRead
	cmp	eax, 3
	je	SHORT $LN3@isRead
	xor	eax, eax
	ret	0
$LN3@isRead:
	mov	eax, 1
	ret	0
?isRead@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isRead
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Transaction::getOriginalTransaction, COMDAT
; _this$ = eax

; 65   : 		unsigned getOriginalTransaction() const { return originalTransaction; }		///< get the external transaction that this is a representation for

	mov	eax, DWORD PTR [eax+108]
	ret	0
?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Transaction::getOriginalTransaction
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_ct$ = 8						; size = 8
?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Event::setCompletionTime, COMDAT
; _this$ = eax

; 100  : 		void setCompletionTime(const tick ct) { completionTime = ct; }

	mov	ecx, DWORD PTR _ct$[esp-4]
	mov	edx, DWORD PTR _ct$[esp]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx
	ret	8
?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Event::setCompletionTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setStartTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_st$ = 8						; size = 8
?setStartTime@Event@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Event::setStartTime, COMDAT
; _this$ = eax

; 99   : 		void setStartTime(const tick st) { startTime = st; }

	mov	ecx, DWORD PTR _st$[esp-4]
	mov	edx, DWORD PTR _st$[esp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx
	ret	8
?setStartTime@Event@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Event::setStartTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_et$ = 8						; size = 8
?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Event::setEnqueueTime, COMDAT
; _this$ = eax

; 98   : 		void setEnqueueTime(const tick et) { enqueueTime = et; }

	mov	ecx, DWORD PTR _et$[esp-4]
	mov	edx, DWORD PTR _et$[esp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	ret	8
?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Event::setEnqueueTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCompletionTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getCompletionTime@Event@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Event::getCompletionTime, COMDAT
; _this$ = ecx

; 88   : 		tick getCompletionTime() const { return completionTime; }

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	ret	0
?getCompletionTime@Event@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Event::getCompletionTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getStartTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getStartTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getStartTime, COMDAT
; _this$ = ecx

; 87   : 		tick getStartTime() const { return startTime; }

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]
	ret	0
?getStartTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getStartTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getArrivalTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getArrivalTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getArrivalTime, COMDAT
; _this$ = ecx

; 85   : 		tick getArrivalTime() const { return arrivalTime; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	ret	0
?getArrivalTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getArrivalTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Event@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
??1Event@DRAMsimII@@UAE@XZ PROC				; DRAMsimII::Event::~Event, COMDAT
; _this$ = ecx

; 82   : 		virtual ~Event() {}

	mov	DWORD PTR [ecx], OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??1Event@DRAMsimII@@UAE@XZ ENDP				; DRAMsimII::Event::~Event
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?setBank@Address@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setBank@Address@DRAMsimII@@QAEXI@Z PROC		; DRAMsimII::Address::setBank, COMDAT
; _this$ = eax
; _value$ = ecx

; 98   : 		void setBank(const unsigned value) { bank = value; }

	mov	DWORD PTR [eax+24], ecx
	ret	0
?setBank@Address@DRAMsimII@@QAEXI@Z ENDP		; DRAMsimII::Address::setBank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getColumn@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getColumn@Address@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Address::getColumn, COMDAT
; _this$ = eax

; 90   : 		unsigned getColumn() const { return column; }

	mov	eax, DWORD PTR [eax+32]
	ret	0
?getColumn@Address@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Address::getColumn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRank@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRank@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getRank, COMDAT
; _this$ = eax

; 87   : 		unsigned getRank() const { return rank; }

	mov	eax, DWORD PTR [eax+20]
	ret	0
?getRank@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getRank
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\noncopyable.hpp
_TEXT	ENDS
;	COMDAT ??1noncopyable@noncopyable_@boost@@IAE@XZ
_TEXT	SEGMENT
??1noncopyable@noncopyable_@boost@@IAE@XZ PROC		; boost::noncopyable_::noncopyable::~noncopyable, COMDAT
; _this$ = ecx

; 25   :       ~noncopyable() {}

	ret	0
??1noncopyable@noncopyable_@boost@@IAE@XZ ENDP		; boost::noncopyable_::noncopyable::~noncopyable
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0noncopyable@noncopyable_@boost@@IAE@XZ
_TEXT	SEGMENT
??0noncopyable@noncopyable_@boost@@IAE@XZ PROC		; boost::noncopyable_::noncopyable::noncopyable, COMDAT
; _this$ = ecx

; 24   :       noncopyable() {}

	mov	eax, ecx
	ret	0
??0noncopyable@noncopyable_@boost@@IAE@XZ ENDP		; boost::noncopyable_::noncopyable::noncopyable
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_alloc@std@@QAE@XZ PROC				; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 376  : 		{	// construct from message string with no memory allocation

	push	esi
	push	1
	push	OFFSET __bad_alloc_Message
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 377  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0bad_alloc@std@@QAE@XZ ENDP				; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@16
	push	esi
	npad	7
$LL9@Fill_n@16:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@16
	pop	esi
$LN7@Fill_n@16:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@26
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@26:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@17
$LL9@Fill_n@17:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@17
$LN7@Fill_n@17:

; 3255 : 	}

	ret	0
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@18
	push	esi
	npad	7
$LL9@Fill_n@18:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@18
	pop	esi
$LN7@Fill_n@18:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN7@Fill_n@19
	push	esi
	npad	7
$LL9@Fill_n@19:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL9@Fill_n@19
	pop	esi
$LN7@Fill_n@19:

; 3255 : 	}

	ret	0
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@20
$LL9@Fill_n@20:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL9@Fill_n@20
$LN7@Fill_n@20:

; 3255 : 	}

	ret	0
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@21
	push	esi
	npad	7
$LL9@Fill_n@21:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@21
	pop	esi
$LN7@Fill_n@21:

; 3255 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@27
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@27:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@28
	push	esi
	npad	7
$LL13@unchecked_@28:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@28
	pop	esi
$LN11@unchecked_@28:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@3:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z PROC	; stdext::unchecked_fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@29
$LL13@unchecked_@29:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@29
$LN11@unchecked_@29:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z ENDP	; stdext::unchecked_fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@30
	push	esi
	npad	7
$LL13@unchecked_@30:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@30
	pop	esi
$LN11@unchecked_@30:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z PROC	; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN11@unchecked_@31
	push	esi
	npad	7
$LL13@unchecked_@31:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL13@unchecked_@31
	pop	esi
$LN11@unchecked_@31:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z ENDP	; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z PROC	; stdext::unchecked_fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@32
$LL13@unchecked_@32:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL13@unchecked_@32
$LN11@unchecked_@32:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z ENDP	; stdext::unchecked_fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@33
	push	esi
	npad	7
$LL13@unchecked_@33:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@33
	pop	esi
$LN11@unchecked_@33:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@4:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
_TEXT	ENDS
;	COMDAT ??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_add_ref$ = 12						; size = 1
??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z PROC ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>, COMDAT
; _this$ = ecx

; 71   :     {

	mov	eax, ecx
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx

; 72   :         if( px != 0 && add_ref ) intrusive_ptr_add_ref( px );

	test	ecx, ecx
	je	SHORT $LN4@intrusive_
	cmp	BYTE PTR _add_ref$[esp-4], 0
	je	SHORT $LN4@intrusive_
	add	ecx, 4
	mov	edx, 1
	lock	 xadd	 DWORD PTR [ecx], edx
$LN4@intrusive_:

; 73   :     }

	ret	8
??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z ENDP ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@10
	push	esi
	npad	7
$LL15@Uninit_fil@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@10
	pop	esi
$LN13@Uninit_fil@10:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@4
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@4:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@6:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 3
	lea	edx, DWORD PTR [eax*8]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@5
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@5:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@7:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@11
$LL15@Uninit_fil@11:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@11
$LN13@Uninit_fil@11:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@6
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@6:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@12
	push	esi
	npad	7
$LL15@Uninit_fil@12:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@12
	pop	esi
$LN13@Uninit_fil@12:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN13@Uninit_fil@13
	push	esi
	npad	7
$LL15@Uninit_fil@13:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL15@Uninit_fil@13
	pop	esi
$LN13@Uninit_fil@13:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@14
$LL15@Uninit_fil@14:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@14
$LN13@Uninit_fil@14:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@15
	push	esi
	npad	7
$LL15@Uninit_fil@15:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@15
	pop	esi
$LN13@Uninit_fil@15:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@8:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@34
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@34:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@35
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@35:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@36
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@36:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@37
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@37:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z
_TEXT	SEGMENT
$T355725 = -16						; size = 4
$T355717 = -12						; size = 12
??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@28

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T355725[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T355717[esp+20]
	mov	DWORD PTR $T355725[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T355717[esp+20]
	push	ecx
	mov	DWORD PTR $T355717[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@28:
$LN1@Allocate@28:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@28:
??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@38
	push	esi
	npad	7
$LL19@unchecked_@38:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@38
	pop	esi
$LN17@unchecked_@38:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@9
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@9:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z
_TEXT	SEGMENT
??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@3:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@N@std@@YAPANIPAN@Z
_TEXT	SEGMENT
$T356071 = -16						; size = 4
$T356063 = -12						; size = 12
??$_Allocate@N@std@@YAPANIPAN@Z PROC			; std::_Allocate<double>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@29

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356071[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356063[esp+20]
	mov	DWORD PTR $T356071[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356063[esp+20]
	push	ecx
	mov	DWORD PTR $T356063[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@29:
$LN1@Allocate@29:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@29:
??$_Allocate@N@std@@YAPANIPAN@Z ENDP			; std::_Allocate<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z PROC ; stdext::_Unchecked_move_backward<double *,double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	edx, DWORD PTR [eax*8]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@10
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@10:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ENDP ; stdext::_Unchecked_move_backward<double *,double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z
_TEXT	SEGMENT
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove<double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@4:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove<double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T356314 = -16						; size = 4
$T356306 = -12						; size = 12
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@30

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356314[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356306[esp+20]
	mov	DWORD PTR $T356314[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356306[esp+20]
	push	ecx
	mov	DWORD PTR $T356306[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@30:
$LN1@Allocate@30:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@30:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@39
$LL19@unchecked_@39:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@39
$LN17@unchecked_@39:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@11
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@11:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@19
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
$LN3@Construct@19:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z
_TEXT	SEGMENT
$T356507 = -16						; size = 4
$T356499 = -12						; size = 12
??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,__int64> >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@31

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356507[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356499[esp+20]
	mov	DWORD PTR $T356507[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356499[esp+20]
	push	ecx
	mov	DWORD PTR $T356499[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@31:
$LN1@Allocate@31:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@31:
??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@40
	push	esi
	npad	7
$LL19@unchecked_@40:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@40
	pop	esi
$LN17@unchecked_@40:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z
_TEXT	SEGMENT
$T356624 = -16						; size = 4
$T356616 = -12						; size = 12
??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Rank>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 424				; 000001a8H
	jae	SHORT $LN1@Allocate@32

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356624[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356616[esp+20]
	mov	DWORD PTR $T356624[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356616[esp+20]
	push	ecx
	mov	DWORD PTR $T356616[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@32:
$LN1@Allocate@32:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	imul	ecx, 424				; 000001a8H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@32:
??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T356638 = -16						; size = 4
$T356630 = -12						; size = 12
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@33

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356638[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356630[esp+20]
	mov	DWORD PTR $T356638[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356630[esp+20]
	push	ecx
	mov	DWORD PTR $T356630[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@33:
$LN1@Allocate@33:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@33:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@_J@std@@YAPA_JIPA_J@Z
_TEXT	SEGMENT
$T356652 = -16						; size = 4
$T356644 = -12						; size = 12
??$_Allocate@_J@std@@YAPA_JIPA_J@Z PROC			; std::_Allocate<__int64>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@34

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356652[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356644[esp+20]
	mov	DWORD PTR $T356652[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356644[esp+20]
	push	ecx
	mov	DWORD PTR $T356644[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@34:
$LN1@Allocate@34:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@34:
??$_Allocate@_J@std@@YAPA_JIPA_J@Z ENDP			; std::_Allocate<__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN17@unchecked_@41
	push	esi
	npad	7
$LL19@unchecked_@41:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL19@unchecked_@41
	pop	esi
$LN17@unchecked_@41:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z
_TEXT	SEGMENT
$T356769 = -16						; size = 4
$T356761 = -12						; size = 12
??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Transaction *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@35

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T356769[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T356761[esp+20]
	mov	DWORD PTR $T356769[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T356761[esp+20]
	push	ecx
	mov	DWORD PTR $T356761[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@35:
$LN1@Allocate@35:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@35:
??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@42
$LL19@unchecked_@42:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL19@unchecked_@42
$LN17@unchecked_@42:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@43
	push	esi
	npad	7
$LL19@unchecked_@43:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@43
	pop	esi
$LN17@unchecked_@43:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@5:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z
_TEXT	SEGMENT
??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@6:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@7:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z
_TEXT	SEGMENT
??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@8:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@9
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@9:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z PROC ; boost::detail::heap_delete<boost::detail::thread_data_base>, COMDAT

; 378  :         {

	push	esi

; 379  :             data->~T();

	mov	esi, DWORD PTR _data$[esp]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx

; 380  :             free_raw_heap_memory(data);

	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
	pop	esi

; 381  :         }

	ret	0
??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z ENDP ; boost::detail::heap_delete<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@MHPBMABM@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@MHPBMABM@std@@QAE@XZ PROC			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@MHPBMABM@std@@QAE@XZ ENDP			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@119
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@119
$LN1@operator@119:
	call	__invalid_parameter_noinfo
$LN2@operator@119:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@17
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@17
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@17
$LN1@Vector_con@17:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@17:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	test	esi, esi
	je	SHORT $LN1@Deque_cons
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN1@Deque_cons
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN2@Deque_cons
$LN1@Deque_cons:
	call	__invalid_parameter_noinfo
$LN2@Deque_cons:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	edx, DWORD PTR [esi]

; 132  : 			_Myoff = _Off;

	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 133  : 			}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@120
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@120
$LN1@operator@120:
	call	__invalid_parameter_noinfo
$LN2@operator@120:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@121
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@121
$LN3@operator@121:
	call	__invalid_parameter_noinfo
$LN4@operator@121:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@6
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@6
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@6
$LN3@Vector_ite@6:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@6:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Deque_iter
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN3@Deque_iter
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN4@Deque_iter
$LN3@Deque_iter:
	call	__invalid_parameter_noinfo
$LN4@Deque_iter:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 382  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@122
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@122
$LN3@operator@122:
	call	__invalid_parameter_noinfo
$LN4@operator@122:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@18
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@18
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@18
$LN1@Vector_con@18:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@18:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@7
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@7
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@7
$LN5@Make_iter@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@7:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
$T357732 = -16						; size = 4
$T357738 = -12						; size = 12
?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@17
	xor	ecx, ecx
$LN3@allocate@17:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@17:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@17
	lea	eax, DWORD PTR $T357732[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T357738[esp+20]
	mov	DWORD PTR $T357732[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T357738[esp+20]
	push	ecx
	mov	DWORD PTR $T357738[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@17:
$LN11@allocate@17:
	int	3
?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@5
	push	ebx
	npad	7
$LL21@Ufill@5:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@5
	pop	ebx
$LN26@Ufill@5:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@123
	call	__invalid_parameter_noinfo
$LN1@operator@123:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@NHPBNABN@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@NHPBNABN@std@@QAE@XZ PROC			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@NHPBNABN@std@@QAE@XZ ENDP			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@HHPBHABH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@HHPBHABH@std@@QAE@XZ PROC			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@HHPBHABH@std@@QAE@XZ ENDP			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@124
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@124
$LN1@operator@124:
	call	__invalid_parameter_noinfo
$LN2@operator@124:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 3

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@19
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@19
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@19
$LN1@Vector_con@19:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@19:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@125
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@125
$LN1@operator@125:
	call	__invalid_parameter_noinfo
$LN2@operator@125:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 2

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@20
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@20
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@20
$LN1@Vector_con@20:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@20:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@126
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@126
$LN1@operator@126:
	call	__invalid_parameter_noinfo
$LN2@operator@126:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@7
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@7
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@7
$LN3@Vector_ite@7:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@7:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@N@std@@QAEPANI@Z
_TEXT	SEGMENT
$T358033 = -16						; size = 4
$T358035 = -12						; size = 12
?allocate@?$allocator@N@std@@QAEPANI@Z PROC		; std::allocator<double>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@18
	xor	ecx, ecx
$LN3@allocate@18:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@18:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@18
	lea	eax, DWORD PTR $T358033[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358035[esp+20]
	mov	DWORD PTR $T358033[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358035[esp+20]
	push	ecx
	mov	DWORD PTR $T358035[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@18:
$LN11@allocate@18:
	int	3
?allocate@?$allocator@N@std@@QAEPANI@Z ENDP		; std::allocator<double>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
$T358055 = -16						; size = 4
$T358061 = -12						; size = 12
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@19
	xor	ecx, ecx
$LN3@allocate@19:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@19:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@19
	lea	eax, DWORD PTR $T358055[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358061[esp+20]
	mov	DWORD PTR $T358055[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358061[esp+20]
	push	ecx
	mov	DWORD PTR $T358061[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@19:
$LN11@allocate@19:
	int	3
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z
_TEXT	SEGMENT
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z PROC ; std::vector<float,std::allocator<float> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@6
$LL21@Ufill@6:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@6
$LN26@Ufill@6:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z PROC ; std::vector<float,std::allocator<float> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@3
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@3
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@3
$LN8@erase@3:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@3:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@3
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@3
$LN24@erase@3:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@3:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@3
	cmp	eax, ecx
	je	SHORT $LN39@erase@3
$LN38@erase@3:
	call	__invalid_parameter_noinfo
$LN39@erase@3:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN63@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ENDP ; std::vector<float,std::allocator<float> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@18
	call	__invalid_parameter_noinfo
$LN6@end@18:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@20
	call	__invalid_parameter_noinfo
$LN6@begin@20:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@19
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
$LN5@construct@19:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back, COMDAT
; _this$ = ecx

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN1@pop_back

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;
; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;
; 879  : 			if (_Mapsize <= _Block)
; 880  : 				_Block -= _Mapsize;
; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);
; 882  : 			if (--_Mysize == 0)

	add	eax, -1
	mov	DWORD PTR [ecx+28], eax
	jne	SHORT $LN1@pop_back

; 883  : 				_Myoff = 0;

	mov	DWORD PTR [ecx+24], 0
$LN1@pop_back:

; 884  : 			}
; 885  : 			}

	ret	0
?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin, COMDAT
; ___$ReturnUdt$ = esi

; 665  : 		{	// return iterator for beginning of mutable sequence

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 666  : 		return (iterator(_Myoff, this));

	mov	eax, DWORD PTR [ebx+28]
	push	edi
	mov	edi, DWORD PTR [ebx+24]
	add	eax, edi
	mov	DWORD PTR [esi], 0
	cmp	edi, eax
	jbe	SHORT $LN6@begin@21
	call	__invalid_parameter_noinfo
$LN6@begin@21:
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], edi
	pop	edi
	mov	DWORD PTR [esi], ecx
	mov	eax, esi
	pop	ebx

; 667  : 		}

	ret	4
?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T358635 = -16						; size = 4
$T358637 = -12						; size = 12
?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Rank>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@20
	xor	ecx, ecx
$LN3@allocate@20:
	imul	ecx, 424				; 000001a8H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@20:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 424				; 000001a8H
	jae	SHORT $LN3@allocate@20
	lea	eax, DWORD PTR $T358635[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358637[esp+20]
	mov	DWORD PTR $T358635[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358637[esp+20]
	push	ecx
	mov	DWORD PTR $T358637[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@20:
$LN11@allocate@20:
	int	3
?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Rank>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z
_TEXT	SEGMENT
?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate, COMDAT
; _p$ = eax

; 2023 :         if (p != 0)

	test	eax, eax
	je	SHORT $LN4@deallocate

; 2024 :             m_alloc.deallocate(p, n);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN4@deallocate:

; 2025 :     }

	ret	0
?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T358663 = -16						; size = 4
$T358665 = -12						; size = 12
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@21
	xor	ecx, ecx
$LN3@allocate@21:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@21:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@21
	lea	eax, DWORD PTR $T358663[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358665[esp+20]
	mov	DWORD PTR $T358663[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358665[esp+20]
	push	ecx
	mov	DWORD PTR $T358665[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@21:
$LN11@allocate@21:
	int	3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_J@std@@QAEPA_JI@Z
_TEXT	SEGMENT
$T358685 = -16						; size = 4
$T358687 = -12						; size = 12
?allocate@?$allocator@_J@std@@QAEPA_JI@Z PROC		; std::allocator<__int64>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@22
	xor	ecx, ecx
$LN3@allocate@22:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@22:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@22
	lea	eax, DWORD PTR $T358685[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358687[esp+20]
	mov	DWORD PTR $T358685[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358687[esp+20]
	push	ecx
	mov	DWORD PTR $T358687[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@22:
$LN11@allocate@22:
	int	3
?allocate@?$allocator@_J@std@@QAEPA_JI@Z ENDP		; std::allocator<__int64>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z
_TEXT	SEGMENT
?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	ecx, esi
	mov	eax, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@7
	push	ebx
	npad	7
$LL21@Ufill@7:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL21@Ufill@7
	pop	ebx
$LN26@Ufill@7:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T358843 = -16						; size = 4
$T358845 = -12						; size = 12
?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Transaction *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@23
	xor	ecx, ecx
$LN3@allocate@23:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@23:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@23
	lea	eax, DWORD PTR $T358843[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T358845[esp+20]
	mov	DWORD PTR $T358843[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T358845[esp+20]
	push	ecx
	mov	DWORD PTR $T358845[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@23:
$LN11@allocate@23:
	int	3
?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@22

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@22:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z
_TEXT	SEGMENT
?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::read, COMDAT
; _this$ = esi
; _offset$ = ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN2@read@7
	test	ecx, ecx
	jl	SHORT $LN2@read@7

; 258  : 			else
; 259  : 				return entry[(head + offset) % (unsigned)entry.size()];

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN8@read@7
	call	__invalid_parameter_noinfo
$LN8@read@7:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 260  : 		}

	ret	0
$LN2@read@7:

; 257  : 				return NULL;

	xor	eax, eax

; 260  : 		}

	ret	0
?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ PROC		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ ENDP		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@127
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@127
$LN3@operator@127:
	call	__invalid_parameter_noinfo
$LN4@operator@127:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@21
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@21
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@21
$LN1@Vector_con@21:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@21:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@8
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@8
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@8
$LN3@Vector_ite@8:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@8:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z
_TEXT	SEGMENT
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z PROC ; std::vector<double,std::allocator<double> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@8
$LL21@Ufill@8:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL21@Ufill@8
$LN26@Ufill@8:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@19
	call	__invalid_parameter_noinfo
$LN4@end@19:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@22
	call	__invalid_parameter_noinfo
$LN4@begin@22:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@22
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@22
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@22
$LN1@Vector_con@22:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@22:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@128
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@128
$LN1@operator@128:
	call	__invalid_parameter_noinfo
$LN2@operator@128:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@23
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@23
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@23
$LN1@Vector_con@23:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@23:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@23

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@23:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T359375 = -8						; size = 4
$T359327 = -8						; size = 8
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T359375[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN8@clear@13
	call	__invalid_parameter_noinfo
$LN8@clear@13:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@13
	call	__invalid_parameter_noinfo
$LN24@clear@13:
	mov	ecx, DWORD PTR $T359375[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T359327[esp+40]
	push	edx
	call	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@9
	push	ebx
	npad	7
$LL21@Ufill@9:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@9
	pop	ebx
$LN26@Ufill@9:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@24

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@24:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@20
	call	__invalid_parameter_noinfo
$LN4@end@20:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@23
	call	__invalid_parameter_noinfo
$LN4@begin@23:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy, COMDAT
; _this$ = esi

; 1268 : 		{	// free all storage

	push	ebx

; 1269 : 		while (!empty())

	xor	ebx, ebx
	cmp	DWORD PTR [esi+28], ebx
	je	SHORT $LN5@Tidy@25
$LL6@Tidy@25:

; 1270 : 			pop_back();

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN11@Tidy@25
	dec	eax
	mov	DWORD PTR [esi+28], eax
	cmp	eax, ebx
	jne	SHORT $LN11@Tidy@25
	mov	DWORD PTR [esi+24], ebx
$LN11@Tidy@25:

; 1269 : 		while (!empty())

	cmp	DWORD PTR [esi+28], ebx
	jne	SHORT $LL6@Tidy@25
$LN5@Tidy@25:
	push	edi

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, ebx
	jbe	SHORT $LN3@Tidy@25
$LL4@Tidy@25:
	mov	eax, DWORD PTR [esi+16]

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	dec	edi
	cmp	DWORD PTR [eax+edi*4], ebx
	lea	eax, DWORD PTR [eax+edi*4]
	je	SHORT $LN18@Tidy@25

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@Tidy@25:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	edi, ebx
	ja	SHORT $LL4@Tidy@25
$LN3@Tidy@25:

; 1275 : 			this->_Almap.destroy(_Map + _Count);
; 1276 : 			}
; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR [esi+16]
	pop	edi
	cmp	eax, ebx
	je	SHORT $LN25@Tidy@25

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy@25:

; 1280 : 		_Mapsize = 0;
; 1281 : 		_Map = 0;

	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	pop	ebx

; 1282 : 		}

	ret	0
?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ
_TEXT	SEGMENT
?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy, COMDAT
; _this$ = eax

; 2075 :         destroy_content();

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN3@destroy@5
$LL8@destroy@5:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN21@destroy@5
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN21@destroy@5:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL8@destroy@5
$LN3@destroy@5:

; 2076 :         deallocate(m_buff, capacity());

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN18@destroy@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN18@destroy@5:

; 2077 : #if BOOST_CB_ENABLE_DEBUG
; 2078 :         m_buff = 0;
; 2079 :         m_first = 0;
; 2080 :         m_last = 0;
; 2081 :         m_end = 0;
; 2082 : #endif
; 2083 :     }

	ret	0
?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@26

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@26:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@129
	call	__invalid_parameter_noinfo
$LN1@operator@129:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@21
	call	__invalid_parameter_noinfo
$LN6@end@21:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@24
	call	__invalid_parameter_noinfo
$LN6@begin@24:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@19
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@19:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z
_TEXT	SEGMENT
?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::at, COMDAT
; _this$ = esi
; _value$ = ecx

; 380  : 			assert(value < count);
; 381  : 			return read(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN4@at@2
	test	ecx, ecx
	jl	SHORT $LN4@at@2
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN10@at@2
	call	__invalid_parameter_noinfo
$LN10@at@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 382  : 		}

	ret	0

; 380  : 			assert(value < count);
; 381  : 			return read(value);

$LN4@at@2:
	xor	eax, eax

; 382  : 		}

	ret	0
?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ
_TEXT	SEGMENT
?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop, COMDAT
; _this$ = esi

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN2@pop@3

; 202  : 			}
; 203  : 		}

	ret	0
$LN2@pop@3:

; 190  : 				return NULL;
; 191  : 			else
; 192  : 			{
; 193  : 				count--;

	dec	eax
	mov	DWORD PTR [esi], eax

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN5@pop@3
	call	__invalid_parameter_noinfo
$LN5@pop@3:
	mov	ecx, DWORD PTR [esi+24]

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@pop@3
	call	__invalid_parameter_noinfo
$LN10@pop@3:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 198  : 
; 199  : 				head = (head + 1) % (unsigned)entry.size();	//advance head_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	pop	edi

; 200  : 
; 201  : 				return item;

	mov	eax, ebx
	pop	ebx
	mov	DWORD PTR [esi+4], edx

; 202  : 			}
; 203  : 		}

	ret	0
?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@130
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@130
$LN1@operator@130:
	call	__invalid_parameter_noinfo
$LN2@operator@130:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z
_TEXT	SEGMENT
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z PROC	; std::vector<double,std::allocator<double> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@131
	call	__invalid_parameter_noinfo
$LN1@operator@131:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ENDP	; std::vector<double,std::allocator<double> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@20
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@20:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@132
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@132
$LN1@operator@132:
	call	__invalid_parameter_noinfo
$LN2@operator@132:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@133
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@133
$LN3@operator@133:
	call	__invalid_parameter_noinfo
$LN4@operator@133:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@21
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@21:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@22
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@22:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax

; 640  : 		{	// destroy the deque

	push	esi
	mov	esi, eax

; 641  : 		_Tidy();

	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy

; 642  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@134
	call	__invalid_parameter_noinfo
$LN1@operator@134:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 424				; 000001a8H
	add	eax, DWORD PTR [esi+12]

; 786  : 		}

	ret	0
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@135
	call	__invalid_parameter_noinfo
$LN1@operator@135:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 424				; 000001a8H
	add	eax, DWORD PTR [esi+12]

; 771  : 		}

	ret	0
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@22
	call	__invalid_parameter_noinfo
$LN4@end@22:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@23
	call	__invalid_parameter_noinfo
$LN6@end@23:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@25
	call	__invalid_parameter_noinfo
$LN4@begin@25:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@26
	call	__invalid_parameter_noinfo
$LN6@begin@26:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@24
	call	__invalid_parameter_noinfo
$LN4@end@24:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@27
	call	__invalid_parameter_noinfo
$LN4@begin@27:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >, COMDAT
; _this$ = eax

; 1172 :         destroy();

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN5@circular_b
$LL10@circular_b:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN23@circular_b
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN23@circular_b:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL10@circular_b
$LN5@circular_b:
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN20@circular_b
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN20@circular_b:

; 1173 : #if BOOST_CB_ENABLE_DEBUG
; 1174 :         invalidate_all_iterators();
; 1175 : #endif
; 1176 :     }

	ret	0
??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z
_TEXT	SEGMENT
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@136
	call	__invalid_parameter_noinfo
$LN1@operator@136:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z
_TEXT	SEGMENT
??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@137
	call	__invalid_parameter_noinfo
$LN1@operator@137:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 771  : 		}

	ret	0
??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@25
	call	__invalid_parameter_noinfo
$LN4@end@25:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@28
	call	__invalid_parameter_noinfo
$LN4@begin@28:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@23
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@23:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::depth, COMDAT
; _this$ = ecx

; 250  : 			return (unsigned)entry.size();

	mov	eax, DWORD PTR [ecx+28]
	sub	eax, DWORD PTR [ecx+24]
	sar	eax, 2

; 251  : 		}

	ret	0
?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::depth
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z
_TEXT	SEGMENT
??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[], COMDAT
; _this$ = esi
; _value$ = ecx

; 386  : 			return at(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN6@operator@138
	test	ecx, ecx
	jl	SHORT $LN6@operator@138
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN12@operator@138
	call	__invalid_parameter_noinfo
$LN12@operator@138:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 387  : 		}

	ret	0

; 386  : 			return at(value);

$LN6@operator@138:
	xor	eax, eax

; 387  : 		}

	ret	0
??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z
_TEXT	SEGMENT
_item$ = -4						; size = 4
?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove, COMDAT
; _this$ = esi
; _offset$ = eax

; 339  : 		{

	push	ecx

; 340  : 			assert(offset <= (int)count && offset >= 0);
; 341  : 
; 342  : 			// first get the item
; 343  : 			T *item = entry[(head + offset) % (unsigned)entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN8@remove
	call	__invalid_parameter_noinfo
$LN8@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 344  : 			count--;

	dec	DWORD PTR [esi]

; 345  : 
; 346  : 			tail = (head + count) % (unsigned)entry.size();

	mov	ebx, DWORD PTR [esi+28]
	sub	ebx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _item$[esp+12], ecx
	mov	ecx, DWORD PTR [esi]
	sar	ebx, 2
	add	eax, ecx
	xor	edx, edx
	div	ebx
	mov	DWORD PTR [esi+8], edx

; 347  : 
; 348  : 			// then shift the other items up
; 349  : 			for (unsigned i = (unsigned)offset; i < count; i++)

	cmp	edi, ecx
	jae	SHORT $LN1@remove
	push	ebp
$LL3@remove:

; 350  : 			{
; 351  : 				entry[(head + i) % entry.size()] = entry[(head + i + 1) % (unsigned)entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN17@remove
	call	__invalid_parameter_noinfo
$LN17@remove:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	lea	ebp, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN24@remove
	call	__invalid_parameter_noinfo
$LN24@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebp]
	inc	edi
	mov	DWORD PTR [eax+ebx*4], ecx
	cmp	edi, DWORD PTR [esi]
	jb	SHORT $LL3@remove
	pop	ebp
$LN1@remove:

; 352  : 			}
; 353  : 
; 354  : 			entry[(head + count) % entry.size()] = NULL;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN31@remove
	call	__invalid_parameter_noinfo
$LN31@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 355  : 
; 356  : 			return item;

	mov	eax, DWORD PTR _item$[esp+12]
	pop	edi
	pop	ebx

; 357  : 		}

	pop	ecx
	ret	0
?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove
_TEXT	ENDS
PUBLIC	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_nextRank$ = 8						; size = 4
_nextBank$ = 12						; size = 4
_isActivate$ = 16					; size = 1
?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z PROC	; DRAMsimII::Channel::getNextCPRHValues
; _this$ = eax

; 2247 : 	unsigned oldBank = nextBank;
; 2248 : 	unsigned oldRank = nextRank;
; 2249 : 
; 2250 : 	if (isActivate)

	cmp	BYTE PTR _isActivate$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _nextBank$[esp]
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR _nextRank$[esp+4]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [ebp]
	push	edi
	je	SHORT $LN4@getNextCPR

; 2251 : 	{
; 2252 : 		// set the rank of the next CAS
; 2253 : 		nextBank = 2 * (oldBank % (systemConfig.getBankCount() / 2)) + !(oldBank / (systemConfig.getBankCount() / 2));

	mov	eax, DWORD PTR [esi+176]
	mov	edi, DWORD PTR [eax+364]
	xor	edx, edx
	shr	edi, 1
	mov	eax, ecx
	div	edi

; 2254 : 		nextRank = (systemConfig.getRankCount() - ((2 * (oldBank % (systemConfig.getBankCount() / 2)) + !(oldBank / (systemConfig.getBankCount() / 2))) % systemConfig.getRankCount()) + oldRank) % systemConfig.getRankCount();

	mov	esi, DWORD PTR [esi+176]
	mov	edi, edx
	xor	edx, edx
	test	eax, eax
	sete	dl
	lea	eax, DWORD PTR [edx+edi*2]
	mov	edi, DWORD PTR [esi+364]
	mov	DWORD PTR [ebx], eax
	xor	edx, edx
	shr	edi, 1
	mov	eax, ecx
	div	edi
	mov	ecx, DWORD PTR [esi+360]
	mov	edi, eax
	xor	eax, eax
	test	edi, edi
	sete	al
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+edx*2]
	xor	edx, edx
	div	ecx
	mov	eax, ecx
	sub	eax, edx
	add	eax, DWORD PTR [ebp]
	xor	edx, edx
	div	ecx

; 2266 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : }

	ret	12					; 0000000cH
$LN4@getNextCPR:

; 2255 : 	}
; 2256 : 	else
; 2257 : 	{
; 2258 : 		if (oldBank == systemConfig.getBankCount() - 1)

	mov	edx, DWORD PTR [esi+176]
	mov	edx, DWORD PTR [edx+364]

; 2259 : 		{
; 2260 : 			nextRank = (oldRank + 1) % systemConfig.getRankCount();

	mov	esi, DWORD PTR [esi+176]
	dec	edx
	cmp	ecx, edx
	jne	SHORT $LN2@getNextCPR
	inc	eax
	xor	edx, edx
	div	DWORD PTR [esi+360]

; 2261 : 			nextBank = systemConfig.getBankCount() / 2;

	mov	eax, DWORD PTR [esi+364]
	pop	edi
	pop	esi
	shr	eax, 1
	mov	DWORD PTR [ebx], eax

; 2266 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : }

	ret	12					; 0000000cH
$LN2@getNextCPR:

; 2262 : 		}
; 2263 : 		else
; 2264 : 		{				
; 2265 : 			nextBank = (oldBank % 2) * (systemConfig.getBankCount() / 2) + ((oldBank + 1) / 2);

	mov	edx, DWORD PTR [esi+364]
	shr	edx, 1
	mov	edi, ecx
	and	edi, 1
	imul	edx, edi
	lea	edi, DWORD PTR [ecx+1]
	shr	edi, 1
	add	edx, edi
	mov	DWORD PTR [ebx], edx

; 2266 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	lea	eax, DWORD PTR [eax+ecx+1]
	xor	edx, edx
	div	DWORD PTR [esi+360]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2267 : 		}
; 2268 : 	}
; 2269 : 
; 2270 : }

	ret	12					; 0000000cH
?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ENDP	; DRAMsimII::Channel::getNextCPRHValues
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Transaction@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
??1Transaction@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::Transaction::~Transaction, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??1Transaction@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::Transaction::~Transaction
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@value
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@value:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@storage4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage4:
	mov	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@value@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@value@2:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+60]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@storage5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage5:
	mov	eax, DWORD PTR [esi+48]
	push	eax
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN29@storage5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN29@storage5:
	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	ret	0
??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+84]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage6:
	mov	eax, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+60]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN29@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN29@storage6:
	mov	ecx, DWORD PTR [esi+48]
	push	ecx
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN48@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN48@storage6:
	mov	edx, DWORD PTR [esi+24]
	push	edx
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	ret	0
??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
	jmp	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
	jmp	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	add	esi, 8
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	pop	esi
	ret	0
??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\mutex.hpp
_TEXT	ENDS
;	COMDAT ??1mutex@boost@@QAE@XZ
_TEXT	SEGMENT
??1mutex@boost@@QAE@XZ PROC				; boost::mutex::~mutex, COMDAT
; _this$ = ecx

; 33   :             destroy();

	xor	eax, eax
	add	ecx, 4
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN3@mutex
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN3@mutex:

; 34   :         }

	ret	0
??1mutex@boost@@QAE@XZ ENDP				; boost::mutex::~mutex
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0mutex@boost@@QAE@XZ
_TEXT	SEGMENT
??0mutex@boost@@QAE@XZ PROC				; boost::mutex::mutex, COMDAT
; _this$ = ecx

; 27   :         mutex()

	mov	eax, ecx

; 28   :         {
; 29   :             initialize();

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 30   :         }

	ret	0
??0mutex@boost@@QAE@XZ ENDP				; boost::mutex::mutex
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z PROC ; intrusive_ptr_release, COMDAT

; 53   :             {

	push	esi

; 54   :                 if(!BOOST_INTERLOCKED_DECREMENT(&p->count))

	mov	esi, DWORD PTR _p$[esp]
	lea	eax, DWORD PTR [esi+4]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	jne	SHORT $LN6@intrusive_@2

; 55   :                 {
; 56   :                     detail::heap_delete(p);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN6@intrusive_@2:
	pop	esi

; 57   :                 }
; 58   :             }

	ret	0
?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z ENDP ; intrusive_ptr_release
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z
_TEXT	SEGMENT
$T361667 = -12						; size = 12
_size$ = 8						; size = 4
?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z PROC	; boost::detail::allocate_raw_heap_memory, COMDAT

; 60   :             void* const heap_memory=detail::win32::HeapAlloc(detail::win32::GetProcessHeap(),0,size);

	mov	eax, DWORD PTR _size$[esp-4]
	sub	esp, 12					; 0000000cH
	push	eax
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12

; 61   :             if(!heap_memory)

	test	eax, eax
	jne	SHORT $LN2@allocate_r

; 62   :             {
; 63   :                 throw std::bad_alloc();

	push	1
	push	OFFSET __bad_alloc_Message
	lea	ecx, DWORD PTR $T361667[esp+20]
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T361667[esp+16]
	push	ecx
	mov	DWORD PTR $T361667[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN7@allocate_r:
$LN2@allocate_r:

; 64   :             }
; 65   :             return heap_memory;
; 66   :         }

	add	esp, 12					; 0000000cH
	ret	0
$LN6@allocate_r:
?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z ENDP	; boost::detail::allocate_raw_heap_memory
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
_TEXT	ENDS
;	COMDAT ??1handle_manager@win32@detail@boost@@QAE@XZ
_TEXT	SEGMENT
??1handle_manager@win32@detail@boost@@QAE@XZ PROC	; boost::detail::win32::handle_manager::~handle_manager, COMDAT
; _this$ = ecx

; 276  :                     cleanup();

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@handle_man
	cmp	eax, -1
	je	SHORT $LN3@handle_man
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN3@handle_man:

; 277  :                 }

	ret	0
??1handle_manager@win32@detail@boost@@QAE@XZ ENDP	; boost::detail::win32::handle_manager::~handle_manager
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z PROC ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	je	SHORT $LN6@scalar@21
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@21:
	mov	eax, esi
	pop	esi
	ret	4
??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ENDP ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1_ns2__submitEpochResultElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__submitEpochResultElement@@UAE@XZ PROC		; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement, COMDAT
; _this$ = ecx

; 264  : 	virtual ~_ns2__submitEpochResultElement() { }

	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultElement@@6B@
	mov	eax, DWORD PTR [esi+108]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN8@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@ns2__submi:
	mov	eax, DWORD PTR [esi+96]
	push	eax
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+84]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN23@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@ns2__submi:
	mov	ecx, DWORD PTR [esi+72]
	push	ecx
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+60]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN38@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@ns2__submi:
	mov	edx, DWORD PTR [esi+48]
	push	edx
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN53@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@ns2__submi:
	mov	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
	ret	0
??1_ns2__submitEpochResultElement@@UAE@XZ ENDP		; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Bank::isHighUtilization, COMDAT
; _this$ = eax

; 122  : 		bool isHighUtilization() const { return perBankQueue.size() > (perBankQueue.depth() / 2);}

	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	sar	ecx, 2
	shr	ecx, 1
	cmp	ecx, DWORD PTR [eax+12]
	sbb	eax, eax
	neg	eax
	ret	0
?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Bank::isHighUtilization
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isFull@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@Bank@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Bank::isFull, COMDAT
; _this$ = eax

; 119  : 		bool isFull() const { return perBankQueue.isFull(); }

	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax+12]
	sete	dl
	mov	al, dl
	ret	0
?isFull@Bank@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Bank::isFull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Bank::freeCommandSlots, COMDAT
; _this$ = ecx

; 115  : 		unsigned freeCommandSlots() const { return perBankQueue.freecount(); }

	mov	eax, DWORD PTR [ecx+40]
	sub	eax, DWORD PTR [ecx+36]
	sar	eax, 2
	sub	eax, DWORD PTR [ecx+12]
	ret	0
?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Bank::freeCommandSlots
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?size@Bank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Bank::size, COMDAT
; _this$ = eax

; 112  : 		unsigned size() const { return perBankQueue.size(); }

	mov	eax, DWORD PTR [eax+12]
	ret	0
?size@Bank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Bank::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GEvent@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GEvent@DRAMsimII@@UAEPAXI@Z PROC			; DRAMsimII::Event::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7Event@DRAMsimII@@6B@
	je	SHORT $LN6@scalar@22
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@22:
	mov	eax, esi
	pop	esi
	ret	4
??_GEvent@DRAMsimII@@UAEPAXI@Z ENDP			; DRAMsimII::Event::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@249
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@249
$LN20@operator@249:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@249
$LN10@operator@249:
	xor	edx, edx
$LN11@operator@249:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@249
	test	eax, eax
	je	SHORT $LN16@operator@249
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@249
$LN16@operator@249:
	xor	eax, eax
$LN17@operator@249:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@249
$LN1@operator@249:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@249:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+, COMDAT
; _this$ = eax

; 169  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 170  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@250
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@250:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@250
	test	esi, esi
	je	SHORT $LN18@operator@250
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@250
$LN22@operator@250:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@250
$LN18@operator@250:
	xor	eax, eax
$LN19@operator@250:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@250
$LN3@operator@250:
	call	__invalid_parameter_noinfo
$LN4@operator@250:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 172  : 		}

	ret	8
??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@8:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First1$[esp]
	push	ebp
	push	esi
	mov	esi, edx
	sub	esi, ebx
	sar	esi, 3
	push	edi
	mov	edi, DWORD PTR __First2$[esp+16]
	mov	ebp, eax
	test	eax, eax
	jne	SHORT $LN39@Equal@7
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
	xor	eax, eax
$LN15@Equal@7:
	lea	esi, DWORD PTR [edi+esi*8]
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@7
	test	ebp, ebp
	je	SHORT $LN20@Equal@7
	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN21@Equal@7
$LN39@Equal@7:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@7
$LN20@Equal@7:
	xor	ebp, ebp
$LN21@Equal@7:
	cmp	esi, DWORD PTR [ebp+12]
	jae	SHORT $LN6@Equal@7
$LN5@Equal@7:
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
$LN6@Equal@7:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN31@Equal@7
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	ecx, ebx
	npad	3
$LL33@Equal@7:
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+eax]
	jne	SHORT $LN37@Equal@7
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [ecx+eax+4]
	jne	SHORT $LN37@Equal@7
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL33@Equal@7
$LN31@Equal@7:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	ret	0
$LN37@Equal@7:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	ret	0
??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@17
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@17:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z
_TEXT	SEGMENT
$T413265 = -4						; size = 1
__First1$ = 8						; size = 8
$T413266 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T413266[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T413265[esp+4], 0
	mov	eax, DWORD PTR $T413265[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@10
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@10:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z
_TEXT	SEGMENT
$T413470 = -8						; size = 8
$T413665 = 8						; size = 1
$T413666 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z PROC ; std::operator==<__int64,std::allocator<__int64> >, COMDAT
; __Left$ = esi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	mov	eax, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, eax
	sub	ecx, edi
	xor	ecx, edx
	test	ecx, -8					; fffffff8H
	jne	SHORT $LN3@operator@251
	cmp	edi, eax
	jbe	SHORT $LN12@operator@251
	call	__invalid_parameter_noinfo
$LN12@operator@251:
	mov	eax, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	mov	DWORD PTR $T413470[esp+20], eax
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@251
	call	__invalid_parameter_noinfo
$LN26@operator@251:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@251
	call	__invalid_parameter_noinfo
$LN40@operator@251:
	mov	eax, DWORD PTR $T413470[esp+20]
	mov	BYTE PTR $T413665[esp+16], 0
	mov	ecx, DWORD PTR $T413665[esp+16]
	mov	edx, DWORD PTR $T413666[esp+16]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	ebp
	push	ebx
	call	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
	add	esp, 24					; 00000018H
	pop	ebp
	test	al, al
	je	SHORT $LN3@operator@251
	pop	edi
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@251:
	pop	edi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ENDP ; std::operator==<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@252
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@252
$LN20@operator@252:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@252
$LN10@operator@252:
	xor	edx, edx
$LN11@operator@252:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@252
	test	eax, eax
	je	SHORT $LN16@operator@252
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@252
$LN16@operator@252:
	xor	eax, eax
$LN17@operator@252:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@252
$LN1@operator@252:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@252:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@253
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@253
$LN20@operator@253:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@253
$LN10@operator@253:
	xor	edx, edx
$LN11@operator@253:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@253
	test	eax, eax
	je	SHORT $LN16@operator@253
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@253
$LN16@operator@253:
	xor	eax, eax
$LN17@operator@253:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@253
$LN1@operator@253:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@253:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@254
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@254
$LN20@operator@254:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@254
$LN10@operator@254:
	xor	edx, edx
$LN11@operator@254:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@254
	test	eax, eax
	je	SHORT $LN16@operator@254
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@254
$LN16@operator@254:
	xor	eax, eax
$LN17@operator@254:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@254
$LN1@operator@254:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@254:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@255
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@255
$LN22@operator@255:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@255
$LN12@operator@255:
	xor	edx, edx
$LN13@operator@255:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@255
	test	eax, eax
	je	SHORT $LN18@operator@255
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@255
$LN18@operator@255:
	xor	eax, eax
$LN19@operator@255:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@255
$LN3@operator@255:
	call	__invalid_parameter_noinfo
$LN23@operator@255:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@29
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@29:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@14
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@14
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@14
$LN5@Make_iter@14:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@14:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ PROC ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*, COMDAT
; _this$ = esi

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN38@operator@256
	call	__invalid_parameter_noinfo

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@256
$LN38@operator@256:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@256
$LN10@operator@256:
	xor	ecx, ecx
$LN11@operator@256:
	test	eax, eax
	je	SHORT $LN16@operator@256
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@256
$LN16@operator@256:
	xor	eax, eax
$LN17@operator@256:
	mov	eax, DWORD PTR [eax+28]
	add	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [esi+4], eax
	jb	SHORT $LN2@operator@256
	call	__invalid_parameter_noinfo
$LN2@operator@256:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@operator@256
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@256
$LN22@operator@256:
	xor	ecx, ecx
$LN23@operator@256:
	cmp	DWORD PTR [ecx+20], edi
	ja	SHORT $LN1@operator@256

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	test	eax, eax
	je	SHORT $LN28@operator@256
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN29@operator@256
$LN28@operator@256:
	xor	ecx, ecx
$LN29@operator@256:
	sub	edi, DWORD PTR [ecx+20]
$LN1@operator@256:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	test	eax, eax
	je	SHORT $LN34@operator@256
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 144  : 			}

	ret	0

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

$LN34@operator@256:
	xor	eax, eax
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi

; 144  : 			}

	ret	0
??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ENDP ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@257
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@257
$LN22@operator@257:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@257
$LN12@operator@257:
	xor	edx, edx
$LN13@operator@257:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@257
	test	eax, eax
	je	SHORT $LN18@operator@257
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@257
$LN18@operator@257:
	xor	eax, eax
$LN19@operator@257:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@257
$LN3@operator@257:
	call	__invalid_parameter_noinfo
$LN23@operator@257:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@258
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@258
$LN22@operator@258:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@258
$LN12@operator@258:
	xor	edx, edx
$LN13@operator@258:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@258
	test	eax, eax
	je	SHORT $LN18@operator@258
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@258
$LN18@operator@258:
	xor	eax, eax
$LN19@operator@258:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@258
$LN3@operator@258:
	call	__invalid_parameter_noinfo
$LN23@operator@258:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@259
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@259
$LN13@operator@259:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@259
$LN9@operator@259:
	xor	eax, eax
$LN10@operator@259:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@259
	call	__invalid_parameter_noinfo
$LN14@operator@259:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@260
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@260:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@260
	test	esi, esi
	je	SHORT $LN20@operator@260
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@260
$LN24@operator@260:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@260
$LN20@operator@260:
	xor	eax, eax
$LN21@operator@260:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@260
$LN5@operator@260:
	call	__invalid_parameter_noinfo
$LN6@operator@260:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 478  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Deque_map
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4

; 478  : 		{	// construct allocator from _Al

$LN8@Deque_map:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@15
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@15
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@15
$LN5@Make_iter@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@15:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@30
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@30:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@7
	mov	eax, DWORD PTR __First_arg$[esp+8]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@7
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@7
$LN8@erase@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+8]
$LN9@erase@7:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@7
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@7
$LN24@erase@7:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+8]
$LN25@erase@7:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@7
	cmp	eax, ecx
	je	SHORT $LN39@erase@7
$LN38@erase@7:
	call	__invalid_parameter_noinfo
$LN39@erase@7:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebp
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
	pop	ebp
$LN63@erase@7:
	pop	edi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	20					; 00000014H
?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ PROC ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*, COMDAT
; _this$ = esi

; 386  : 		return ((reference)**(_Mybase *)this);

	jmp	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ ENDP ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@261
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@261:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@261
	test	esi, esi
	je	SHORT $LN20@operator@261
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@261
$LN24@operator@261:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@261
$LN20@operator@261:
	xor	eax, eax
$LN21@operator@261:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@261
$LN5@operator@261:
	call	__invalid_parameter_noinfo
$LN6@operator@261:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@17
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@17
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@17
$LN3@Vector_ite@17:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@17:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@262
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@262:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@262
	test	esi, esi
	je	SHORT $LN20@operator@262
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@262
$LN24@operator@262:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@262
$LN20@operator@262:
	xor	eax, eax
$LN21@operator@262:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@262
$LN5@operator@262:
	call	__invalid_parameter_noinfo
$LN6@operator@262:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@18
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@18
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@18
$LN3@Vector_ite@18:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@18:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@263
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@263
$LN15@operator@263:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@263
$LN11@operator@263:
	xor	eax, eax
$LN12@operator@263:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@263
	call	__invalid_parameter_noinfo
$LN16@operator@263:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@31
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@31:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@40
	call	__invalid_parameter_noinfo
$LN6@begin@40:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@32
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@32:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@33
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@33:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@41
	call	__invalid_parameter_noinfo
$LN6@begin@41:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 500  : 		{	// construct allocator and base from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Deque_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4

; 500  : 		{	// construct allocator and base from _Al

$LN13@Deque_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@34
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@34:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@35
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@35:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@20
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@20:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@264
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@264
$LN17@operator@264:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@264
$LN13@operator@264:
	xor	eax, eax
$LN14@operator@264:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@264
	call	__invalid_parameter_noinfo
$LN18@operator@264:
	add	DWORD PTR [esi+4], 4

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@19
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@19
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@19
$LN3@Vector_ite@19:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@19:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@20
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@20
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@20
$LN3@Vector_ite@20:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@20:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=, COMDAT
; _this$ = edi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN20@operator@265
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@operator@265
$LN20@operator@265:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@265
$LN10@operator@265:
	xor	edx, edx
$LN11@operator@265:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 424				; 000001a8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@265
	test	eax, eax
	je	SHORT $LN16@operator@265
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@265
$LN16@operator@265:
	xor	eax, eax
$LN17@operator@265:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@265
$LN1@operator@265:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@265:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [edi+4], esi

; 165  : 		return (*this);

	mov	eax, edi
	pop	esi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@266
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@266
$LN13@operator@266:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@266
$LN9@operator@266:
	xor	eax, eax
$LN10@operator@266:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@266
	call	__invalid_parameter_noinfo
$LN14@operator@266:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 424			; 000001a8H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@267
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@267
$LN13@operator@267:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@267
$LN9@operator@267:
	xor	eax, eax
$LN10@operator@267:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@267
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@267:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=, COMDAT
; _this$ = edi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN22@operator@268
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@operator@268
$LN22@operator@268:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@268
$LN12@operator@268:
	xor	edx, edx
$LN13@operator@268:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 424				; 000001a8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@268
	test	eax, eax
	je	SHORT $LN18@operator@268
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@268
$LN18@operator@268:
	xor	eax, eax
$LN19@operator@268:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@268
$LN3@operator@268:
	call	__invalid_parameter_noinfo
$LN23@operator@268:
	add	DWORD PTR [edi+4], esi

; 376  : 		return (*this);

	mov	eax, edi
	pop	esi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@269
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@269
$LN15@operator@269:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@269
$LN11@operator@269:
	xor	eax, eax
$LN12@operator@269:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@269
	call	__invalid_parameter_noinfo
$LN16@operator@269:
	add	DWORD PTR [esi+4], 424			; 000001a8H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@21
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@21:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@37
	call	__invalid_parameter_noinfo
$LN6@end@37:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=, COMDAT
; _this$ = edi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN20@operator@270
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@operator@270
$LN20@operator@270:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@270
$LN10@operator@270:
	xor	edx, edx
$LN11@operator@270:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 168				; 000000a8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@270
	test	eax, eax
	je	SHORT $LN16@operator@270
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@270
$LN16@operator@270:
	xor	eax, eax
$LN17@operator@270:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@270
$LN1@operator@270:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@270:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [edi+4], esi

; 165  : 		return (*this);

	mov	eax, edi
	pop	esi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@271
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@271
$LN13@operator@271:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@271
$LN9@operator@271:
	xor	eax, eax
$LN10@operator@271:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@271
	call	__invalid_parameter_noinfo
$LN14@operator@271:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 168			; 000000a8H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@272
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@272
$LN13@operator@272:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@272
$LN9@operator@272:
	xor	eax, eax
$LN10@operator@272:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@272
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@272:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@273
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@273
$LN13@operator@273:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@273
$LN9@operator@273:
	xor	eax, eax
$LN10@operator@273:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@273
	call	__invalid_parameter_noinfo
$LN14@operator@273:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 8

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@22
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@22:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@23
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@23:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@38
	call	__invalid_parameter_noinfo
$LN6@end@38:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ
_TEXT	SEGMENT
$T416189 = -8						; size = 8
?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front, COMDAT
; _this$ = edi

; 780  : 		return (*begin());

	mov	eax, DWORD PTR [edi+28]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR [edi+24]
	add	eax, esi
	cmp	esi, eax
	jbe	SHORT $LN8@front@4
	call	__invalid_parameter_noinfo
$LN8@front@4:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T416189[esp+16], esi
	lea	esi, DWORD PTR $T416189[esp+12]
	mov	DWORD PTR $T416189[esp+12], ecx
	call	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
	pop	esi

; 781  : 		}

	add	esp, 8
	ret	0
?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 554  : 		{	// construct empty deque

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN18@deque
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0

; 554  : 		{	// construct empty deque

$LN18@deque:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0
??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@24
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@24:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z PROC ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@25
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@25:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ENDP ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@274
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@274
$LN3@operator@274:
	call	__invalid_parameter_noinfo
$LN4@operator@274:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 169  : 		{	// return this + integer

	push	ebx

; 170  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@275
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@275:
	imul	edi, 424				; 000001a8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@275
	test	esi, esi
	je	SHORT $LN18@operator@275
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@275
$LN22@operator@275:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@275
$LN18@operator@275:
	xor	eax, eax
$LN19@operator@275:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@275
$LN3@operator@275:
	call	__invalid_parameter_noinfo
$LN4@operator@275:
	mov	DWORD PTR [ebp+4], edi

; 172  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@276
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@276
$LN15@operator@276:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@276
$LN11@operator@276:
	xor	eax, eax
$LN12@operator@276:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@276
	call	__invalid_parameter_noinfo
$LN16@operator@276:
	add	DWORD PTR [esi+4], 424			; 000001a8H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@277
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@277
$LN15@operator@277:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@277
$LN11@operator@277:
	xor	eax, eax
$LN12@operator@277:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@277
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@277:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 380  : 		{	// return this + integer

	push	ebx

; 381  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@278
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@278:
	imul	edi, 424				; 000001a8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@278
	test	esi, esi
	je	SHORT $LN20@operator@278
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@278
$LN24@operator@278:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@278
$LN20@operator@278:
	xor	eax, eax
$LN21@operator@278:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@278
$LN5@operator@278:
	call	__invalid_parameter_noinfo
$LN6@operator@278:
	mov	DWORD PTR [ebp+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@279
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@279
$LN17@operator@279:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@279
$LN13@operator@279:
	xor	eax, eax
$LN14@operator@279:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@279
	call	__invalid_parameter_noinfo
$LN18@operator@279:
	add	DWORD PTR [esi+4], 424			; 000001a8H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@280
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@280
$LN15@operator@280:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@280
$LN11@operator@280:
	xor	eax, eax
$LN12@operator@280:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@280
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@280:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@281
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@281
$LN3@operator@281:
	call	__invalid_parameter_noinfo
$LN4@operator@281:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 169  : 		{	// return this + integer

	push	ebx

; 170  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@282
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@282:
	imul	edi, 168				; 000000a8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@282
	test	esi, esi
	je	SHORT $LN18@operator@282
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@282
$LN22@operator@282:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@282
$LN18@operator@282:
	xor	eax, eax
$LN19@operator@282:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@282
$LN3@operator@282:
	call	__invalid_parameter_noinfo
$LN4@operator@282:
	mov	DWORD PTR [ebp+4], edi

; 172  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@283
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@283
$LN15@operator@283:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@283
$LN11@operator@283:
	xor	eax, eax
$LN12@operator@283:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@283
	call	__invalid_parameter_noinfo
$LN16@operator@283:
	add	DWORD PTR [esi+4], 168			; 000000a8H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@284
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@284
$LN15@operator@284:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@284
$LN11@operator@284:
	xor	eax, eax
$LN12@operator@284:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@284
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@284:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@285
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@285
$LN15@operator@285:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@285
$LN11@operator@285:
	xor	eax, eax
$LN12@operator@285:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@285
	call	__invalid_parameter_noinfo
$LN16@operator@285:
	add	DWORD PTR [esi+4], 8

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@286
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@286
$LN13@operator@286:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@286
$LN9@operator@286:
	xor	eax, eax
$LN10@operator@286:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@286
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@286:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
_TEXT	ENDS
;	COMDAT ??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ PROC ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>, COMDAT
; _this$ = ecx

; 100  :     {

	push	esi

; 101  :         if( px != 0 ) intrusive_ptr_release( px );

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN9@intrusive_@3
	lea	eax, DWORD PTR [esi+4]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	jne	SHORT $LN9@intrusive_@3
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN9@intrusive_@3:
	pop	esi

; 102  :     }

	ret	0
??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ENDP ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
_TEXT	ENDS
;	COMDAT ?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ
_TEXT	SEGMENT
$T417194 = -8						; size = 8
?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front, COMDAT
; _this$ = edi

; 51   : 		return (c.front());

	mov	eax, DWORD PTR [edi+28]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR [edi+24]
	add	eax, esi
	cmp	esi, eax
	jbe	SHORT $LN10@front@5
	call	__invalid_parameter_noinfo
$LN10@front@5:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T417194[esp+16], esi
	lea	esi, DWORD PTR $T417194[esp+12]
	mov	DWORD PTR $T417194[esp+12], ecx
	call	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
	pop	esi

; 52   : 		}

	add	esp, 8
	ret	0
?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >, COMDAT
; _this$ = esi

; 31   : 		{	// construct with empty container

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN21@queue
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 32   : 		}

	mov	eax, esi
	ret	0

; 31   : 		{	// construct with empty container

$LN21@queue:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 32   : 		}

	mov	eax, esi
	ret	0
??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@39
	call	__invalid_parameter_noinfo
$LN6@end@39:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@42
	call	__invalid_parameter_noinfo
$LN6@begin@42:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@40
	call	__invalid_parameter_noinfo
$LN6@end@40:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@43
	call	__invalid_parameter_noinfo
$LN6@begin@43:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::front, COMDAT
; _this$ = esi

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN8@front@6
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
$LN8@front@6:

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==, COMDAT

; 391  : 		{

	push	ebp
	mov	ebp, DWORD PTR _this$[esp]

; 392  : 			if (count == rhs.count && entry.size() == rhs.entry.size() &&
; 393  : 				head == rhs.head && tail == rhs.tail && pool == rhs.pool)

	mov	eax, DWORD PTR [ebp]
	push	edi
	mov	edi, DWORD PTR _rhs$[esp+4]
	cmp	eax, DWORD PTR [edi]
	jne	$LN11@operator@287
	mov	ecx, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [edi+24]
	sub	edx, DWORD PTR [ebp+24]
	xor	ecx, edx
	test	ecx, -4					; fffffffcH
	jne	$LN11@operator@287
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, DWORD PTR [edi+4]
	jne	$LN11@operator@287
	mov	edx, DWORD PTR [ebp+8]
	cmp	edx, DWORD PTR [edi+8]
	jne	$LN11@operator@287
	mov	cl, BYTE PTR [ebp+36]
	cmp	cl, BYTE PTR [edi+36]
	jne	$LN11@operator@287
	push	ebx

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	xor	ebx, ebx
	push	esi
	test	eax, eax
	jbe	SHORT $LN8@operator@287
	npad	5
$LL10@operator@287:

; 396  : 				{
; 397  : 					if (at(i) && rhs.at(i))

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN7@operator@287
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN7@operator@287

; 398  : 					{
; 399  : 						if (!(*(at(i)) == *(rhs.at(i))))

	mov	ecx, ebx
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	mov	ecx, ebx
	mov	esi, ebp
	mov	edi, eax
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	mov	esi, edi
	mov	edi, eax
	call	??8Transaction@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Transaction::operator==
	test	al, al
	je	SHORT $LN21@operator@287

; 400  : 							return false;
; 401  : 					}

	mov	edi, DWORD PTR _rhs$[esp+12]
	jmp	SHORT $LN9@operator@287
$LN7@operator@287:

; 402  : 					else if (at(i) != NULL && rhs.at(i) == NULL)

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN4@operator@287
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN21@operator@287
$LN4@operator@287:

; 403  : 						return false;
; 404  : 					else if (at(i) == NULL && rhs.at(i) != NULL)

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	jne	SHORT $LN9@operator@287
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	jne	SHORT $LN21@operator@287
$LN9@operator@287:

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [ebp]
	jb	SHORT $LL10@operator@287
$LN8@operator@287:
	pop	esi
	pop	ebx
	pop	edi

; 406  : 				}	
; 407  : 				return true;

	mov	al, 1
	pop	ebp

; 411  : 		}

	ret	8
$LN21@operator@287:
	pop	esi
	pop	ebx
	pop	edi

; 405  : 						return false;

	xor	al, al
	pop	ebp

; 411  : 		}

	ret	8
$LN11@operator@287:
	pop	edi

; 408  : 			}
; 409  : 			else
; 410  : 				return false;

	xor	al, al
	pop	ebp

; 411  : 		}

	ret	8
??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ$0
__ehfuncinfo$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>, COMDAT

; 103  : 		{

	push	-1
	push	__ehhandler$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
$LL7@Queue@2:

; 104  : 			while (T* value = pop())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN107@Queue@2
	mov	edi, DWORD PTR [esi+4]
	dec	eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN19@Queue@2
	call	__invalid_parameter_noinfo
$LN19@Queue@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ecx+edi*4]
	sub	edx, ecx
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN24@Queue@2
	call	__invalid_parameter_noinfo
$LN24@Queue@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+ebp*4], 0
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	DWORD PTR [esi+4], edx
	test	edi, edi
	je	SHORT $LN107@Queue@2

; 105  : 			{
; 106  : 				if (pool)

	cmp	BYTE PTR [esi+36], 0

; 107  : 					::delete value;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, edi
	je	SHORT $LN5@Queue@2
	push	0
	call	eax
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 				else

	jmp	SHORT $LL7@Queue@2
$LN5@Queue@2:

; 109  : 					delete value;			

	push	1
	call	eax

; 110  : 			}

	jmp	SHORT $LL7@Queue@2
$LN107@Queue@2:

; 111  : 			for (typename std::vector<T*>::iterator i = entry.begin(); i != entry.end(); i++)

	mov	ebp, DWORD PTR [esi+24]
	cmp	ebp, DWORD PTR [esi+28]
	jbe	SHORT $LN36@Queue@2
	call	__invalid_parameter_noinfo
$LN36@Queue@2:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, ebp
	npad	3
$LL53@Queue@2:
	mov	ebp, DWORD PTR [esi+28]
	cmp	DWORD PTR [esi+24], ebp
	jbe	SHORT $LN68@Queue@2
	call	__invalid_parameter_noinfo
$LN68@Queue@2:
	mov	eax, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN81@Queue@2
	cmp	edi, eax
	je	SHORT $LN82@Queue@2
$LN81@Queue@2:
	call	__invalid_parameter_noinfo
$LN82@Queue@2:
	cmp	ebx, ebp
	je	SHORT $LN1@Queue@2
	test	edi, edi
	jne	SHORT $LN106@Queue@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN60@Queue@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN51@Queue@2
	call	__invalid_parameter_noinfo
$LN51@Queue@2:
	add	ebx, 4
	jmp	SHORT $LL53@Queue@2
$LN106@Queue@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN60@Queue@2
$LN1@Queue@2:

; 112  : 				assert(*i == NULL);
; 113  : 		}	

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN94@Queue@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Queue@2:
	mov	ecx, DWORD PTR [esi+12]
	xor	eax, eax
	push	ecx
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__ehhandler$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv904 = -36						; size = 4
$T418144 = -36						; size = 4
tv162 = -32						; size = 8
_this$ = -32						; size = 4
$T418419 = -24						; size = 4
$T418313 = -24						; size = 4
tv893 = -20						; size = 4
$T418517 = -20						; size = 4
__Tmp$418137 = -16					; size = 8
__Tmp$418289 = -8					; size = 8
_currentCommand$ = 8					; size = 4
?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::earliestExecuteTime
; _this$ = ecx

; 2664 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H

; 2665 : 
; 2666 : 	tick nextTime;	
; 2667 : 
; 2668 : 	const vector<Rank>::const_iterator currentRank = rank.begin() + currentCommand->getAddress().getRank();

	mov	eax, DWORD PTR _currentCommand$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [eax+60]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+412]
	mov	DWORD PTR _this$[esp+48], esi
	cmp	edi, DWORD PTR [esi+416]
	jbe	SHORT $LN16@earliestEx
	call	__invalid_parameter_noinfo
$LN16@earliestEx:
	mov	esi, DWORD PTR [esi+400]
	mov	DWORD PTR __Tmp$418137[esp+48], esi
	mov	DWORD PTR __Tmp$418137[esp+52], edi
	test	esi, esi
	jne	SHORT $LN213@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN39@earliestEx:
	imul	ebx, 424				; 000001a8H
	add	edi, ebx
	mov	DWORD PTR tv893[esp+48], edi
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN29@earliestEx
	test	esi, esi
	je	SHORT $LN44@earliestEx
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN45@earliestEx
$LN213@earliestEx:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN39@earliestEx
$LN44@earliestEx:
	xor	esi, esi
$LN45@earliestEx:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN30@earliestEx
$LN29@earliestEx:
	call	__invalid_parameter_noinfo
$LN30@earliestEx:

; 2669 : 
; 2670 : 	const vector<Bank>::const_iterator currentBank = currentRank->bank.begin() + currentCommand->getAddress().getBank();

	mov	ecx, DWORD PTR _currentCommand$[ebp]
	mov	eax, DWORD PTR __Tmp$418137[esp+48]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T418144[esp+48], edx
	test	eax, eax
	jne	SHORT $LN212@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN63@earliestEx:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN54@earliestEx
	call	__invalid_parameter_noinfo
$LN54@earliestEx:
	mov	ebx, DWORD PTR [edi+412]
	cmp	ebx, DWORD PTR [edi+416]
	jbe	SHORT $LN69@earliestEx
	call	__invalid_parameter_noinfo
$LN69@earliestEx:
	mov	esi, DWORD PTR [edi+400]
	mov	edi, esi
	mov	DWORD PTR __Tmp$418289[esp+48], edi
	mov	DWORD PTR __Tmp$418289[esp+52], ebx
	test	esi, esi
	jne	SHORT $LN211@earliestEx
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN92@earliestEx:
	mov	eax, DWORD PTR $T418144[esp+48]
	imul	eax, 168				; 000000a8H
	add	ebx, eax
	mov	DWORD PTR tv904[esp+48], ebx
	cmp	ebx, DWORD PTR [ecx+16]
	ja	SHORT $LN82@earliestEx
	test	esi, esi
	je	SHORT $LN97@earliestEx
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN98@earliestEx
$LN212@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN63@earliestEx
$LN211@earliestEx:
	mov	ecx, DWORD PTR [esi]
	jmp	SHORT $LN92@earliestEx
$LN97@earliestEx:
	xor	esi, esi
$LN98@earliestEx:
	cmp	ebx, DWORD PTR [esi+12]
	jae	SHORT $LN83@earliestEx
$LN82@earliestEx:
	call	__invalid_parameter_noinfo
$LN83@earliestEx:

; 2671 : 
; 2672 : #ifndef NDEBUG
; 2673 : 	switch(currentCommand->getCommandType())
; 2674 : 	{
; 2675 : 	case Command::ACTIVATE:
; 2676 : 		{
; 2677 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2678 : 
; 2679 : 			// respect the row cycle time limitation
; 2680 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2681 : 
; 2682 : 			// respect the row-to-row activation delay for different banks within a rank
; 2683 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2684 : 
; 2685 : 			// respect tRP of same bank
; 2686 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2687 : 
; 2688 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2689 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2690 : 
; 2691 : 			// respect tRFC, refresh cycle time
; 2692 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2693 : 
; 2694 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2695 : 
; 2696 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2697 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2698 : 		}
; 2699 : 		break;
; 2700 : 
; 2701 : 	case Command::READ_AND_PRECHARGE:
; 2702 : 		// Auto precharge will be issued as part of command,
; 2703 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2704 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2705 : 
; 2706 : 	case Command::READ:
; 2707 : 		{
; 2708 : 			//respect last RAS of same rank
; 2709 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2710 : 
; 2711 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2712 : 			// this as if a CAS command was issued long ago
; 2713 : 
; 2714 : 			// respect last CAS of same rank
; 2715 : 			// DW 3/9/2006 add these two lines
; 2716 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2717 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2718 : 			// DW 3/9/2006 replace the line after next with the next line
; 2719 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2720 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2721 : 
; 2722 : 			// respect last CASW of same rank
; 2723 : 			// DW 3/9/2006 replace the line after next with the next line
; 2724 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2725 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2726 : 
; 2727 : 			//if (rank->size() > 1)
; 2728 : 			{
; 2729 : 				//respect most recent CAS of different rank
; 2730 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2731 : 				//respect timing of READ follow WRITE, different ranks
; 2732 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2733 : 			}
; 2734 : 
; 2735 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2736 : 
; 2737 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2738 : 		}
; 2739 : 		break;
; 2740 : 
; 2741 : 	case Command::WRITE_AND_PRECHARGE:
; 2742 : 		// Auto precharge will be issued as part of command, so
; 2743 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2744 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2745 : 		// has the exact same timing requirements as a simple WRITE.
; 2746 : 
; 2747 : 	case Command::WRITE:
; 2748 : 		{
; 2749 : 			//respect last RAS of same rank
; 2750 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2751 : 
; 2752 : 			// DW 3/9/2006 add these two lines
; 2753 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2754 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2755 : 
; 2756 : 			// respect last cas to same rank
; 2757 : 			// DW 3/9/2006 replace the line after next with the next line
; 2758 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2759 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2760 : 
; 2761 : 			// respect last cas to different ranks
; 2762 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2763 : 
; 2764 : 			// respect last cas write to same rank
; 2765 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2766 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2767 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2768 : 
; 2769 : 			// respect last CASW to different ranks
; 2770 : 			// TODO: should this not also be -tAL?
; 2771 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2772 : 
; 2773 : 			nextTime = max(tRASLimit,tCASLimit);
; 2774 : 		}
; 2775 : 		break;
; 2776 : 
; 2777 : 	case Command::PRECHARGE:
; 2778 : 		{
; 2779 : 			// respect t_ras of same bank
; 2780 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2781 : 
; 2782 : 			// respect t_cas of same bank
; 2783 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2784 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2785 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2786 : 
; 2787 : 			// respect t_casw of same bank
; 2788 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2789 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2790 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2791 : 
; 2792 : 			nextTime = max(tRASLimit,tCASLimit);
; 2793 : 		}
; 2794 : 		break;
; 2795 : 
; 2796 : 	case Command::REFRESH_ALL:
; 2797 : 		// respect tRFC and tRP
; 2798 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2799 : 		break;
; 2800 : 
; 2801 : 	case Command::RETIRE_COMMAND:
; 2802 : 	case Command::PRECHARGE_ALL:
; 2803 : 	case Command::ACTIVATE_ALL:
; 2804 : 	case Command::DRIVE_COMMAND:
; 2805 : 	case Command::DATA_COMMAND:
; 2806 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2807 : 	case Command::SELF_REFRESH:
; 2808 : 	case Command::DESELECT:
; 2809 : 	case Command::NOOP:
; 2810 : 	case Command::INVALID_COMMAND:
; 2811 : 	default:
; 2812 : 		cerr << "Unsupported command encountered." << endl;
; 2813 : 		nextTime = 0;
; 2814 : 		break;
; 2815 : 	}
; 2816 : 
; 2817 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2818 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2819 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2820 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2821 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2822 : 	if (actualNext != predictedNext )
; 2823 : 		assert(actualNext == predictedNext);
; 2824 : #endif
; 2825 : 
; 2826 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2827 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T418313[esp+48], ecx
	test	edi, edi
	jne	SHORT $LN210@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN114@earliestEx:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN105@earliestEx
	call	__invalid_parameter_noinfo
$LN105@earliestEx:
	mov	ebx, DWORD PTR _this$[esp+48]
	mov	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR tv904[esp+48]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR $T418313[esp+48]
	mov	esi, edx
	adc	esi, DWORD PTR [ebx+20]
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	cmp	edx, esi
	jl	SHORT $LN3@earliestEx
	jg	SHORT $LN214@earliestEx
	cmp	eax, edi
	jbe	SHORT $LN3@earliestEx
$LN214@earliestEx:
	mov	eax, DWORD PTR __Tmp$418289[esp+48]
	mov	edx, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edx+80]
	test	eax, eax
	jne	SHORT $LN209@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN132@earliestEx:
	mov	edi, DWORD PTR tv904[esp+48]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN123@earliestEx
	call	__invalid_parameter_noinfo
$LN123@earliestEx:
	mov	eax, esi
	mov	ecx, edi
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	mov	DWORD PTR tv162[esp+48], eax
	mov	esi, edx
	jmp	SHORT $LN4@earliestEx
$LN210@earliestEx:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN114@earliestEx
$LN209@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN132@earliestEx
$LN3@earliestEx:
	mov	DWORD PTR tv162[esp+48], edi
$LN4@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$418137[esp+48]
	mov	DWORD PTR $T418419[esp+48], ecx
	test	eax, eax
	jne	SHORT $LN208@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN150@earliestEx:
	mov	edi, DWORD PTR tv893[esp+48]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN141@earliestEx
	call	__invalid_parameter_noinfo
$LN141@earliestEx:
	mov	eax, DWORD PTR $T418419[esp+48]
	mov	ecx, edi
	call	?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Rank::next
	cmp	edx, esi
	jl	SHORT $LN7@earliestEx
	jg	SHORT $LN215@earliestEx
	cmp	eax, DWORD PTR tv162[esp+48]
	jbe	SHORT $LN7@earliestEx
$LN215@earliestEx:
	mov	eax, DWORD PTR __Tmp$418137[esp+48]
	mov	edx, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edx+80]
	test	eax, eax
	jne	SHORT $LN207@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN166@earliestEx:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN157@earliestEx
	call	__invalid_parameter_noinfo
$LN157@earliestEx:
	mov	eax, esi
	mov	ecx, edi
	call	?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Rank::next

; 2828 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN208@earliestEx:

; 2671 : 
; 2672 : #ifndef NDEBUG
; 2673 : 	switch(currentCommand->getCommandType())
; 2674 : 	{
; 2675 : 	case Command::ACTIVATE:
; 2676 : 		{
; 2677 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2678 : 
; 2679 : 			// respect the row cycle time limitation
; 2680 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2681 : 
; 2682 : 			// respect the row-to-row activation delay for different banks within a rank
; 2683 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2684 : 
; 2685 : 			// respect tRP of same bank
; 2686 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2687 : 
; 2688 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2689 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2690 : 
; 2691 : 			// respect tRFC, refresh cycle time
; 2692 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2693 : 
; 2694 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2695 : 
; 2696 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2697 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2698 : 		}
; 2699 : 		break;
; 2700 : 
; 2701 : 	case Command::READ_AND_PRECHARGE:
; 2702 : 		// Auto precharge will be issued as part of command,
; 2703 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2704 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2705 : 
; 2706 : 	case Command::READ:
; 2707 : 		{
; 2708 : 			//respect last RAS of same rank
; 2709 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2710 : 
; 2711 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2712 : 			// this as if a CAS command was issued long ago
; 2713 : 
; 2714 : 			// respect last CAS of same rank
; 2715 : 			// DW 3/9/2006 add these two lines
; 2716 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2717 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2718 : 			// DW 3/9/2006 replace the line after next with the next line
; 2719 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2720 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2721 : 
; 2722 : 			// respect last CASW of same rank
; 2723 : 			// DW 3/9/2006 replace the line after next with the next line
; 2724 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2725 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2726 : 
; 2727 : 			//if (rank->size() > 1)
; 2728 : 			{
; 2729 : 				//respect most recent CAS of different rank
; 2730 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2731 : 				//respect timing of READ follow WRITE, different ranks
; 2732 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2733 : 			}
; 2734 : 
; 2735 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2736 : 
; 2737 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2738 : 		}
; 2739 : 		break;
; 2740 : 
; 2741 : 	case Command::WRITE_AND_PRECHARGE:
; 2742 : 		// Auto precharge will be issued as part of command, so
; 2743 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2744 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2745 : 		// has the exact same timing requirements as a simple WRITE.
; 2746 : 
; 2747 : 	case Command::WRITE:
; 2748 : 		{
; 2749 : 			//respect last RAS of same rank
; 2750 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2751 : 
; 2752 : 			// DW 3/9/2006 add these two lines
; 2753 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2754 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2755 : 
; 2756 : 			// respect last cas to same rank
; 2757 : 			// DW 3/9/2006 replace the line after next with the next line
; 2758 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2759 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2760 : 
; 2761 : 			// respect last cas to different ranks
; 2762 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2763 : 
; 2764 : 			// respect last cas write to same rank
; 2765 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2766 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2767 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2768 : 
; 2769 : 			// respect last CASW to different ranks
; 2770 : 			// TODO: should this not also be -tAL?
; 2771 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2772 : 
; 2773 : 			nextTime = max(tRASLimit,tCASLimit);
; 2774 : 		}
; 2775 : 		break;
; 2776 : 
; 2777 : 	case Command::PRECHARGE:
; 2778 : 		{
; 2779 : 			// respect t_ras of same bank
; 2780 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2781 : 
; 2782 : 			// respect t_cas of same bank
; 2783 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2784 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2785 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2786 : 
; 2787 : 			// respect t_casw of same bank
; 2788 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2789 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2790 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2791 : 
; 2792 : 			nextTime = max(tRASLimit,tCASLimit);
; 2793 : 		}
; 2794 : 		break;
; 2795 : 
; 2796 : 	case Command::REFRESH_ALL:
; 2797 : 		// respect tRFC and tRP
; 2798 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2799 : 		break;
; 2800 : 
; 2801 : 	case Command::RETIRE_COMMAND:
; 2802 : 	case Command::PRECHARGE_ALL:
; 2803 : 	case Command::ACTIVATE_ALL:
; 2804 : 	case Command::DRIVE_COMMAND:
; 2805 : 	case Command::DATA_COMMAND:
; 2806 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2807 : 	case Command::SELF_REFRESH:
; 2808 : 	case Command::DESELECT:
; 2809 : 	case Command::NOOP:
; 2810 : 	case Command::INVALID_COMMAND:
; 2811 : 	default:
; 2812 : 		cerr << "Unsupported command encountered." << endl;
; 2813 : 		nextTime = 0;
; 2814 : 		break;
; 2815 : 	}
; 2816 : 
; 2817 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2818 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2819 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2820 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2821 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2822 : 	if (actualNext != predictedNext )
; 2823 : 		assert(actualNext == predictedNext);
; 2824 : #endif
; 2825 : 
; 2826 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2827 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN150@earliestEx
$LN207@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN166@earliestEx
$LN7@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$418289[esp+48]
	mov	DWORD PTR $T418517[esp+48], ecx
	test	eax, eax
	jne	SHORT $LN206@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN182@earliestEx:
	mov	edx, DWORD PTR tv904[esp+48]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN173@earliestEx
	call	__invalid_parameter_noinfo
$LN173@earliestEx:
	mov	eax, DWORD PTR [ebx+44]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR $T418517[esp+48]
	mov	esi, edx
	adc	esi, DWORD PTR [ebx+20]
	mov	ebx, DWORD PTR tv904[esp+48]
	mov	ecx, ebx
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	cmp	edx, esi
	jl	SHORT $LN5@earliestEx
	jg	SHORT $LN216@earliestEx
	cmp	eax, edi
	jbe	SHORT $LN5@earliestEx
$LN216@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$418289[esp+48]
	test	eax, eax
	jne	SHORT $LN205@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN200@earliestEx:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN191@earliestEx
	call	__invalid_parameter_noinfo
$LN191@earliestEx:
	mov	eax, esi
	mov	ecx, ebx
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next

; 2828 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN206@earliestEx:

; 2671 : 
; 2672 : #ifndef NDEBUG
; 2673 : 	switch(currentCommand->getCommandType())
; 2674 : 	{
; 2675 : 	case Command::ACTIVATE:
; 2676 : 		{
; 2677 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2678 : 
; 2679 : 			// respect the row cycle time limitation
; 2680 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2681 : 
; 2682 : 			// respect the row-to-row activation delay for different banks within a rank
; 2683 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2684 : 
; 2685 : 			// respect tRP of same bank
; 2686 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2687 : 
; 2688 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2689 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2690 : 
; 2691 : 			// respect tRFC, refresh cycle time
; 2692 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2693 : 
; 2694 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2695 : 
; 2696 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2697 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2698 : 		}
; 2699 : 		break;
; 2700 : 
; 2701 : 	case Command::READ_AND_PRECHARGE:
; 2702 : 		// Auto precharge will be issued as part of command,
; 2703 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2704 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2705 : 
; 2706 : 	case Command::READ:
; 2707 : 		{
; 2708 : 			//respect last RAS of same rank
; 2709 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2710 : 
; 2711 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2712 : 			// this as if a CAS command was issued long ago
; 2713 : 
; 2714 : 			// respect last CAS of same rank
; 2715 : 			// DW 3/9/2006 add these two lines
; 2716 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2717 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2718 : 			// DW 3/9/2006 replace the line after next with the next line
; 2719 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2720 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2721 : 
; 2722 : 			// respect last CASW of same rank
; 2723 : 			// DW 3/9/2006 replace the line after next with the next line
; 2724 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2725 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2726 : 
; 2727 : 			//if (rank->size() > 1)
; 2728 : 			{
; 2729 : 				//respect most recent CAS of different rank
; 2730 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2731 : 				//respect timing of READ follow WRITE, different ranks
; 2732 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2733 : 			}
; 2734 : 
; 2735 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2736 : 
; 2737 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2738 : 		}
; 2739 : 		break;
; 2740 : 
; 2741 : 	case Command::WRITE_AND_PRECHARGE:
; 2742 : 		// Auto precharge will be issued as part of command, so
; 2743 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2744 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2745 : 		// has the exact same timing requirements as a simple WRITE.
; 2746 : 
; 2747 : 	case Command::WRITE:
; 2748 : 		{
; 2749 : 			//respect last RAS of same rank
; 2750 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2751 : 
; 2752 : 			// DW 3/9/2006 add these two lines
; 2753 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2754 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2755 : 
; 2756 : 			// respect last cas to same rank
; 2757 : 			// DW 3/9/2006 replace the line after next with the next line
; 2758 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2759 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2760 : 
; 2761 : 			// respect last cas to different ranks
; 2762 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2763 : 
; 2764 : 			// respect last cas write to same rank
; 2765 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2766 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2767 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2768 : 
; 2769 : 			// respect last CASW to different ranks
; 2770 : 			// TODO: should this not also be -tAL?
; 2771 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2772 : 
; 2773 : 			nextTime = max(tRASLimit,tCASLimit);
; 2774 : 		}
; 2775 : 		break;
; 2776 : 
; 2777 : 	case Command::PRECHARGE:
; 2778 : 		{
; 2779 : 			// respect t_ras of same bank
; 2780 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2781 : 
; 2782 : 			// respect t_cas of same bank
; 2783 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2784 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2785 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2786 : 
; 2787 : 			// respect t_casw of same bank
; 2788 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2789 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2790 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2791 : 
; 2792 : 			nextTime = max(tRASLimit,tCASLimit);
; 2793 : 		}
; 2794 : 		break;
; 2795 : 
; 2796 : 	case Command::REFRESH_ALL:
; 2797 : 		// respect tRFC and tRP
; 2798 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2799 : 		break;
; 2800 : 
; 2801 : 	case Command::RETIRE_COMMAND:
; 2802 : 	case Command::PRECHARGE_ALL:
; 2803 : 	case Command::ACTIVATE_ALL:
; 2804 : 	case Command::DRIVE_COMMAND:
; 2805 : 	case Command::DATA_COMMAND:
; 2806 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2807 : 	case Command::SELF_REFRESH:
; 2808 : 	case Command::DESELECT:
; 2809 : 	case Command::NOOP:
; 2810 : 	case Command::INVALID_COMMAND:
; 2811 : 	default:
; 2812 : 		cerr << "Unsupported command encountered." << endl;
; 2813 : 		nextTime = 0;
; 2814 : 		break;
; 2815 : 	}
; 2816 : 
; 2817 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2818 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2819 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2820 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2821 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2822 : 	if (actualNext != predictedNext )
; 2823 : 		assert(actualNext == predictedNext);
; 2824 : #endif
; 2825 : 
; 2826 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2827 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN182@earliestEx
$LN205@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN200@earliestEx
$LN5@earliestEx:
	mov	eax, edi

; 2828 : }

	pop	edi
	mov	edx, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::earliestExecuteTime
; Function compile flags: /Ogtpy
tv1964 = -80						; size = 4
_t_cas_gap$223787 = -80					; size = 8
_otherRankLastCASLength$223749 = -80			; size = 4
tv1664 = -72						; size = 8
tv466 = -72						; size = 4
tv418 = -72						; size = 4
_currentRank$ = -72					; size = 4
tv387 = -60						; size = 4
_otherRankLastCASLength$223777 = -60			; size = 4
_otherRankLastCASWLength$223751 = -60			; size = 4
tv478 = -56						; size = 4
_otherRankLastCASWLength$223779 = -56			; size = 4
_tRRDGap$223733 = -56					; size = 8
tv1152 = -48						; size = 4
tv531 = -48						; size = 8
tv421 = -48						; size = 4
tv389 = -48						; size = 4
_t_ras_gap$223801 = -48					; size = 8
_tRCDGap$223747 = -48					; size = 4
_tRPGap$223735 = -48					; size = 8
_currentRankID$ = -48					; size = 4
tv1555 = -40						; size = 8
tv1529 = -40						; size = 8
tv924 = -40						; size = 8
tv605 = -40						; size = 4
_t_ras_gap$223775 = -40					; size = 4
_thisRank$223756 = -40					; size = 8
_tRCGap$223731 = -40					; size = 8
_min_gap$ = -32						; size = 8
tv1738 = -24						; size = 8
_otherRankLastCASTime$223776 = -24			; size = 8
_otherRankLastCASTime$223748 = -24			; size = 8
_tFAWGap$223737 = -24					; size = 8
tv1710 = -16						; size = 8
tv175 = -16						; size = 8
_otherRankLastCASWTime$223778 = -16			; size = 8
_otherRankLastCASWTime$223750 = -16			; size = 8
tv1714 = -8						; size = 8
tv1656 = -8						; size = 8
tv1520 = -8						; size = 8
tv177 = -8						; size = 8
tv171 = -8						; size = 8
_currentCommand$ = 8					; size = 4
?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::minProtocolGap
; _this$ = ecx

; 2455 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H

; 2456 : 	tick min_gap = 0;

	xor	eax, eax
	push	ebx
	mov	ebx, ecx

; 2457 : 
; 2458 : 	const unsigned currentRankID = currentCommand->getAddress().getRank();
; 2459 : 
; 2460 : 	const Rank &currentRank = rank[currentRankID];

	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	mov	DWORD PTR _min_gap$[esp+88], eax
	mov	DWORD PTR _min_gap$[esp+92], eax
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	push	esi
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edi+60]
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _currentRankID$[esp+96], esi
	cmp	esi, eax
	jb	SHORT $LN79@minProtoco@2
	call	__invalid_parameter_noinfo
$LN79@minProtoco@2:
	imul	esi, 424				; 000001a8H
	add	esi, DWORD PTR [ebx+412]

; 2461 : 
; 2462 : 	const Bank &currentBank = currentRank.bank[currentCommand->getAddress().getBank()];

	mov	edi, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [esi+416]
	sub	ecx, DWORD PTR [esi+412]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _currentRank$[esp+96], esi
	cmp	edi, ecx
	jb	SHORT $LN88@minProtoco@2
	call	__invalid_parameter_noinfo
$LN88@minProtoco@2:

; 2463 : 
; 2464 : 	switch(currentCommand->getCommandType())

	mov	edx, DWORD PTR _currentCommand$[ebp]
	imul	edi, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+80]
	add	edi, DWORD PTR [esi+412]
	cmp	eax, 12					; 0000000cH
	ja	$LN1@minProtoco@2
	movzx	eax, BYTE PTR $LN410@minProtoco@2[eax]
	jmp	DWORD PTR $LN456@minProtoco@2[eax*4]
$LN26@minProtoco@2:

; 2465 : 	{
; 2466 : 	case Command::ACTIVATE:
; 2467 : 		{
; 2468 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2469 : 
; 2470 : 			// respect the row cycle time limitation
; 2471 : 			tick tRCGap = (tick)(currentBank.getLastRASTime() - time) + timingSpecification.tRC();

	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+8]
	cdq
	add	eax, DWORD PTR [edi+56]
	adc	edx, DWORD PTR [edi+60]
	sub	eax, ecx
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRCGap$223731[esp+96], eax

; 2472 : 
; 2473 : 			// respect tRRD and tRC of all other banks of same rank
; 2474 : 			tick tRRDGap = (tick)(currentRank.lastActivateTimes.front() - time) + timingSpecification.tRRD();

	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR _tRCGap$223731[esp+100], edx
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+384]
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, edx
	sub	ecx, DWORD PTR [ebx+8]
	sbb	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRRDGap$223733[esp+100], eax

; 2475 : 
; 2476 : 			// respect tRP of same bank
; 2477 : 			tick tRPGap = (tick)(currentBank.getLastPrechargeTime() - time) + timingSpecification.tRP();

	mov	eax, DWORD PTR [ebx+72]
	cdq
	add	eax, DWORD PTR [edi+80]
	adc	edx, DWORD PTR [edi+84]
	sub	eax, DWORD PTR [ebx+8]
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRPGap$223735[esp+96], eax

; 2478 : 
; 2479 : 			// respect the t_faw value for DDR2 and beyond
; 2480 : 			tick tFAWGap = (tick)(currentRank.lastActivateTimes.back() - time) + timingSpecification.tFAW();

	mov	eax, DWORD PTR [esi+388]
	mov	DWORD PTR _tRPGap$223735[esp+100], edx
	cmp	eax, DWORD PTR [esi+376]
	jne	SHORT $LN109@minProtoco@2
	mov	edi, DWORD PTR [esi+380]
	jmp	SHORT $LN110@minProtoco@2
$LN109@minProtoco@2:
	mov	edi, eax
$LN110@minProtoco@2:
	mov	eax, DWORD PTR [ebx+52]
	cdq
	add	eax, DWORD PTR [edi-8]
	adc	edx, DWORD PTR [edi-4]
	mov	edi, DWORD PTR [ebx+8]
	sub	eax, edi
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tFAWGap$223737[esp+96], eax

; 2481 : 
; 2482 : 			// respect tRFC
; 2483 : 			tick tRFCGap = (tick)(currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC();

	mov	eax, DWORD PTR [ebx+68]
	mov	DWORD PTR _tFAWGap$223737[esp+100], edx
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]

; 2484 : 
; 2485 : 			min_gap = max(max(max(tRFCGap,tRCGap) , tRPGap) , max(tRRDGap , tFAWGap));

	mov	esi, DWORD PTR _tRCGap$223731[esp+100]
	sub	eax, edi
	sbb	edx, DWORD PTR [ebx+12]
	cmp	edx, esi
	jl	SHORT $LN31@minProtoco@2
	jg	SHORT $LN411@minProtoco@2
	cmp	eax, DWORD PTR _tRCGap$223731[esp+96]
	jbe	SHORT $LN31@minProtoco@2
$LN411@minProtoco@2:
	mov	DWORD PTR tv171[esp+96], eax
	mov	esi, edx
	jmp	SHORT $LN32@minProtoco@2
$LN31@minProtoco@2:
	mov	edi, DWORD PTR _tRCGap$223731[esp+96]
	mov	DWORD PTR tv171[esp+96], edi
$LN32@minProtoco@2:
	cmp	esi, DWORD PTR _tRPGap$223735[esp+100]
	jl	SHORT $LN35@minProtoco@2
	jg	SHORT $LN412@minProtoco@2
	mov	esi, DWORD PTR tv171[esp+96]
	cmp	esi, DWORD PTR _tRPGap$223735[esp+96]
	jbe	SHORT $LN35@minProtoco@2
$LN412@minProtoco@2:
	mov	esi, DWORD PTR _tRCGap$223731[esp+100]
	cmp	edx, esi
	jl	SHORT $LN33@minProtoco@2
	jg	SHORT $LN413@minProtoco@2
	cmp	eax, DWORD PTR _tRCGap$223731[esp+96]
	jbe	SHORT $LN33@minProtoco@2
$LN413@minProtoco@2:
	mov	DWORD PTR tv175[esp+96], eax
	mov	DWORD PTR tv175[esp+100], edx
	jmp	SHORT $LN36@minProtoco@2
$LN33@minProtoco@2:
	mov	edi, DWORD PTR _tRCGap$223731[esp+96]
	mov	DWORD PTR tv175[esp+96], edi
	jmp	SHORT $LN454@minProtoco@2
$LN35@minProtoco@2:
	mov	esi, DWORD PTR _tRPGap$223735[esp+96]
	mov	DWORD PTR tv175[esp+96], esi
	mov	esi, DWORD PTR _tRPGap$223735[esp+100]
$LN454@minProtoco@2:
	mov	DWORD PTR tv175[esp+100], esi
$LN36@minProtoco@2:
	mov	esi, DWORD PTR _tRRDGap$223733[esp+100]
	mov	edi, DWORD PTR _tFAWGap$223737[esp+100]
	cmp	esi, edi
	jl	SHORT $LN37@minProtoco@2
	jg	SHORT $LN414@minProtoco@2
	cmp	ecx, DWORD PTR _tFAWGap$223737[esp+96]
	jbe	SHORT $LN37@minProtoco@2
$LN414@minProtoco@2:
	mov	DWORD PTR tv177[esp+96], ecx
	jmp	SHORT $LN38@minProtoco@2
$LN37@minProtoco@2:
	mov	esi, DWORD PTR _tFAWGap$223737[esp+96]
	mov	DWORD PTR tv177[esp+96], esi
	mov	esi, edi
$LN38@minProtoco@2:
	cmp	DWORD PTR tv175[esp+100], esi
	jl	SHORT $LN47@minProtoco@2
	jg	SHORT $LN415@minProtoco@2
	mov	esi, DWORD PTR tv177[esp+96]
	cmp	DWORD PTR tv175[esp+96], esi
	jbe	SHORT $LN47@minProtoco@2
$LN415@minProtoco@2:
	mov	ecx, DWORD PTR _tRCGap$223731[esp+100]
	cmp	edx, ecx
	mov	edi, DWORD PTR _tRCGap$223731[esp+96]
	jl	SHORT $LN39@minProtoco@2
	jg	SHORT $LN416@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN39@minProtoco@2
$LN416@minProtoco@2:
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN40@minProtoco@2
$LN39@minProtoco@2:
	mov	esi, edi
$LN40@minProtoco@2:
	cmp	ecx, DWORD PTR _tRPGap$223735[esp+100]
	jl	SHORT $LN43@minProtoco@2
	jg	SHORT $LN417@minProtoco@2
	cmp	esi, DWORD PTR _tRPGap$223735[esp+96]
	jbe	SHORT $LN43@minProtoco@2
$LN417@minProtoco@2:
	mov	ecx, DWORD PTR _tRCGap$223731[esp+100]
	cmp	edx, ecx
	jl	SHORT $LN41@minProtoco@2
	jg	SHORT $LN418@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN41@minProtoco@2
$LN418@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN455@minProtoco@2
$LN41@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], edi
	mov	DWORD PTR _min_gap$[esp+100], ecx
	jmp	$LN1@minProtoco@2
$LN43@minProtoco@2:
	mov	ecx, DWORD PTR _tRPGap$223735[esp+96]
	mov	edx, DWORD PTR _tRPGap$223735[esp+100]
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN1@minProtoco@2
$LN47@minProtoco@2:
	mov	eax, DWORD PTR _tRRDGap$223733[esp+100]
	mov	edx, DWORD PTR _tFAWGap$223737[esp+100]
	cmp	eax, edx
	jl	SHORT $LN45@minProtoco@2
	jg	SHORT $LN419@minProtoco@2
	cmp	ecx, DWORD PTR _tFAWGap$223737[esp+96]
	jbe	SHORT $LN45@minProtoco@2
$LN419@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], eax
	jmp	$LN1@minProtoco@2
$LN45@minProtoco@2:
	mov	eax, DWORD PTR _tFAWGap$223737[esp+96]
	mov	DWORD PTR _min_gap$[esp+100], edx

; 2486 : 		}
; 2487 : 		break;

	jmp	$LN455@minProtoco@2
$LN25@minProtoco@2:

; 2488 : 
; 2489 : 	case Command::READ_AND_PRECHARGE:
; 2490 : 		// Auto precharge will be issued as part of command,
; 2491 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2492 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2493 : 
; 2494 : 	case Command::READ:
; 2495 : 		{
; 2496 : 			//respect last ras of same rank
; 2497 : 			int tRCDGap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	edi, DWORD PTR [edi+56]
	sub	edi, DWORD PTR [ebx+28]

; 2498 : 
; 2499 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2500 : 			// this as if a CAS command was issued long ago
; 2501 : 			tick otherRankLastCASTime = time - 10000000;

	mov	eax, DWORD PTR [ebx+8]
	add	edi, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [ebx+12]
	sub	edi, DWORD PTR [ebx+8]

; 2502 : 			int otherRankLastCASLength = timingSpecification.tBurst();

	mov	edx, DWORD PTR [ebx+32]
	sub	eax, 10000000				; 00989680H
	mov	DWORD PTR _tRCDGap$223747[esp+96], edi

; 2503 : 			tick otherRankLastCASWTime = time - 10000000;
; 2504 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2505 : 
; 2506 : 			// find the most recent cas(w) time and length
; 2507 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	mov	edi, DWORD PTR [ebx+412]
	sbb	ecx, 0
	mov	DWORD PTR _otherRankLastCASTime$223748[esp+96], eax
	mov	DWORD PTR _otherRankLastCASTime$223748[esp+100], ecx
	mov	DWORD PTR _otherRankLastCASLength$223749[esp+96], edx
	mov	DWORD PTR _otherRankLastCASWTime$223750[esp+96], eax
	mov	DWORD PTR _otherRankLastCASWTime$223750[esp+100], ecx
	mov	DWORD PTR _otherRankLastCASWLength$223751[esp+96], edx
	cmp	edi, DWORD PTR [ebx+416]
	jbe	SHORT $LN130@minProtoco@2
	call	__invalid_parameter_noinfo
$LN130@minProtoco@2:
	mov	ecx, DWORD PTR [ebx+400]
	mov	DWORD PTR _thisRank$223756[esp+96], ecx
	mov	DWORD PTR _thisRank$223756[esp+100], edi
	npad	1
$LL145@minProtoco@2:
	mov	edi, DWORD PTR [ebx+416]
	cmp	DWORD PTR [ebx+412], edi
	jbe	SHORT $LN158@minProtoco@2
	call	__invalid_parameter_noinfo
$LN158@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$223756[esp+96]
	mov	eax, DWORD PTR [ebx+400]
	test	ecx, ecx
	je	SHORT $LN171@minProtoco@2
	cmp	ecx, eax
	je	SHORT $LN172@minProtoco@2
$LN171@minProtoco@2:
	call	__invalid_parameter_noinfo
$LN172@minProtoco@2:
	cmp	DWORD PTR _thisRank$223756[esp+100], edi
	je	$LN22@minProtoco@2

; 2508 : 			{
; 2509 : 				if (thisRank->getRankID() != currentRank.getRankID())

	mov	eax, DWORD PTR _thisRank$223756[esp+96]
	test	eax, eax
	jne	$LN409@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN190@minProtoco@2:
	mov	edx, DWORD PTR _thisRank$223756[esp+100]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN181@minProtoco@2
	call	__invalid_parameter_noinfo
$LN181@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$223756[esp+100]
	mov	ecx, DWORD PTR [eax+136]
	cmp	ecx, DWORD PTR [esi+136]
	je	$LN23@minProtoco@2

; 2510 : 				{
; 2511 : 					if (thisRank->getLastCASTime() > otherRankLastCASTime)

	mov	eax, DWORD PTR _thisRank$223756[esp+96]
	test	eax, eax
	jne	$LN408@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN208@minProtoco@2:
	mov	edx, DWORD PTR _thisRank$223756[esp+100]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN199@minProtoco@2
	call	__invalid_parameter_noinfo
$LN199@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$223756[esp+100]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _otherRankLastCASTime$223748[esp+100]
	jl	SHORT $LN20@minProtoco@2
	jg	SHORT $LN420@minProtoco@2
	mov	edx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR _otherRankLastCASTime$223748[esp+96]
	jbe	SHORT $LN20@minProtoco@2
$LN420@minProtoco@2:

; 2512 : 					{
; 2513 : 						otherRankLastCASTime = thisRank->getLastCASTime();

	lea	esi, DWORD PTR _thisRank$223756[esp+96]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _otherRankLastCASTime$223748[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASTime$223748[esp+100], edx

; 2514 : 						otherRankLastCASLength = thisRank->getLastCASLength();

	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	eax, DWORD PTR [eax+112]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASLength$223749[esp+96], eax
$LN20@minProtoco@2:

; 2515 : 					}
; 2516 : 					if (thisRank->getLastCASWTime() > otherRankLastCASWTime)

	mov	eax, DWORD PTR _thisRank$223756[esp+96]
	test	eax, eax
	jne	$LN407@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN228@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$223756[esp+100]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN219@minProtoco@2
	call	__invalid_parameter_noinfo
$LN219@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$223756[esp+100]
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR _otherRankLastCASWTime$223750[esp+100]
	jl	SHORT $LN23@minProtoco@2
	jg	SHORT $LN421@minProtoco@2
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, DWORD PTR _otherRankLastCASWTime$223750[esp+96]
	jbe	SHORT $LN23@minProtoco@2
$LN421@minProtoco@2:

; 2517 : 					{
; 2518 : 						otherRankLastCASWTime = thisRank->getLastCASWTime();

	lea	esi, DWORD PTR _thisRank$223756[esp+96]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _otherRankLastCASWTime$223750[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASWTime$223750[esp+100], edx

; 2519 : 						otherRankLastCASWLength = thisRank->getLastCASWLength();

	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	eax, DWORD PTR [eax+116]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASWLength$223751[esp+96], eax
$LN23@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$223756[esp+96]
	test	eax, eax
	jne	SHORT $LN406@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN152@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$223756[esp+100]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN143@minProtoco@2

; 2503 : 			tick otherRankLastCASWTime = time - 10000000;
; 2504 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2505 : 
; 2506 : 			// find the most recent cas(w) time and length
; 2507 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	call	__invalid_parameter_noinfo
$LN143@minProtoco@2:
	add	DWORD PTR _thisRank$223756[esp+100], 424 ; 000001a8H
	jmp	$LL145@minProtoco@2
$LN409@minProtoco@2:

; 2508 : 			{
; 2509 : 				if (thisRank->getRankID() != currentRank.getRankID())

	mov	eax, DWORD PTR [eax]
	jmp	$LN190@minProtoco@2
$LN408@minProtoco@2:

; 2510 : 				{
; 2511 : 					if (thisRank->getLastCASTime() > otherRankLastCASTime)

	mov	eax, DWORD PTR [eax]
	jmp	$LN208@minProtoco@2
$LN407@minProtoco@2:

; 2515 : 					}
; 2516 : 					if (thisRank->getLastCASWTime() > otherRankLastCASWTime)

	mov	eax, DWORD PTR [eax]
	jmp	$LN228@minProtoco@2
$LN406@minProtoco@2:

; 2503 : 			tick otherRankLastCASWTime = time - 10000000;
; 2504 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2505 : 
; 2506 : 			// find the most recent cas(w) time and length
; 2507 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN152@minProtoco@2
$LN22@minProtoco@2:

; 2520 : 					}
; 2521 : 				}
; 2522 : 			}			
; 2523 : 
; 2524 : 			//respect last cas of same rank
; 2525 : 			// DW 3/9/2006 add these two lines
; 2526 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2527 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2528 : 			// DW 3/9/2006 replace the line after next with the next line
; 2529 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2530 : 			int t_cas_gap = ((currentRank.getLastCASTime() - time) + timingSpecification.tBurst());

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+32]

; 2531 : 
; 2532 : 			//respect last cas write of same rank
; 2533 : 			// DW 3/9/2006 replace the line after next with the next line
; 2534 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2535 : 			t_cas_gap = max((tick)t_cas_gap,((currentRank.getLastCASWTime() - time) + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR()));

	mov	edi, DWORD PTR [ebx+92]
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	DWORD PTR tv1520[esp+96], eax
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR tv1529[esp+100], eax
	mov	DWORD PTR tv1520[esp+100], edx
	mov	edx, DWORD PTR [esi+32]
	mov	eax, edi
	mov	DWORD PTR tv1529[esp+96], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+32]
	mov	esi, edx
	sbb	esi, DWORD PTR [ebx+12]
	cdq
	add	edi, eax
	adc	esi, edx
	add	edi, DWORD PTR tv1529[esp+96]
	mov	eax, ecx
	adc	esi, DWORD PTR tv1529[esp+100]
	add	edi, DWORD PTR tv1520[esp+96]
	cdq
	adc	esi, DWORD PTR tv1520[esp+100]
	cmp	edx, esi
	jg	SHORT $LN50@minProtoco@2
	jl	SHORT $LN422@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN50@minProtoco@2
$LN422@minProtoco@2:
	mov	ecx, DWORD PTR tv1529[esp+96]
	sub	ecx, DWORD PTR [ebx+8]
	add	ecx, DWORD PTR [ebx+48]
	add	ecx, DWORD PTR [ebx+92]
	add	ecx, DWORD PTR [ebx+32]
$LN50@minProtoco@2:

; 2536 : 
; 2537 : 			if (rank.size() > 1)

	mov	edx, DWORD PTR [ebx+416]
	sub	edx, DWORD PTR [ebx+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jbe	$LN54@minProtoco@2

; 2538 : 			{
; 2539 : 				//respect most recent cas of different rank
; 2540 : 				t_cas_gap = max((tick)t_cas_gap, (otherRankLastCASTime - time) + otherRankLastCASLength + timingSpecification.tRTRS());

	mov	eax, DWORD PTR [ebx+84]
	cdq
	mov	DWORD PTR tv1555[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASLength$223749[esp+96]
	mov	DWORD PTR tv1555[esp+100], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	esi, edx
	sbb	esi, DWORD PTR [ebx+12]
	add	edi, DWORD PTR tv1555[esp+96]
	mov	eax, ecx
	adc	esi, DWORD PTR tv1555[esp+100]
	add	edi, DWORD PTR _otherRankLastCASTime$223748[esp+96]
	cdq
	adc	esi, DWORD PTR _otherRankLastCASTime$223748[esp+100]
	cmp	edx, esi
	jg	SHORT $LN52@minProtoco@2
	jl	SHORT $LN423@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN52@minProtoco@2
$LN423@minProtoco@2:
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _otherRankLastCASTime$223748[esp+96]
	sub	ecx, eax
	add	ecx, DWORD PTR [ebx+84]
	add	ecx, DWORD PTR _otherRankLastCASLength$223749[esp+96]
$LN52@minProtoco@2:

; 2541 : 				//respect timing of READ follow WRITE, different ranks
; 2542 : 				t_cas_gap = max((tick)t_cas_gap, (otherRankLastCASWTime - time) + timingSpecification.tCWD() + otherRankLastCASWLength + timingSpecification.tRTRS() - timingSpecification.tCAS());

	mov	eax, DWORD PTR [ebx+36]
	cdq
	mov	DWORD PTR tv478[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASWLength$223751[esp+96]
	mov	DWORD PTR tv466[esp+96], edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv478[esp+96]
	sub	edi, eax
	mov	eax, DWORD PTR tv466[esp+96]
	mov	esi, edx
	sbb	esi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, ecx
	sbb	esi, DWORD PTR [ebx+12]
	add	edi, DWORD PTR tv1555[esp+96]
	cdq
	adc	esi, DWORD PTR tv1555[esp+100]
	add	edi, DWORD PTR tv1520[esp+96]
	adc	esi, DWORD PTR tv1520[esp+100]
	add	edi, DWORD PTR _otherRankLastCASWTime$223750[esp+96]
	adc	esi, DWORD PTR _otherRankLastCASWTime$223750[esp+100]
	cmp	edx, esi
	jg	SHORT $LN54@minProtoco@2
	jl	SHORT $LN424@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN54@minProtoco@2
$LN424@minProtoco@2:
	mov	ecx, DWORD PTR _otherRankLastCASWTime$223750[esp+96]
	sub	ecx, DWORD PTR [ebx+36]
	sub	ecx, DWORD PTR [ebx+8]
	add	ecx, DWORD PTR [ebx+84]
	add	ecx, DWORD PTR [ebx+48]
	add	ecx, DWORD PTR _otherRankLastCASWLength$223751[esp+96]
$LN54@minProtoco@2:

; 2543 : 			}
; 2544 : 			min_gap = max(tRCDGap,t_cas_gap);

	mov	eax, DWORD PTR _tRCDGap$223747[esp+96]
	cmp	eax, ecx
	jg	SHORT $LN56@minProtoco@2
	mov	eax, ecx
$LN56@minProtoco@2:
	cdq
	mov	DWORD PTR _min_gap$[esp+100], edx

; 2545 : 
; 2546 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2547 : 		}
; 2548 : 		break;

	jmp	$LN455@minProtoco@2
$LN17@minProtoco@2:

; 2549 : 
; 2550 : 	case Command::WRITE_AND_PRECHARGE:
; 2551 : 		// Auto precharge will be issued as part of command, so
; 2552 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2553 : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 2554 : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 2555 : 
; 2556 : 	case Command::WRITE:
; 2557 : 		{
; 2558 : 			//respect last ras of same rank
; 2559 : 			int t_ras_gap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	edi, DWORD PTR [edi+56]
	sub	edi, DWORD PTR [ebx+28]

; 2560 : 
; 2561 : 			tick otherRankLastCASTime = time - 10000000;

	mov	eax, DWORD PTR [ebx+8]
	add	edi, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [ebx+12]
	sub	edi, DWORD PTR [ebx+8]

; 2562 : 			int otherRankLastCASLength = timingSpecification.tBurst();

	mov	edx, DWORD PTR [ebx+32]
	sub	eax, 10000000				; 00989680H
	mov	DWORD PTR _t_ras_gap$223775[esp+96], edi
	mov	edi, 0
	sbb	ecx, edi
	mov	DWORD PTR _otherRankLastCASTime$223776[esp+100], ecx

; 2563 : 			tick otherRankLastCASWTime = time - 10000000;

	mov	DWORD PTR _otherRankLastCASWTime$223778[esp+100], ecx

; 2564 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2565 : 
; 2566 : 			// find the most recent CAS/CASW time and length
; 2567 : 			// FIXME: change to use iterators
; 2568 : 			for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)

	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	mov	DWORD PTR _otherRankLastCASTime$223776[esp+96], eax
	mov	DWORD PTR _otherRankLastCASWTime$223778[esp+96], eax
	mov	DWORD PTR _otherRankLastCASLength$223777[esp+96], edx
	mov	DWORD PTR _otherRankLastCASWLength$223779[esp+96], edx
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	$LN14@minProtoco@2

; 2549 : 
; 2550 : 	case Command::WRITE_AND_PRECHARGE:
; 2551 : 		// Auto precharge will be issued as part of command, so
; 2552 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2553 : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 2554 : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 2555 : 
; 2556 : 	case Command::WRITE:
; 2557 : 		{
; 2558 : 			//respect last ras of same rank
; 2559 : 			int t_ras_gap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	DWORD PTR tv1964[esp+96], edi
$LN16@minProtoco@2:

; 2569 : 			{
; 2570 : 				if (rank_id != currentRankID)

	cmp	edi, DWORD PTR _currentRankID$[esp+96]
	je	$LN15@minProtoco@2

; 2571 : 				{
; 2572 : 					if (rank[rank_id].getLastCASTime() > otherRankLastCASTime)

	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN287@minProtoco@2
	call	__invalid_parameter_noinfo
$LN287@minProtoco@2:
	mov	eax, DWORD PTR [ebx+412]
	mov	ecx, DWORD PTR tv1964[esp+96]
	mov	edx, DWORD PTR [ecx+eax+28]
	cmp	edx, DWORD PTR _otherRankLastCASTime$223776[esp+100]
	jl	SHORT $LN12@minProtoco@2
	jg	SHORT $LN425@minProtoco@2
	mov	eax, DWORD PTR [ecx+eax+24]
	cmp	eax, DWORD PTR _otherRankLastCASTime$223776[esp+96]
	jbe	SHORT $LN12@minProtoco@2
$LN425@minProtoco@2:

; 2573 : 					{
; 2574 : 						otherRankLastCASTime = rank[rank_id].getLastCASTime();

	lea	esi, DWORD PTR [ebx+400]
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]

; 2575 : 						otherRankLastCASLength = rank[rank_id].getLastCASLength();

	lea	esi, DWORD PTR [ebx+400]
	mov	DWORD PTR _otherRankLastCASTime$223776[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASTime$223776[esp+100], edx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	eax, DWORD PTR [eax+112]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASLength$223777[esp+96], eax
$LN12@minProtoco@2:

; 2576 : 					}
; 2577 : 					if (rank[rank_id].getLastCASWTime() > otherRankLastCASWTime)

	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	edi, ecx
	jb	SHORT $LN298@minProtoco@2
	call	__invalid_parameter_noinfo
$LN298@minProtoco@2:
	mov	eax, DWORD PTR [ebx+412]
	mov	edx, DWORD PTR tv1964[esp+96]
	mov	ecx, DWORD PTR [edx+eax+36]
	cmp	ecx, DWORD PTR _otherRankLastCASWTime$223778[esp+100]
	jl	SHORT $LN15@minProtoco@2
	jg	SHORT $LN426@minProtoco@2
	mov	eax, DWORD PTR [edx+eax+32]
	cmp	eax, DWORD PTR _otherRankLastCASWTime$223778[esp+96]
	jbe	SHORT $LN15@minProtoco@2
$LN426@minProtoco@2:

; 2578 : 					{
; 2579 : 						otherRankLastCASWTime = rank[rank_id].getLastCASWTime();

	lea	esi, DWORD PTR [ebx+400]
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]

; 2580 : 						otherRankLastCASWLength = rank[rank_id].getLastCASWLength();

	lea	esi, DWORD PTR [ebx+400]
	mov	DWORD PTR _otherRankLastCASWTime$223778[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASWTime$223778[esp+100], edx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	eax, DWORD PTR [eax+116]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASWLength$223779[esp+96], eax
$LN15@minProtoco@2:
	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	add	DWORD PTR tv1964[esp+96], 424		; 000001a8H
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	edi
	add	ecx, edx
	cmp	edi, ecx
	jb	$LN16@minProtoco@2
$LN14@minProtoco@2:

; 2581 : 					}
; 2582 : 				}
; 2583 : 			}
; 2584 : 			// DW 3/9/2006 add these two lines
; 2585 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2586 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2587 : 
; 2588 : 			// respect last cas to same rank
; 2589 : 			// DW 3/9/2006 replace the line after next with the next line
; 2590 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2591 : 			tick t_cas_gap = (tick)(currentRank.getLastCASTime() - time) + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+84]
	mov	edi, edx
	cdq
	sub	eax, ecx
	sbb	edx, edi
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+36]
	mov	edi, edx
	cdq
	add	ecx, eax
	mov	eax, edi
	mov	edi, DWORD PTR [esi+24]
	adc	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv1656[esp+100], eax
	mov	eax, DWORD PTR [ebx+8]
	sub	edi, eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR tv1656[esp+96], ecx
	mov	ecx, DWORD PTR [esi+28]
	sbb	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR _otherRankLastCASLength$223777[esp+96]
	adc	ecx, edx
	add	edi, DWORD PTR tv1656[esp+96]
	cdq
	adc	ecx, DWORD PTR tv1656[esp+100]
	mov	DWORD PTR tv1664[esp+96], eax

; 2592 : 
; 2593 : 			// respect last cas to different ranks
; 2594 : 			t_cas_gap = max((tick)t_cas_gap,(otherRankLastCASTime - time) + timingSpecification.tCAS() + otherRankLastCASLength + timingSpecification.tRTRS() - timingSpecification.tCWD());

	sub	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR tv1664[esp+100], edx
	mov	DWORD PTR tv531[esp+96], eax
	mov	eax, edx
	sbb	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR tv1656[esp+96]
	add	DWORD PTR tv531[esp+96], edx
	mov	edx, DWORD PTR tv531[esp+96]
	mov	DWORD PTR tv531[esp+100], eax
	adc	eax, DWORD PTR tv1656[esp+100]
	add	edx, DWORD PTR _otherRankLastCASTime$223776[esp+96]
	mov	DWORD PTR _t_cas_gap$223787[esp+96], edi
	adc	eax, DWORD PTR _otherRankLastCASTime$223776[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN58@minProtoco@2
	jl	SHORT $LN427@minProtoco@2
	cmp	edi, edx
	ja	SHORT $LN58@minProtoco@2
$LN427@minProtoco@2:
	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	DWORD PTR tv1152[esp+96], eax
	mov	eax, DWORD PTR [ebx+84]
	mov	ecx, edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv1152[esp+96]
	sub	edi, eax
	mov	eax, ecx
	mov	ecx, edx
	sbb	ecx, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+36]
	sbb	ecx, DWORD PTR [ebx+12]
	cdq
	add	edi, eax
	adc	ecx, edx
	add	edi, DWORD PTR tv1664[esp+96]
	adc	ecx, DWORD PTR tv1664[esp+100]
	add	edi, DWORD PTR _otherRankLastCASTime$223776[esp+96]
	adc	ecx, DWORD PTR _otherRankLastCASTime$223776[esp+100]
	mov	DWORD PTR _t_cas_gap$223787[esp+96], edi
$LN58@minProtoco@2:

; 2595 : 
; 2596 : 			// respect last cas write to same rank
; 2597 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2598 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2599 : 			t_cas_gap = max((tick)t_cas_gap,(currentRank.getLastCASWTime() - time) + currentRank.getLastCASWLength());

	mov	edx, DWORD PTR [esi+116]
	xor	eax, eax
	add	edx, DWORD PTR [esi+32]
	adc	eax, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+12]
	sbb	eax, esi
	cmp	ecx, eax
	jg	SHORT $LN60@minProtoco@2
	jl	SHORT $LN428@minProtoco@2
	cmp	edi, edx
	ja	SHORT $LN60@minProtoco@2
$LN428@minProtoco@2:
	mov	DWORD PTR _t_cas_gap$223787[esp+96], edx
	mov	ecx, eax
$LN60@minProtoco@2:

; 2600 : 
; 2601 : 			// respect last cas write to different ranks
; 2602 : 			t_cas_gap = max((tick)t_cas_gap,(otherRankLastCASWTime - time) + otherRankLastCASWLength + timingSpecification.tOST());

	mov	eax, DWORD PTR [ebx+96]
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, edx
	sbb	eax, esi
	mov	DWORD PTR tv389[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASWLength$223779[esp+96]
	cdq
	add	edi, eax
	mov	eax, DWORD PTR tv389[esp+96]
	adc	eax, edx
	mov	edx, edi
	add	edx, DWORD PTR _otherRankLastCASWTime$223778[esp+96]
	adc	eax, DWORD PTR _otherRankLastCASWTime$223778[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN436@minProtoco@2
	jl	SHORT $LN429@minProtoco@2
	mov	esi, DWORD PTR _t_cas_gap$223787[esp+96]
	cmp	esi, edx
	ja	SHORT $LN62@minProtoco@2
$LN429@minProtoco@2:
	mov	esi, edx
	mov	ecx, eax
	jmp	SHORT $LN62@minProtoco@2
$LN436@minProtoco@2:
	mov	esi, DWORD PTR _t_cas_gap$223787[esp+96]
$LN62@minProtoco@2:

; 2603 : 
; 2604 : 			min_gap = max((tick)t_ras_gap,(tick)t_cas_gap);

	mov	eax, DWORD PTR _t_ras_gap$223775[esp+96]
	cdq
	cmp	edx, ecx
	jl	SHORT $LN63@minProtoco@2
	jg	SHORT $LN430@minProtoco@2
	cmp	eax, esi
	jbe	SHORT $LN63@minProtoco@2
$LN430@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN455@minProtoco@2
$LN63@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], esi
	mov	DWORD PTR _min_gap$[esp+100], ecx

; 2605 : 		}
; 2606 : 		break;

	jmp	$LN1@minProtoco@2
$LN9@minProtoco@2:

; 2607 : 
; 2608 : 	case Command::RETIRE_COMMAND:
; 2609 : 		break;
; 2610 : 
; 2611 : 	case Command::PRECHARGE:
; 2612 : 		{
; 2613 : 			// respect t_ras of same bank
; 2614 : 			tick t_ras_gap = (currentBank.getLastRASTime() - time) + timingSpecification.tRAS();

	mov	eax, DWORD PTR [ebx+56]
	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+12]
	cdq
	add	eax, DWORD PTR [edi+56]
	adc	edx, DWORD PTR [edi+60]
	sub	eax, ecx
	sbb	edx, esi
	mov	DWORD PTR _t_ras_gap$223801[esp+96], eax

; 2615 : 
; 2616 : 			// respect t_cas of same bank
; 2617 : 			tick t_cas_gap = ((tick)(currentBank.getLastCASTime() - time) + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));

	mov	eax, DWORD PTR [ebx+80]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, 0
	sets	cl
	mov	DWORD PTR _t_ras_gap$223801[esp+100], edx
	dec	ecx
	and	ecx, eax
	mov	eax, DWORD PTR [ebx+32]
	cdq
	mov	DWORD PTR tv1710[esp+96], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR tv1710[esp+100], edx
	cdq
	mov	DWORD PTR tv1714[esp+96], eax
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR tv1714[esp+100], edx
	cdq
	mov	esi, eax
	add	esi, DWORD PTR [edi+64]
	mov	eax, ecx
	mov	ecx, edx
	adc	ecx, DWORD PTR [edi+68]
	sub	esi, DWORD PTR [ebx+8]
	cdq
	sbb	ecx, DWORD PTR [ebx+12]
	add	esi, eax

; 2618 : 
; 2619 : 			// respect t_casw of same bank
; 2620 : 			t_cas_gap = max((tick)t_cas_gap,((currentBank.getLastCASWTime() - time) + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR()));

	mov	eax, DWORD PTR [edi+76]
	adc	ecx, edx
	add	esi, DWORD PTR tv1714[esp+96]
	mov	edx, DWORD PTR [edi+72]
	adc	ecx, DWORD PTR tv1714[esp+100]
	add	esi, DWORD PTR tv1710[esp+96]
	mov	DWORD PTR tv1738[esp+100], eax
	adc	ecx, DWORD PTR tv1710[esp+100]
	mov	eax, DWORD PTR [ebx+88]
	mov	DWORD PTR tv1738[esp+96], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+48]
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv924[esp+100], edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR tv924[esp+100]
	adc	eax, edx
	add	edi, DWORD PTR tv1738[esp+96]
	adc	eax, DWORD PTR tv1738[esp+100]
	add	edi, DWORD PTR tv1714[esp+96]
	adc	eax, DWORD PTR tv1714[esp+100]
	add	edi, DWORD PTR tv1710[esp+96]
	adc	eax, DWORD PTR tv1710[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN68@minProtoco@2
	jl	SHORT $LN431@minProtoco@2
	cmp	esi, edi
	ja	SHORT $LN68@minProtoco@2
$LN431@minProtoco@2:
	mov	eax, DWORD PTR [ebx+28]
	cdq
	mov	esi, eax
	sub	esi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, edx
	sbb	ecx, DWORD PTR [ebx+12]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	adc	ecx, edx
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [ebx+32]
	adc	ecx, edx
	cdq
	add	esi, eax
	adc	ecx, edx
	add	esi, DWORD PTR tv1738[esp+96]
	adc	ecx, DWORD PTR tv1738[esp+100]
$LN68@minProtoco@2:

; 2621 : 
; 2622 : 			min_gap = max(t_ras_gap,t_cas_gap);

	mov	eax, DWORD PTR _t_ras_gap$223801[esp+100]
	cmp	eax, ecx
	jl	$LN63@minProtoco@2
	jg	SHORT $LN432@minProtoco@2
	cmp	DWORD PTR _t_ras_gap$223801[esp+96], esi
	jbe	$LN63@minProtoco@2
$LN432@minProtoco@2:
	mov	ecx, DWORD PTR _t_ras_gap$223801[esp+96]
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], eax
	jmp	SHORT $LN1@minProtoco@2
$LN3@minProtoco@2:

; 2623 : 		}
; 2624 : 		break;
; 2625 : 
; 2626 : 	case Command::PRECHARGE_ALL:
; 2627 : 		break;
; 2628 : 
; 2629 : 	case Command::ACTIVATE_ALL:
; 2630 : 		break;
; 2631 : 
; 2632 : 	case Command::DRIVE_COMMAND:
; 2633 : 		break;
; 2634 : 
; 2635 : 	case Command::DATA_COMMAND:
; 2636 : 		break;
; 2637 : 
; 2638 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2639 : 		break;
; 2640 : 
; 2641 : 	case Command::REFRESH_ALL:
; 2642 : 		// respect tRFC and tRP
; 2643 : 		min_gap = max((currentRank.getLastRefreshTime() + timingSpecification.tRFC()),(currentRank.getLastPrechargeTime() + timingSpecification.tRP())) - time;

	mov	eax, DWORD PTR [ebx+72]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebx+68]
	mov	ecx, edx
	adc	ecx, DWORD PTR [esi+20]
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	cmp	edx, ecx
	jl	SHORT $LN71@minProtoco@2
	jg	SHORT $LN433@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN71@minProtoco@2
$LN433@minProtoco@2:
	mov	ecx, edx
	jmp	SHORT $LN72@minProtoco@2
$LN71@minProtoco@2:
	mov	eax, edi
$LN72@minProtoco@2:
	sub	eax, DWORD PTR [ebx+8]
	sbb	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _min_gap$[esp+100], ecx
$LN455@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], eax
$LN1@minProtoco@2:

; 2644 : 		break;
; 2645 : 
; 2646 : 	case Command::INVALID_COMMAND:
; 2647 : 		break;
; 2648 : 
; 2649 : 	default:
; 2650 : 		break;
; 2651 : 	}
; 2652 : 
; 2653 : 	//return max(min_gap,timingSpecification.tCMD());
; 2654 : 	//return max(min_gap,max(lastCommandIssueTime - time + (tick)timingSpecification.tCMD(),(tick)0));
; 2655 : 	return max(min_gap, lastCommandIssueTime + (tick)(timingSpecification.tCMD()) - time);

	mov	eax, DWORD PTR [ebx+44]
	cdq
	sub	eax, DWORD PTR [ebx+8]
	sbb	edx, DWORD PTR [ebx+12]
	add	eax, DWORD PTR [ebx+16]
	mov	ecx, edx
	adc	ecx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR _min_gap$[esp+100]
	cmp	edx, ecx
	jl	SHORT $LN73@minProtoco@2
	jg	SHORT $LN434@minProtoco@2
	cmp	DWORD PTR _min_gap$[esp+96], eax
	jbe	SHORT $LN73@minProtoco@2
$LN434@minProtoco@2:
	mov	eax, DWORD PTR _min_gap$[esp+96]

; 2656 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN73@minProtoco@2:
	pop	edi
	pop	esi
	mov	edx, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN456@minProtoco@2:
	DD	$LN26@minProtoco@2
	DD	$LN25@minProtoco@2
	DD	$LN17@minProtoco@2
	DD	$LN9@minProtoco@2
	DD	$LN3@minProtoco@2
	DD	$LN1@minProtoco@2
$LN410@minProtoco@2:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::minProtocolGap
_TEXT	ENDS
PUBLIC	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ	; DRAMsimII::Channel::nextRefreshTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T419686 = -8						; size = 8
?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ PROC	; DRAMsimII::Channel::nextRefreshTime
; _this$ = eax

; 349  : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 350  : 	assert(rank.size() >= 1);
; 351  : 
; 352  : 	if (systemConfig.getRefreshPolicy() != NO_REFRESH)

	mov	eax, DWORD PTR [edi+176]
	cmp	DWORD PTR [eax+304], 0
	je	SHORT $LN2@nextRefres

; 353  : 		return *(std::min_element(refreshCounter.begin(), refreshCounter.end()));

	mov	ebx, DWORD PTR [edi+168]
	cmp	DWORD PTR [edi+164], ebx
	jbe	SHORT $LN10@nextRefres
	call	__invalid_parameter_noinfo
$LN10@nextRefres:
	mov	esi, DWORD PTR [edi+164]
	cmp	esi, DWORD PTR [edi+168]
	jbe	SHORT $LN24@nextRefres
	call	__invalid_parameter_noinfo
$LN24@nextRefres:
	mov	edi, DWORD PTR [edi+152]
	mov	DWORD PTR $T419686[esp+24], esi
	cmp	esi, ebx
	je	SHORT $LN50@nextRefres
	lea	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN50@nextRefres
$LL51@nextRefres:
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+4]
	jg	SHORT $LN49@nextRefres
	jl	SHORT $LN73@nextRefres
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN49@nextRefres
$LN73@nextRefres:
	mov	esi, eax
$LN49@nextRefres:
	add	eax, 8
	cmp	eax, ebx
	jne	SHORT $LL51@nextRefres
$LN50@nextRefres:
	test	edi, edi
	jne	SHORT $LN72@nextRefres
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN68@nextRefres:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN59@nextRefres
	call	__invalid_parameter_noinfo
$LN59@nextRefres:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]

; 354  : 	else
; 355  : 		return TICK_MAX;
; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	ret	0
$LN72@nextRefres:

; 353  : 		return *(std::min_element(refreshCounter.begin(), refreshCounter.end()));

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN68@nextRefres
$LN2@nextRefres:

; 354  : 	else
; 355  : 		return TICK_MAX;
; 356  : }

	pop	edi
	pop	esi
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
	pop	ebx
	add	esp, 8
	ret	0
?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ENDP	; DRAMsimII::Channel::nextRefreshTime
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ??1thread_data_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1thread_data_base@detail@boost@@UAE@XZ PROC		; boost::detail::thread_data_base::~thread_data_base, COMDAT
; _this$ = ecx

; 45   :             {}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	je	SHORT $LN5@thread_dat
	cmp	eax, -1
	je	SHORT $LN5@thread_dat
	push	eax
	call	edi
$LN5@thread_dat:
	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	je	SHORT $LN10@thread_dat
	cmp	esi, -1
	je	SHORT $LN10@thread_dat
	push	esi
	call	edi
$LN10@thread_dat:
	pop	edi
	pop	esi
	ret	0
??1thread_data_base@detail@boost@@UAE@XZ ENDP		; boost::detail::thread_data_base::~thread_data_base
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
xdata$x	SEGMENT
__unwindtable$??0thread_data_base@detail@boost@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0thread_data_base@detail@boost@@QAE@XZ$0
__ehfuncinfo$??0thread_data_base@detail@boost@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0thread_data_base@detail@boost@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
xdata$x	ENDS
;	COMDAT ??0thread_data_base@detail@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T419759 = -28						; size = 16
__$EHRec$ = -12						; size = 12
??0thread_data_base@detail@boost@@QAE@XZ PROC		; boost::detail::thread_data_base::thread_data_base, COMDAT
; _this$ = ecx

; 43   :             {}

	push	-1
	push	__ehhandler$??0thread_data_base@detail@boost@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+44], esi
	xor	edi, edi
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], -1
	push	edi
	push	edi
	push	1
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], edi
	call	DWORD PTR __imp__CreateEventA@16
	cmp	eax, edi
	jne	SHORT $LN7@thread_dat@2
	lea	ecx, DWORD PTR $T419759[esp+44]
	call	??0thread_resource_error@boost@@QAE@XZ	; boost::thread_resource_error::thread_resource_error
	push	OFFSET __TI3?AVthread_resource_error@boost@@
	lea	eax, DWORD PTR $T419759[esp+48]
	push	eax
	call	__CxxThrowException@8
$LN15@thread_dat@2:
$LN7@thread_dat@2:
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	BYTE PTR [esi+24], 1
	mov	DWORD PTR [esi+28], edi
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 32					; 00000020H
	ret	0
$LN14@thread_dat@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0thread_data_base@detail@boost@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1handle_manager@win32@detail@boost@@QAE@XZ ; boost::detail::win32::handle_manager::~handle_manager
__ehhandler$??0thread_data_base@detail@boost@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-28]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0thread_data_base@detail@boost@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0thread_data_base@detail@boost@@QAE@XZ ENDP		; boost::detail::thread_data_base::thread_data_base
; Function compile flags: /Ogtpy
;	COMDAT ??_G_ns2__submitEpochResultElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_ns2__submitEpochResultElement@@UAEPAXI@Z PROC	; _ns2__submitEpochResultElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@51
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@51:
	mov	eax, esi
	pop	esi
	ret	4
??_G_ns2__submitEpochResultElement@@UAEPAXI@Z ENDP	; _ns2__submitEpochResultElement::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ PROC		; DRAMsimII::Bank::back, COMDAT
; _this$ = esi

; 111  : 		const Command *back() const { return perBankQueue.back(); }

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@back@4
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+40]
	sub	eax, DWORD PTR [esi+36]
	push	edi
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN9@back@4
	call	__invalid_parameter_noinfo
$LN9@back@4:
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi
	ret	0
$LN5@back@4:
	xor	eax, eax
	ret	0
?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ENDP		; DRAMsimII::Bank::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ PROC		; DRAMsimII::Bank::front, COMDAT
; _this$ = esi

; 110  : 		const inline Command *front() const { return perBankQueue.front(); }

	mov	eax, DWORD PTR [esi+40]
	sub	eax, DWORD PTR [esi+36]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN10@front@7
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi
	ret	0
$LN10@front@7:
	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi
	ret	0
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ENDP		; DRAMsimII::Bank::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z
_TEXT	SEGMENT
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z PROC		; DRAMsimII::Bank::read, COMDAT
; _this$ = esi

; 109  : 		const Command *read(const unsigned value) const { return perBankQueue.read(value); }

	cmp	DWORD PTR [esi+12], 1
	jle	SHORT $LN4@read@9
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+16]
	xor	edx, edx
	sar	ecx, 2
	inc	eax
	div	ecx
	push	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+40]
	sub	edx, DWORD PTR [esi+36]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@read@9
	call	__invalid_parameter_noinfo
$LN10@read@9:
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+edi*4]
	pop	edi
	ret	0
$LN4@read@9:
	xor	eax, eax
	ret	0
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ENDP		; DRAMsimII::Bank::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ PROC		; DRAMsimII::Bank::pop, COMDAT
; _this$ = eax

; 106  : 		Command *pop() { return perBankQueue.pop(); }

	push	esi
	mov	esi, eax
	add	esi, 12					; 0000000cH
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	pop	esi
	ret	0
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ ENDP		; DRAMsimII::Bank::pop
; Function compile flags: /Ogtpy
;	COMDAT ??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; _this$ = eax
	push	esi
	push	edi
	mov	edi, eax
	lea	esi, DWORD PTR [edi+40]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	esi, DWORD PTR __imp__CloseHandle@4
	mov	DWORD PTR [edi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN13@thread_dat@3
	cmp	eax, -1
	je	SHORT $LN13@thread_dat@3
	push	eax
	call	esi
$LN13@thread_dat@3:
	mov	edi, DWORD PTR [edi+8]
	test	edi, edi
	je	SHORT $LN18@thread_dat@3
	cmp	edi, -1
	je	SHORT $LN18@thread_dat@3
	push	edi
	call	esi
$LN18@thread_dat@3:
	pop	edi
	pop	esi
	ret	0
??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+40]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	esi, DWORD PTR __imp__CloseHandle@4
	mov	DWORD PTR [edi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN16@scalar@69
	cmp	eax, -1
	je	SHORT $LN16@scalar@69
	push	eax
	call	esi
$LN16@scalar@69:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN21@scalar@69
	cmp	eax, -1
	je	SHORT $LN21@scalar@69
	push	eax
	call	esi
$LN21@scalar@69:
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN24@scalar@69
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@69:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>, COMDAT
; __First1$ = ecx
; __First2$ = eax

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	esi, ebx
	je	SHORT $LN2@Equal@13
	npad	1
$LL4@Equal@13:

; 2993 : 		if (!(*_First1 == *_First2))

	push	esi
	call	??8Rank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Rank::operator==
	test	al, al
	je	SHORT $LN8@Equal@13
	add	esi, 424				; 000001a8H
	add	edi, 424				; 000001a8H
	cmp	esi, ebx
	jne	SHORT $LL4@Equal@13
$LN2@Equal@13:
	pop	edi
	pop	esi

; 2995 : 	return (true);

	mov	al, 1
	pop	ebx

; 2996 : 	}

	ret	0
$LN8@Equal@13:
	pop	edi
	pop	esi

; 2994 : 			return (false);

	xor	al, al
	pop	ebx

; 2996 : 	}

	ret	0
??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Bank@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
??1Bank@DRAMsimII@@QAE@XZ PROC				; DRAMsimII::Bank::~Bank, COMDAT
; _this$ = eax
	push	ecx
	add	eax, 12					; 0000000cH
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx
	ret	0
??1Bank@DRAMsimII@@QAE@XZ ENDP				; DRAMsimII::Bank::~Bank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GBank@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
??_GBank@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::Bank::`scalar deleting destructor', COMDAT
; _this$ = esi
	push	ecx
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	mov	eax, esi
	pop	ecx
	ret	0
??_GBank@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::Bank::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z PROC ; std::_Destroy<DRAMsimII::Bank>, COMDAT
; __Ptr$ = eax

; 58   : 	{	// destroy object at _Ptr

	push	ecx

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	add	eax, 12					; 0000000cH
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx

; 60   : 	}

	ret	0
??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z ENDP ; std::_Destroy<DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Tmp$449464 = -8					; size = 8
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT

; 3042 : 	{

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR __First1$[esp+12]

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	mov	eax, DWORD PTR __First2$[esp+12]
	push	esi
	sar	edx, 7
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	ecx, eax
	push	edi
	mov	edi, DWORD PTR __First2$[esp+24]
	mov	DWORD PTR __Tmp$449464[esp+24], ecx
	test	eax, eax
	jne	SHORT $LN39@Equal@14
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Tmp$449464[esp+24]
	xor	eax, eax
$LN15@Equal@14:
	imul	esi, 424				; 000001a8H
	add	esi, edi
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@14
	test	ecx, ecx
	je	SHORT $LN20@Equal@14
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN21@Equal@14
$LN39@Equal@14:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@14
$LN20@Equal@14:
	xor	ecx, ecx
$LN21@Equal@14:
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Equal@14
$LN5@Equal@14:
	call	__invalid_parameter_noinfo
$LN6@Equal@14:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	edi, DWORD PTR __First2$[esp+24]
	mov	esi, ebp
	cmp	ebp, ebx
	je	SHORT $LN31@Equal@14
$LL33@Equal@14:
	push	esi
	call	??8Rank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Rank::operator==
	test	al, al
	je	SHORT $LN37@Equal@14
	add	esi, 424				; 000001a8H
	add	edi, 424				; 000001a8H
	cmp	esi, ebx
	jne	SHORT $LL33@Equal@14
$LN31@Equal@14:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
$LN37@Equal@14:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z PROC ; std::allocator<DRAMsimII::Bank>::destroy, COMDAT
; __Ptr$ = eax

; 159  : 		{	// destroy object at _Ptr

	push	ecx

; 160  : 		_Destroy(_Ptr);

	add	eax, 12					; 0000000cH
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx

; 161  : 		}

	ret	0
?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z ENDP ; std::allocator<DRAMsimII::Bank>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ecx
	push	esi
	mov	esi, eax

; 233  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@14
	npad	8
$LL3@Destroy_ra@14:
	lea	eax, DWORD PTR [esi+12]

; 234  : 		_Al.destroy(_First);

	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 168				; 000000a8H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@14
$LN1@Destroy_ra@14:

; 235  : 	}

	pop	esi
	pop	ecx
	ret	0
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z
_TEXT	SEGMENT
$T449575 = -4						; size = 1
__First1$ = 8						; size = 8
$T449576 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T449576[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T449575[esp+4], 0
	mov	eax, DWORD PTR $T449575[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@15
$LL7@Destroy_ra@15:
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 168				; 000000a8H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@15
$LN5@Destroy_ra@15:

; 226  : 	}

	pop	esi
	ret	0
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
$T449673 = -8						; size = 8
tv284 = 8						; size = 4
$T449867 = 8						; size = 1
$T449868 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z PROC ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Left$ = esi

; 1307 : 	{	// test for vector equality

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	push	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	ebp, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv284[esp+16], eax
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	mov	ecx, DWORD PTR tv284[esp+16]
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LN3@operator@333
	cmp	edi, ebp
	jbe	SHORT $LN12@operator@333
	call	__invalid_parameter_noinfo
$LN12@operator@333:
	mov	ebp, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR $T449673[esp+20], ecx
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@333
	call	__invalid_parameter_noinfo
$LN26@operator@333:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@333
	call	__invalid_parameter_noinfo
$LN40@operator@333:
	mov	ecx, DWORD PTR $T449673[esp+20]
	mov	BYTE PTR $T449867[esp+16], 0
	mov	edx, DWORD PTR $T449867[esp+16]
	mov	eax, DWORD PTR $T449868[esp+16]
	push	edx
	push	eax
	push	edi
	push	ecx
	push	ebp
	push	ebx
	call	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN3@operator@333
	pop	edi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@333:
	pop	edi
	pop	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@21
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@21
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@21
$LN5@Make_iter@21:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@21:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@22
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@22
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@22
$LN5@Make_iter@22:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@22:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@12
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@12
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@12
$LN8@erase@12:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@12:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@12
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@12
$LN24@erase@12:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@12:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@12
	cmp	eax, ecx
	je	SHORT $LN39@erase@12
$LN38@erase@12:
	call	__invalid_parameter_noinfo
$LN39@erase@12:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@12
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@12:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN63@erase@12:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = edi

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, edi
	je	SHORT $LN7@Destroy@14
$LL9@Destroy@14:
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 168				; 000000a8H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@14
$LN7@Destroy@14:

; 1120 : 		}

	pop	esi
	ret	0
?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@13
	mov	eax, DWORD PTR __First_arg$[esp+8]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@13
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@13
$LN8@erase@13:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+8]
$LN9@erase@13:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@13
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@13
$LN24@erase@13:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+8]
$LN25@erase@13:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@13
	cmp	eax, ecx
	je	SHORT $LN39@erase@13
$LN38@erase@13:
	call	__invalid_parameter_noinfo
$LN39@erase@13:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@13

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	ebp
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@13
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@13:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
	pop	ebp
$LN63@erase@13:
	pop	edi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	20					; 00000014H
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@334
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@334
$LN15@operator@334:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@334
$LN11@operator@334:
	xor	eax, eax
$LN12@operator@334:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@334
	call	__invalid_parameter_noinfo
$LN16@operator@334:
	add	DWORD PTR [esi+4], 8

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=, COMDAT
; _this$ = edi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN22@operator@335
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@operator@335
$LN22@operator@335:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@335
$LN12@operator@335:
	xor	edx, edx
$LN13@operator@335:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 168				; 000000a8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@335
	test	eax, eax
	je	SHORT $LN18@operator@335
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@335
$LN18@operator@335:
	xor	eax, eax
$LN19@operator@335:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@335
$LN3@operator@335:
	call	__invalid_parameter_noinfo
$LN23@operator@335:
	add	DWORD PTR [edi+4], esi

; 376  : 		return (*this);

	mov	eax, edi
	pop	esi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@336
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@336
$LN15@operator@336:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@336
$LN11@operator@336:
	xor	eax, eax
$LN12@operator@336:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@336
	call	__invalid_parameter_noinfo
$LN16@operator@336:
	add	DWORD PTR [esi+4], 168			; 000000a8H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@337
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@337
$LN15@operator@337:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@337
$LN11@operator@337:
	xor	eax, eax
$LN12@operator@337:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@337
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@337:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T450735 = -8						; size = 4
$T450687 = -8						; size = 8
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T450735[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN8@clear@14
	call	__invalid_parameter_noinfo
$LN8@clear@14:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@14
	call	__invalid_parameter_noinfo
$LN24@clear@14:
	mov	ecx, DWORD PTR $T450735[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T450687[esp+40]
	push	edx
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy, COMDAT

; 1123 : 		{	// free all storage

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+12]
	push	edi
	test	esi, esi
	je	SHORT $LN25@Tidy@35

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+16]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@35
$LL12@Tidy@35:
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 168				; 000000a8H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@35
$LN10@Tidy@35:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy@35:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1135 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	pop	ebx
	pop	ecx
	ret	4
?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T450930 = -8						; size = 8
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN8@clear@15
	call	__invalid_parameter_noinfo
$LN8@clear@15:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@15
	call	__invalid_parameter_noinfo
$LN24@clear@15:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T450930[esp+40]
	push	eax
	call	?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ; std::vector<__int64,std::allocator<__int64> >::erase
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	add	esp, 8
	ret	0
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@338
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@338
$LN17@operator@338:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@338
$LN13@operator@338:
	xor	eax, eax
$LN14@operator@338:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@338
	call	__invalid_parameter_noinfo
$LN18@operator@338:
	add	DWORD PTR [esi+4], 8

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@339
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@339
$LN15@operator@339:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@339
$LN11@operator@339:
	xor	eax, eax
$LN12@operator@339:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@339
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@339:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 380  : 		{	// return this + integer

	push	ebx

; 381  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@340
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@340:
	imul	edi, 168				; 000000a8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@340
	test	esi, esi
	je	SHORT $LN20@operator@340
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@340
$LN24@operator@340:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@340
$LN20@operator@340:
	xor	eax, eax
$LN21@operator@340:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@340
$LN5@operator@340:
	call	__invalid_parameter_noinfo
$LN6@operator@340:
	mov	DWORD PTR [ebp+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@341
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@341
$LN17@operator@341:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@341
$LN13@operator@341:
	xor	eax, eax
$LN14@operator@341:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@341
	call	__invalid_parameter_noinfo
$LN18@operator@341:
	add	DWORD PTR [esi+4], 168			; 000000a8H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@342
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@342
$LN17@operator@342:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@342
$LN13@operator@342:
	xor	eax, eax
$LN14@operator@342:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@342
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@342:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@343
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@343
$LN17@operator@343:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@343
$LN13@operator@343:
	xor	eax, eax
$LN14@operator@343:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@343
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@343:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT

; 558  : 		{	// destroy the object

	push	-1
	push	__ehhandler$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]

; 559  : 		_Tidy();

	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?isEmpty@Channel@DRAMsimII@@QBE_NXZ		; DRAMsimII::Channel::isEmpty
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
?isEmpty@Channel@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Channel::isEmpty

; 2831 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	push	edi

; 2832 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebp+412]
	cmp	edi, DWORD PTR [ebp+416]
	jbe	SHORT $LN10@isEmpty@2
	call	__invalid_parameter_noinfo
$LN10@isEmpty@2:
	mov	esi, DWORD PTR [ebp+400]
$LL25@isEmpty@2:
	mov	ebx, DWORD PTR [ebp+416]
	cmp	DWORD PTR [ebp+412], ebx
	jbe	SHORT $LN38@isEmpty@2
	call	__invalid_parameter_noinfo
$LN38@isEmpty@2:
	mov	eax, DWORD PTR [ebp+400]
	test	esi, esi
	je	SHORT $LN51@isEmpty@2
	cmp	esi, eax
	je	SHORT $LN52@isEmpty@2
$LN51@isEmpty@2:
	call	__invalid_parameter_noinfo
$LN52@isEmpty@2:
	cmp	edi, ebx
	je	SHORT $LN2@isEmpty@2

; 2833 : 	{
; 2834 : 		if (!i->isEmpty())

	test	esi, esi
	jne	SHORT $LN78@isEmpty@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN70@isEmpty@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN61@isEmpty@2
	call	__invalid_parameter_noinfo
$LN61@isEmpty@2:
	push	edi
	call	?isEmpty@Rank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Rank::isEmpty
	test	al, al
	je	SHORT $LN76@isEmpty@2

; 2832 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN77@isEmpty@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN32@isEmpty@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN23@isEmpty@2
	call	__invalid_parameter_noinfo
$LN23@isEmpty@2:
	add	edi, 424				; 000001a8H
	jmp	SHORT $LL25@isEmpty@2
$LN78@isEmpty@2:

; 2833 : 	{
; 2834 : 		if (!i->isEmpty())

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN70@isEmpty@2
$LN77@isEmpty@2:

; 2832 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN32@isEmpty@2
$LN76@isEmpty@2:
	pop	edi
	pop	esi
	pop	ebp

; 2835 : 			return false;

	xor	al, al
	pop	ebx

; 2838 : }

	ret	4
$LN2@isEmpty@2:
	pop	edi

; 2836 : 	}
; 2837 : 	return transactionQueue.isEmpty();

	xor	eax, eax
	cmp	DWORD PTR [ebp+112], eax
	pop	esi
	pop	ebp
	sete	al
	pop	ebx

; 2838 : }

	ret	4
?isEmpty@Channel@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Channel::isEmpty
_TEXT	ENDS
PUBLIC	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T452046 = -16						; size = 4
__Tmp$451804 = -16					; size = 8
_currentBank$223116 = -16				; size = 8
$T451632 = -8						; size = 8
_bankEnd$223093 = -8					; size = 8
_this$ = 8						; size = 4
_useThisCommand$ = 12					; size = 4
?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z PROC ; DRAMsimII::Channel::getNextCommand

; 1425 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, DWORD PTR _useThisCommand$[ebp]
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi

; 1426 : 	// populate the cache if need be
; 1427 : 	if (useThisCommand == NULL)

	test	eax, eax
	jne	SHORT $LN343@getNextCom

; 1428 : 		useThisCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	DWORD PTR _useThisCommand$[ebp], eax

; 1429 : 
; 1430 : 	if (useThisCommand)

	test	eax, eax
	je	$LN11@getNextCom
$LN343@getNextCom:

; 1431 : 	{
; 1432 : 		vector<Rank>::iterator currentRank = rank.begin() + useThisCommand->getAddress().getRank();

	mov	ebx, DWORD PTR [esi+412]
	mov	edi, DWORD PTR [eax+60]
	cmp	ebx, DWORD PTR [esi+416]
	jbe	SHORT $LN26@getNextCom
	call	__invalid_parameter_noinfo
$LN26@getNextCom:
	mov	esi, DWORD PTR [esi+400]
	mov	DWORD PTR __Tmp$451804[esp+32], esi
	mov	DWORD PTR __Tmp$451804[esp+36], ebx
	test	esi, esi
	jne	SHORT $LN342@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN51@getNextCom:
	imul	edi, 424				; 000001a8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN41@getNextCom
	test	esi, esi
	je	SHORT $LN56@getNextCom
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN57@getNextCom
$LN342@getNextCom:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN51@getNextCom
$LN56@getNextCom:
	xor	esi, esi
$LN57@getNextCom:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN42@getNextCom
$LN41@getNextCom:
	call	__invalid_parameter_noinfo
$LN42@getNextCom:

; 1433 : 
; 1434 : 		if (rank[useThisCommand->getAddress().getRank()].bank[useThisCommand->getAddress().getBank()].front() != useThisCommand)

	mov	eax, DWORD PTR _useThisCommand$[ebp]
	mov	esi, DWORD PTR [eax+60]
	mov	ebx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	sub	ecx, DWORD PTR [eax+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN68@getNextCom
	call	__invalid_parameter_noinfo
$LN68@getNextCom:
	mov	ecx, DWORD PTR _this$[ebp]
	imul	esi, 424				; 000001a8H
	mov	edx, DWORD PTR [ecx+412]
	mov	ecx, DWORD PTR [esi+edx+416]
	sub	ecx, DWORD PTR [esi+edx+412]
	lea	esi, DWORD PTR [esi+edx+400]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN73@getNextCom
	call	__invalid_parameter_noinfo
$LN73@getNextCom:
	mov	ecx, DWORD PTR [esi+12]
	imul	ebx, 168				; 000000a8H
	mov	edx, DWORD PTR [ebx+ecx+40]
	sub	edx, DWORD PTR [ebx+ecx+36]
	lea	eax, DWORD PTR [ebx+ecx+12]
	sar	edx, 2
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN82@getNextCom
	call	__invalid_parameter_noinfo
$LN82@getNextCom:

; 1435 : 			assert(rank[useThisCommand->getAddress().getRank()].bank[useThisCommand->getAddress().getBank()].front() == useThisCommand);
; 1436 : 
; 1437 : 		// if it was a refresh all command, then dequeue all n banks worth of commands
; 1438 : 		if (useThisCommand->isRefresh())

	mov	eax, DWORD PTR _useThisCommand$[ebp]
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	jne	$LN9@getNextCom

; 1439 : 		{		
; 1440 : 			if (!currentRank->refreshAllReady())

	mov	eax, DWORD PTR __Tmp$451804[esp+32]
	test	eax, eax
	jne	$LN341@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN102@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN93@getNextCom
	call	__invalid_parameter_noinfo
$LN93@getNextCom:
	push	edi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady

; 1441 : 				assert(currentRank->refreshAllReady());
; 1442 : 
; 1443 : 			vector<Bank>::iterator bankEnd = currentRank->bank.end();

	mov	ebx, DWORD PTR __Tmp$451804[esp+32]
	test	ebx, ebx
	jne	$LN340@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN118@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN109@getNextCom
	call	__invalid_parameter_noinfo
$LN109@getNextCom:
	mov	esi, DWORD PTR [edi+416]
	mov	DWORD PTR $T452046[esp+32], esi
	cmp	DWORD PTR [edi+412], esi
	jbe	SHORT $LN126@getNextCom
	call	__invalid_parameter_noinfo
$LN126@getNextCom:
	mov	eax, DWORD PTR [edi+400]
	mov	DWORD PTR _bankEnd$223093[esp+32], eax

; 1444 : 
; 1445 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin();

	test	ebx, ebx
	jne	$LN339@getNextCom
	call	__invalid_parameter_noinfo
$LN150@getNextCom:
	cmp	edi, DWORD PTR [ebx+16]
	jb	SHORT $LN141@getNextCom
	call	__invalid_parameter_noinfo
$LN141@getNextCom:
	mov	ebx, DWORD PTR [edi+412]
	cmp	ebx, DWORD PTR [edi+416]
	jbe	SHORT $LN158@getNextCom
	call	__invalid_parameter_noinfo
$LN158@getNextCom:
	mov	edi, DWORD PTR [edi+400]
	npad	3

; 1446 : 
; 1447 : 			assert(currentBank->front() == useThisCommand);
; 1448 : 
; 1449 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1450 : 
; 1451 : 			for (;currentBank != bankEnd;currentBank++)

$LL175@getNextCom:
	test	edi, edi
	je	SHORT $LN187@getNextCom
	cmp	edi, DWORD PTR _bankEnd$223093[esp+32]
	je	SHORT $LN188@getNextCom
$LN187@getNextCom:
	call	__invalid_parameter_noinfo
$LN188@getNextCom:
	cmp	ebx, esi
	je	$LN5@getNextCom

; 1452 : 			{				
; 1453 : 				assert(currentBank->front() != NULL);
; 1454 : 				if (!currentBank->front()->isRefresh())

	test	edi, edi
	jne	SHORT $LN338@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN208@getNextCom:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN199@getNextCom
	call	__invalid_parameter_noinfo
$LN199@getNextCom:
	mov	ecx, DWORD PTR [ebx+40]
	sub	ecx, DWORD PTR [ebx+36]
	sar	ecx, 2
	cmp	DWORD PTR [ebx+16], ecx
	jb	SHORT $LN215@getNextCom
	call	__invalid_parameter_noinfo
$LN215@getNextCom:

; 1455 : 					assert(currentBank->front()->isRefresh());
; 1456 : 
; 1457 : 				currentBank->pop();

	test	edi, edi
	jne	SHORT $LN337@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN235@getNextCom:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN226@getNextCom
	call	__invalid_parameter_noinfo
$LN226@getNextCom:
	lea	esi, DWORD PTR [ebx+12]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	test	edi, edi
	jne	SHORT $LN336@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN182@getNextCom:

; 1446 : 
; 1447 : 			assert(currentBank->front() == useThisCommand);
; 1448 : 
; 1449 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1450 : 
; 1451 : 			for (;currentBank != bankEnd;currentBank++)

	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN173@getNextCom
	call	__invalid_parameter_noinfo
$LN173@getNextCom:
	mov	esi, DWORD PTR $T452046[esp+32]
	add	ebx, 168				; 000000a8H
	jmp	SHORT $LL175@getNextCom
$LN341@getNextCom:

; 1439 : 		{		
; 1440 : 			if (!currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN102@getNextCom
$LN340@getNextCom:

; 1441 : 				assert(currentRank->refreshAllReady());
; 1442 : 
; 1443 : 			vector<Bank>::iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebx]
	jmp	$LN118@getNextCom
$LN339@getNextCom:

; 1444 : 
; 1445 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin();

	mov	ebx, DWORD PTR [ebx]
	jmp	$LN150@getNextCom
$LN338@getNextCom:

; 1452 : 			{				
; 1453 : 				assert(currentBank->front() != NULL);
; 1454 : 				if (!currentBank->front()->isRefresh())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN208@getNextCom
$LN337@getNextCom:

; 1455 : 					assert(currentBank->front()->isRefresh());
; 1456 : 
; 1457 : 				currentBank->pop();

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN235@getNextCom
$LN336@getNextCom:

; 1446 : 
; 1447 : 			assert(currentBank->front() == useThisCommand);
; 1448 : 
; 1449 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1450 : 
; 1451 : 			for (;currentBank != bankEnd;currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN182@getNextCom
$LN5@getNextCom:

; 1458 : 			}
; 1459 : 
; 1460 : 			return const_cast<Command*>(useThisCommand);

	mov	eax, DWORD PTR _useThisCommand$[ebp]

; 1488 : 		}
; 1489 : 	}
; 1490 : 	else
; 1491 : 	{
; 1492 : 		return NULL;
; 1493 : 	}
; 1494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN9@getNextCom:

; 1461 : 		}
; 1462 : 		else
; 1463 : 		{			
; 1464 : 			assert((useThisCommand->isPrecharge() && systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE) ||
; 1465 : 				(currentRank->bank[useThisCommand->getAddress().getBank()].front() == useThisCommand));
; 1466 : 
; 1467 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin() + useThisCommand->getAddress().getBank();

	mov	ebx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR __Tmp$451804[esp+32]
	test	eax, eax
	jne	$LN335@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN257@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN248@getNextCom
	call	__invalid_parameter_noinfo
$LN248@getNextCom:
	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN265@getNextCom
	call	__invalid_parameter_noinfo
$LN265@getNextCom:
	mov	edx, DWORD PTR [edi+400]
	lea	eax, DWORD PTR _currentBank$223116[esp+32]
	push	eax
	mov	ecx, ebx
	lea	eax, DWORD PTR $T451632[esp+36]
	mov	DWORD PTR $T451632[esp+36], edx
	mov	DWORD PTR $T451632[esp+40], esi
	call	??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+

; 1468 : 
; 1469 : 			assert(currentBank->front() == useThisCommand);
; 1470 : 
; 1471 : 			Command *tempCommand = currentBank->pop();

	mov	eax, DWORD PTR _currentBank$223116[esp+32]
	test	eax, eax
	jne	$LN334@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN289@getNextCom:
	mov	esi, DWORD PTR _currentBank$223116[esp+36]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN280@getNextCom
	call	__invalid_parameter_noinfo
$LN280@getNextCom:
	add	esi, 12					; 0000000cH
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop

; 1472 : 
; 1473 : 			assert(tempCommand && tempCommand == useThisCommand);
; 1474 : 
; 1475 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1476 : 				useThisCommand->isReadOrWrite() &&
; 1477 : 				!currentBank->isEmpty() && 
; 1478 : 				currentBank->isHighUtilization() &&
; 1479 : 				currentBank->front()->isBasicPrecharge())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	cmp	DWORD PTR [edx+328], 2
	mov	edi, eax
	jne	$LN15@getNextCom
	mov	eax, DWORD PTR _useThisCommand$[ebp]
	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN298@getNextCom
	cmp	eax, 2
	je	SHORT $LN298@getNextCom
	cmp	eax, 3
	je	SHORT $LN298@getNextCom
	cmp	eax, 4
	jne	$LN15@getNextCom
$LN298@getNextCom:
	lea	esi, DWORD PTR _currentBank$223116[esp+32]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN15@getNextCom
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	sar	ecx, 2
	shr	ecx, 1
	cmp	DWORD PTR [eax+12], ecx
	jbe	SHORT $LN15@getNextCom
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	DWORD PTR [eax+80], 6
	jne	SHORT $LN15@getNextCom

; 1480 : 			{
; 1481 : 				assert(!tempCommand->isPrecharge());
; 1482 : 				tempCommand->setAutoPrecharge(true);

	mov	eax, DWORD PTR [edi+80]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 3
	ja	SHORT $LN323@getNextCom
	jmp	DWORD PTR $LN347@getNextCom[ecx*4]
$LN335@getNextCom:

; 1461 : 		}
; 1462 : 		else
; 1463 : 		{			
; 1464 : 			assert((useThisCommand->isPrecharge() && systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE) ||
; 1465 : 				(currentRank->bank[useThisCommand->getAddress().getBank()].front() == useThisCommand));
; 1466 : 
; 1467 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin() + useThisCommand->getAddress().getBank();

	mov	eax, DWORD PTR [eax]
	jmp	$LN257@getNextCom
$LN334@getNextCom:

; 1468 : 
; 1469 : 			assert(currentBank->front() == useThisCommand);
; 1470 : 
; 1471 : 			Command *tempCommand = currentBank->pop();

	mov	eax, DWORD PTR [eax]
	jmp	$LN289@getNextCom

; 1480 : 			{
; 1481 : 				assert(!tempCommand->isPrecharge());
; 1482 : 				tempCommand->setAutoPrecharge(true);

$LN324@getNextCom:
	xor	edx, edx
	cmp	eax, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [edi+80], edx
$LN323@getNextCom:

; 1483 : 				assert(currentBank->front()->isBasicPrecharge());
; 1484 : 				delete currentBank->pop();

	lea	esi, DWORD PTR _currentBank$223116[esp+32]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	lea	esi, DWORD PTR [eax+12]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	test	eax, eax
	je	SHORT $LN15@getNextCom
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN15@getNextCom:

; 1485 : 			}
; 1486 : 
; 1487 : 			return tempCommand;

	mov	eax, edi

; 1488 : 		}
; 1489 : 	}
; 1490 : 	else
; 1491 : 	{
; 1492 : 		return NULL;
; 1493 : 	}
; 1494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN11@getNextCom:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN347@getNextCom:
	DD	$LN324@getNextCom
	DD	$LN323@getNextCom
	DD	$LN324@getNextCom
	DD	$LN323@getNextCom
?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ENDP ; DRAMsimII::Channel::getNextCommand
_TEXT	ENDS
PUBLIC	?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z ; DRAMsimII::Channel::setReadWriteType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_readCount$ = -20					; size = 4
$T452781 = -16						; size = 4
$T452839 = -12						; size = 4
_bankEnd$ = -8						; size = 8
_writeCount$ = 8					; size = 4
_rankID$ = 8						; size = 4
?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z PROC ; DRAMsimII::Channel::setReadWriteType
; _this$ = eax

; 470  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _rankID$[esp+24]
	push	esi
	mov	esi, eax

; 471  : 	unsigned readCount = 0;
; 472  : 	unsigned writeCount = 0;
; 473  : 	unsigned emptyCount = 0;
; 474  : 
; 475  : 	vector<Bank>::const_iterator currentBank = rank[rankID].bank.begin();

	mov	ecx, DWORD PTR [esi+416]
	sub	ecx, DWORD PTR [esi+412]
	xor	eax, eax
	mov	DWORD PTR _readCount$[esp+32], eax
	mov	DWORD PTR _writeCount$[esp+28], eax
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	edi
	cmp	ebp, eax
	jb	SHORT $LN13@setReadWri
	call	__invalid_parameter_noinfo
$LN13@setReadWri:
	mov	ecx, DWORD PTR [esi+412]
	mov	ebx, ebp
	imul	ebx, 424				; 000001a8H
	mov	eax, DWORD PTR [ecx+ebx+412]
	lea	edi, DWORD PTR [ecx+ebx+400]
	mov	DWORD PTR $T452781[esp+36], eax
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN21@setReadWri
	call	__invalid_parameter_noinfo
$LN21@setReadWri:

; 476  : 	vector<Bank>::const_iterator bankEnd = rank[rankID].bank.end();

	mov	ecx, DWORD PTR [esi+416]
	sub	ecx, DWORD PTR [esi+412]
	mov	edi, DWORD PTR [edi]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN32@setReadWri
	call	__invalid_parameter_noinfo
$LN32@setReadWri:
	mov	ecx, DWORD PTR [esi+412]
	mov	eax, DWORD PTR [ebx+ecx+416]
	lea	esi, DWORD PTR [ebx+ecx+400]
	mov	DWORD PTR $T452839[esp+36], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN40@setReadWri
	call	__invalid_parameter_noinfo
$LN40@setReadWri:
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR $T452781[esp+36]
	mov	DWORD PTR _bankEnd$[esp+36], edx
	add	ebx, 36					; 00000024H
	npad	2

; 477  : 
; 478  : 	for(; currentBank != bankEnd; currentBank++)

$LL55@setReadWri:
	test	edi, edi
	je	SHORT $LN67@setReadWri
	cmp	edi, DWORD PTR _bankEnd$[esp+36]
	je	SHORT $LN68@setReadWri
$LN67@setReadWri:
	call	__invalid_parameter_noinfo
$LN68@setReadWri:
	lea	ebp, DWORD PTR [ebx-36]
	cmp	ebp, DWORD PTR $T452839[esp+36]
	je	$LN8@setReadWri

; 479  : 	{
; 480  : 		if (const Command *currentCommand = currentBank->front())

	test	edi, edi
	jne	SHORT $LN137@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN86@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN77@setReadWri
	call	__invalid_parameter_noinfo
$LN77@setReadWri:
	mov	eax, DWORD PTR [ebx+4]
	sub	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx-20]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN93@setReadWri
	call	__invalid_parameter_noinfo
$LN93@setReadWri:
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN9@setReadWri

; 481  : 		{
; 482  : 			if (currentCommand->isActivate())

	mov	ecx, DWORD PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN100@setReadWri
	cmp	ecx, 8
	jne	SHORT $LN140@setReadWri
$LN100@setReadWri:

; 483  : 			{
; 484  : 				currentCommand = currentBank->read(1);

	test	edi, edi
	jne	SHORT $LN136@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN113@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN104@setReadWri
	call	__invalid_parameter_noinfo
$LN104@setReadWri:
	cmp	DWORD PTR [ebx-24], 1
	jle	SHORT $LN119@setReadWri
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx-20]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN125@setReadWri
	call	__invalid_parameter_noinfo
$LN125@setReadWri:
	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN118@setReadWri
$LN137@setReadWri:

; 479  : 	{
; 480  : 		if (const Command *currentCommand = currentBank->front())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN86@setReadWri
$LN136@setReadWri:

; 483  : 			{
; 484  : 				currentCommand = currentBank->read(1);

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN113@setReadWri
$LN119@setReadWri:
	xor	esi, esi
$LN118@setReadWri:
	mov	eax, esi
$LN140@setReadWri:

; 485  : 				assert(currentCommand && currentCommand->isReadOrWrite());
; 486  : 			}
; 487  : 
; 488  : 			if (currentCommand->isRead())

	mov	eax, DWORD PTR [eax+80]
	mov	ecx, 1
	cmp	eax, ecx
	je	SHORT $LN132@setReadWri
	cmp	eax, 2
	jne	SHORT $LN5@setReadWri
$LN132@setReadWri:

; 489  : 			{
; 490  : 				readCount++;

	add	DWORD PTR _readCount$[esp+36], ecx

; 491  : 			}
; 492  : 			else

	jmp	SHORT $LN9@setReadWri
$LN5@setReadWri:

; 493  : 			{
; 494  : 				writeCount++;

	add	DWORD PTR _writeCount$[esp+32], ecx
$LN9@setReadWri:

; 477  : 
; 478  : 	for(; currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	SHORT $LN135@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN62@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN53@setReadWri
	call	__invalid_parameter_noinfo
$LN53@setReadWri:
	add	ebx, 168				; 000000a8H
	jmp	$LL55@setReadWri
$LN135@setReadWri:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN62@setReadWri
$LN8@setReadWri:

; 495  : 			}
; 496  : 		}
; 497  : 		else
; 498  : 		{
; 499  : 			emptyCount++;
; 500  : 		}
; 501  : 	}
; 502  : 
; 503  : 	DEBUG_LOG("Rank[" << rankID << "] Read[" << readCount << "] Write[" << writeCount << "] Empty[" << emptyCount << "]");
; 504  : 
; 505  : 	if (readCount >= writeCount)

	mov	eax, DWORD PTR _writeCount$[esp+32]
	cmp	DWORD PTR _readCount$[esp+36], eax
	pop	edi
	pop	esi
	sbb	eax, eax
	pop	ebp
	add	eax, 2
	pop	ebx

; 506  : 		return Transaction::READ_TRANSACTION;
; 507  : 	else
; 508  : 		return Transaction::WRITE_TRANSACTION;
; 509  : }

	add	esp, 20					; 00000014H
	ret	4
?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z ENDP ; DRAMsimII::Channel::setReadWriteType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gthread_data_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_data_base@detail@boost@@UAEPAXI@Z PROC	; boost::detail::thread_data_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	je	SHORT $LN8@scalar@70
	cmp	eax, -1
	je	SHORT $LN8@scalar@70
	push	eax
	call	edi
$LN8@scalar@70:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@scalar@70
	cmp	eax, -1
	je	SHORT $LN13@scalar@70
	push	eax
	call	edi
$LN13@scalar@70:
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN16@scalar@70
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN16@scalar@70:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_data_base@detail@boost@@UAEPAXI@Z ENDP	; boost::detail::thread_data_base::`scalar deleting destructor'
PUBLIC	??8Channel@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Channel::operator==
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??8Channel@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Channel::operator==

; 3105 : {

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]

; 3106 : 	return (time == rhs.time && lastCommandIssueTime == rhs.lastCommandIssueTime && 
; 3107 : 		timingSpecification == rhs.timingSpecification && transactionQueue == rhs.transactionQueue && 
; 3108 : 		((lastCommand == NULL && rhs.lastCommand == NULL) || (*lastCommand == *(rhs.lastCommand)) )
; 3109 : 		&& systemConfig == rhs.systemConfig && 
; 3110 : 		statistics == rhs.statistics && powerModel == rhs.powerModel && channelID == rhs.channelID 
; 3111 : 		&& rank == rhs.rank && refreshCounter == rhs.refreshCounter);

	mov	eax, DWORD PTR [ebp+8]
	push	esi
	push	edi
	cmp	eax, DWORD PTR [ebx+8]
	jne	$LN7@operator@360
	mov	ecx, DWORD PTR [ebp+12]
	cmp	ecx, DWORD PTR [ebx+12]
	jne	$LN7@operator@360
	mov	edx, DWORD PTR [ebp+16]
	cmp	edx, DWORD PTR [ebx+16]
	jne	$LN7@operator@360
	mov	eax, DWORD PTR [ebp+20]
	cmp	eax, DWORD PTR [ebx+20]
	jne	$LN7@operator@360
	lea	eax, DWORD PTR [ebx+28]
	lea	ecx, DWORD PTR [ebp+28]
	call	??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::TimingSpecification::operator==
	test	al, al
	je	$LN7@operator@360
	lea	ecx, DWORD PTR [ebx+112]
	push	ecx
	lea	edx, DWORD PTR [ebp+112]
	push	edx
	call	??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
	test	al, al
	je	$LN7@operator@360
	mov	ecx, DWORD PTR [ebp+24]
	test	ecx, ecx
	jne	SHORT $LN4@operator@360
	cmp	DWORD PTR [ebx+24], ecx
	je	SHORT $LN5@operator@360
$LN4@operator@360:
	mov	eax, DWORD PTR [ebx+24]
	call	??8Command@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Command::operator==
	test	al, al
	je	$LN7@operator@360
$LN5@operator@360:
	mov	eax, DWORD PTR [ebx+176]
	mov	ecx, DWORD PTR [ebp+176]
	call	??8SystemConfiguration@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::SystemConfiguration::operator==
	test	al, al
	je	SHORT $LN7@operator@360
	mov	eax, DWORD PTR [ebp+180]
	mov	edi, DWORD PTR [ebx+180]
	push	eax
	call	??8Statistics@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Statistics::operator==
	test	al, al
	je	SHORT $LN7@operator@360
	lea	esi, DWORD PTR [ebx+184]
	lea	edi, DWORD PTR [ebp+184]
	call	??8PowerConfig@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::PowerConfig::operator==
	test	al, al
	je	SHORT $LN7@operator@360
	mov	ecx, DWORD PTR [ebp+392]
	cmp	ecx, DWORD PTR [ebx+392]
	jne	SHORT $LN7@operator@360
	lea	edx, DWORD PTR [ebx+400]
	push	edx
	lea	esi, DWORD PTR [ebp+400]
	call	??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	add	esp, 4
	test	al, al
	je	SHORT $LN7@operator@360
	add	ebx, 152				; 00000098H
	push	ebx
	lea	esi, DWORD PTR [ebp+152]
	call	??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ; std::operator==<__int64,std::allocator<__int64> >
	add	esp, 4
	test	al, al
	je	SHORT $LN7@operator@360
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 3112 : }

	ret	8
$LN7@operator@360:
	pop	edi
	pop	esi
	pop	ebp

; 3106 : 	return (time == rhs.time && lastCommandIssueTime == rhs.lastCommandIssueTime && 
; 3107 : 		timingSpecification == rhs.timingSpecification && transactionQueue == rhs.transactionQueue && 
; 3108 : 		((lastCommand == NULL && rhs.lastCommand == NULL) || (*lastCommand == *(rhs.lastCommand)) )
; 3109 : 		&& systemConfig == rhs.systemConfig && 
; 3110 : 		statistics == rhs.statistics && powerModel == rhs.powerModel && channelID == rhs.channelID 
; 3111 : 		&& rank == rhs.rank && refreshCounter == rhs.refreshCounter);

	xor	eax, eax
	pop	ebx

; 3112 : }

	ret	8
??8Channel@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Channel::operator==
_TEXT	ENDS
PUBLIC	?resetToTime@Channel@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Channel::resetToTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_time$ = 12						; size = 8
?resetToTime@Channel@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Channel::resetToTime

; 967  : 	lastCommandIssueTime = time - timingSpecification.tCMD();

	mov	ecx, DWORD PTR _time$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [ebx+44]
	push	ebp
	push	esi
	cdq
	mov	esi, ecx
	sub	esi, eax
	mov	eax, DWORD PTR _time$[esp+12]
	push	edi
	mov	edi, eax
	sbb	edi, edx
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+20], edi

; 968  : 	this->time = time;

	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [ebx+12], eax

; 969  : 	powerModel.resetToTime(time);

	mov	DWORD PTR [ebx+384], ecx
	mov	DWORD PTR [ebx+388], eax

; 970  : 	// adjust the start time of the refreshes to match the new time
; 971  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	mov	esi, DWORD PTR [ebx+164]
	cmp	esi, DWORD PTR [ebx+168]
	jbe	SHORT $LN18@resetToTim@3
	call	__invalid_parameter_noinfo
$LN18@resetToTim@3:
	mov	edi, DWORD PTR [ebx+152]
	npad	3
$LL35@resetToTim@3:
	mov	ebp, DWORD PTR [ebx+168]
	cmp	DWORD PTR [ebx+164], ebp
	jbe	SHORT $LN50@resetToTim@3
	call	__invalid_parameter_noinfo
$LN50@resetToTim@3:
	mov	eax, DWORD PTR [ebx+152]
	test	edi, edi
	je	SHORT $LN63@resetToTim@3
	cmp	edi, eax
	je	SHORT $LN64@resetToTim@3
$LN63@resetToTim@3:
	call	__invalid_parameter_noinfo
$LN64@resetToTim@3:
	cmp	esi, ebp
	je	SHORT $LN4@resetToTim@3

; 972  : 	{
; 973  : 		*i = *i + time;

	test	edi, edi
	jne	SHORT $LN179@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN82@resetToTim@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN73@resetToTim@3
	call	__invalid_parameter_noinfo
$LN73@resetToTim@3:
	test	edi, edi
	jne	SHORT $LN178@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN96@resetToTim@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN87@resetToTim@3
	call	__invalid_parameter_noinfo
$LN87@resetToTim@3:
	mov	eax, DWORD PTR _time$[esp+12]
	add	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _time$[esp+16]
	adc	DWORD PTR [esi+4], ecx
	test	edi, edi
	jne	SHORT $LN177@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN42@resetToTim@3:

; 970  : 	// adjust the start time of the refreshes to match the new time
; 971  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN33@resetToTim@3
	call	__invalid_parameter_noinfo
$LN33@resetToTim@3:
	add	esi, 8
	jmp	SHORT $LL35@resetToTim@3
$LN179@resetToTim@3:

; 972  : 	{
; 973  : 		*i = *i + time;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN82@resetToTim@3
$LN178@resetToTim@3:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN96@resetToTim@3
$LN177@resetToTim@3:

; 970  : 	// adjust the start time of the refreshes to match the new time
; 971  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN42@resetToTim@3
$LN4@resetToTim@3:

; 974  : 	}
; 975  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+412]
	cmp	edi, DWORD PTR [ebx+416]
	jbe	SHORT $LN104@resetToTim@3
	call	__invalid_parameter_noinfo
$LN104@resetToTim@3:
	mov	esi, DWORD PTR [ebx+400]
$LL121@resetToTim@3:
	mov	ebp, DWORD PTR [ebx+416]
	cmp	DWORD PTR [ebx+412], ebp
	jbe	SHORT $LN136@resetToTim@3
	call	__invalid_parameter_noinfo
$LN136@resetToTim@3:
	mov	eax, DWORD PTR [ebx+400]
	test	esi, esi
	je	SHORT $LN149@resetToTim@3
	cmp	esi, eax
	je	SHORT $LN150@resetToTim@3
$LN149@resetToTim@3:
	call	__invalid_parameter_noinfo
$LN150@resetToTim@3:
	cmp	edi, ebp
	je	SHORT $LN1@resetToTim@3

; 976  : 	{
; 977  : 		i->resetToTime(time);

	test	esi, esi
	jne	SHORT $LN176@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN170@resetToTim@3:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN161@resetToTim@3
	call	__invalid_parameter_noinfo
$LN161@resetToTim@3:
	mov	edx, DWORD PTR _time$[esp+16]
	mov	eax, DWORD PTR _time$[esp+12]
	push	edx
	push	eax
	call	?resetToTime@Rank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Rank::resetToTime
	test	esi, esi
	jne	SHORT $LN175@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN128@resetToTim@3:

; 974  : 	}
; 975  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN119@resetToTim@3
	call	__invalid_parameter_noinfo
$LN119@resetToTim@3:
	add	edi, 424				; 000001a8H
	jmp	SHORT $LL121@resetToTim@3
$LN176@resetToTim@3:

; 976  : 	{
; 977  : 		i->resetToTime(time);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN170@resetToTim@3
$LN175@resetToTim@3:

; 974  : 	}
; 975  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN128@resetToTim@3
$LN1@resetToTim@3:

; 978  : 	}
; 979  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
?resetToTime@Channel@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Channel::resetToTime
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T565890 = -80						; size = 28
$T565889 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T565890[esp+92]
	mov	DWORD PTR $T565890[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T565890[esp+112], 0
	mov	BYTE PTR $T565890[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T565890[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T565889[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T565889[esp+88]
	push	ecx
	mov	DWORD PTR $T565889[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@19:
$LN44@Xlen@19:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T565890[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T566051 = -80						; size = 28
$T566050 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ PROC	; std::vector<double,std::allocator<double> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T566051[esp+92]
	mov	DWORD PTR $T566051[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T566051[esp+112], 0
	mov	BYTE PTR $T566051[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T566051[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T566050[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T566050[esp+88]
	push	ecx
	mov	DWORD PTR $T566050[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@20:
$LN44@Xlen@20:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T566051[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ENDP	; std::vector<double,std::allocator<double> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
_TEXT	SEGMENT
__Tmp$231365 = -12					; size = 8
__Tmp$231355 = -12					; size = 8
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z PROC ; std::vector<double,std::allocator<double> >::_Insert_n, COMDAT

; 1153 : 		{	// insert _Count * _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+12]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	test	ecx, ecx
	jne	SHORT $LN29@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN205@Insert_n
$LN29@Insert_n:
	mov	ebp, DWORD PTR [ebx+20]
	sub	ebp, ecx
	sar	ebp, 3
$LN205@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)
; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	esi, DWORD PTR [ebx+16]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	mov	ecx, 536870911				; 1fffffffH
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN208@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ebp, eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, ebp
	shr	ecx, 1
	mov	edx, 536870911				; 1fffffffH
	sub	edx, ecx
	cmp	edx, ebp
	jae	SHORT $LN17@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ebp, ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebp, eax

; 1172 : 				_Capacity = size() + _Count;

	cmovb	ebp, eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, ebp
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	esi, DWORD PTR __Where$[esp+28]
	sub	esi, DWORD PTR [ebx+12]
	mov	edi, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+24]
	fld	QWORD PTR [eax]
	sar	esi, 3
	fstp	QWORD PTR [edi+esi*8]

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN102@Insert_n
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+44]
	add	esp, 16					; 00000010H
$LN102@Insert_n:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN133@Insert_n
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	lea	ecx, DWORD PTR [edi+esi*8+8]
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN133@Insert_n:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+16]
	sub	esi, eax
	sar	esi, 3
	inc	esi

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN140@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN140@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	lea	edx, DWORD PTR [edi+ebp*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [ebx+20], edx
	mov	DWORD PTR [ebx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+28]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3
	cmp	ecx, 1
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+24]
	movsd	xmm0, QWORD PTR [edx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	edx, DWORD PTR [edi+8]
	mov	eax, esi
	movsd	QWORD PTR __Tmp$231355[esp+28], xmm0
	call	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	esi, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR __Where$[esp+28]
	movsd	xmm0, QWORD PTR __Tmp$231355[esp+28]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 3
	mov	eax, 1
	sub	eax, edx
	je	SHORT $LN162@Insert_n
	lea	ecx, DWORD PTR [eax*8-5]
	shr	ecx, 2
	movsd	QWORD PTR [esi], xmm0
	lea	edi, DWORD PTR [esi+8]
	rep movsd
	mov	ecx, DWORD PTR __Where$[esp+28]
$LN162@Insert_n:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [ebx+16], 8
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR [ebx-8]
	mov	eax, ecx
	cmp	ecx, edx
	je	SHORT $LN190@Insert_n
$LL177@Insert_n:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL177@Insert_n

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+24]
	movsd	xmm0, QWORD PTR [eax]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [esi-8]
	mov	edx, esi
	mov	eax, esi
	movsd	QWORD PTR __Tmp$231365[esp+28], xmm0
	call	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+28]
	mov	ecx, esi
	call	??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ; stdext::_Unchecked_move_backward<double *,double *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR [eax+8]
	cmp	eax, ecx
	je	SHORT $LN190@Insert_n
	movsd	xmm0, QWORD PTR __Tmp$231365[esp+28]
$LL192@Insert_n:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL192@Insert_n
$LN190@Insert_n:

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN207@Insert_n:
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Insert_n
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T567130 = -84						; size = 28
$T567129 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T567130[esp+100]
	mov	DWORD PTR $T567130[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T567130[esp+120], 0
	mov	BYTE PTR $T567130[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T567130[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T567129[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T567129[esp+96]
	push	ecx
	mov	DWORD PTR $T567129[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@21:
$LN44@Xlen@21:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T567130[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T567290 = -84						; size = 28
$T567289 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T567290[esp+100]
	mov	DWORD PTR $T567290[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T567290[esp+120], 0
	mov	BYTE PTR $T567290[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T567290[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T567289[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T567289[esp+96]
	push	ecx
	mov	DWORD PTR $T567289[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@22:
$LN44@Xlen@22:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T567290[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Newvec$230902 = -4					; size = 4
__Tmp$230927 = 8					; size = 4
__Tmp$230917 = 8					; size = 4
__Capacity$ = 8						; size = 4
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; __Val$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	mov	esi, eax
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN121@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [ebx+20]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN121@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)
; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebp, DWORD PTR [ebx+16]
	mov	eax, ebp
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, 1
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN125@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ecx, eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, edx
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+16], 0
	mov	ecx, DWORD PTR __Capacity$[esp+16]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[esp+16], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+16], eax
	mov	ecx, eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebp, DWORD PTR __Where$[esp+20]
	sub	ebp, DWORD PTR [ebx+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, esi
	sar	ebp, 2
	lea	edi, DWORD PTR [eax+ebp*4]
	mov	esi, 1
	mov	DWORD PTR __Newvec$230902[esp+20], eax
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __Newvec$230902[esp+20]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN79@Insert_n@2
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN79@Insert_n@2:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN110@Insert_n@2
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	lea	eax, DWORD PTR [edi+ebp*4+4]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN110@Insert_n@2:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+16]
	sub	esi, eax
	sar	esi, 2
	inc	esi

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[esp+16]
	lea	edx, DWORD PTR [edi+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	eax, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [ebx+20], edx
	mov	DWORD PTR [ebx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+20]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [esi]
	mov	ecx, ebp
	sub	ecx, edi
	sar	ecx, 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, ebp
	mov	DWORD PTR __Tmp$230917[esp+16], edx
	cmp	ecx, 1
	jae	SHORT $LN3@Insert_n@2
	lea	edx, DWORD PTR [edi+4]
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	eax, edi
	sub	eax, DWORD PTR __Where$[esp+20]
	mov	esi, 1
	sar	eax, 2
	sub	esi, eax
	lea	edx, DWORD PTR __Tmp$230917[esp+16]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [ebx+16], 4
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR __Tmp$230917[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [ebx-4]

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 4

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [ebp-4]
	mov	edx, ebp
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+20]
	mov	ecx, ebp
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$230927[esp+16]
	push	eax
	mov	eax, DWORD PTR __Where$[esp+24]
	lea	ecx, DWORD PTR [eax+4]
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 4

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN123@Insert_n@2:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myboff$ = -8						; size = 4
__Newmap$ = -4						; size = 4
__Count$ = 8						; size = 4
_this$ = 8						; size = 4
?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap, COMDAT

; 1225 : 		{	// grow map by _Count pointers

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+20]
	push	ebp
	mov	ecx, 268435455				; 0fffffffH
	mov	edx, 1
	sub	ecx, eax
	push	esi
	push	edi

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	DWORD PTR __Count$[esp+20], edx
	cmp	ecx, edx
	jae	SHORT $LN6@Growmap

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
$LN157@Growmap:
$LN6@Growmap:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $LN5@Growmap

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	jmp	SHORT $LN152@Growmap
$LN5@Growmap:
	cmp	ecx, 1
	jbe	SHORT $LN4@Growmap
$LN152@Growmap:
	mov	esi, 268435455				; 0fffffffH
	sub	esi, ecx
	cmp	eax, esi
	ja	SHORT $LN4@Growmap

; 1233 : 			_Count = _Inc;

	mov	edx, ecx
	mov	DWORD PTR __Count$[esp+20], ecx
$LN4@Growmap:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	esi, DWORD PTR [ebx+24]

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR __Myboff$[esp+24], esi
	call	?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocate

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR __Newmap$[esp+24], eax
	add	esi, esi
	add	esi, esi
	lea	edi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ebx+20]
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [esi+ecx]
	sub	eax, edx
	add	eax, ecx
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN33@Growmap
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN33@Growmap:

; 1240 : 		if (_Myboff <= _Count)

	mov	edx, DWORD PTR __Myboff$[esp+24]
	mov	eax, DWORD PTR __Count$[esp+20]
	cmp	edx, eax
	ja	SHORT $LN3@Growmap

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	sar	esi, 2
	lea	ecx, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [ecx+ebp]
	test	esi, esi
	jbe	SHORT $LN48@Growmap
	push	ecx
	push	eax
	push	ecx
	push	ebp
	call	_memmove_s
	mov	edx, DWORD PTR __Myboff$[esp+40]
	add	esp, 16					; 00000010H
$LN48@Growmap:

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	ecx, DWORD PTR __Count$[esp+20]
	sub	ecx, edx
	je	SHORT $LN69@Growmap
	mov	edx, DWORD PTR __Myboff$[esp+24]
	xor	eax, eax
	rep stosd
$LN69@Growmap:

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	ebp, DWORD PTR __Newmap$[esp+24]
	test	edx, edx
	jbe	SHORT $LN141@Growmap
	mov	ecx, edx
	mov	edi, ebp

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN156@Growmap
$LN3@Growmap:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	ecx, DWORD PTR [ebx+16]
	lea	edi, DWORD PTR [eax*4]
	mov	eax, edi
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN105@Growmap
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN105@Growmap:

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	mov	ebp, DWORD PTR __Newmap$[esp+24]
	lea	ecx, DWORD PTR [edi+eax]
	sub	esi, ecx
	add	esi, eax
	sar	esi, 2
	lea	eax, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [eax+ebp]
	test	esi, esi
	jbe	SHORT $LN120@Growmap
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN120@Growmap:

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	ecx, DWORD PTR __Count$[esp+20]
	test	ecx, ecx
	jbe	SHORT $LN141@Growmap
$LN156@Growmap:
	xor	eax, eax
	rep stosd
$LN141@Growmap:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 1260 : 		if (_Map)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN144@Growmap

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN144@Growmap:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new
; 1264 : 		_Mapsize += _Count;

	mov	edx, DWORD PTR __Count$[esp+20]
	add	DWORD PTR [ebx+20], edx

; 1265 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+16], ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN155@Growmap:
?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T568626 = -80						; size = 28
$T568625 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T568626[esp+92]
	mov	DWORD PTR $T568626[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T568626[esp+112], 0
	mov	BYTE PTR $T568626[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T568626[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T568625[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T568625[esp+88]
	push	ecx
	mov	DWORD PTR $T568625[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@23:
$LN44@Xlen@23:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T568626[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T568787 = -80						; size = 28
$T568786 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ PROC	; std::vector<__int64,std::allocator<__int64> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T568787[esp+92]
	mov	DWORD PTR $T568787[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T568787[esp+112], 0
	mov	BYTE PTR $T568787[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T568787[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T568786[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T568786[esp+88]
	push	ecx
	mov	DWORD PTR $T568786[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@24:
$LN44@Xlen@24:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T568787[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ENDP	; std::vector<__int64,std::allocator<__int64> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T568948 = -84						; size = 28
$T568947 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T568948[esp+100]
	mov	DWORD PTR $T568948[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T568948[esp+120], 0
	mov	BYTE PTR $T568948[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T568948[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T568947[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T568947[esp+96]
	push	ecx
	mov	DWORD PTR $T568947[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@25:
$LN44@Xlen@25:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T568948[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z PROC	; std::vector<double,std::allocator<double> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@17

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN18@Buy@17:
$LN2@Buy@17:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN17@Buy@17:
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ENDP	; std::vector<double,std::allocator<double> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z
_TEXT	SEGMENT
__Tmp$569365 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z PROC ; std::vector<double,std::allocator<double> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -8					; fffffff8H
	jne	SHORT $LN3@insert@14
	xor	ebx, ebx
	jmp	SHORT $LN4@insert@14
$LN3@insert@14:
	cmp	edi, eax
	jbe	SHORT $LN12@insert@14
	call	__invalid_parameter_noinfo
$LN12@insert@14:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@insert@14
	cmp	ecx, eax
	je	SHORT $LN24@insert@14
$LN23@insert@14:
	call	__invalid_parameter_noinfo
$LN24@insert@14:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 3
$LN4@insert@14:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	mov	ecx, DWORD PTR __Val$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN36@insert@14
	call	__invalid_parameter_noinfo
$LN36@insert@14:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$569365[esp+32], edi
	test	esi, esi
	jne	SHORT $LN70@insert@14
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@insert@14:
	lea	edi, DWORD PTR [edi+ebx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN51@insert@14
	test	esi, esi
	je	SHORT $LN66@insert@14
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN67@insert@14
$LN70@insert@14:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN61@insert@14
$LN66@insert@14:
	xor	esi, esi
$LN67@insert@14:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN52@insert@14
$LN51@insert@14:
	call	__invalid_parameter_noinfo
$LN52@insert@14:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ENDP ; std::vector<double,std::allocator<double> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@18

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN2@Buy@18:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z PROC ; std::vector<float,std::allocator<float> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+4]

; 546  : 		if (_Buy(_Count))

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	test	edi, edi
	je	SHORT $LN5@Construct_@6
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@6
	call	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN50@Construct_@6:
$LN10@Construct_@6:
	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	test	edi, edi
	jbe	SHORT $LN40@Construct_@6
$LL42@Construct_@6:
	fld	DWORD PTR [ebx]
	dec	ecx
	fstp	DWORD PTR [edx]
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@6
$LN40@Construct_@6:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@6:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebx
	pop	ecx
	ret	4
$LN49@Construct_@6:
?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@19

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN2@Buy@19:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
__Tmp$569864 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@insert@15
	xor	ebx, ebx
	jmp	SHORT $LN4@insert@15
$LN3@insert@15:
	cmp	edi, eax
	jbe	SHORT $LN12@insert@15
	call	__invalid_parameter_noinfo
$LN12@insert@15:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@insert@15
	cmp	ecx, eax
	je	SHORT $LN24@insert@15
$LN23@insert@15:
	call	__invalid_parameter_noinfo
$LN24@insert@15:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 2
$LN4@insert@15:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Val$[esp+32]
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN36@insert@15
	call	__invalid_parameter_noinfo
$LN36@insert@15:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$569864[esp+32], edi
	test	esi, esi
	jne	SHORT $LN70@insert@15
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@insert@15:
	lea	edi, DWORD PTR [edi+ebx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN51@insert@15
	test	esi, esi
	je	SHORT $LN66@insert@15
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN67@insert@15
$LN70@insert@15:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN61@insert@15
$LN66@insert@15:
	xor	esi, esi
$LN67@insert@15:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN52@insert@15
$LN51@insert@15:
	call	__invalid_parameter_noinfo
$LN52@insert@15:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back, COMDAT
; _this$ = esi

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [esi+28]
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	inc	eax
	push	edi
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN3@push_back

; 851  : 			_Growmap(1);

	push	esi
	call	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
$LN3@push_back:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+28]

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	ja	SHORT $LN2@push_back

; 855  : 			_Block -= _Mapsize;

	sub	edi, eax
$LN2@push_back:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], 0
	jne	SHORT $LN1@push_back

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [esi+16]
	add	esp, 4
	mov	DWORD PTR [edx+edi*4], eax
$LN1@push_back:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [eax+edi*4]
	test	edi, edi
	je	SHORT $LN25@push_back
	movq	xmm0, QWORD PTR [ebx]
	movq	QWORD PTR [edi], xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	movq	QWORD PTR [edi+8], xmm0
$LN25@push_back:

; 859  : 		++_Mysize;

	inc	DWORD PTR [esi+28]

; 860  : 		}

	pop	edi
	pop	ebx
	ret	4
?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@20

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	pop	esi
	ret	0
$LN4@Buy@20:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 10129639				; 009a90e7H
	jbe	SHORT $LN2@Buy@20

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN14@Buy@20:
$LN2@Buy@20:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	imul	esi, 424				; 000001a8H
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	pop	esi
	ret	0
$LN13@Buy@20:
?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@21

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@21:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@21

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN14@Buy@21:
$LN2@Buy@21:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@21:
?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@7
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN10@Construct_@7
	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN50@Construct_@7:
$LN10@Construct_@7:
	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	lea	ecx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, edi
	mov	ecx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@7
	npad	3
$LL42@Construct_@7:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx+4], ebp
	dec	edx
	add	ecx, 8
	test	edx, edx
	ja	SHORT $LL42@Construct_@7
$LN40@Construct_@7:
	lea	edx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@7:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@7:
?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T570345 = -4						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 8
	push	ebx
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@4

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN97@reserve@4:
$LN5@reserve@4:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@4
	xor	eax, eax
	jmp	SHORT $LN21@reserve@4
$LN20@reserve@4:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@4:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@4

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@4
	call	__invalid_parameter_noinfo
$LN27@reserve@4:
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T570345[esp+16], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@4
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T570345[esp+16]
$LN43@reserve@4:
	sub	edi, ecx
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@4
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@4:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@4

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@4:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@4:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN96@reserve@4:
?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z
_TEXT	SEGMENT
$T570608 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z PROC ; std::vector<double,std::allocator<double> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@2:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	fld	QWORD PTR [ebx]
	add	esi, 8
	fstp	QWORD PTR [esi-8]
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN39@push_back@2
	call	__invalid_parameter_noinfo
$LN39@push_back@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	eax, DWORD PTR $T570608[esp+28]
	push	eax
	mov	eax, edi
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z ENDP ; std::vector<double,std::allocator<double> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@49
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@49
$LN19@vector@49:
	xor	eax, eax
$LN20@vector@49:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@49
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN46@vector@49
	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN110@vector@49:
$LN46@vector@49:
	mov	ecx, edi
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@49
	call	__invalid_parameter_noinfo
$LN60@vector@49:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@49
	call	__invalid_parameter_noinfo
$LN74@vector@49:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 3
	lea	eax, DWORD PTR [edi*8]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@49
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@49:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@49:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@49:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@50
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@50
$LN13@vector@50:
	xor	eax, eax
$LN14@vector@50:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<float,std::allocator<float> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	mov	esi, eax
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN1@operator@375

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@375

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN8@operator@375:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, edx
	sar	edi, 2
	cmp	eax, edi
	ja	SHORT $LN6@operator@375

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN32@operator@375
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	ebx
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@375:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 2
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN6@operator@375:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	xor	ebx, ebx
	cmp	edx, ebx
	jne	SHORT $LN41@operator@375
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@375
$LN41@operator@375:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 2
$LN42@operator@375:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@375

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR [ebp+12]
	lea	ebx, DWORD PTR [ecx+edi*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebx
	mov	edi, ecx
	call	??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z ; stdext::unchecked_copy<float *,float *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebp+16]
	mov	edi, ebx
	call	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@375:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	cmp	edx, ebx
	je	SHORT $LN45@operator@375

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@375:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebp+16]
	sub	edi, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], ebx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	cmp	edi, ebx
	je	SHORT $LN61@operator@375
	call	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
	test	al, al
	je	SHORT $LN61@operator@375

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	call	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
	mov	DWORD PTR [esi+16], eax
$LN61@operator@375:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
$LN1@operator@375:

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<float,std::allocator<float> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T571549 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@51
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@51
$LN13@vector@51:
	xor	eax, eax
$LN14@vector@51:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 483  : 		_Construct_n(_Count, _Ty());

	xorps	xmm0, xmm0
	lea	eax, DWORD PTR $T571549[esp+24]
	push	eax
	movss	DWORD PTR $T571549[esp+28], xmm0
	call	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@52
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@52
$LN13@vector@52:
	xor	eax, eax
$LN14@vector@52:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
$T571875 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN39@push_back@3
	call	__invalid_parameter_noinfo
$LN39@push_back@3:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	ecx, DWORD PTR $T571875[esp+28]
	push	ecx
	mov	eax, edi
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	mov	esi, eax
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN1@operator@376

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@376

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN8@operator@376:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, edx
	sar	edi, 2
	cmp	eax, edi
	ja	SHORT $LN6@operator@376

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN32@operator@376
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	ebx
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@376:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 2
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN6@operator@376:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	xor	ebx, ebx
	cmp	edx, ebx
	jne	SHORT $LN41@operator@376
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@376
$LN41@operator@376:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 2
$LN42@operator@376:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@376

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR [ebp+12]
	lea	ebx, DWORD PTR [ecx+edi*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebx
	mov	edi, ecx
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebp+16]
	mov	edi, ebx
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@376:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	cmp	edx, ebx
	je	SHORT $LN45@operator@376

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@376:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebp+16]
	sub	edi, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], ebx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	cmp	edi, ebx
	je	SHORT $LN61@operator@376
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	test	al, al
	je	SHORT $LN61@operator@376

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+16], eax
$LN61@operator@376:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
$LN1@operator@376:

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@53
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@53
$LN19@vector@53:
	xor	eax, eax
$LN20@vector@53:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@53
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN46@vector@53
	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN110@vector@53:
$LN46@vector@53:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@53
	call	__invalid_parameter_noinfo
$LN60@vector@53:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@53
	call	__invalid_parameter_noinfo
$LN74@vector@53:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 2
	lea	eax, DWORD PTR [edi*4]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@53
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@53:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@53:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@53:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@54
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@54
$LN13@vector@54:
	xor	eax, eax
$LN14@vector@54:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
;	COMDAT ?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push, COMDAT
; _this$ = esi
; __Val$ = eax

; 70   : 		{	// insert element at beginning

	push	ecx

; 71   : 		c.push_back(_Val);

	push	eax
	call	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
	pop	ecx

; 72   : 		}

	ret	0
?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	mov	ebx, DWORD PTR __Right$[esp]
	push	esi
	mov	esi, eax

; 564  : 		if (this != &_Right)

	cmp	esi, ebx
	je	$LN1@operator@377

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	test	eax, eax
	jne	SHORT $LN8@operator@377

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN8@operator@377:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	sub	ebp, edx
	sar	ebp, 3
	cmp	eax, ebp
	ja	SHORT $LN6@operator@377

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, edi
	sar	ecx, 3
	test	ecx, ecx
	jle	SHORT $LN32@operator@377
	lea	eax, DWORD PTR [ecx*8]
	push	eax
	push	edi
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@377:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 3
	pop	ebp
	lea	edx, DWORD PTR [ecx+eax*8]
	pop	edi
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN6@operator@377:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	edx, edx
	jne	SHORT $LN41@operator@377
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@377
$LN41@operator@377:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 3
$LN42@operator@377:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@377

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	lea	ebp, DWORD PTR [edi+ebp*8]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebp
	call	??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ; stdext::unchecked_copy<__int64 *,__int64 *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	edi, ebp
	call	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
	pop	ebp
	mov	DWORD PTR [esi+16], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN4@operator@377:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	edx, edx
	je	SHORT $LN45@operator@377

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@377:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	sar	edi, 3
	call	?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ; std::vector<__int64,std::allocator<__int64> >::_Buy
	test	al, al
	je	SHORT $LN49@operator@377

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+16]
	call	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
	mov	DWORD PTR [esi+16], eax
$LN49@operator@377:
	pop	ebp

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	edi
$LN1@operator@377:
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@55
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@55
$LN19@vector@55:
	xor	eax, eax
$LN20@vector@55:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@55
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN46@vector@55
	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN110@vector@55:
$LN46@vector@55:
	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@55
	call	__invalid_parameter_noinfo
$LN60@vector@55:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@55
	call	__invalid_parameter_noinfo
$LN74@vector@55:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 3
	lea	eax, DWORD PTR [edi*8]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@55
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@55:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@55:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@55:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T573308 = -24						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z PROC	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@56
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@56
$LN13@vector@56:
	xor	eax, eax
$LN14@vector@56:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T573308[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], ecx
	push	eax
	mov	DWORD PTR $T573308[esp+36], ecx
	mov	DWORD PTR $T573308[esp+40], ecx
	call	?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ENDP	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z ; DRAMsimII::Channel::getPendingTransactions
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_outputQueue$ = 12					; size = 4
?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z PROC ; DRAMsimII::Channel::getPendingTransactions

; 308  : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _outputQueue$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+8]

; 309  : 	while (finishedTransactions.size() > 0)

	cmp	DWORD PTR [ebp+452], 0
	push	esi
	push	edi
	jbe	$LN1@getPending
	npad	6
$LL2@getPending:

; 310  : 	{
; 311  : 		outputQueue.push(finishedTransactions.front());

	mov	edi, DWORD PTR [ebp+448]
	mov	eax, DWORD PTR [ebp+452]
	add	eax, edi
	cmp	edi, eax
	jbe	SHORT $LN18@getPending
	call	__invalid_parameter_noinfo
$LN18@getPending:
	mov	esi, DWORD PTR [ebp+424]
	test	esi, esi
	jne	SHORT $LN108@getPending
	call	__invalid_parameter_noinfo
	xor	eax, eax
	xor	ecx, ecx
$LN48@getPending:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	cmp	edi, ecx
	jb	SHORT $LN33@getPending
	call	__invalid_parameter_noinfo
$LN33@getPending:
	test	esi, esi
	je	SHORT $LN53@getPending
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN54@getPending
$LN108@getPending:
	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	jmp	SHORT $LN48@getPending
$LN53@getPending:
	xor	eax, eax
$LN54@getPending:
	cmp	DWORD PTR [eax+20], edi
	ja	SHORT $LN32@getPending
	test	esi, esi
	je	SHORT $LN59@getPending
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN60@getPending
$LN59@getPending:
	xor	eax, eax
$LN60@getPending:
	sub	edi, DWORD PTR [eax+20]
$LN32@getPending:
	test	esi, esi
	je	SHORT $LN65@getPending
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN66@getPending
$LN65@getPending:
	xor	esi, esi
$LN66@getPending:
	mov	eax, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [edx+edi*4]
	inc	eax
	cmp	DWORD PTR [ebx+20], eax
	ja	SHORT $LN73@getPending
	push	ebx
	call	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
$LN73@getPending:
	mov	esi, DWORD PTR [ebx+28]
	add	esi, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, esi
	ja	SHORT $LN72@getPending
	sub	esi, eax
$LN72@getPending:
	mov	ecx, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ecx+esi*4], 0
	jne	SHORT $LN71@getPending
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+16]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$LN71@getPending:
	mov	eax, DWORD PTR [ebx+16]
	mov	esi, DWORD PTR [eax+esi*4]
	xor	edx, edx
	cmp	esi, edx
	je	SHORT $LN91@getPending
	movq	xmm0, QWORD PTR [edi]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+8]
	movq	QWORD PTR [esi+8], xmm0
$LN91@getPending:
	mov	ecx, 1
	add	DWORD PTR [ebx+28], ecx

; 312  : 		finishedTransactions.pop();

	mov	eax, DWORD PTR [ebp+452]
	cmp	eax, edx
	je	SHORT $LN99@getPending
	add	DWORD PTR [ebp+448], ecx
	mov	ecx, DWORD PTR [ebp+448]
	cmp	DWORD PTR [ebp+444], ecx
	ja	SHORT $LN100@getPending
	mov	DWORD PTR [ebp+448], edx
$LN100@getPending:
	dec	eax
	mov	DWORD PTR [ebp+452], eax
	cmp	eax, edx
	jne	SHORT $LN99@getPending
	mov	DWORD PTR [ebp+448], edx
$LN99@getPending:

; 309  : 	while (finishedTransactions.size() > 0)

	cmp	DWORD PTR [ebp+452], edx
	ja	$LL2@getPending
$LN1@getPending:

; 313  : 	}
; 314  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z ENDP ; DRAMsimII::Channel::getPendingTransactions
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
xdata$x	SEGMENT
__unwindtable$??0_ns2__submitEpochResultElement@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$2
__ehfuncinfo$??0_ns2__submitEpochResultElement@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0_ns2__submitEpochResultElement@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0_ns2__submitEpochResultElement@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_ns2__submitEpochResultElement@@QAE@XZ PROC		; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement, COMDAT
; _this$ = ecx

; 263  : 	_ns2__submitEpochResultElement() : sessionID(NULL), epoch(0), PsysRD(0), PsysWR(0), soap(NULL) { }

	push	-1
	push	__ehhandler$??0_ns2__submitEpochResultElement@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultElement@@6B@
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	lea	ecx, DWORD PTR [esi+96]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	xorps	xmm0, xmm0
	movss	DWORD PTR [esi+120], xmm0
	movss	DWORD PTR [esi+124], xmm0
	mov	DWORD PTR [esi+128], edi
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__ehhandler$??0_ns2__submitEpochResultElement@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_ns2__submitEpochResultElement@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_ns2__submitEpochResultElement@@QAE@XZ ENDP		; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\get_pointer.hpp
xdata$x	SEGMENT
__unwindtable$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$1
__ehfuncinfo$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
xdata$x	ENDS
;	COMDAT ??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_u$ = 12						; size = 4
_b1$ = 16						; size = 4
_b2$ = 20						; size = 4
_b3$ = 24						; size = 4
$T599555 = 28						; size = 4
_b4$ = 28						; size = 4
$T599554 = 32						; size = 4
_b5$ = 32						; size = 4
$T599553 = 36						; size = 4
_b6$ = 36						; size = 4
??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT

; 765  :     template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const

	push	-1
	push	__ehhandler$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	push	ecx
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _b6$[esp+16]

; 766  :     {
; 767  :         BOOST_MEM_FN_RETURN (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _b5$[esp+20]
	push	edx
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR $T599553[esp+48], esp
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _b4$[esp+48]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+84], 0
	mov	edx, esp
	mov	DWORD PTR $T599554[esp+72], esp
	push	eax
	push	edx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	edx, DWORD PTR _b3$[esp+72]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T599555[esp+96], esp
	push	edx
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _u$[esp+96]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _b2$[esp+96]
	fld	QWORD PTR [edx]
	mov	eax, DWORD PTR _b1$[esp+96]
	mov	edx, DWORD PTR _this$[esp+96]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR [esp]
	call	eax

; 768  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$0:
	mov	esi, DWORD PTR $T599553[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$1:
	mov	esi, DWORD PTR $T599554[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$2
__ehfuncinfo$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
xdata$x	ENDS
;	COMDAT ??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_u$ = 12						; size = 4
_a6$ = 16						; size = 8
_a1$ = 24						; size = 8
_a2$ = 32						; size = 8
_a3$ = 40						; size = 24
_a4$ = 64						; size = 24
_a5$ = 88						; size = 24
??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>, COMDAT

; 774  :     template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const

	push	-1
	push	__ehhandler$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 775  :     {
; 776  :         BOOST_MEM_FN_RETURN call(u, &u, a1, a2, a3, a4, a5, a6);

	lea	eax, DWORD PTR _a6$[esp+24]
	push	eax
	lea	ecx, DWORD PTR _a5$[esp+28]
	push	ecx
	lea	edx, DWORD PTR _a4$[esp+32]
	push	edx
	lea	eax, DWORD PTR _a3$[esp+36]
	push	eax
	mov	eax, DWORD PTR _u$[esp+40]
	lea	ecx, DWORD PTR _a2$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+44]
	lea	edx, DWORD PTR _a1$[esp+44]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+68], 2
	call	??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
	mov	bl, al
	mov	eax, DWORD PTR _a3$[esp+36]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN11@operator@388
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@operator@388:
	mov	edx, DWORD PTR _a3$[esp+24]
	push	edx
	mov	DWORD PTR _a3$[esp+40], esi
	mov	DWORD PTR _a3$[esp+44], esi
	mov	DWORD PTR _a3$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a4$[esp+40]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN26@operator@388
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@operator@388:
	mov	eax, DWORD PTR _a4$[esp+24]
	push	eax
	mov	DWORD PTR _a4$[esp+40], esi
	mov	DWORD PTR _a4$[esp+44], esi
	mov	DWORD PTR _a4$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+40]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN41@operator@388
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@operator@388:
	mov	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	mov	DWORD PTR _a5$[esp+40], esi
	mov	DWORD PTR _a5$[esp+44], esi
	mov	DWORD PTR _a5$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	al, bl

; 777  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	104					; 00000068H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$0:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$1:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$2:
	lea	ecx, DWORD PTR _a3$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
xdata$x	SEGMENT
__unwindtable$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$1
__ehfuncinfo$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
_TEXT	SEGMENT
$T599735 = -76						; size = 4
$T599736 = -72						; size = 4
$T599737 = -68						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
_f$ = 12						; size = 4
??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>, COMDAT
; _this$ = esi

; 651  :     template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, eax

; 652  :     {
; 653  :         return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);

	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR [esi+72]
	mov	ecx, esp
	mov	DWORD PTR $T599735[esp+156], esp
	push	eax
	push	ecx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+188], 0
	lea	edx, DWORD PTR [esi+48]
	mov	eax, esp
	mov	DWORD PTR $T599736[esp+180], esp
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [esi+24]
	mov	edx, esp
	mov	DWORD PTR $T599737[esp+204], esp
	push	ecx
	push	edx
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	fld	QWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR _f$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	push	esi
	push	edx
	call	??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>

; 654  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$0:
	mov	esi, DWORD PTR $T599735[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$1:
	mov	esi, DWORD PTR $T599736[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-116]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind_template.hpp
;	COMDAT ??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ
_TEXT	SEGMENT
$T599808 = -4						; size = 1
??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator(), COMDAT
; _this$ = eax

; 18   :     {

	push	ecx
	push	esi

; 19   :         list0 a;
; 20   :         BOOST_BIND_RETURN l_(type<result_type>(), f_, a, 0);

	mov	BYTE PTR $T599808[esp+8], 0
	mov	ecx, DWORD PTR $T599808[esp+8]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [eax+8]
	call	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
	pop	esi

; 21   :     }

	pop	ecx
	ret	0
??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
_TEXT	ENDS
;	COMDAT ?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ
_TEXT	SEGMENT
$T599823 = -4						; size = 1
?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run, COMDAT
; _this$ = ecx

; 55   :             {

	push	ecx
	push	esi

; 56   :                 f();

	lea	eax, DWORD PTR [ecx+32]
	mov	BYTE PTR $T599823[esp+8], 0
	mov	ecx, DWORD PTR $T599823[esp+8]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [eax+8]
	call	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
	pop	esi

; 57   :             }

	pop	ecx
	ret	0
?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@13
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@13
	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN50@Construct_@13:
$LN10@Construct_@13:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@13
	npad	3
$LL42@Construct_@13:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@13
$LN40@Construct_@13:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@13:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@13:
?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z
_TEXT	SEGMENT
$T600041 = -4						; size = 4
___formal$ = 8						; size = 1
??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>, COMDAT
; _this$ = esi
; __Count$ = edi
; __Val$ = eax

; 525  : 		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)

	sub	esp, 8

; 526  : 		{	// initialize with _Count * _Val
; 527  : 		size_type _Size = (size_type)_Count;
; 528  : 		_Construct_n(_Size, (_Ty)_Val);

	lea	ecx, DWORD PTR $T600041[esp+8]
	push	ecx
	mov	DWORD PTR $T600041[esp+12], eax
	call	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n

; 529  : 		}

	add	esp, 8
	ret	4
??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
; _t$ = eax

; 116  :     value(T const & t): t_(t) {}

	push	ecx
	push	eax
	push	esi
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
; _t$ = eax

; 116  :     value(T const & t): t_(t) {}

	push	ecx
	push	eax
	push	esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	push	eax
	push	esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	add	eax, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR [esi+24]
	push	eax
	movq	QWORD PTR [esi+16], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	push	eax
	push	esi
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z$0
__ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; ___that$ = ecx
	push	-1
	push	__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+20]
	movq	xmm0, QWORD PTR [edi]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+24]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	lea	eax, DWORD PTR [esi+24]
	push	ecx
	push	eax
	movq	QWORD PTR [esi+16], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	add	edi, 48					; 00000030H
	push	edi
	lea	edx, DWORD PTR [esi+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z$0
__ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; ___that$ = ecx
	push	-1
	push	__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+20]
	push	esi
	call	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	add	edi, 72					; 00000048H
	push	edi
	lea	eax, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
; ___that$ = edi
	push	ecx
	push	esi
	mov	ecx, edi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], ecx
	mov	eax, esi
	pop	ecx
	ret	0
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
; ___that$ = edi
	push	ecx
	push	esi
	mov	ecx, edi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], ecx
	mov	eax, esi
	pop	ecx
	ret	0
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; ___that$ = eax
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx], ecx
	lea	edi, DWORD PTR [ebx+8]
	push	edi
	mov	ecx, esi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], edx
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edi+100], eax
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z$0
__ehfuncinfo$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T600267 = 12						; size = 4
__Last$ = 12						; size = 4
??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>, COMDAT
; __First$ = edi

; 513  : 		{	// construct from [_First, _Last)

	push	-1
	push	__ehhandler$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@allocator@5
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@allocator@5
$LN13@allocator@5:
	xor	eax, eax
$LN14@allocator@5:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 514  : 		_Construct(_First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR __Last$[esp+16]
	lea	ecx, DWORD PTR $T600267[esp+16]
	push	ecx
	mov	DWORD PTR $T600267[esp+20], eax
	call	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n

; 515  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Newvec$231733 = -4					; size = 4
tv523 = 8						; size = 4
__Capacity$ = 8						; size = 4
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__Tmp$231758 = 20					; size = 4
__Tmp$231748 = 20					; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n, COMDAT
; __Count$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [ebx+12]
	push	esi
	mov	esi, eax
	test	edx, edx
	jne	SHORT $LN29@Insert_n@7
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@7
$LN29@Insert_n@7:
	mov	eax, DWORD PTR [ebx+20]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@7:

; 1162 : 
; 1163 : 		if (_Count == 0)

	test	esi, esi
	je	$LN1@Insert_n@7
	push	ebp

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebp, DWORD PTR [ebx+16]
	mov	eax, ebp
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, esi
	jae	SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN126@Insert_n@7:
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+esi]
	push	edi
	cmp	ecx, edx
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR __Capacity$[esp+16], 0
	mov	ecx, DWORD PTR __Capacity$[esp+16]
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+16], ecx
$LN18@Insert_n@7:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+16], edx
	mov	ecx, edx
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebp, DWORD PTR __Where$[esp+20]
	sub	ebp, DWORD PTR [ebx+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[esp+16]
	sar	ebp, 2
	lea	edi, DWORD PTR [eax+ebp*4]
	mov	DWORD PTR __Newvec$231733[esp+20], eax
	call	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __Newvec$231733[esp+20]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN79@Insert_n@7
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN79@Insert_n@7:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN110@Insert_n@7
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	add	ebp, esi
	lea	eax, DWORD PTR [edi+ebp*4]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN110@Insert_n@7:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, eax
	sar	ecx, 2
	add	esi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+16]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+esi*4]
	lea	eax, DWORD PTR [edi+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi
	pop	edi
	pop	ebp
	pop	esi
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+16], ecx
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+20]
	mov	edx, ebp
	sub	edx, edi
	sar	edx, 2
	cmp	edx, esi
	jae	SHORT $LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+16]
	mov	ecx, DWORD PTR [eax]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv523[esp+16], eax
	lea	edx, DWORD PTR [eax+edi]
	mov	eax, ebp
	mov	DWORD PTR __Tmp$231748[esp+16], ecx
	call	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	edx, edi
	sub	edx, DWORD PTR __Where$[esp+20]
	sar	edx, 2
	sub	esi, edx
	lea	edx, DWORD PTR __Tmp$231748[esp+16]
	call	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv523[esp+16]
	add	DWORD PTR [ebx+16], eax
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$231748[esp+16]
	push	ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR __Where$[esp+24]

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	call	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
	add	esp, 4
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN3@Insert_n@7:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+16]
	mov	eax, DWORD PTR [edx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	add	esi, esi
	mov	DWORD PTR __Tmp$231758[esp+16], eax
	add	esi, esi
	mov	edi, ebp
	sub	edi, esi
	mov	edx, ebp
	mov	eax, ebp
	call	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+20]
	mov	ecx, ebp
	call	??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR __Tmp$231758[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [esi+eax]
	call	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
	add	esp, 4
	pop	edi
	pop	ebp
$LN1@Insert_n@7:
	pop	esi
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN124@Insert_n@7:
?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@24

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	ret	0
$LN4@Buy@24:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@24

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN2@Buy@24:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
$T600796 = -24						; size = 8
$T600798 = -16						; size = 8
$T600794 = -16						; size = 8
$T600797 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 8						; size = 4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize, COMDAT
; _this$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR __Newsize$[esp+24]
	push	esi
	mov	esi, eax

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2
	mov	DWORD PTR __Val$[esp+32], 0
	cmp	ebx, eax
	jbe	SHORT $LN60@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	cmp	ecx, edi
	jbe	SHORT $LN13@resize@2
	call	__invalid_parameter_noinfo
$LN13@resize@2:
	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR __Val$[esp+32]
	push	eax
	push	edi
	sar	edx, 2
	push	ecx
	mov	eax, ebx
	sub	eax, edx
	push	esi
	call	?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 722  : 		}

	add	esp, 24					; 00000018H
	ret	4
$LN60@resize@2:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	cmp	ecx, edi
	jbe	SHORT $LN33@resize@2
	call	__invalid_parameter_noinfo
$LN33@resize@2:
	mov	eax, DWORD PTR [esi]
	push	ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR $T600794[esp+40], eax
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN49@resize@2
	call	__invalid_parameter_noinfo
$LN49@resize@2:
	mov	ecx, DWORD PTR [esi]
	push	ebx
	lea	edx, DWORD PTR $T600797[esp+44]
	push	edx
	lea	eax, DWORD PTR $T600796[esp+48]
	mov	DWORD PTR $T600796[esp+48], ecx
	mov	DWORD PTR $T600796[esp+52], ebp
	call	??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
	mov	ecx, DWORD PTR $T600794[esp+40]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	edi
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T600798[esp+56]
	push	ecx
	call	?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
	pop	ebp
$LN1@resize@2:
	pop	edi
	pop	esi
	pop	ebx

; 722  : 		}

	add	esp, 24					; 00000018H
	ret	4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@14
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@14
	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN50@Construct_@14:
$LN10@Construct_@14:
	mov	ecx, edi
	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@14
	npad	3
$LL42@Construct_@14:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@14
$LN40@Construct_@14:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@14:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@14:
?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize, COMDAT
; __Newsize$ = eax

; 713  : 		resize(_Newsize, _Ty());

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize

; 714  : 		}

	ret	4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T601219 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@66
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@66
$LN13@vector@66:
	xor	eax, eax
$LN14@vector@66:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T601219[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T601219[esp+28], ecx
	call	?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Rank@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$1
__ehfuncinfo$??1Rank@DRAMsimII@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Rank@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1Rank@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1Rank@DRAMsimII@@QAE@XZ PROC				; DRAMsimII::Rank::~Rank, COMDAT
	push	-1
	push	__ehhandler$??1Rank@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	lea	eax, DWORD PTR [esi+400]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 1
	call	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	xor	ecx, ecx
	cmp	DWORD PTR [esi+392], ecx
	jbe	SHORT $LN10@Rank
	mov	edx, 8
	npad	7
$LL15@Rank:
	add	DWORD PTR [esi+384], edx
	mov	eax, DWORD PTR [esi+384]
	inc	ecx
	cmp	eax, DWORD PTR [esi+380]
	jne	SHORT $LN28@Rank
	mov	eax, DWORD PTR [esi+376]
	mov	DWORD PTR [esi+384], eax
$LN28@Rank:
	cmp	ecx, DWORD PTR [esi+392]
	jb	SHORT $LL15@Rank
$LN10@Rank:
	mov	eax, DWORD PTR [esi+376]
	test	eax, eax
	je	SHORT $LN25@Rank
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Rank:
	lea	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1LRU@DRAMsimII@@UAE@XZ		; DRAMsimII::LRU::~LRU
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 152				; 00000098H
	jmp	??1LRU@DRAMsimII@@UAE@XZ		; DRAMsimII::LRU::~LRU
__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 376				; 00000178H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__ehhandler$??1Rank@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Rank@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Rank@DRAMsimII@@QAE@XZ ENDP				; DRAMsimII::Rank::~Rank
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$1
__ehfuncinfo$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_f_$ = 12						; size = 112
??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT

; 49   :             {}

	push	-1
	push	__ehhandler$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[esp+20]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0thread_data_base@detail@boost@@QAE@XZ ; boost::detail::thread_data_base::thread_data_base
	mov	BYTE PTR __$EHRec$[esp+32], 1
	mov	eax, DWORD PTR _f_$[esp+20]
	lea	esi, DWORD PTR [edi+40]
	mov	DWORD PTR [edi], OFFSET ??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
	push	esi
	lea	ecx, DWORD PTR _f_$[esp+32]
	mov	DWORD PTR [edi+32], eax
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	ecx, DWORD PTR _f_$[esp+124]
	mov	edx, DWORD PTR _f_$[esp+128]
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+100], edx
	lea	esi, DWORD PTR _f_$[esp+28]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	116					; 00000074H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$0:
	lea	eax, DWORD PTR _f_$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1thread_data_base@detail@boost@@UAE@XZ ; boost::detail::thread_data_base::~thread_data_base
__ehhandler$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__unwindtable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0
__tryblocktable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$7
__ehfuncinfo$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
xdata$x	ENDS
;	COMDAT ??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
$T619843 = -44						; size = 12
$T619828 = -32						; size = 4
$T619827 = -28						; size = 4
_heap_memory$ = -24					; size = 4
_heap_memory$619847 = -20				; size = 4
__$EHRec$ = -16						; size = 16
??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>, COMDAT
; _a1$ = ecx

; 155  :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 156  :             void* const heap_memory=allocate_raw_heap_memory(sizeof(T));

	push	144					; 00000090H
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	ebx, eax
	mov	DWORD PTR _heap_memory$619847[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN12@heap_new_i
	push	1
	push	OFFSET __bad_alloc_Message
	lea	ecx, DWORD PTR $T619843[ebp]
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T619843[ebp]
	push	eax
	mov	DWORD PTR $T619843[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN32@heap_new_i:
$LN12@heap_new_i:

; 157  :             try
; 158  :             {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _heap_memory$[ebp], ebx

; 159  :                 T* const data=new (heap_memory) T(a1);

	mov	DWORD PTR $T619827[ebp], ebx
	sub	esp, 112				; 00000070H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+8]
	mov	DWORD PTR $T619828[ebp], esp
	mov	DWORD PTR [eax], ecx
	add	esi, 8
	push	edi
	mov	ecx, esi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], edx
	mov	eax, DWORD PTR [esi+100]
	push	ebx
	mov	DWORD PTR [edi+100], eax
	call	??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >

; 166  :             }
; 167  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0:

; 160  :                 return data;
; 161  :             }
; 162  :             catch(...)
; 163  :             {
; 164  :                 free_raw_heap_memory(heap_memory);

	mov	ecx, DWORD PTR _heap_memory$619847[ebp]
	push	ecx
	call	?free_raw_heap_memory@detail@boost@@YAXPAX@Z ; boost::detail::free_raw_heap_memory
	add	esp, 4

; 165  :                 throw;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@heap_new_i:
$LN31@heap_new_i:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$2:
	mov	eax, DWORD PTR _heap_memory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T619827[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
; Function compile flags: /Ogtpy
;	COMDAT ??_GRank@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
??_GRank@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::Rank::`scalar deleting destructor', COMDAT
; _this$ = esi
	push	ecx
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	mov	eax, esi
	pop	ecx
	ret	0
??_GRank@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::Rank::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z PROC ; std::_Destroy<DRAMsimII::Rank>, COMDAT
; __Ptr$ = eax

; 58   : 	{	// destroy object at _Ptr

	push	ecx

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	pop	ecx

; 60   : 	}

	ret	0
??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z ENDP ; std::_Destroy<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; _a1$ = ecx

; 225  :         {

	push	ecx

; 226  :             return heap_new_impl<T,A1&>(a1);

	call	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
	pop	ecx

; 227  :         }

	ret	0
??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z PROC ; std::allocator<DRAMsimII::Rank>::destroy, COMDAT
; __Ptr$ = eax

; 159  : 		{	// destroy object at _Ptr

	push	ecx

; 160  : 		_Destroy(_Ptr);

	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	pop	ecx

; 161  : 		}

	ret	0
?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z ENDP ; std::allocator<DRAMsimII::Rank>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ecx
	push	esi
	mov	esi, eax

; 233  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@16
$LL3@Destroy_ra@16:

; 234  : 		_Al.destroy(_First);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@16
$LN1@Destroy_ra@16:

; 235  : 	}

	pop	esi
	pop	ecx
	ret	0
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0
__ehfuncinfo$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
$T619939 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_f$ = 8							; size = 112
??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; ___$ReturnUdt$ = edi

; 135  :         {

	push	-1
	push	__ehhandler$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	xor	esi, esi
	mov	DWORD PTR $T619939[esp+28], esi

; 136  :             return detail::thread_data_ptr(detail::heap_new<detail::thread_data<F> >(f));

	lea	ecx, DWORD PTR _f$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], esi
	call	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
	mov	DWORD PTR [edi], eax
	cmp	eax, esi
	je	SHORT $LN11@make_threa
	add	eax, 4
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx
$LN11@make_threa:
	lea	esi, DWORD PTR _f$[esp+32]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, edi

; 137  :         }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0:
	lea	eax, DWORD PTR _f$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__ehhandler$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z$0
__ehfuncinfo$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi

; 178  :     storage4( A1 a1, A2 a2, A3 a3, A4 a4 ): storage3<A1, A2, A3>( a1, a2, a3 ), a4_( a4 ) {}

	push	-1
	push	__ehhandler$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	eax, DWORD PTR _a1$[esp+20]
	mov	edx, DWORD PTR _a2$[esp+24]
	mov	ecx, DWORD PTR _a2$[esp+20]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _a3$[esp+20]
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR _a4$[esp+20]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR _a3$[esp+24]
	push	edx
	lea	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+20], ecx
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a4$[esp+32]
	cmp	eax, edi
	je	SHORT $LN21@storage4@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@storage4@2:
	mov	ecx, DWORD PTR _a4$[esp+20]
	push	ecx
	mov	DWORD PTR _a4$[esp+36], edi
	mov	DWORD PTR _a4$[esp+40], edi
	mov	DWORD PTR _a4$[esp+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 16					; 00000010H
	ret	44					; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z$0:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$3
__ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
_TEXT	SEGMENT
$T620078 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 8
_a3$ = 24						; size = 8
_a4$ = 32						; size = 24
_a5$ = 56						; size = 24
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT

; 227  :     storage5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ), a5_( a5 ) {}

	push	-1
	push	__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T620078[esp+52], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+48]
	push	ecx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	edx, DWORD PTR _a3$[esp+52]
	mov	eax, DWORD PTR _a3$[esp+48]
	mov	ecx, DWORD PTR _a2$[esp+52]
	push	edx
	mov	edx, DWORD PTR _a2$[esp+52]
	push	eax
	mov	eax, DWORD PTR _a1$[esp+56]
	push	ecx
	push	edx
	push	eax
	call	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
	lea	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	lea	edx, DWORD PTR [esi+48]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _a4$[esp+36]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN21@storage5@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@storage5@2:
	mov	eax, DWORD PTR _a4$[esp+24]
	push	eax
	mov	DWORD PTR _a4$[esp+40], edi
	mov	DWORD PTR _a4$[esp+44], edi
	mov	DWORD PTR _a4$[esp+48], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+40]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN38@storage5@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@storage5@2:
	mov	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	mov	DWORD PTR _a5$[esp+40], edi
	mov	DWORD PTR _a5$[esp+44], edi
	mov	DWORD PTR _a5$[esp+48], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	72					; 00000048H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$0:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$1:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$3:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$5
__ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
_TEXT	SEGMENT
$T620239 = -20						; size = 4
$T620240 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 8
_a3$ = 24						; size = 8
_a4$ = 32						; size = 24
_a5$ = 56						; size = 24
_a6$ = 80						; size = 24
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT

; 276  :     storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ), a6_( a6 ) {}

	push	-1
	push	__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+32]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR $T620239[esp+60], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a5$[esp+56]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T620240[esp+84], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a4$[esp+80]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 3
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a3$[esp+84]
	mov	ecx, DWORD PTR _a3$[esp+80]
	mov	edx, DWORD PTR _a2$[esp+84]
	push	eax
	mov	eax, DWORD PTR _a2$[esp+84]
	push	ecx
	mov	ecx, DWORD PTR _a1$[esp+88]
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
	lea	edx, DWORD PTR _a6$[esp+32]
	push	edx
	lea	eax, DWORD PTR [esi+72]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 4
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _a4$[esp+44]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN26@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@storage6@2:
	mov	ecx, DWORD PTR _a4$[esp+32]
	push	ecx
	mov	DWORD PTR _a4$[esp+48], edi
	mov	DWORD PTR _a4$[esp+52], edi
	mov	DWORD PTR _a4$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+48]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@storage6@2:
	mov	edx, DWORD PTR _a5$[esp+32]
	push	edx
	mov	DWORD PTR _a5$[esp+48], edi
	mov	DWORD PTR _a5$[esp+52], edi
	mov	DWORD PTR _a5$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+48]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@storage6@2:
	mov	eax, DWORD PTR _a6$[esp+32]
	push	eax
	mov	DWORD PTR _a6$[esp+48], edi
	mov	DWORD PTR _a6$[esp+52], edi
	mov	DWORD PTR _a6$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 24					; 00000018H
	ret	96					; 00000060H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$3:
	mov	esi, DWORD PTR $T620239[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$5:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4
__ehfuncinfo$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
_TEXT	SEGMENT
$T620476 = -24						; size = 4
$T620477 = -20						; size = 4
$T620478 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
_a5$ = 52						; size = 24
_a6$ = 76						; size = 24
_a7$ = 100						; size = 8
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi

; 325  :     storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ), a7_( a7 ) {}

	push	-1
	push	__ehhandler$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+64], 2
	mov	DWORD PTR $T620476[esp+56], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a6$[esp+52]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+88], 3
	mov	DWORD PTR $T620477[esp+80], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a5$[esp+76]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T620478[esp+104], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+100]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+120], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	edx, DWORD PTR _a3$[esp+104]
	mov	eax, DWORD PTR _a3$[esp+100]
	mov	ecx, DWORD PTR _a2$[esp+104]
	push	edx
	mov	edx, DWORD PTR _a2$[esp+104]
	push	eax
	mov	eax, DWORD PTR _a1$[esp+108]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
	mov	eax, DWORD PTR _a4$[esp+40]
	mov	ecx, DWORD PTR _a7$[esp+28]
	mov	edx, DWORD PTR _a7$[esp+32]
	xor	edi, edi
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+100], edx
	cmp	eax, edi
	je	SHORT $LN26@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@storage7:
	mov	eax, DWORD PTR _a4$[esp+28]
	push	eax
	mov	DWORD PTR _a4$[esp+44], edi
	mov	DWORD PTR _a4$[esp+48], edi
	mov	DWORD PTR _a4$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+44]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@storage7:
	mov	ecx, DWORD PTR _a5$[esp+28]
	push	ecx
	mov	DWORD PTR _a5$[esp+44], edi
	mov	DWORD PTR _a5$[esp+48], edi
	mov	DWORD PTR _a5$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+44]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@storage7:
	mov	edx, DWORD PTR _a6$[esp+28]
	push	edx
	mov	DWORD PTR _a6$[esp+44], edi
	mov	DWORD PTR _a6$[esp+48], edi
	mov	DWORD PTR _a6$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 24					; 00000018H
	ret	100					; 00000064H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3:
	mov	esi, DWORD PTR $T620476[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4:
	mov	esi, DWORD PTR $T620477[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4
__ehfuncinfo$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
xdata$x	ENDS
;	COMDAT ??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
_TEXT	SEGMENT
$T620714 = -24						; size = 4
$T620715 = -20						; size = 4
$T620716 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
_a5$ = 52						; size = 24
_a6$ = 76						; size = 24
_a7$ = 100						; size = 8
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = ecx

; 623  :     list7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): base_type( a1, a2, a3, a4, a5, a6, a7 ) {}

	push	-1
	push	__ehhandler$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[esp+48], 2
	mov	eax, DWORD PTR _a7$[esp+40]
	mov	ecx, DWORD PTR _a7$[esp+36]
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T620714[esp+72], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a6$[esp+68]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+104], 3
	mov	DWORD PTR $T620715[esp+96], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a5$[esp+92]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T620716[esp+120], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a4$[esp+116]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a3$[esp+120]
	mov	ecx, DWORD PTR _a3$[esp+116]
	mov	edx, DWORD PTR _a2$[esp+120]
	push	eax
	mov	eax, DWORD PTR _a2$[esp+120]
	push	ecx
	mov	ecx, DWORD PTR _a1$[esp+124]
	push	edx
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+148], 2
	call	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
	mov	eax, DWORD PTR _a4$[esp+48]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN26@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@list7:
	mov	edx, DWORD PTR _a4$[esp+36]
	push	edx
	mov	DWORD PTR _a4$[esp+52], edi
	mov	DWORD PTR _a4$[esp+56], edi
	mov	DWORD PTR _a4$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+52]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@list7:
	mov	eax, DWORD PTR _a5$[esp+36]
	push	eax
	mov	DWORD PTR _a5$[esp+52], edi
	mov	DWORD PTR _a5$[esp+56], edi
	mov	DWORD PTR _a5$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+52]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@list7:
	mov	ecx, DWORD PTR _a6$[esp+36]
	push	ecx
	mov	DWORD PTR _a6$[esp+52], edi
	mov	DWORD PTR _a6$[esp+56], edi
	mov	DWORD PTR _a6$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 28					; 0000001cH
	ret	100					; 00000064H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3:
	mov	esi, DWORD PTR $T620714[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4:
	mov	esi, DWORD PTR $T620715[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_f$ = 12						; size = 4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; _l$ = edi

; 859  :     bind_t(F f, L const & l): f_(f), l_(l) {}

	push	ecx
	mov	eax, DWORD PTR _f$[esp]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi
	lea	esi, DWORD PTR [ebx+8]
	push	esi
	mov	ecx, edi
	mov	DWORD PTR [ebx], eax
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	8
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@17
$LL7@Destroy_ra@17:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@17
$LN5@Destroy_ra@17:

; 226  : 	}

	pop	esi
	ret	0
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$3
__ehfuncinfo$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
_TEXT	SEGMENT
$T621010 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_f$ = 12						; size = 112
??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z PROC ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT

; 187  :         {

	push	-1
	push	__ehhandler$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+28]
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], eax
	sub	esp, 112				; 00000070H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+152], 1
	mov	ecx, DWORD PTR _f$[esp+140]
	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR $T621010[esp+144], esp
	mov	DWORD PTR [eax], ecx
	push	esi
	lea	ecx, DWORD PTR _f$[esp+152]
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR _f$[esp+244]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR _f$[esp+248]
	lea	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+100], eax
	call	??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
	add	esp, 112				; 00000070H

; 188  :             start_thread();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	?start_thread@thread@boost@@AAEXXZ	; boost::thread::start_thread

; 189  :         }

	lea	esi, DWORD PTR _f$[esp+36]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	116					; 00000074H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$0:
	lea	eax, DWORD PTR _f$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1mutex@boost@@QAE@XZ			; boost::mutex::~mutex
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 8
	jmp	??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
__ehhandler$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ENDP ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$6
__ehfuncinfo$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind_mf_cc.hpp
xdata$x	ENDS
;	COMDAT ??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
_TEXT	SEGMENT
$T621072 = -124						; size = 4
$T621068 = -120						; size = 104
__$EHRec$ = -12						; size = 12
$T621085 = 8						; size = 4
$T621075 = 8						; size = 4
$T621074 = 8						; size = 4
$T621073 = 8						; size = 4
$T621070 = 8						; size = 4
$T621069 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_a1$ = 12						; size = 4
$T621071 = 16						; size = 4
_a7$ = 16						; size = 8
_a2$ = 24						; size = 8
_a3$ = 32						; size = 8
_a4$ = 40						; size = 24
_a5$ = 64						; size = 24
_a6$ = 88						; size = 24
??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z PROC ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT

; 175  : {

	push	-1
	push	__ehhandler$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+144]
	xor	ebx, ebx
	mov	DWORD PTR $T621085[esp+144], ebx

; 176  :     typedef _mfi::BOOST_BIND_MF_NAME(cmf6)<R, T, B1, B2, B3, B4, B5, B6> F;
; 177  :     typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
; 178  :     return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));

	sub	esp, 8
	mov	DWORD PTR __$EHRec$[esp+164], 2
	mov	ecx, DWORD PTR _a7$[esp+152]
	mov	edx, DWORD PTR _a7$[esp+156]
	mov	eax, esp
	mov	DWORD PTR $T621069[esp+152], esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR $T621070[esp+176], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a6$[esp+176]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+212], 3
	mov	DWORD PTR $T621071[esp+200], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a5$[esp+200]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T621072[esp+228], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+224]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+244], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	movsd	xmm0, QWORD PTR _a3$[esp+224]
	mov	edx, DWORD PTR _a1$[esp+224]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T621073[esp+232], esp
	movsd	QWORD PTR [eax], xmm0
	movsd	xmm0, QWORD PTR _a2$[esp+232]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T621074[esp+240], esp
	push	ecx
	movsd	QWORD PTR [eax], xmm0
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	lea	ecx, DWORD PTR $T621068[esp+248]
	mov	DWORD PTR $T621075[esp+244], esp
	mov	BYTE PTR __$EHRec$[esp+256], 2
	call	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
	mov	esi, eax
	lea	edi, DWORD PTR [ebp+8]
	mov	BYTE PTR __$EHRec$[esp+156], 5
	push	edi
	mov	ecx, esi
	mov	DWORD PTR [ebp], OFFSET ?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], eax
	mov	ecx, DWORD PTR [esi+100]
	lea	esi, DWORD PTR $T621068[esp+148]
	mov	DWORD PTR [edi+100], ecx
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, DWORD PTR _a4$[esp+156]
	cmp	eax, ebx
	je	SHORT $LN49@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@bind:
	mov	edx, DWORD PTR _a4$[esp+144]
	push	edx
	mov	DWORD PTR _a4$[esp+160], ebx
	mov	DWORD PTR _a4$[esp+164], ebx
	mov	DWORD PTR _a4$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+160]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN64@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@bind:
	mov	eax, DWORD PTR _a5$[esp+144]
	push	eax
	mov	DWORD PTR _a5$[esp+160], ebx
	mov	DWORD PTR _a5$[esp+164], ebx
	mov	DWORD PTR _a5$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+160]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN79@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@bind:
	mov	ecx, DWORD PTR _a6$[esp+144]
	push	ecx
	mov	DWORD PTR _a6$[esp+160], ebx
	mov	DWORD PTR _a6$[esp+164], ebx
	mov	DWORD PTR _a6$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, ebp

; 179  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 128				; 00000080H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$2:
	lea	ecx, DWORD PTR _a4$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$3:
	mov	esi, DWORD PTR $T621070[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$4:
	mov	esi, DWORD PTR $T621071[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$6:
	lea	esi, DWORD PTR $T621068[ebp]
	jmp	??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
__ehhandler$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-132]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ENDP ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = edi

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, edi
	je	SHORT $LN7@Destroy@15
$LL9@Destroy@15:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@15
$LN7@Destroy@15:

; 1120 : 		}

	pop	esi
	ret	0
?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
_TEXT	SEGMENT
$T621376 = -52						; size = 8
__Ok$ = -44						; size = 8
__Nput_fac$224378 = -36					; size = 4
$T621425 = -32						; size = 1
__Lock$621411 = -32					; size = 4
$T621373 = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
$T621377 = 12						; size = 8
__Val$ = 12						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 411  : 		{	// insert a double

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 412  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 413  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 414  : 
; 415  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@400

; 416  : 			{	// state okay, use facet to insert
; 417  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T621373[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T621373[ebp]
	mov	DWORD PTR __Nput_fac$224378[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@400
	push	0
	lea	ecx, DWORD PTR __Lock$621411[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@400
	cmp	eax, -1
	jae	SHORT $LN21@operator@400
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@400:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$621411[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@400
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@400:

; 418  : 
; 419  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 420  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 421  : 				_Myios::fill(), _Val).failed())

	fld	QWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	add	ecx, esi
	mov	cl, BYTE PTR [ecx+48]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	BYTE PTR $T621425[ebp], cl
	mov	ebx, DWORD PTR $T621425[ebp]
	mov	ecx, DWORD PTR __Nput_fac$224378[ebp]
	mov	edi, DWORD PTR [ecx]
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	BYTE PTR $T621376[ebp], 0
	mov	edx, DWORD PTR $T621376[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR $T621377[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T621377[ebp], 0
	je	SHORT $LN1@operator@400

; 422  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@400:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@400
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0:

; 423  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@400
	or	eax, 4
$LN42@operator@400:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@400
	ret	0
$LN79@operator@400:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@400:

; 424  : 			}
; 425  : 
; 426  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@400
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@400
	or	eax, 4
$LN73@operator@400:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@400:

; 427  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 428  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3:
	lea	ecx, DWORD PTR $T621373[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T621519 = -16						; size = 16
_this$ = 8						; size = 4
?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z PROC ; DRAMsimII::Channel::retireCommand
; _newestCommand$ = eax

; 364  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+20]
	push	esi
	push	edi
	mov	edi, eax

; 365  : 	statistics.collectCommandStats(newestCommand);

	mov	eax, DWORD PTR [ebp+180]
	push	eax
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 366  : 
; 367  : 	assert(((newestCommand->isReadOrWrite() || newestCommand->isRefresh()) && newestCommand->getHost()) ||
; 368  : 		(!(newestCommand->isReadOrWrite() || newestCommand->isRefresh()) && !newestCommand->getHost()));
; 369  : 
; 370  : 	// transaction complete? if so, put incomingTransaction completion queue
; 371  : 	// note that the host transaction should only be pointed to by a CAS command
; 372  : 	// since this is when a transaction is done from the standpoint of the requester
; 373  : 	if (Transaction *completedTransaction = newestCommand->removeHost())

	mov	ebx, DWORD PTR [edi+84]
	mov	DWORD PTR [edi+84], 0
	test	ebx, ebx
	je	SHORT $LN7@retireComm

; 374  : 	{
; 375  : 		DEBUG_TRANSACTION_LOG("-T " << *completedTransaction);
; 376  : 
; 377  : 		if (!newestCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	je	SHORT $LN21@retireComm

; 378  : 		{
; 379  : 			statistics.collectTransactionStats(completedTransaction);

	mov	ecx, DWORD PTR [ebp+180]
	push	ebx
	push	ecx
	call	?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ; DRAMsimII::Statistics::collectTransactionStats

; 380  : 
; 381  : 			assert(newestCommand->getEnqueueTime() >= completedTransaction->getEnqueueTime() && 
; 382  : 				newestCommand->getCompletionTime() <= completedTransaction->getCompletionTime());
; 383  : 
; 384  : 			const unsigned origTrans = completedTransaction->getOriginalTransaction();

	mov	eax, DWORD PTR [ebx+108]

; 385  : 
; 386  : 			M5_DEBUG(assert(origTrans < UINT_MAX));
; 387  : 
; 388  : 			if (origTrans < UINT_MAX)

	cmp	eax, -1
	jae	SHORT $LN21@retireComm

; 389  : 				finishedTransactions.push(std::pair<unsigned,tick>(origTrans, completedTransaction->getCompletionTime()));

	mov	edx, DWORD PTR [ebx+32]
	mov	DWORD PTR $T621519[esp+32], eax
	mov	eax, DWORD PTR [ebx+36]
	lea	ecx, DWORD PTR $T621519[esp+32]
	push	ecx
	lea	esi, DWORD PTR [ebp+424]
	mov	DWORD PTR $T621519[esp+44], edx
	mov	DWORD PTR $T621519[esp+48], eax
	call	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
$LN21@retireComm:

; 390  : 		}
; 391  : 		else
; 392  : 		{
; 393  : 			assert(systemConfig.getRefreshPolicy() != NO_REFRESH);
; 394  : 		}
; 395  : 
; 396  : 		delete completedTransaction;

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, ebx
	call	eax
$LN7@retireComm:

; 397  : 
; 398  : 	}
; 399  : 	assert(!newestCommand->getHost());
; 400  : 
; 401  : 	delete lastCommand;

	mov	ecx, DWORD PTR [ebp+24]
	test	ecx, ecx
	je	SHORT $LN23@retireComm
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN23@retireComm:

; 402  : 
; 403  : 	lastCommand = newestCommand;

	mov	DWORD PTR [ebp+24], edi

; 404  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ENDP ; DRAMsimII::Channel::retireCommand
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy, COMDAT

; 1123 : 		{	// free all storage

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+12]
	push	edi
	test	esi, esi
	je	SHORT $LN22@Tidy@36

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+16]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@36
$LL12@Tidy@36:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@36
$LN10@Tidy@36:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@Tidy@36:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1135 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	pop	ebx
	pop	ecx
	ret	4
?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 558  : 		{	// destroy the object

	push	-1
	push	__ehhandler$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]

; 559  : 		_Tidy();

	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
_offset$ = 12						; size = 4
?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert, COMDAT
; _this$ = eax

; 310  : 		{

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 311  : 			assert(offset <= (int)count);
; 312  : 
; 313  : 			if (count == entry.size())

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi]
	sar	eax, 2
	cmp	edi, eax

; 314  : 				return false;

	je	SHORT $LN41@insert@19

; 315  : 
; 316  : 			else if (item == NULL)

	cmp	DWORD PTR _item$[esp+16], 0
	jne	SHORT $LN5@insert@19

; 317  : 			{
; 318  : 				std::cerr << "Attempting to insert NULL into queue" << std::endl;

	push	OFFSET ??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN41@insert@19:

; 319  : 				return false;

	xor	al, al

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN5@insert@19:

; 320  : 				//_exit(2);
; 321  : 			}
; 322  : 			else
; 323  : 			{
; 324  : 				// move everything back by one unit
; 325  : 				for (int i = count - 1 ; i >= offset ; --i)

	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	jl	SHORT $LN1@insert@19
$LL3@insert@19:

; 326  : 					entry[(head + i + 1) % entry.size()] = entry[(head + i) % (unsigned)entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN18@insert@19
	call	__invalid_parameter_noinfo
$LN18@insert@19:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+4]
	sub	ecx, eax
	lea	ebp, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN25@insert@19
	call	__invalid_parameter_noinfo
$LN25@insert@19:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ebp]
	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	mov	DWORD PTR [ecx+ebx*4], edx
	jge	SHORT $LL3@insert@19
$LN1@insert@19:

; 327  : 
; 328  : 				count++;

	inc	DWORD PTR [esi]

; 329  : 
; 330  : 				entry[(head + offset) % (unsigned)entry.size()] = item;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR _offset$[esp+16]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN32@insert@19
	call	__invalid_parameter_noinfo
$LN32@insert@19:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _item$[esp+16]
	mov	DWORD PTR [eax+edi*4], ecx

; 331  : 
; 332  : 				tail = (tail + 1) % (unsigned)entry.size();	// advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front, COMDAT
; _this$ = eax

; 167  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 168  : 			assert(item != NULL);
; 169  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 170  : 				return false;

	je	SHORT $LN22@push_front@2

; 171  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push_front@2

; 172  : 			{
; 173  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN22@push_front@2:

; 174  : 				return false;

	xor	al, al

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push_front@2:

; 175  : 			}
; 176  : 			else
; 177  : 			{
; 178  : 				count++;

	inc	eax
	mov	DWORD PTR [esi], eax

; 179  : 				head = ((int)head > 0) ? head - 1 : (unsigned)entry.size() - 1;

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jle	SHORT $LN7@push_front@2
	lea	edi, DWORD PTR [eax-1]
	jmp	SHORT $LN8@push_front@2
$LN7@push_front@2:
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	sar	edi, 2
	dec	edi
$LN8@push_front@2:
	mov	DWORD PTR [esi+4], edi

; 180  : 				entry[head] = item;

	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN17@push_front@2
	call	__invalid_parameter_noinfo
$LN17@push_front@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	pop	ecx
	ret	4
?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::push, COMDAT
; _this$ = eax

; 147  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 148  : 			assert(item != NULL);
; 149  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 150  : 				return false;

	je	SHORT $LN20@push@2

; 151  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push@2

; 152  : 			{
; 153  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN20@push@2:

; 154  : 				return false;

	xor	al, al

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push@2:

; 155  : 			}
; 156  : 			else
; 157  : 			{
; 158  : 				count++;
; 159  : 				entry[tail] = item;

	mov	edi, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN13@push@2
	call	__invalid_parameter_noinfo
$LN13@push@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 160  : 				tail = (tail + 1) % (unsigned)entry.size(); 	//advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = ecx
; _r$ = eax

; 3120 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 3121 : 	os << "T[" << r.time << "] ch[" << r.channelID << endl;

	mov	eax, DWORD PTR [edi+392]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	mov	esi, ecx
	mov	ecx, DWORD PTR [edi+12]
	push	OFFSET ??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@
	push	ecx
	push	edx
	push	OFFSET ??_C@_02DCEECEBO@T?$FL?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3122 : 	os << r.timingSpecification << endl;

	mov	eax, DWORD PTR [edi+84]
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	push	eax
	push	OFFSET ??_C@_05MKELIOBI@rtrs?$FL?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3123 : 	os << r.powerModel << endl;

	lea	eax, DWORD PTR [edi+184]
	call	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVPowerConfig@0@@Z ; DRAMsimII::operator<<
	mov	edi, eax
	push	10					; 0000000aH
	mov	ecx, edi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, edi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	pop	edi

; 3124 : 	return os;

	mov	eax, esi
	pop	esi
	pop	ebx

; 3125 : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	__real@41cdcd6500000000
PUBLIC	?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z ; DRAMsimII::Channel::printVerilogCommand
;	COMDAT ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_BSS	SEGMENT
?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA DQ 01H DUP (?) ; `DRAMsimII::Channel::printVerilogCommand'::`2'::lastTime
_BSS	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+009
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
CONST	ENDS
_TEXT	SEGMENT
tv588 = -8						; size = 8
tv237 = -8						; size = 4
tv146 = -8						; size = 4
?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z PROC ; DRAMsimII::Channel::printVerilogCommand
; _this$ = ecx
; _thisCommand$ = eax

; 3041 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, eax

; 3042 : 	static tick lastTime;
; 3043 : 
; 3044 : 	systemConfig.verilogOutStream << "nop(" << (time - lastTime) / systemConfig.getDatarate() * 1.0E9 << "); //" << time - lastTime << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	ecx, DWORD PTR [eax+216]
	test	ecx, ecx
	je	SHORT $LN12@printVeril
	lea	edx, DWORD PTR [eax+224]
	jmp	SHORT $LN13@printVeril
$LN12@printVeril:
	xor	edx, edx
$LN13@printVeril:
	fld	QWORD PTR [eax+336]
	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA
	mov	ecx, DWORD PTR [edi+12]
	sbb	ecx, DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA+4
	mov	DWORD PTR tv588[esp+24], eax
	mov	DWORD PTR tv588[esp+28], ecx
	fild	QWORD PTR tv588[esp+24]
	push	ecx
	push	eax
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	fdivrp	ST(1), ST(0)
	sub	esp, 8
	fmul	QWORD PTR __real@41cdcd6500000000
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04HFDGOAGB@nop?$CI?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3045 : 
; 3046 : 	lastTime = time;
; 3047 : 
; 3048 : 	if (thisCommand->isRead())

	mov	edx, DWORD PTR [esi+80]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA, eax
	mov	DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA+4, ecx
	cmp	edx, 1
	je	SHORT $LN40@printVeril
	cmp	edx, 2
	jne	$LN9@printVeril
$LN40@printVeril:

; 3049 : 	{
; 3050 : 		systemConfig.verilogOutStream << "read\t\t(" << thisCommand->getAddress().getRank() << ",\t"
; 3051 : 			<< thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() <<
; 3052 : 			",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" <<
; 3053 : 			(thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") << "); //" <<
; 3054 : 			time << endl;

	mov	ebx, DWORD PTR [esi+88]
	mov	ebp, OFFSET ??_C@_01GBGANLPD@0?$AA@
	mov	DWORD PTR tv146[esp+24], OFFSET ??_C@_01HIHLOKLC@1?$AA@
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN15@printVeril
	mov	DWORD PTR tv146[esp+24], ebp
$LN15@printVeril:
	cmp	edx, 2
	je	SHORT $LN48@printVeril
	cmp	edx, 4
	je	SHORT $LN48@printVeril
	cmp	edx, 6
	jne	SHORT $LN16@printVeril
$LN48@printVeril:
	mov	ebp, OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN16@printVeril:
	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN18@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN19@printVeril
$LN18@printVeril:
	xor	ebx, ebx
$LN19@printVeril:
	mov	edx, DWORD PTR [esi+72]
	mov	edi, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	eax
	mov	eax, DWORD PTR tv146[esp+32]
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	eax
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ebp
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edi
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	esi
	push	OFFSET ??_C@_07CNLIACOE@read?7?7?$CI?$AA@
$LN141@printVeril:
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN142@printVeril:
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN143@printVeril:
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	pop	edi
	mov	ecx, esi
	pop	esi
	pop	ebp
	pop	ebx

; 3076 : 	}
; 3077 : 
; 3078 : }

	add	esp, 8

; 3049 : 	{
; 3050 : 		systemConfig.verilogOutStream << "read\t\t(" << thisCommand->getAddress().getRank() << ",\t"
; 3051 : 			<< thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() <<
; 3052 : 			",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" <<
; 3053 : 			(thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") << "); //" <<
; 3054 : 			time << endl;

	jmp	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN9@printVeril:

; 3055 : 	}
; 3056 : 	else if (thisCommand->isWrite())

	cmp	edx, 3
	je	SHORT $LN68@printVeril
	cmp	edx, 4
	jne	SHORT $LN7@printVeril
$LN68@printVeril:

; 3057 : 	{
; 3058 : 		systemConfig.verilogOutStream << "write\t\t(" << thisCommand->getAddress().getRank() << ",\t" << thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() << ",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" << (thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") <<
; 3059 : 			",\t0,\t10); //" << time << endl;

	mov	ebx, DWORD PTR [esi+88]
	mov	ebp, OFFSET ??_C@_01GBGANLPD@0?$AA@
	mov	DWORD PTR tv237[esp+24], OFFSET ??_C@_01HIHLOKLC@1?$AA@
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN21@printVeril
	mov	DWORD PTR tv237[esp+24], ebp
$LN21@printVeril:
	cmp	edx, 4
	je	SHORT $LN76@printVeril
	cmp	edx, 6
	jne	SHORT $LN22@printVeril
$LN76@printVeril:
	mov	ebp, OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN22@printVeril:
	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN24@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN25@printVeril
$LN24@printVeril:
	xor	ebx, ebx
$LN25@printVeril:
	mov	edx, DWORD PTR [esi+72]
	mov	edi, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	eax
	mov	eax, DWORD PTR tv237[esp+32]
	push	OFFSET ??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@
	push	eax
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ebp
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edi
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	esi
	push	OFFSET ??_C@_08JDIKLHND@write?7?7?$CI?$AA@
	jmp	$LN141@printVeril
$LN7@printVeril:

; 3060 : 	}
; 3061 : 	else if (thisCommand->isActivate())

	test	edx, edx
	je	SHORT $LN96@printVeril
	cmp	edx, 8
	jne	SHORT $LN5@printVeril
$LN96@printVeril:

; 3062 : 	{
; 3063 : 		systemConfig.verilogOutStream << "activate\t(" << thisCommand->getAddress().getRank() << ",\t" << 
; 3064 : 			thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getRow() << "); //" <<
; 3065 : 			time << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN26@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN27@printVeril
$LN26@printVeril:
	xor	ebx, ebx
$LN27@printVeril:
	mov	edx, DWORD PTR [esi+68]
	mov	edi, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	eax
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	edx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edi
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	esi
	push	OFFSET ??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	jmp	$LN142@printVeril
$LN5@printVeril:

; 3066 : 	}
; 3067 : 	else if (thisCommand->isRefresh())

	cmp	edx, 12					; 0000000cH
	jne	SHORT $LN3@printVeril

; 3068 : 	{
; 3069 : 		systemConfig.verilogOutStream << "refresh(" << thisCommand->getAddress().getRank() << ");" << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	eax, DWORD PTR [edi+216]
	test	eax, eax
	je	SHORT $LN28@printVeril
	lea	eax, DWORD PTR [edi+224]
	jmp	SHORT $LN29@printVeril
$LN28@printVeril:
	xor	eax, eax
$LN29@printVeril:
	mov	esi, DWORD PTR [esi+60]
	push	OFFSET ??_C@_02LJALELK@?$CJ?$DL?$AA@
	push	esi
	push	OFFSET ??_C@_08MCOFLILF@refresh?$CI?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	jmp	$LN143@printVeril
$LN3@printVeril:

; 3070 : 	}
; 3071 : 	else if (thisCommand->isBasicPrecharge())

	cmp	edx, 6
	jne	$LN1@printVeril

; 3072 : 	{
; 3073 : 		systemConfig.verilogOutStream << "precharge\t(" << thisCommand->getAddress().getRank() << ",\t" <<
; 3074 : 			thisCommand->getAddress().getBank() << ",\t" << "0" << "); //" <<
; 3075 : 			time << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN30@printVeril
	add	edi, 224				; 000000e0H
	jmp	SHORT $LN31@printVeril
$LN30@printVeril:
	xor	edi, edi
$LN31@printVeril:
	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	eax
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	edx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	esi
	push	OFFSET ??_C@_0M@EJENEINP@precharge?7?$CI?$AA@
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN1@printVeril:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3076 : 	}
; 3077 : 
; 3078 : }

	add	esp, 8
	ret	0
?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::printVerilogCommand
_TEXT	ENDS
;	COMDAT ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_BSS	SEGMENT
?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRAScount
_BSS	ENDS
;	COMDAT ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASWotherCount
_BSS	ENDS
;	COMDAT ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASotherCount
_BSS	ENDS
;	COMDAT ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASWcount
_BSS	ENDS
;	COMDAT ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCAScount
_BSS	ENDS
;	COMDAT ?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRCDcount
_BSS	ENDS
;	COMDAT ?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRFCcount
_BSS	ENDS
;	COMDAT ?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tFAWcount
_BSS	ENDS
;	COMDAT ?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRPcount
_BSS	ENDS
;	COMDAT ?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRRDcount
_BSS	ENDS
;	COMDAT ?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRCcount
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_BSS	ENDS
_TEXT	SEGMENT
tv971 = -56						; size = 8
tv444 = -56						; size = 4
tv384 = -56						; size = 8
_nextTime$ = -56					; size = 8
_tCASWLimit$223921 = -48				; size = 8
_tCASOtherLimit$223905 = -48				; size = 8
_tRCLimit$223884 = -48					; size = 8
_tCASLimit$223919 = -40					; size = 8
_tRCDLimit$223902 = -40					; size = 8
_tFAWLimit$223888 = -40					; size = 8
tv1092 = -32						; size = 8
_tRASLimit$223918 = -32					; size = 8
_tCASLimit$223903 = -32					; size = 8
_tRRDLimit$223886 = -32					; size = 8
tv463 = -24						; size = 8
_tCASLimit$223935 = -24					; size = 8
_tCASOtherLimit$223920 = -24				; size = 8
_tCASWLimit$223904 = -24				; size = 8
_tRPLimit$223887 = -24					; size = 8
tv1046 = -16						; size = 8
tv957 = -16						; size = 8
tv382 = -16						; size = 8
tv256 = -16						; size = 8
_tRFCLimit$223889 = -16					; size = 8
tv945 = -8						; size = 8
tv569 = -8						; size = 8
tv307 = -8						; size = 8
tv262 = -8						; size = 8
tv181 = -8						; size = 8
tv85 = -8						; size = 8
_tRASLimit$223934 = -8					; size = 8
_tCASWOtherLimit$223922 = -8				; size = 8
_currentCommand$ = 8					; size = 4
?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::earliestExecuteTimeLog
; _this$ = ecx

; 2847 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 60					; 0000003cH
	push	ebx

; 2848 : 	static unsigned tRCcount, tRRDcount, tRPcount, tFAWcount, tRFCcount;
; 2849 : 	static unsigned tRCDcount, tCAScount, tCASWcount, tCASotherCount, tCASWotherCount;
; 2850 : 	static unsigned tRAScount;
; 2851 : 	tick nextTime;	
; 2852 : 
; 2853 : 	const Rank &currentRank = rank[currentCommand->getAddress().getRank()];

	mov	ebx, DWORD PTR _currentCommand$[ebp]
	push	esi
	mov	esi, DWORD PTR [ebx+60]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+416]
	sub	ecx, DWORD PTR [edi+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN104@earliestEx@2
	call	__invalid_parameter_noinfo
$LN104@earliestEx@2:
	imul	esi, 424				; 000001a8H
	add	esi, DWORD PTR [edi+412]

; 2854 : 
; 2855 : 	const Bank &currentBank = currentRank.bank[currentCommand->getAddress().getBank()];

	mov	ebx, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [esi+416]
	sub	ecx, DWORD PTR [esi+412]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebx, ecx
	jb	SHORT $LN113@earliestEx@2
	call	__invalid_parameter_noinfo
$LN113@earliestEx@2:

; 2856 : 
; 2857 : 	switch(currentCommand->getCommandType())

	mov	edx, DWORD PTR _currentCommand$[ebp]
	imul	ebx, 168				; 000000a8H
	add	ebx, DWORD PTR [esi+412]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, ebx
	cmp	eax, 12					; 0000000cH
	ja	$LN1@earliestEx@2
	movzx	eax, BYTE PTR $LN301@earliestEx@2[eax]
	jmp	DWORD PTR $LN395@earliestEx@2[eax*4]
$LN21@earliestEx@2:

; 2858 : 	{
; 2859 : 	case Command::ACTIVATE:
; 2860 : 		{
; 2861 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2862 : 
; 2863 : 			// respect the row cycle time limitation
; 2864 : 			tick tRCLimit = currentBank.getLastRASTime() + timingSpecification.tRC();

	mov	eax, DWORD PTR [edi+60]
	cdq
	add	eax, DWORD PTR [ecx+56]
	adc	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _tRCLimit$223884[esp+72], eax

; 2865 : 
; 2866 : 			const tick lastRASTime = currentRank.lastActivateTimes.front();
; 2867 : 
; 2868 : 			// respect the row-to-row activation delay for different banks within a rank
; 2869 : 			tick tRRDLimit = lastRASTime + timingSpecification.tRRD();				

	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR _tRCLimit$223884[esp+76], edx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+384]
	add	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, edx
	mov	DWORD PTR _tRRDLimit$223886[esp+76], eax

; 2870 : 
; 2871 : 			// respect tRP of same bank
; 2872 : 			tick tRPLimit = currentBank.getLastPrechargeTime() + timingSpecification.tRP();

	mov	eax, DWORD PTR [edi+72]
	cdq
	mov	DWORD PTR _tRRDLimit$223886[esp+72], ebx
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+80]

; 2873 : 
; 2874 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2875 : 			tick tFAWLimit = currentRank.lastActivateTimes.back() + timingSpecification.tFAW();

	mov	eax, DWORD PTR [esi+388]
	adc	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _tRPLimit$223887[esp+72], ebx
	mov	DWORD PTR _tRPLimit$223887[esp+76], edx
	cmp	eax, DWORD PTR [esi+376]
	jne	SHORT $LN134@earliestEx@2
	mov	ecx, DWORD PTR [esi+380]
	jmp	SHORT $LN135@earliestEx@2
$LN134@earliestEx@2:
	mov	ecx, eax
$LN135@earliestEx@2:
	mov	eax, DWORD PTR [edi+52]
	cdq
	add	eax, DWORD PTR [ecx-8]
	adc	edx, DWORD PTR [ecx-4]

; 2876 : 
; 2877 : 			// respect tRFC, refresh cycle time
; 2878 : 			tick tRFCLimit = currentRank.getLastRefreshTime() + timingSpecification.tRFC();
; 2879 : 
; 2880 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));

	mov	ecx, DWORD PTR _tRCLimit$223884[esp+76]
	mov	DWORD PTR _tFAWLimit$223888[esp+72], eax
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR _tFAWLimit$223888[esp+76], edx
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _tRFCLimit$223889[esp+72], eax
	cmp	edx, ecx
	jl	SHORT $LN26@earliestEx@2
	jg	SHORT $LN302@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$223884[esp+72]
	jbe	SHORT $LN26@earliestEx@2
$LN302@earliestEx@2:
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN27@earliestEx@2
$LN26@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$223884[esp+72]
$LN27@earliestEx@2:
	cmp	ecx, DWORD PTR _tRPLimit$223887[esp+76]
	jl	SHORT $LN30@earliestEx@2
	jg	SHORT $LN303@earliestEx@2
	cmp	esi, ebx
	jbe	SHORT $LN30@earliestEx@2
$LN303@earliestEx@2:
	cmp	edx, DWORD PTR _tRCLimit$223884[esp+76]
	jl	SHORT $LN28@earliestEx@2
	jg	SHORT $LN304@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$223884[esp+72]
	jbe	SHORT $LN28@earliestEx@2
$LN304@earliestEx@2:
	mov	ebx, DWORD PTR _tRFCLimit$223889[esp+72]
	mov	esi, edx
	jmp	SHORT $LN31@earliestEx@2
$LN28@earliestEx@2:
	mov	ebx, DWORD PTR _tRCLimit$223884[esp+72]
	mov	esi, DWORD PTR _tRCLimit$223884[esp+76]
	jmp	SHORT $LN31@earliestEx@2
$LN30@earliestEx@2:
	mov	ebx, DWORD PTR _tRPLimit$223887[esp+72]
	mov	esi, DWORD PTR _tRPLimit$223887[esp+76]
$LN31@earliestEx@2:
	mov	ecx, DWORD PTR _tFAWLimit$223888[esp+76]
	cmp	DWORD PTR _tRRDLimit$223886[esp+76], ecx
	jl	SHORT $LN32@earliestEx@2
	jg	SHORT $LN305@earliestEx@2
	mov	eax, DWORD PTR _tFAWLimit$223888[esp+72]
	cmp	DWORD PTR _tRRDLimit$223886[esp+72], eax
	jbe	SHORT $LN32@earliestEx@2
$LN305@earliestEx@2:
	mov	eax, DWORD PTR _tRRDLimit$223886[esp+72]
	mov	ecx, DWORD PTR _tRRDLimit$223886[esp+76]
	jmp	SHORT $LN33@earliestEx@2
$LN32@earliestEx@2:
	mov	eax, DWORD PTR _tFAWLimit$223888[esp+72]
	mov	ecx, DWORD PTR _tFAWLimit$223888[esp+76]
$LN33@earliestEx@2:
	cmp	esi, ecx
	jl	SHORT $LN42@earliestEx@2
	jg	SHORT $LN306@earliestEx@2
	cmp	ebx, eax
	jbe	SHORT $LN42@earliestEx@2
$LN306@earliestEx@2:
	cmp	edx, DWORD PTR _tRCLimit$223884[esp+76]
	jl	SHORT $LN34@earliestEx@2
	jg	SHORT $LN307@earliestEx@2
	mov	ecx, DWORD PTR _tRCLimit$223884[esp+72]
	cmp	DWORD PTR _tRFCLimit$223889[esp+72], ecx
	jbe	SHORT $LN34@earliestEx@2
$LN307@earliestEx@2:
	mov	eax, DWORD PTR _tRFCLimit$223889[esp+72]
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN35@earliestEx@2
$LN34@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$223884[esp+72]
	mov	ecx, DWORD PTR _tRCLimit$223884[esp+76]
	mov	eax, DWORD PTR _tRFCLimit$223889[esp+72]
$LN35@earliestEx@2:
	mov	ebx, DWORD PTR _tRPLimit$223887[esp+76]
	cmp	ecx, ebx
	jl	SHORT $LN38@earliestEx@2
	jg	SHORT $LN308@earliestEx@2
	cmp	esi, DWORD PTR _tRPLimit$223887[esp+72]
	jbe	SHORT $LN38@earliestEx@2
$LN308@earliestEx@2:
	mov	ecx, DWORD PTR _tRCLimit$223884[esp+76]
	cmp	edx, ecx
	jl	SHORT $LN36@earliestEx@2
	jg	SHORT $LN309@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$223884[esp+72]
	jbe	SHORT $LN36@earliestEx@2
$LN309@earliestEx@2:
	mov	esi, eax
	mov	eax, edx
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN41@earliestEx@2
$LN36@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$223884[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ecx
	mov	eax, ecx
	jmp	SHORT $LN298@earliestEx@2
$LN38@earliestEx@2:
	mov	esi, DWORD PTR _tRPLimit$223887[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ebx
	jmp	SHORT $LN388@earliestEx@2
$LN42@earliestEx@2:
	mov	ecx, DWORD PTR _tRRDLimit$223886[esp+76]
	mov	eax, DWORD PTR _tFAWLimit$223888[esp+76]
	cmp	ecx, eax
	jl	SHORT $LN40@earliestEx@2
	jg	SHORT $LN310@earliestEx@2
	mov	esi, DWORD PTR _tRRDLimit$223886[esp+72]
	cmp	esi, DWORD PTR _tFAWLimit$223888[esp+72]
	jbe	SHORT $LN40@earliestEx@2
$LN310@earliestEx@2:
	mov	esi, DWORD PTR _tRRDLimit$223886[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ecx
	jmp	SHORT $LN388@earliestEx@2
$LN40@earliestEx@2:
	mov	esi, DWORD PTR _tFAWLimit$223888[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
$LN388@earliestEx@2:
	mov	eax, DWORD PTR _nextTime$[esp+76]
$LN41@earliestEx@2:

; 2881 : 
; 2882 : 			if (nextTime == tRCLimit)

	cmp	esi, DWORD PTR _tRCLimit$223884[esp+72]
	jne	SHORT $LN20@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$223884[esp+76]
	jne	SHORT $LN20@earliestEx@2
$LN298@earliestEx@2:

; 2883 : 				tRCcount++;				

	inc	DWORD PTR ?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN20@earliestEx@2:

; 2884 : 			if (nextTime == tRRDLimit)

	cmp	esi, DWORD PTR _tRRDLimit$223886[esp+72]
	jne	SHORT $LN378@earliestEx@2
	cmp	eax, DWORD PTR _tRRDLimit$223886[esp+76]
	jne	SHORT $LN378@earliestEx@2

; 2885 : 				tRRDcount++;

	mov	ecx, 1
	add	DWORD PTR ?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
	jmp	SHORT $LN19@earliestEx@2
$LN378@earliestEx@2:
	mov	ecx, 1
$LN19@earliestEx@2:

; 2886 : 			if (nextTime == tRPLimit)

	cmp	esi, DWORD PTR _tRPLimit$223887[esp+72]
	jne	SHORT $LN18@earliestEx@2
	cmp	eax, DWORD PTR _tRPLimit$223887[esp+76]
	jne	SHORT $LN18@earliestEx@2

; 2887 : 				tRPcount++;

	add	DWORD PTR ?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
$LN18@earliestEx@2:

; 2888 : 			if (nextTime == tFAWLimit)

	cmp	esi, DWORD PTR _tFAWLimit$223888[esp+72]
	jne	SHORT $LN17@earliestEx@2
	cmp	eax, DWORD PTR _tFAWLimit$223888[esp+76]
	jne	SHORT $LN17@earliestEx@2

; 2889 : 				tFAWcount++;

	add	DWORD PTR ?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
$LN17@earliestEx@2:

; 2890 : 			if (nextTime == tRFCLimit)

	cmp	esi, DWORD PTR _tRFCLimit$223889[esp+72]
	jne	$LN22@earliestEx@2
	cmp	eax, edx
	jne	$LN22@earliestEx@2

; 2891 : 				tRFCcount++;

	add	DWORD PTR ?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx

; 2892 : 
; 2893 : 			assert(nextTime >= currentBank.getLastPrechargeTime() + timingSpecification.tRP());
; 2894 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2895 : 		}
; 2896 : 		break;

	jmp	$LN22@earliestEx@2
$LN15@earliestEx@2:

; 2897 : 
; 2898 : 	case Command::READ_AND_PRECHARGE:
; 2899 : 		// Auto precharge will be issued as part of command,
; 2900 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2901 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2902 : 
; 2903 : 	case Command::READ:
; 2904 : 		{
; 2905 : 			//respect last RAS of same rank
; 2906 : 			tick tRCDLimit = currentBank.getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());

	mov	eax, DWORD PTR [edi+64]
	sub	eax, DWORD PTR [edi+28]
	cdq
	add	eax, DWORD PTR [ecx+56]
	adc	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _tRCDLimit$223902[esp+72], eax

; 2907 : 
; 2908 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2909 : 			// this as if a CAS command was issued long ago
; 2910 : 
; 2911 : 			// respect last CAS of same rank
; 2912 : 			// DW 3/9/2006 add these two lines
; 2913 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2914 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2915 : 			// DW 3/9/2006 replace the line after next with the next line
; 2916 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2917 : 			tick tCASLimit = currentRank.getLastCASTime() + timingSpecification.tBurst();

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR _tRCDLimit$223902[esp+76], edx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+24]
	add	eax, ebx
	mov	DWORD PTR _tCASLimit$223903[esp+72], eax
	mov	eax, DWORD PTR [esi+28]
	adc	eax, edx
	mov	DWORD PTR _tCASLimit$223903[esp+76], eax

; 2918 : 
; 2919 : 			// respect last CASW of same rank
; 2920 : 			// DW 3/9/2006 replace the line after next with the next line
; 2921 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2922 : 			tick tCASWLimit = currentRank.getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR();

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR tv945[esp+76], edx
	cdq
	mov	DWORD PTR tv957[esp+72], eax
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR tv957[esp+76], edx
	cdq
	mov	ecx, eax
	add	ecx, DWORD PTR [esi+32]

; 2923 : 
; 2924 : 			//respect most recent CAS of different rank
; 2925 : 			tick tCASOtherLimit = currentRank.getOtherLastCASTime() + currentRank.getOtherLastCASLength() + timingSpecification.tRTRS();

	mov	eax, DWORD PTR [edi+84]
	adc	edx, DWORD PTR [esi+36]
	add	ecx, DWORD PTR tv957[esp+72]
	adc	edx, DWORD PTR tv957[esp+76]
	add	ecx, ebx
	adc	edx, DWORD PTR tv945[esp+76]
	mov	ebx, DWORD PTR [esi+120]
	mov	DWORD PTR _tCASWLimit$223904[esp+76], edx
	cdq
	mov	DWORD PTR tv971[esp+76], edx
	xor	edx, edx
	add	ebx, DWORD PTR [esi+40]
	mov	DWORD PTR tv971[esp+72], eax
	adc	edx, DWORD PTR [esi+44]
	add	ebx, eax
	adc	edx, DWORD PTR tv971[esp+76]

; 2926 : 			//respect timing of READ follow WRITE, different ranks
; 2927 : 			tick tCASWOtherLimit = currentRank.getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank.getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS();

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _tCASOtherLimit$223905[esp+72], ebx
	mov	ebx, DWORD PTR [esi+124]
	mov	DWORD PTR _tCASOtherLimit$223905[esp+76], edx
	cdq
	sub	ebx, eax
	mov	DWORD PTR tv85[esp+76], 0
	mov	eax, DWORD PTR tv85[esp+76]
	sbb	eax, edx
	add	ebx, DWORD PTR [esi+48]

; 2928 : 
; 2929 : 			nextTime = max(max(tRCDLimit,tCASLimit),max(max(tCASWLimit,tCASOtherLimit),tCASWOtherLimit));

	mov	edx, DWORD PTR _tRCDLimit$223902[esp+76]
	adc	eax, DWORD PTR [esi+52]
	add	ebx, DWORD PTR tv971[esp+72]
	adc	eax, DWORD PTR tv971[esp+76]
	add	ebx, DWORD PTR tv957[esp+72]
	adc	eax, DWORD PTR tv957[esp+76]
	cmp	edx, DWORD PTR _tCASLimit$223903[esp+76]
	jl	SHORT $LN44@earliestEx@2
	jg	SHORT $LN311@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$223903[esp+72]
	jbe	SHORT $LN44@earliestEx@2
$LN311@earliestEx@2:
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+72]
	mov	DWORD PTR tv256[esp+72], edx
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+76]
	jmp	SHORT $LN389@earliestEx@2
$LN44@earliestEx@2:
	mov	edx, DWORD PTR _tCASLimit$223903[esp+72]
	mov	DWORD PTR tv256[esp+72], edx
	mov	edx, DWORD PTR _tCASLimit$223903[esp+76]
$LN389@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$223904[esp+76]
	cmp	esi, DWORD PTR _tCASOtherLimit$223905[esp+76]
	mov	DWORD PTR tv256[esp+76], edx
	jl	SHORT $LN46@earliestEx@2
	jg	SHORT $LN312@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	jbe	SHORT $LN46@earliestEx@2
$LN312@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN47@earliestEx@2
$LN46@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	mov	esi, DWORD PTR _tCASOtherLimit$223905[esp+76]
$LN47@earliestEx@2:
	cmp	esi, eax
	jl	SHORT $LN50@earliestEx@2
	jg	SHORT $LN313@earliestEx@2
	cmp	edx, ebx
	jbe	SHORT $LN50@earliestEx@2
$LN313@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$223904[esp+76]
	mov	esi, DWORD PTR _tCASOtherLimit$223905[esp+76]
	cmp	edx, esi
	jl	SHORT $LN48@earliestEx@2
	jg	SHORT $LN314@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	jbe	SHORT $LN48@earliestEx@2
$LN314@earliestEx@2:
	mov	DWORD PTR tv262[esp+72], ecx
	jmp	SHORT $LN51@earliestEx@2
$LN48@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	mov	DWORD PTR tv262[esp+72], edx
	mov	edx, esi
	jmp	SHORT $LN51@earliestEx@2
$LN50@earliestEx@2:
	mov	DWORD PTR tv262[esp+72], ebx
	mov	edx, eax
$LN51@earliestEx@2:
	cmp	DWORD PTR tv256[esp+76], edx
	jl	SHORT $LN60@earliestEx@2
	jg	SHORT $LN315@earliestEx@2
	mov	edx, DWORD PTR tv262[esp+72]
	cmp	DWORD PTR tv256[esp+72], edx
	jbe	SHORT $LN60@earliestEx@2
$LN315@earliestEx@2:
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+76]
	cmp	edx, DWORD PTR _tCASLimit$223903[esp+76]
	jl	SHORT $LN52@earliestEx@2
	jg	SHORT $LN316@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$223903[esp+72]
	jbe	SHORT $LN52@earliestEx@2
$LN316@earliestEx@2:
	mov	esi, DWORD PTR _tRCDLimit$223902[esp+72]
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+76]
	mov	DWORD PTR _nextTime$[esp+72], esi
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN299@earliestEx@2
$LN52@earliestEx@2:
	mov	edx, DWORD PTR _tCASLimit$223903[esp+76]
	mov	esi, DWORD PTR _tCASLimit$223903[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN60@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$223904[esp+76]
	cmp	esi, DWORD PTR _tCASOtherLimit$223905[esp+76]
	jl	SHORT $LN54@earliestEx@2
	jg	SHORT $LN317@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	jbe	SHORT $LN54@earliestEx@2
$LN317@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN55@earliestEx@2
$LN54@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	mov	esi, DWORD PTR _tCASOtherLimit$223905[esp+76]
$LN55@earliestEx@2:
	cmp	esi, eax
	jl	SHORT $LN58@earliestEx@2
	jg	SHORT $LN318@earliestEx@2
	cmp	edx, ebx
	jbe	SHORT $LN58@earliestEx@2
$LN318@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$223904[esp+76]
	cmp	edx, DWORD PTR _tCASOtherLimit$223905[esp+76]
	jl	SHORT $LN56@earliestEx@2
	jg	SHORT $LN319@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$223905[esp+72]
	jbe	SHORT $LN56@earliestEx@2
$LN319@earliestEx@2:
	mov	esi, ecx
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN56@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223905[esp+76]
	mov	esi, DWORD PTR _tCASOtherLimit$223905[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN58@earliestEx@2:
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], eax
$LN390@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+72], esi

; 2930 : 
; 2931 : 			if (nextTime == tRCDLimit)

	cmp	esi, DWORD PTR _tRCDLimit$223902[esp+72]
	jne	SHORT $LN14@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$223902[esp+76]
	cmp	DWORD PTR _nextTime$[esp+76], edx
	jne	SHORT $LN14@earliestEx@2
$LN299@earliestEx@2:

; 2932 : 				tRCDcount++;				

	inc	DWORD PTR ?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN14@earliestEx@2:

; 2933 : 			if (nextTime == tCASLimit)

	mov	edx, DWORD PTR _nextTime$[esp+76]
	cmp	esi, DWORD PTR _tCASLimit$223903[esp+72]
	jne	SHORT $LN13@earliestEx@2

; 2934 : 				tCAScount++;

	mov	esi, DWORD PTR _nextTime$[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$223903[esp+76]
	jne	SHORT $LN13@earliestEx@2
	inc	DWORD PTR ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN13@earliestEx@2:

; 2935 : 			if (nextTime == tCASWLimit)

	cmp	esi, ecx
	jne	SHORT $LN12@earliestEx@2
	cmp	edx, DWORD PTR _tCASWLimit$223904[esp+76]
	jne	SHORT $LN12@earliestEx@2

; 2936 : 				tCASWcount++;

	inc	DWORD PTR ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN12@earliestEx@2:

; 2937 : 			if (nextTime == tCASOtherLimit)

	cmp	esi, DWORD PTR _tCASOtherLimit$223905[esp+72]
	jne	SHORT $LN11@earliestEx@2
	cmp	edx, DWORD PTR _tCASOtherLimit$223905[esp+76]
	jne	SHORT $LN11@earliestEx@2

; 2938 : 				tCASotherCount++;

	inc	DWORD PTR ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN11@earliestEx@2:

; 2939 : 			if (nextTime == tCASWOtherLimit)

	cmp	esi, ebx
	jne	$LN22@earliestEx@2
	cmp	DWORD PTR _nextTime$[esp+76], eax
	jne	$LN22@earliestEx@2

; 2940 : 				tCASWotherCount++;

	inc	DWORD PTR ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA

; 2941 : 
; 2942 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2943 : 		}
; 2944 : 		break;

	jmp	$LN22@earliestEx@2
$LN9@earliestEx@2:

; 2945 : 
; 2946 : 	case Command::WRITE_AND_PRECHARGE:
; 2947 : 		// Auto precharge will be issued as part of command, so
; 2948 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2949 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2950 : 		// has the exact same timing requirements as a simple WRITE.
; 2951 : 
; 2952 : 	case Command::WRITE:
; 2953 : 		{
; 2954 : 			//respect last RAS of same rank
; 2955 : 			tick tRASLimit = currentBank.getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();

	mov	eax, DWORD PTR [edi+64]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR tv181[esp+76], edx
	cdq
	sub	ebx, eax
	mov	eax, DWORD PTR tv181[esp+76]
	sbb	eax, edx
	add	ebx, DWORD PTR [ecx+56]
	adc	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR _tRASLimit$223918[esp+72], ebx
	mov	DWORD PTR _tRASLimit$223918[esp+76], eax

; 2956 : 
; 2957 : 			// DW 3/9/2006 add these two lines
; 2958 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2959 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2960 : 
; 2961 : 			// respect last cas to same rank
; 2962 : 			// DW 3/9/2006 replace the line after next with the next line
; 2963 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2964 : 			tick tCASLimit = max(time,currentRank.getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD());

	mov	eax, DWORD PTR [edi+32]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ecx, edx
	cdq
	sub	ebx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ecx, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ecx, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [edi+12]
	adc	ecx, edx
	add	ebx, DWORD PTR [esi+24]
	adc	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN62@earliestEx@2
	jg	SHORT $LN320@earliestEx@2
	cmp	DWORD PTR [edi+8], ebx
	jbe	SHORT $LN62@earliestEx@2
$LN320@earliestEx@2:
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _tCASLimit$223919[esp+76], eax
	jmp	SHORT $LN391@earliestEx@2
$LN62@earliestEx@2:
	mov	eax, DWORD PTR [edi+32]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ebx, edx
	cdq
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ebx, edx
	cdq
	add	ecx, eax
	adc	ebx, edx
	add	ecx, DWORD PTR [esi+24]
	adc	ebx, DWORD PTR [esi+28]
	mov	DWORD PTR _tCASLimit$223919[esp+76], ebx
$LN391@earliestEx@2:

; 2965 : 
; 2966 : 			// respect last cas to different ranks
; 2967 : 			tick tCASOtherLimit = currentRank.getOtherLastCASTime() + timingSpecification.tCAS() + currentRank.getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	eax, DWORD PTR [edi+48]
	xor	ebx, ebx
	cdq
	mov	DWORD PTR _tCASLimit$223919[esp+72], ecx
	mov	ecx, DWORD PTR [esi+120]
	add	ecx, DWORD PTR [esi+40]

; 2968 : 
; 2969 : 			// respect last cas write to same rank
; 2970 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2971 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2972 : 			tick tCASWLimit = currentRank.getLastCASWTime() + currentRank.getLastCASWLength();
; 2973 : 
; 2974 : 			// respect last CASW to different ranks
; 2975 : 			// TODO: should this not also be -tAL?
; 2976 : 			tick tCASWOtherLimit = currentRank.getOtherLastCASWTime() + currentRank.getOtherLastCASWLength() + timingSpecification.tOST();

	mov	DWORD PTR tv307[esp+76], 0
	adc	ebx, DWORD PTR [esi+44]
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [esi+116]
	adc	ebx, edx
	xor	edx, edx
	add	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _tCASOtherLimit$223920[esp+76], ebx
	adc	edx, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR [esi+124]
	mov	DWORD PTR _tCASWLimit$223921[esp+72], eax
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR _tCASWLimit$223921[esp+76], edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR tv307[esp+76]
	adc	eax, edx
	add	ebx, DWORD PTR [esi+48]

; 2977 : 
; 2978 : 			nextTime = max(max(tRASLimit,tCASLimit), max(max(tCASOtherLimit,tCASWOtherLimit),tCASWLimit));

	mov	edx, DWORD PTR _tCASLimit$223919[esp+76]
	adc	eax, DWORD PTR [esi+52]
	cmp	DWORD PTR _tRASLimit$223918[esp+76], edx
	mov	DWORD PTR _tCASWOtherLimit$223922[esp+76], eax
	jl	SHORT $LN64@earliestEx@2
	jg	SHORT $LN321@earliestEx@2
	mov	esi, DWORD PTR _tRASLimit$223918[esp+72]
	cmp	esi, DWORD PTR _tCASLimit$223919[esp+72]
	jbe	SHORT $LN64@earliestEx@2
$LN321@earliestEx@2:
	mov	edx, DWORD PTR _tRASLimit$223918[esp+72]
	mov	DWORD PTR tv382[esp+72], edx
	mov	edx, DWORD PTR _tRASLimit$223918[esp+76]
	jmp	SHORT $LN392@earliestEx@2
$LN64@earliestEx@2:
	mov	esi, DWORD PTR _tCASLimit$223919[esp+72]
	mov	DWORD PTR tv382[esp+72], esi
$LN392@earliestEx@2:
	mov	esi, DWORD PTR _tCASOtherLimit$223920[esp+76]
	cmp	esi, eax
	mov	DWORD PTR tv382[esp+76], edx
	jl	SHORT $LN66@earliestEx@2
	jg	SHORT $LN322@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN66@earliestEx@2
$LN322@earliestEx@2:
	mov	DWORD PTR tv384[esp+72], ecx
	jmp	SHORT $LN67@earliestEx@2
$LN66@earliestEx@2:
	mov	DWORD PTR tv384[esp+72], ebx
	mov	esi, eax
$LN67@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$223921[esp+76]
	cmp	esi, edx
	jl	SHORT $LN70@earliestEx@2
	jg	SHORT $LN323@earliestEx@2
	mov	esi, DWORD PTR tv384[esp+72]
	cmp	esi, DWORD PTR _tCASWLimit$223921[esp+72]
	jbe	SHORT $LN70@earliestEx@2
$LN323@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223920[esp+76]
	cmp	edx, eax
	jl	SHORT $LN68@earliestEx@2
	jg	SHORT $LN324@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN68@earliestEx@2
$LN324@earliestEx@2:
	mov	esi, ecx
	jmp	SHORT $LN393@earliestEx@2
$LN68@earliestEx@2:
	mov	esi, ebx
	jmp	SHORT $LN71@earliestEx@2
$LN70@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$223921[esp+72]
$LN393@earliestEx@2:
	mov	eax, edx
$LN71@earliestEx@2:
	cmp	DWORD PTR tv382[esp+76], eax
	jl	SHORT $LN80@earliestEx@2
	jg	SHORT $LN325@earliestEx@2
	cmp	DWORD PTR tv382[esp+72], esi
	jbe	SHORT $LN80@earliestEx@2
$LN325@earliestEx@2:
	mov	eax, DWORD PTR _tCASLimit$223919[esp+76]
	cmp	DWORD PTR _tRASLimit$223918[esp+76], eax
	jl	SHORT $LN72@earliestEx@2
	jg	SHORT $LN326@earliestEx@2
	mov	edx, DWORD PTR _tRASLimit$223918[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$223919[esp+72]
	jbe	SHORT $LN72@earliestEx@2
$LN326@earliestEx@2:
	mov	eax, DWORD PTR _tRASLimit$223918[esp+76]
	mov	esi, DWORD PTR _tRASLimit$223918[esp+72]

; 2981 : 				tRAScount++;				

	inc	DWORD PTR ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	$LN8@earliestEx@2
$LN72@earliestEx@2:

; 2977 : 
; 2978 : 			nextTime = max(max(tRASLimit,tCASLimit), max(max(tCASOtherLimit,tCASWOtherLimit),tCASWLimit));

	mov	esi, DWORD PTR _tCASLimit$223919[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN79@earliestEx@2
$LN80@earliestEx@2:
	mov	eax, DWORD PTR _tCASOtherLimit$223920[esp+76]
	mov	esi, DWORD PTR _tCASWOtherLimit$223922[esp+76]
	cmp	eax, esi
	jl	SHORT $LN74@earliestEx@2
	jg	SHORT $LN327@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN74@earliestEx@2
$LN327@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN75@earliestEx@2
$LN74@earliestEx@2:
	mov	edx, ebx
	mov	eax, esi
$LN75@earliestEx@2:
	cmp	eax, DWORD PTR _tCASWLimit$223921[esp+76]
	jl	SHORT $LN78@earliestEx@2
	jg	SHORT $LN328@earliestEx@2
	cmp	edx, DWORD PTR _tCASWLimit$223921[esp+72]
	jbe	SHORT $LN78@earliestEx@2
$LN328@earliestEx@2:
	mov	eax, DWORD PTR _tCASWOtherLimit$223922[esp+76]
	cmp	DWORD PTR _tCASOtherLimit$223920[esp+76], eax
	jl	SHORT $LN76@earliestEx@2
	jg	SHORT $LN329@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN76@earliestEx@2
$LN329@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$223920[esp+76]
	mov	esi, ecx
	jmp	SHORT $LN394@earliestEx@2
$LN76@earliestEx@2:
	mov	eax, DWORD PTR _tCASWOtherLimit$223922[esp+76]
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN79@earliestEx@2
$LN78@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$223921[esp+72]
	mov	edx, DWORD PTR _tCASWLimit$223921[esp+76]
$LN394@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+76], edx
$LN79@earliestEx@2:

; 2979 : 
; 2980 : 			if (nextTime == tRASLimit)

	cmp	esi, DWORD PTR _tRASLimit$223918[esp+72]
	jne	SHORT $LN358@earliestEx@2
	mov	eax, DWORD PTR _tRASLimit$223918[esp+76]
	cmp	DWORD PTR _nextTime$[esp+76], eax
	jne	SHORT $LN358@earliestEx@2
	mov	eax, DWORD PTR _nextTime$[esp+76]

; 2981 : 				tRAScount++;				

	inc	DWORD PTR ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
	jmp	SHORT $LN8@earliestEx@2
$LN358@earliestEx@2:
	mov	eax, DWORD PTR _nextTime$[esp+76]
$LN8@earliestEx@2:

; 2982 : 			if (nextTime == tCASLimit)

	cmp	esi, DWORD PTR _tCASLimit$223919[esp+72]
	jne	SHORT $LN7@earliestEx@2
	cmp	eax, DWORD PTR _tCASLimit$223919[esp+76]
	jne	SHORT $LN7@earliestEx@2

; 2983 : 				tCAScount++;

	inc	DWORD PTR ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN7@earliestEx@2:

; 2984 : 			if (nextTime == tCASWLimit)

	cmp	esi, DWORD PTR _tCASWLimit$223921[esp+72]
	jne	SHORT $LN6@earliestEx@2
	cmp	eax, DWORD PTR _tCASWLimit$223921[esp+76]
	jne	SHORT $LN6@earliestEx@2

; 2985 : 				tCASWcount++;

	inc	DWORD PTR ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN6@earliestEx@2:

; 2986 : 			if (nextTime == tCASOtherLimit)

	cmp	esi, ecx
	jne	SHORT $LN5@earliestEx@2
	cmp	eax, DWORD PTR _tCASOtherLimit$223920[esp+76]
	jne	SHORT $LN5@earliestEx@2

; 2987 : 				tCASotherCount++;

	inc	DWORD PTR ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN5@earliestEx@2:

; 2988 : 			if (nextTime == tCASWOtherLimit)

	cmp	esi, ebx
	jne	$LN22@earliestEx@2
	mov	ecx, DWORD PTR _nextTime$[esp+76]
	cmp	ecx, DWORD PTR _tCASWOtherLimit$223922[esp+76]
	jne	$LN22@earliestEx@2

; 2989 : 				tCASWotherCount++;

	inc	DWORD PTR ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA

; 2990 : 		}
; 2991 : 		break;

	jmp	$LN22@earliestEx@2
$LN3@earliestEx@2:

; 2992 : 
; 2993 : 	case Command::PRECHARGE:
; 2994 : 		{
; 2995 : 			// respect t_ras of same bank
; 2996 : 			tick tRASLimit = currentBank.getLastRASTime() + timingSpecification.tRAS();

	mov	eax, DWORD PTR [edi+56]

; 2997 : 
; 2998 : 			// respect t_cas of same bank
; 2999 : 			// TODO: do not need tAL for these
; 3000 : 			//tick tCASLimit = max(time,currentBank.getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 3001 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 3002 : 			tick tCASLimit = max(time,currentBank.getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));

	mov	esi, DWORD PTR [edi+80]
	cdq
	add	eax, DWORD PTR [ecx+56]
	adc	edx, DWORD PTR [ecx+60]
	sub	esi, DWORD PTR [edi+44]
	mov	DWORD PTR _tRASLimit$223934[esp+76], edx
	mov	edx, 0
	sets	dl
	mov	DWORD PTR _tRASLimit$223934[esp+72], eax
	mov	eax, DWORD PTR [edi+32]
	dec	edx
	and	edx, esi
	mov	DWORD PTR tv444[esp+72], edx
	cdq
	mov	DWORD PTR tv1046[esp+72], eax
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR tv1046[esp+76], edx
	cdq
	add	eax, DWORD PTR [ecx+64]
	adc	edx, DWORD PTR [ecx+68]
	mov	ebx, eax
	add	ebx, DWORD PTR tv1046[esp+72]
	mov	eax, edx
	adc	eax, DWORD PTR tv1046[esp+76]
	mov	DWORD PTR tv1092[esp+76], eax
	mov	eax, DWORD PTR tv444[esp+72]
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR tv1092[esp+76]
	mov	DWORD PTR tv463[esp+72], eax
	cmp	DWORD PTR [edi+12], edx
	jl	SHORT $LN86@earliestEx@2
	jg	SHORT $LN330@earliestEx@2
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR tv463[esp+72]
	jbe	SHORT $LN86@earliestEx@2
$LN330@earliestEx@2:
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _tCASLimit$223935[esp+72], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _tCASLimit$223935[esp+76], eax
	jmp	SHORT $LN87@earliestEx@2
$LN86@earliestEx@2:
	xor	eax, eax
	test	esi, esi
	setl	al
	dec	eax
	and	eax, esi
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR tv1092[esp+76]
	mov	DWORD PTR _tCASLimit$223935[esp+72], eax
	mov	DWORD PTR _tCASLimit$223935[esp+76], edx
$LN87@earliestEx@2:

; 3003 : 
; 3004 : 			// respect t_casw of same bank
; 3005 : 			//tCASLimit = max(tCASLimit,currentBank.getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 3006 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 3007 : 			tCASLimit = max(tCASLimit,currentBank.getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());

	mov	eax, DWORD PTR [edi+88]
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ebx, edx
	cdq
	add	esi, eax
	adc	ebx, edx
	add	esi, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _tCASLimit$223935[esp+76]
	adc	ebx, DWORD PTR [ecx+76]
	mov	ecx, esi
	add	ecx, DWORD PTR tv1046[esp+72]
	mov	eax, ebx
	adc	eax, DWORD PTR tv1046[esp+76]
	cmp	edx, eax
	jg	SHORT $LN339@earliestEx@2
	jl	SHORT $LN331@earliestEx@2
	mov	esi, DWORD PTR _tCASLimit$223935[esp+72]
	cmp	esi, ecx
	ja	SHORT $LN89@earliestEx@2
$LN331@earliestEx@2:
	mov	esi, ecx
	mov	edx, eax
	jmp	SHORT $LN89@earliestEx@2
$LN339@earliestEx@2:
	mov	esi, DWORD PTR _tCASLimit$223935[esp+72]
$LN89@earliestEx@2:

; 3008 : 
; 3009 : 			nextTime = max(tRASLimit,tCASLimit);

	mov	eax, DWORD PTR _tRASLimit$223934[esp+76]
	cmp	eax, edx
	jl	SHORT $LN90@earliestEx@2
	jg	SHORT $LN332@earliestEx@2
	cmp	DWORD PTR _tRASLimit$223934[esp+72], esi
	jbe	SHORT $LN90@earliestEx@2
$LN332@earliestEx@2:
	mov	esi, DWORD PTR _tRASLimit$223934[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN22@earliestEx@2
$LN2@earliestEx@2:

; 3010 : 		}
; 3011 : 		break;
; 3012 : 
; 3013 : 	case Command::REFRESH_ALL:
; 3014 : 		// respect tRFC and tRP
; 3015 : 		nextTime = max(currentRank.getLastRefreshTime() + timingSpecification.tRFC(), currentRank.getLastPrechargeTime() + timingSpecification.tRP());

	mov	eax, DWORD PTR [edi+72]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edi+68]
	mov	ecx, edx
	adc	ecx, DWORD PTR [esi+20]
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	cmp	edx, ecx
	jl	SHORT $LN92@earliestEx@2
	jg	SHORT $LN333@earliestEx@2
	cmp	eax, ebx
	jbe	SHORT $LN92@earliestEx@2
$LN333@earliestEx@2:
	mov	esi, eax
$LN90@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN22@earliestEx@2
$LN92@earliestEx@2:
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], ecx

; 3016 : 		break;

	jmp	SHORT $LN22@earliestEx@2
$LN1@earliestEx@2:

; 3017 : 
; 3018 : 	case Command::RETIRE_COMMAND:
; 3019 : 	case Command::PRECHARGE_ALL:
; 3020 : 	case Command::ACTIVATE_ALL:
; 3021 : 	case Command::DRIVE_COMMAND:
; 3022 : 	case Command::DATA_COMMAND:
; 3023 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 3024 : 	case Command::SELF_REFRESH:
; 3025 : 	case Command::DESELECT:
; 3026 : 	case Command::NOOP:
; 3027 : 	case Command::INVALID_COMMAND:
; 3028 : 	default:
; 3029 : 		cerr << "Unsupported command encountered." << endl;

	push	OFFSET ??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3030 : 		nextTime = 0;

	xor	esi, esi
	mov	DWORD PTR _nextTime$[esp+76], esi
$LN22@earliestEx@2:

; 3031 : 		break;
; 3032 : 	}
; 3033 : 
; 3034 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 3035 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 3036 : 	return max(nextTime, max(time , lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+8]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	mov	edi, DWORD PTR [edi+12]
	cmp	edi, edx
	jl	SHORT $LN94@earliestEx@2
	jg	SHORT $LN334@earliestEx@2
	cmp	ecx, eax
	jbe	SHORT $LN94@earliestEx@2
$LN334@earliestEx@2:
	mov	DWORD PTR tv569[esp+72], ecx
	mov	ebx, edi
	jmp	SHORT $LN95@earliestEx@2
$LN94@earliestEx@2:
	mov	DWORD PTR tv569[esp+72], eax
	mov	ebx, edx
$LN95@earliestEx@2:
	cmp	DWORD PTR _nextTime$[esp+76], ebx
	jl	SHORT $LN98@earliestEx@2
	jg	SHORT $LN335@earliestEx@2
	cmp	esi, DWORD PTR tv569[esp+72]
	jbe	SHORT $LN98@earliestEx@2
$LN335@earliestEx@2:
	mov	edx, DWORD PTR _nextTime$[esp+76]
	mov	eax, esi

; 3037 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN98@earliestEx@2:

; 3031 : 		break;
; 3032 : 	}
; 3033 : 
; 3034 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 3035 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 3036 : 	return max(nextTime, max(time , lastCommandIssueTime + timingSpecification.tCMD()));

	cmp	edi, edx
	jl	SHORT $LN97@earliestEx@2
	jg	SHORT $LN336@earliestEx@2
	cmp	ecx, eax
	jbe	SHORT $LN97@earliestEx@2
$LN336@earliestEx@2:
	mov	eax, ecx
	mov	edx, edi
$LN97@earliestEx@2:

; 3037 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN395@earliestEx@2:
	DD	$LN21@earliestEx@2
	DD	$LN15@earliestEx@2
	DD	$LN9@earliestEx@2
	DD	$LN3@earliestEx@2
	DD	$LN2@earliestEx@2
	DD	$LN1@earliestEx@2
$LN301@earliestEx@2:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::earliestExecuteTimeLog
; Function compile flags: /Ogtpy
_readSweep$223456 = -357				; size = 1
_readSweep$223345 = -357				; size = 1
_notAllRefresh$223320 = -357				; size = 1
_isRefreshCommand$223266 = -357				; size = 1
_isRefreshCommand$223208 = -357				; size = 1
tv7449 = -356						; size = 4
tv7199 = -356						; size = 4
_this$ = -356						; size = 4
tv7280 = -352						; size = 4
_isActivate$223581 = -352				; size = 1
$T648854 = -352						; size = 4
$T648809 = -352						; size = 4
_currentBankOffset$223400 = -352			; size = 4
_candidateCommand$223188 = -352				; size = 4
tv7523 = -348						; size = 4
tv7368 = -348						; size = 4
tv5223 = -348						; size = 4
$T647166 = -348						; size = 4
_nextBank$223583 = -348					; size = 4
_oldestCommand$223303 = -348				; size = 4
$T648912 = -344						; size = 4
$T648224 = -344						; size = 4
$T647574 = -344						; size = 4
$T646954 = -344						; size = 4
_originalBank$223589 = -344				; size = 4
_currentRank$223515 = -344				; size = 8
_currentRank$223405 = -344				; size = 8
_originalActivate$223590 = -333				; size = 1
_originalReadSweep$223549 = -333			; size = 1
_originalReadSweep$223424 = -333			; size = 1
$T647786 = -332						; size = 4
_nextRank$223582 = -332					; size = 4
_candidateCommand$223246 = -332				; size = 4
_candidateCommand$223136 = -332				; size = 4
_currentBank$223522 = -328				; size = 8
_oldestCommandTime$223300 = -328			; size = 8
_candidateExecuteTime$223247 = -328			; size = 8
_currentRank$223202 = -328				; size = 8
_bankEnd$223161 = -328					; size = 8
__Tmp$651325 = -320					; size = 8
_startingRank$223548 = -320				; size = 8
$T646895 = -320						; size = 8
$T646892 = -320						; size = 8
_startingRank$223423 = -320				; size = 8
$T646862 = -320						; size = 8
_currentRank$223260 = -320				; size = 8
_challengerExecuteTime$223237 = -320			; size = 8
_currentRank$223150 = -320				; size = 8
_currentRank$223314 = -312				; size = 8
_currentBank$223277 = -312				; size = 8
_candidateExecuteTime$223189 = -312			; size = 8
$T650460 = -304						; size = 4
$T649428 = -304						; size = 4
$T649124 = -304						; size = 4
$T648436 = -304						; size = 4
_originalRank$223588 = -304				; size = 4
_startingBankOffset$223418 = -304			; size = 4
_rankEnd$223196 = -304					; size = 8
_candidateExecuteTime$223137 = -304			; size = 8
$T646916 = -296						; size = 8
_startingBank$223543 = -296				; size = 8
$T646870 = -296						; size = 8
_challengerExecuteTime$223293 = -296			; size = 8
_currentBank$223219 = -296				; size = 8
_rankEnd$223144 = -296					; size = 8
__Tmp$651140 = -288					; size = 8
__Tmp$649781 = -288					; size = 8
_rankEnd$223537 = -288					; size = 8
$T646900 = -288						; size = 8
_rankEnd$223308 = -288					; size = 8
_bankEnd$223271 = -288					; size = 8
_bankEnd$223325 = -280					; size = 8
_rankEnd$223254 = -280					; size = 8
_bankEnd$223213 = -280					; size = 8
$T646857 = -272						; size = 8
$T646881 = -264						; size = 8
$T646849 = -256						; size = 8
$T646880 = -248						; size = 8
$T646850 = -240						; size = 8
$T646882 = -232						; size = 8
$T646853 = -224						; size = 8
$T646887 = -216						; size = 8
$T646854 = -208						; size = 8
$T646885 = -200						; size = 8
$T646851 = -192						; size = 8
$T646884 = -184						; size = 8
$T646858 = -176						; size = 8
$T646886 = -168						; size = 8
$T646867 = -160						; size = 8
$T646891 = -152						; size = 8
$T646874 = -144						; size = 8
$T646889 = -136						; size = 8
$T646848 = -128						; size = 8
$T646888 = -120						; size = 8
$T646852 = -112						; size = 8
$T646890 = -104						; size = 8
$T646856 = -96						; size = 8
$T646898 = -88						; size = 8
$T646871 = -80						; size = 8
$T646901 = -72						; size = 8
$T646855 = -64						; size = 8
$T646902 = -56						; size = 8
$T646865 = -48						; size = 8
$T646903 = -40						; size = 8
$T646859 = -32						; size = 8
$T646908 = -24						; size = 8
$T646883 = -16						; size = 8
$T646917 = -8						; size = 8
?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ PROC ; DRAMsimII::Channel::readNextCommand
; _this$ = ecx

; 1505 : {	

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 360				; 00000168H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 1506 : 	switch (systemConfig.getCommandOrderingAlgorithm())

	mov	ecx, DWORD PTR [ebp+176]
	mov	eax, DWORD PTR [ecx+288]
	mov	DWORD PTR _this$[esp+376], ebp
	cmp	eax, 6
	ja	$LN1@readNextCo@2
	jmp	DWORD PTR $LN1843@readNextCo@2[eax*4]
$LN151@readNextCo@2:

; 1507 : 	{
; 1508 : 	case FIRST_AVAILABLE_AGE:
; 1509 : 		{
; 1510 : 			const Command *candidateCommand = NULL;
; 1511 : 
; 1512 : 			tick candidateExecuteTime = TICK_MAX;
; 1513 : 
; 1514 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ebx, DWORD PTR [ebp+416]
	mov	DWORD PTR _candidateCommand$223136[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$223137[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$223137[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T646954[esp+376], ebx
	cmp	DWORD PTR [ebp+412], ebx
	jbe	SHORT $LN177@readNextCo@2
	call	__invalid_parameter_noinfo
$LN177@readNextCo@2:

; 1515 : 
; 1516 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+412]
	mov	eax, DWORD PTR [ebp+400]
	mov	DWORD PTR _rankEnd$223144[esp+376], eax
	cmp	esi, DWORD PTR [ebp+416]
	jbe	SHORT $LN191@readNextCo@2
	call	__invalid_parameter_noinfo
$LN191@readNextCo@2:
	mov	edi, DWORD PTR [ebp+400]
	add	esi, 416				; 000001a0H
	mov	DWORD PTR _currentRank$223150[esp+376], edi
	mov	DWORD PTR tv7280[esp+376], esi
$LL206@readNextCo@2:
	test	edi, edi
	je	SHORT $LN218@readNextCo@2
	cmp	edi, DWORD PTR _rankEnd$223144[esp+376]
	je	SHORT $LN219@readNextCo@2
$LN218@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN219@readNextCo@2:
	lea	eax, DWORD PTR [esi-416]
	cmp	eax, ebx
	je	$LN148@readNextCo@2

; 1517 : 			{
; 1518 : 				bool isRefreshCommand = true;

	mov	bl, 1

; 1519 : 
; 1520 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	edi, edi
	jne	$LN1774@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN237@readNextCo@2:
	lea	ecx, DWORD PTR [esi-416]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN228@readNextCo@2
	call	__invalid_parameter_noinfo
$LN228@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T647166[esp+376], eax
	cmp	DWORD PTR [esi-4], eax
	jbe	SHORT $LN243@readNextCo@2
	call	__invalid_parameter_noinfo
$LN243@readNextCo@2:
	mov	ecx, DWORD PTR [esi-16]
	mov	DWORD PTR _bankEnd$223161[esp+376], ecx

; 1521 : 
; 1522 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	$LN1773@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN265@readNextCo@2:
	lea	ecx, DWORD PTR [esi-416]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN256@readNextCo@2
	call	__invalid_parameter_noinfo
$LN256@readNextCo@2:
	mov	esi, DWORD PTR [esi-4]
	mov	edx, DWORD PTR tv7280[esp+376]
	cmp	esi, DWORD PTR [edx]
	jbe	SHORT $LN271@readNextCo@2
	call	__invalid_parameter_noinfo
$LN271@readNextCo@2:
	mov	eax, DWORD PTR tv7280[esp+376]
	mov	edi, DWORD PTR [eax-16]
	lea	ecx, DWORD PTR [esi+36]
$LN1834@readNextCo@2:
	mov	DWORD PTR tv7199[esp+376], ecx
	test	edi, edi
	je	SHORT $LN298@readNextCo@2
	cmp	edi, DWORD PTR _bankEnd$223161[esp+376]
	je	SHORT $LN299@readNextCo@2
$LN298@readNextCo@2:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN299@readNextCo@2:
	lea	eax, DWORD PTR [ecx-36]
	cmp	eax, DWORD PTR $T647166[esp+376]
	je	$LN149@readNextCo@2

; 1523 : 				{	
; 1524 : 					if (!currentBank->isEmpty())

	test	edi, edi
	jne	$LN1772@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
	xor	eax, eax
$LN317@readNextCo@2:
	lea	edx, DWORD PTR [ecx-36]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN308@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN308@readNextCo@2:
	cmp	DWORD PTR [ecx-24], 0
	je	$LN138@readNextCo@2

; 1525 : 					{
; 1526 : 						const Command *challengerCommand = currentBank->front();

	test	edi, edi
	jne	$LN1771@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
	xor	eax, eax
$LN335@readNextCo@2:
	lea	edx, DWORD PTR [ecx-36]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN326@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN326@readNextCo@2:
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN342@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN342@readNextCo@2:
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax+esi*4]

; 1527 : 
; 1528 : 						assert(!challengerCommand || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1529 : 
; 1530 : 						// see if it is a refresh command
; 1531 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	test	bl, bl
	je	$LN143@readNextCo@2
	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	jne	$LN1833@readNextCo@2
	mov	eax, DWORD PTR _currentRank$223150[esp+376]
	test	eax, eax
	jne	$LN1770@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN360@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -416				; fffffe60H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN351@readNextCo@2
	call	__invalid_parameter_noinfo
$LN351@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -416				; fffffe60H
	push	ecx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN143@readNextCo@2

; 1532 : 						{
; 1533 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	mov	ecx, ebp
	call	eax

; 1534 : #ifndef NDEBUG
; 1535 : 							int minGap = minProtocolGap(challengerCommand);
; 1536 : 
; 1537 : 							if (time + minGap != challengerExecuteTime)
; 1538 : 							{
; 1539 : 								cerr << "cet " << challengerExecuteTime << ", mingap " << time+minGap << endl;
; 1540 : 								cerr << challengerCommand << endl;
; 1541 : 								assert(time + minGap == challengerExecuteTime);
; 1542 : 							}
; 1543 : #endif
; 1544 : 							if (challengerExecuteTime < candidateExecuteTime ||
; 1545 : 								(candidateExecuteTime == challengerExecuteTime && 
; 1546 : 								challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	cmp	edx, DWORD PTR _candidateExecuteTime$223137[esp+380]
	jl	SHORT $LN1723@readNextCo@2
	jg	SHORT $LN1786@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$223137[esp+376]
	jb	SHORT $LN1723@readNextCo@2
$LN1786@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$223137[esp+376], eax
	jne	$LN138@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$223137[esp+380], edx
	jne	$LN138@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _candidateCommand$223136[esp+376]
	cmp	ecx, DWORD PTR [eax+20]
	jl	SHORT $LN1723@readNextCo@2
	jg	$LN138@readNextCo@2
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN138@readNextCo@2
$LN1723@readNextCo@2:

; 1547 : 							{						
; 1548 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$223136[esp+376], esi
$LN149@readNextCo@2:

; 1515 : 
; 1516 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$223150[esp+376]
	test	eax, eax
	jne	$LN1768@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN213@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -416				; fffffe60H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN204@readNextCo@2
	call	__invalid_parameter_noinfo
$LN204@readNextCo@2:
	add	DWORD PTR tv7280[esp+376], 424		; 000001a8H
	mov	edi, DWORD PTR _currentRank$223150[esp+376]
	mov	ebx, DWORD PTR $T646954[esp+376]
	mov	esi, DWORD PTR tv7280[esp+376]
	jmp	$LL206@readNextCo@2
$LN1774@readNextCo@2:

; 1519 : 
; 1520 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [edi]
	jmp	$LN237@readNextCo@2
$LN1773@readNextCo@2:

; 1521 : 
; 1522 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	$LN265@readNextCo@2
$LN1772@readNextCo@2:

; 1523 : 				{	
; 1524 : 					if (!currentBank->isEmpty())

	mov	eax, DWORD PTR [edi]
	jmp	$LN317@readNextCo@2
$LN1771@readNextCo@2:

; 1525 : 					{
; 1526 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [edi]
	jmp	$LN335@readNextCo@2
$LN1770@readNextCo@2:

; 1527 : 
; 1528 : 						assert(!challengerCommand || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1529 : 
; 1530 : 						// see if it is a refresh command
; 1531 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN360@readNextCo@2
$LN143@readNextCo@2:

; 1549 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1550 : 								break;
; 1551 : 							}						
; 1552 : 						}
; 1553 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1554 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	je	SHORT $LN138@readNextCo@2
$LN1833@readNextCo@2:

; 1555 : 						{
; 1556 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	ecx, ebp
	call	edx

; 1557 : #ifndef NDEBUG
; 1558 : 							int minGap = minProtocolGap(challengerCommand);
; 1559 : 
; 1560 : 							if (time + minGap != challengerExecuteTime)
; 1561 : 							{
; 1562 : 								cerr << time << " " << minGap << " " << challengerExecuteTime << " " << challengerCommand->getCommandType() << " " << challengerCommand->getAddress() << endl;
; 1563 : 
; 1564 : 								if (challengerCommand && (time + minGap != challengerExecuteTime))
; 1565 : 								{
; 1566 : 									minGap = minProtocolGap(challengerCommand);
; 1567 : 									assert(challengerCommand && (time + minGap == challengerExecuteTime));
; 1568 : 								}
; 1569 : 							}
; 1570 : #endif
; 1571 : 							// set a new candidate if the challenger can be executed sooner or execution times are the same but the challenger is older
; 1572 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1573 : 								(candidateExecuteTime == challengerExecuteTime &&
; 1574 : 								challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	cmp	edx, DWORD PTR _candidateExecuteTime$223137[esp+380]
	jl	SHORT $LN1789@readNextCo@2
	jg	SHORT $LN1788@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$223137[esp+376]
	jb	SHORT $LN1789@readNextCo@2
$LN1788@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$223137[esp+376], eax
	jne	SHORT $LN138@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$223137[esp+380], edx
	jne	SHORT $LN138@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR _candidateCommand$223136[esp+376]
	cmp	ecx, DWORD PTR [ebx+20]
	jg	SHORT $LN138@readNextCo@2
	jl	SHORT $LN1789@readNextCo@2
	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR [ebx+16]
	jae	SHORT $LN138@readNextCo@2
$LN1789@readNextCo@2:

; 1575 : 							{								
; 1576 : 								candidateExecuteTime = challengerExecuteTime;

	mov	DWORD PTR _candidateExecuteTime$223137[esp+376], eax
	mov	DWORD PTR _candidateExecuteTime$223137[esp+380], edx

; 1577 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$223136[esp+376], esi
$LN138@readNextCo@2:

; 1578 : 							}
; 1579 : 						}
; 1580 : 					}
; 1581 : 
; 1582 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1583 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1584 : 					isRefreshCommand = false;

	xor	bl, bl
	test	edi, edi
	jne	SHORT $LN1769@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN293@readNextCo@2:
	mov	ecx, DWORD PTR tv7199[esp+376]
	lea	edx, DWORD PTR [ecx-36]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN284@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN284@readNextCo@2:

; 1521 : 
; 1522 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	add	ecx, 168				; 000000a8H
	jmp	$LN1834@readNextCo@2
$LN1769@readNextCo@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN293@readNextCo@2
$LN1768@readNextCo@2:

; 1515 : 
; 1516 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN213@readNextCo@2
$LN148@readNextCo@2:

; 1585 : 				}				
; 1586 : 			}
; 1587 : 
; 1588 : 			if (candidateCommand)
; 1589 : 			{
; 1590 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1591 : 
; 1592 : #ifdef DEBUG_GREEDY
; 1593 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1594 : #endif
; 1595 : 			}
; 1596 : 
; 1597 : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$223136[esp+376]

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN135@readNextCo@2:

; 1598 : 		}
; 1599 : 		break;
; 1600 : 
; 1601 : 	case FIRST_AVAILABLE_RIFF:
; 1602 : 		{
; 1603 : 			const Command *candidateCommand = NULL;
; 1604 : 
; 1605 : 			tick candidateExecuteTime = TICK_MAX;
; 1606 : 
; 1607 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	eax, DWORD PTR [ebp+416]
	mov	DWORD PTR _candidateCommand$223188[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$223189[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$223189[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T647574[esp+376], eax
	cmp	DWORD PTR [ebp+412], eax
	jbe	SHORT $LN376@readNextCo@2
	call	__invalid_parameter_noinfo
$LN376@readNextCo@2:

; 1608 : 
; 1609 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+412]
	mov	edx, DWORD PTR [ebp+400]
	mov	DWORD PTR _rankEnd$223196[esp+376], edx
	cmp	esi, DWORD PTR [ebp+416]
	jbe	SHORT $LN390@readNextCo@2
	call	__invalid_parameter_noinfo
$LN390@readNextCo@2:
	mov	edi, DWORD PTR [ebp+400]
	lea	ebx, DWORD PTR [esi+416]
	mov	DWORD PTR _currentRank$223202[esp+376], edi
	mov	DWORD PTR tv7449[esp+376], ebx
$LL405@readNextCo@2:
	test	edi, edi
	je	SHORT $LN417@readNextCo@2
	cmp	edi, DWORD PTR _rankEnd$223196[esp+376]
	je	SHORT $LN418@readNextCo@2
$LN417@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN418@readNextCo@2:
	lea	esi, DWORD PTR [ebx-416]
	cmp	esi, DWORD PTR $T647574[esp+376]
	je	$LN132@readNextCo@2

; 1610 : 			{
; 1611 : 				bool isRefreshCommand = true;

	mov	BYTE PTR _isRefreshCommand$223208[esp+376], 1

; 1612 : 
; 1613 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	edi, edi
	jne	$LN1767@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN436@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN427@readNextCo@2
	call	__invalid_parameter_noinfo
$LN427@readNextCo@2:
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T647786[esp+376], eax
	cmp	DWORD PTR [ebx-4], eax
	jbe	SHORT $LN442@readNextCo@2
	call	__invalid_parameter_noinfo
$LN442@readNextCo@2:
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR _bankEnd$223213[esp+376], eax

; 1614 : 
; 1615 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	$LN1766@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN464@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN455@readNextCo@2
	call	__invalid_parameter_noinfo
$LN455@readNextCo@2:
	mov	esi, DWORD PTR [ebx-4]
	cmp	esi, DWORD PTR [ebx]
	jbe	SHORT $LN470@readNextCo@2
	call	__invalid_parameter_noinfo
$LN470@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	mov	edi, DWORD PTR [ecx-16]
	lea	ebx, DWORD PTR [esi+36]
	mov	DWORD PTR _currentBank$223219[esp+376], edi
	mov	DWORD PTR tv7368[esp+376], ebx
$LL485@readNextCo@2:
	test	edi, edi
	je	SHORT $LN497@readNextCo@2
	cmp	edi, DWORD PTR _bankEnd$223213[esp+376]
	je	SHORT $LN498@readNextCo@2
$LN497@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN498@readNextCo@2:
	lea	esi, DWORD PTR [ebx-36]
	cmp	esi, DWORD PTR $T647786[esp+376]
	je	$LN133@readNextCo@2

; 1616 : 				{	
; 1617 : 					if (!currentBank->isEmpty())

	test	edi, edi
	jne	$LN1765@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN516@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN507@readNextCo@2
	call	__invalid_parameter_noinfo
$LN507@readNextCo@2:
	cmp	DWORD PTR [ebx-24], 0
	je	$LN119@readNextCo@2

; 1618 : 					{
; 1619 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR _currentBank$223219[esp+376]
	test	eax, eax
	jne	$LN1764@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN534@readNextCo@2:
	mov	edi, DWORD PTR tv7368[esp+376]
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN525@readNextCo@2
	call	__invalid_parameter_noinfo
$LN525@readNextCo@2:
	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN541@readNextCo@2
	call	__invalid_parameter_noinfo
$LN541@readNextCo@2:

; 1620 : 
; 1621 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1622 : 
; 1623 : 						// see if it is a refresh command
; 1624 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	cmp	BYTE PTR _isRefreshCommand$223208[esp+376], 0
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+esi*4]
	je	$LN127@readNextCo@2
	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	jne	$LN1836@readNextCo@2
	mov	eax, DWORD PTR _currentRank$223202[esp+376]
	test	eax, eax
	jne	$LN1763@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN559@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -416				; fffffe60H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN550@readNextCo@2
	call	__invalid_parameter_noinfo
$LN550@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -416				; fffffe60H
	push	ecx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN127@readNextCo@2

; 1625 : 						{
; 1626 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	mov	ecx, ebp
	call	eax

; 1627 : #ifndef NDEBUG
; 1628 : 							int minGap = minProtocolGap(challengerCommand);
; 1629 : 
; 1630 : 							if (time + minGap != challengerExecuteTime)
; 1631 : 								assert(time + minGap == challengerExecuteTime);
; 1632 : #endif
; 1633 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1634 : 								(candidateExecuteTime == challengerExecuteTime && ((challengerCommand->isRead() && candidateCommand->isWrite()) ||
; 1635 : 								(challengerCommand->isRead() && candidateCommand->isRead() && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))) ||
; 1636 : 								(time - challengerCommand->getEnqueueTime() > 12 * systemConfig.getSeniorityAgeLimit()))

	mov	ecx, DWORD PTR _candidateExecuteTime$223189[esp+380]
	cmp	edx, ecx
	jl	$LN1724@readNextCo@2
	jg	SHORT $LN1790@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$223189[esp+376]
	jb	SHORT $LN1724@readNextCo@2
$LN1790@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$223189[esp+376], eax
	jne	SHORT $LN1791@readNextCo@2
	cmp	ecx, edx
	jne	SHORT $LN1791@readNextCo@2
	mov	eax, esi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	mov	edi, DWORD PTR _candidateCommand$223188[esp+376]
	test	al, al
	je	SHORT $LN123@readNextCo@2
	mov	eax, edi
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	jne	SHORT $LN1724@readNextCo@2
$LN123@readNextCo@2:
	mov	eax, esi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1791@readNextCo@2
	mov	eax, edi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1791@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR [edi+20]
	jl	SHORT $LN1724@readNextCo@2
	jg	SHORT $LN1791@readNextCo@2
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [edi+16]
	jb	SHORT $LN1724@readNextCo@2
$LN1791@readNextCo@2:
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+176]
	mov	edx, DWORD PTR [edx+320]
	sub	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebp+12]
	sbb	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	xor	edi, edi
	add	edx, edx
	cmp	eax, edi
	jg	SHORT $LN1724@readNextCo@2
	jl	$LN119@readNextCo@2
	cmp	ecx, edx
	jbe	$LN119@readNextCo@2
$LN1724@readNextCo@2:

; 1637 : 							{						
; 1638 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$223188[esp+376], esi
$LN133@readNextCo@2:

; 1608 : 
; 1609 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$223202[esp+376]
	test	eax, eax
	jne	$LN1761@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN412@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -416				; fffffe60H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN403@readNextCo@2
	call	__invalid_parameter_noinfo
$LN403@readNextCo@2:
	add	DWORD PTR tv7449[esp+376], 424		; 000001a8H
	mov	edi, DWORD PTR _currentRank$223202[esp+376]
	mov	ebx, DWORD PTR tv7449[esp+376]
	jmp	$LL405@readNextCo@2
$LN1767@readNextCo@2:

; 1612 : 
; 1613 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [edi]
	jmp	$LN436@readNextCo@2
$LN1766@readNextCo@2:

; 1614 : 
; 1615 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	$LN464@readNextCo@2
$LN1765@readNextCo@2:

; 1616 : 				{	
; 1617 : 					if (!currentBank->isEmpty())

	mov	eax, DWORD PTR [edi]
	jmp	$LN516@readNextCo@2
$LN1764@readNextCo@2:

; 1618 : 					{
; 1619 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	$LN534@readNextCo@2
$LN1763@readNextCo@2:

; 1620 : 
; 1621 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1622 : 
; 1623 : 						// see if it is a refresh command
; 1624 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN559@readNextCo@2
$LN127@readNextCo@2:

; 1639 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1640 : 								break;
; 1641 : 							}						
; 1642 : 						}
; 1643 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1644 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	je	$LN119@readNextCo@2
$LN1836@readNextCo@2:

; 1645 : 						{
; 1646 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	ecx, ebp
	call	edx
	mov	ebx, edx

; 1647 : #ifndef NDEBUG
; 1648 : 							int minGap = minProtocolGap(challengerCommand);
; 1649 : 
; 1650 : 							if (time + minGap != challengerExecuteTime)
; 1651 : 							{
; 1652 : 								cerr << time << " " << minGap << " " << challengerExecuteTime;
; 1653 : 
; 1654 : 								assert(time + minGap == challengerExecuteTime);
; 1655 : 							}
; 1656 : #endif
; 1657 : 							// set a new candidate if the challenger can be executed sooner or execution times are the same but the challenger is older
; 1658 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1659 : 								(candidateExecuteTime == challengerExecuteTime && ((challengerCommand->isRead() && candidateCommand->isWrite()) ||
; 1660 : 								(challengerCommand->isRead() && candidateCommand->isRead() && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))) ||
; 1661 : 								(time - challengerCommand->getEnqueueTime() > 12 *systemConfig.getSeniorityAgeLimit()))

	cmp	ebx, DWORD PTR _candidateExecuteTime$223189[esp+380]
	mov	DWORD PTR _challengerExecuteTime$223237[esp+376], eax
	jl	$LN1795@readNextCo@2
	jg	SHORT $LN1793@readNextCo@2
	mov	eax, DWORD PTR _candidateExecuteTime$223189[esp+376]
	cmp	DWORD PTR _challengerExecuteTime$223237[esp+376], eax
	jb	$LN1795@readNextCo@2
$LN1793@readNextCo@2:
	mov	ecx, DWORD PTR _challengerExecuteTime$223237[esp+376]
	cmp	DWORD PTR _candidateExecuteTime$223189[esp+376], ecx
	jne	SHORT $LN1794@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$223189[esp+380], ebx
	jne	SHORT $LN1794@readNextCo@2
	mov	edi, DWORD PTR [esi+80]
	cmp	edi, 1
	je	SHORT $LN574@readNextCo@2
	cmp	edi, 2
	jne	SHORT $LN116@readNextCo@2
$LN574@readNextCo@2:
	mov	eax, DWORD PTR _candidateCommand$223188[esp+376]
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	jne	SHORT $LN1795@readNextCo@2
$LN116@readNextCo@2:
	cmp	edi, 1
	je	SHORT $LN578@readNextCo@2
	cmp	edi, 2
	jne	SHORT $LN1794@readNextCo@2
$LN578@readNextCo@2:
	mov	edi, DWORD PTR _candidateCommand$223188[esp+376]
	mov	eax, edi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1794@readNextCo@2
	mov	edx, DWORD PTR [esi+20]
	cmp	edx, DWORD PTR [edi+20]
	jl	SHORT $LN1795@readNextCo@2
	jg	SHORT $LN1794@readNextCo@2
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, edi
	cmp	eax, DWORD PTR [ecx+16]
	jb	SHORT $LN1795@readNextCo@2
$LN1794@readNextCo@2:
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+176]
	mov	edx, DWORD PTR [edx+320]
	sub	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebp+12]
	sbb	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	xor	edi, edi
	add	edx, edx
	cmp	eax, edi
	jl	SHORT $LN119@readNextCo@2
	jg	SHORT $LN1795@readNextCo@2
	cmp	ecx, edx
	jbe	SHORT $LN119@readNextCo@2
$LN1795@readNextCo@2:

; 1662 : 							{								
; 1663 : 								candidateExecuteTime = challengerExecuteTime;

	mov	eax, DWORD PTR _challengerExecuteTime$223237[esp+376]
	mov	DWORD PTR _candidateExecuteTime$223189[esp+376], eax
	mov	DWORD PTR _candidateExecuteTime$223189[esp+380], ebx

; 1664 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$223188[esp+376], esi
$LN119@readNextCo@2:
	mov	eax, DWORD PTR _currentBank$223219[esp+376]

; 1665 : 							}
; 1666 : 						}
; 1667 : 					}
; 1668 : 
; 1669 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1670 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1671 : 					isRefreshCommand = false;

	mov	BYTE PTR _isRefreshCommand$223208[esp+376], 0
	test	eax, eax
	jne	SHORT $LN1762@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN492@readNextCo@2:
	mov	ecx, DWORD PTR tv7368[esp+376]
	add	ecx, -36				; ffffffdcH
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN483@readNextCo@2

; 1614 : 
; 1615 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN483@readNextCo@2:
	add	DWORD PTR tv7368[esp+376], 168		; 000000a8H
	mov	ebx, DWORD PTR tv7368[esp+376]
	mov	edi, DWORD PTR _currentBank$223219[esp+376]
	jmp	$LL485@readNextCo@2
$LN1762@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN492@readNextCo@2
$LN1761@readNextCo@2:

; 1608 : 
; 1609 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN412@readNextCo@2
$LN132@readNextCo@2:

; 1672 : 				}				
; 1673 : 			}
; 1674 : 
; 1675 : 			if (candidateCommand)
; 1676 : 			{
; 1677 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1678 : 
; 1679 : #ifdef DEBUG_GREEDY
; 1680 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1681 : #endif
; 1682 : 			}
; 1683 : 
; 1684 : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$223188[esp+376]

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@readNextCo@2:

; 1685 : 		}
; 1686 : 		break;
; 1687 : 
; 1688 : 	case FIRST_AVAILABLE_QUEUE:
; 1689 : 		{
; 1690 : 			const Command *candidateCommand = NULL;
; 1691 : 
; 1692 : 			tick candidateExecuteTime = TICK_MAX;
; 1693 : 
; 1694 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	eax, DWORD PTR [ebp+416]
	lea	esi, DWORD PTR [ebp+400]
	mov	DWORD PTR _candidateCommand$223246[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$223247[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$223247[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T648224[esp+376], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN591@readNextCo@2
	call	__invalid_parameter_noinfo
$LN591@readNextCo@2:

; 1695 : 
; 1696 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	edi, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _rankEnd$223254[esp+376], ecx
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN605@readNextCo@2
	call	__invalid_parameter_noinfo
$LN605@readNextCo@2:
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR _currentRank$223260[esp+376], ebp
	lea	ebx, DWORD PTR [edi+416]
$LN1839@readNextCo@2:
	mov	DWORD PTR tv7523[esp+376], ebx
	test	ebp, ebp
	je	SHORT $LN632@readNextCo@2
	cmp	ebp, DWORD PTR _rankEnd$223254[esp+376]
	je	SHORT $LN633@readNextCo@2
$LN632@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN633@readNextCo@2:
	lea	esi, DWORD PTR [ebx-416]
	cmp	esi, DWORD PTR $T648224[esp+376]
	je	$LN148@readNextCo@2

; 1697 : 			{
; 1698 : 				bool isRefreshCommand = true;

	mov	BYTE PTR _isRefreshCommand$223266[esp+376], 1

; 1699 : 
; 1700 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	ebp, ebp
	jne	$LN1760@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN651@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN642@readNextCo@2
	call	__invalid_parameter_noinfo
$LN642@readNextCo@2:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR $T648436[esp+376], ebp
	cmp	DWORD PTR [ebx-4], ebp
	jbe	SHORT $LN657@readNextCo@2
	call	__invalid_parameter_noinfo
$LN657@readNextCo@2:

; 1701 : 
; 1702 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR _currentRank$223260[esp+376]
	mov	edx, DWORD PTR [ebx-16]
	mov	DWORD PTR _bankEnd$223271[esp+376], edx
	test	eax, eax
	jne	$LN1759@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN679@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN670@readNextCo@2
	call	__invalid_parameter_noinfo
$LN670@readNextCo@2:
	mov	edi, DWORD PTR [ebx-4]
	cmp	edi, DWORD PTR [ebx]
	jbe	SHORT $LN685@readNextCo@2
	call	__invalid_parameter_noinfo
$LN685@readNextCo@2:
	mov	esi, DWORD PTR [ebx-16]
	mov	DWORD PTR _currentBank$223277[esp+376], esi
	mov	DWORD PTR _currentBank$223277[esp+380], edi
$LL700@readNextCo@2:
	test	esi, esi
	je	SHORT $LN712@readNextCo@2
	cmp	esi, DWORD PTR _bankEnd$223271[esp+376]
	je	SHORT $LN713@readNextCo@2
$LN712@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN713@readNextCo@2:
	cmp	edi, ebp
	je	$LN111@readNextCo@2

; 1703 : 				{	
; 1704 : 					if (!currentBank->isEmpty())

	test	esi, esi
	jne	$LN1758@readNextCo@2
	call	__invalid_parameter_noinfo
$LN731@readNextCo@2:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN722@readNextCo@2
	call	__invalid_parameter_noinfo
$LN722@readNextCo@2:
	cmp	DWORD PTR [edi+12], 0
	je	$LN99@readNextCo@2

; 1705 : 					{
; 1706 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR _currentBank$223277[esp+376]
	test	eax, eax
	jne	$LN1757@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN749@readNextCo@2:
	mov	esi, DWORD PTR _currentBank$223277[esp+380]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN740@readNextCo@2
	call	__invalid_parameter_noinfo
$LN740@readNextCo@2:
	mov	eax, DWORD PTR [esi+40]
	sub	eax, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [esi+16]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN756@readNextCo@2
	call	__invalid_parameter_noinfo
$LN756@readNextCo@2:

; 1707 : 
; 1708 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1709 : 
; 1710 : 						// see if it is a refresh command
; 1711 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	cmp	BYTE PTR _isRefreshCommand$223266[esp+376], 0
	mov	ecx, DWORD PTR [esi+36]
	mov	ebp, DWORD PTR [ecx+edi*4]
	je	$LN105@readNextCo@2
	cmp	DWORD PTR [ebp+80], 12			; 0000000cH
	jne	$LN1838@readNextCo@2
	mov	eax, DWORD PTR _currentRank$223260[esp+376]
	test	eax, eax
	jne	$LN1756@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN774@readNextCo@2:
	mov	ebx, DWORD PTR tv7523[esp+376]
	lea	ecx, DWORD PTR [ebx-416]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN765@readNextCo@2
	call	__invalid_parameter_noinfo
$LN765@readNextCo@2:
	lea	edx, DWORD PTR [ebx-416]
	push	edx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN105@readNextCo@2

; 1712 : 						{
; 1713 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	esi, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	ebp
	mov	ecx, esi
	call	edx

; 1714 : #ifndef NDEBUG
; 1715 : 							int minGap = minProtocolGap(challengerCommand);
; 1716 : 
; 1717 : 							if (time + minGap!= max(challengerExecuteTime,time))
; 1718 : 								assert(time + minGap == challengerExecuteTime);
; 1719 : #endif
; 1720 : 							// if it can execute earlier, at the same time and has greater queue pressure or it is starving
; 1721 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1722 : 								(candidateExecuteTime == challengerExecuteTime && currentBank->size() > rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].size()) ||
; 1723 : 								(time - challengerCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()))

	mov	ecx, DWORD PTR _candidateExecuteTime$223247[esp+380]
	cmp	edx, ecx
	jl	$LN1725@readNextCo@2
	jg	SHORT $LN1796@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$223247[esp+376]
	jb	SHORT $LN1725@readNextCo@2
$LN1796@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$223247[esp+376], eax
	jne	SHORT $LN102@readNextCo@2
	cmp	ecx, edx
	jne	SHORT $LN102@readNextCo@2
	lea	esi, DWORD PTR _currentBank$223277[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ebx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _candidateCommand$223246[esp+376]
	mov	ecx, DWORD PTR [eax+64]
	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [eax+60]
	add	esi, 400				; 00000190H
	mov	DWORD PTR $T648809[esp+376], ecx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR $T648809[esp+376]
	mov	esi, eax
	add	esi, 400				; 00000190H
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	cmp	ebx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR tv7523[esp+376]
	ja	SHORT $LN1725@readNextCo@2
	mov	esi, DWORD PTR _this$[esp+376]
$LN102@readNextCo@2:
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+176]
	sbb	eax, DWORD PTR [ebp+20]
	mov	esi, DWORD PTR [edx+320]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN1725@readNextCo@2
	jl	$LN99@readNextCo@2
	cmp	ecx, esi
	jbe	$LN99@readNextCo@2
$LN1725@readNextCo@2:

; 1724 : 							{						
; 1725 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$223246[esp+376], ebp
$LN111@readNextCo@2:

; 1695 : 
; 1696 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$223260[esp+376]
	test	eax, eax
	jne	$LN1754@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN627@readNextCo@2:
	lea	ecx, DWORD PTR [ebx-416]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN618@readNextCo@2
	call	__invalid_parameter_noinfo
$LN618@readNextCo@2:
	mov	ebp, DWORD PTR _currentRank$223260[esp+376]
	add	ebx, 424				; 000001a8H
	jmp	$LN1839@readNextCo@2
$LN1760@readNextCo@2:

; 1699 : 
; 1700 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebp]
	jmp	$LN651@readNextCo@2
$LN1759@readNextCo@2:

; 1701 : 
; 1702 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN679@readNextCo@2
$LN1758@readNextCo@2:

; 1703 : 				{	
; 1704 : 					if (!currentBank->isEmpty())

	mov	esi, DWORD PTR [esi]
	jmp	$LN731@readNextCo@2
$LN1757@readNextCo@2:

; 1705 : 					{
; 1706 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	$LN749@readNextCo@2
$LN1756@readNextCo@2:

; 1707 : 
; 1708 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1709 : 
; 1710 : 						// see if it is a refresh command
; 1711 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN774@readNextCo@2
$LN105@readNextCo@2:

; 1726 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1727 : 								break;
; 1728 : 							}						
; 1729 : 						}
; 1730 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1731 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [ebp+80], 12			; 0000000cH
	je	$LN99@readNextCo@2
$LN1838@readNextCo@2:

; 1732 : 						{
; 1733 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	ebp
	call	edx

; 1734 : #ifndef NDEBUG
; 1735 : 							int minGap = minProtocolGap(challengerCommand);
; 1736 : 
; 1737 : 							if (time + minGap != challengerExecuteTime)
; 1738 : 							{
; 1739 : 								cerr << time << " " << minGap << " " << challengerExecuteTime;
; 1740 : 
; 1741 : 								assert(time + minGap == challengerExecuteTime);
; 1742 : 							}
; 1743 : #endif
; 1744 : 							// if it can execute earlier, at the same time and has greater queue pressure or it is starving
; 1745 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1746 : 								(candidateExecuteTime == challengerExecuteTime && currentBank->size() > rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].size()) ||
; 1747 : 								(time - challengerCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()))

	cmp	edx, DWORD PTR _candidateExecuteTime$223247[esp+380]
	mov	edi, eax
	mov	DWORD PTR _challengerExecuteTime$223293[esp+376], edi
	mov	DWORD PTR _challengerExecuteTime$223293[esp+380], edx
	jl	$LN1799@readNextCo@2
	jg	SHORT $LN1798@readNextCo@2
	cmp	edi, DWORD PTR _candidateExecuteTime$223247[esp+376]
	jb	$LN1799@readNextCo@2
$LN1798@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$223247[esp+376], edi
	jne	SHORT $LN97@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$223247[esp+380], edx
	jne	SHORT $LN97@readNextCo@2
	lea	esi, DWORD PTR _currentBank$223277[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ebx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _candidateCommand$223246[esp+376]
	mov	ecx, DWORD PTR [eax+64]
	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [eax+60]
	add	esi, 400				; 00000190H
	mov	DWORD PTR $T648854[esp+376], ecx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR $T648854[esp+376]
	mov	esi, eax
	add	esi, 400				; 00000190H
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	edi, DWORD PTR _challengerExecuteTime$223293[esp+376]
	mov	edx, DWORD PTR _challengerExecuteTime$223293[esp+380]
	cmp	ebx, DWORD PTR [eax+12]
	ja	SHORT $LN1799@readNextCo@2
$LN97@readNextCo@2:
	mov	esi, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [ebp+16]
	mov	esi, DWORD PTR [esi+176]
	sbb	eax, DWORD PTR [ebp+20]
	mov	ebx, DWORD PTR [esi+320]
	xor	esi, esi
	cmp	eax, esi
	jl	SHORT $LN99@readNextCo@2
	jg	SHORT $LN1799@readNextCo@2
	cmp	ecx, ebx
	jbe	SHORT $LN99@readNextCo@2
$LN1799@readNextCo@2:

; 1748 : 							{								
; 1749 : 								candidateExecuteTime = challengerExecuteTime;

	mov	DWORD PTR _candidateExecuteTime$223247[esp+376], edi
	mov	DWORD PTR _candidateExecuteTime$223247[esp+380], edx

; 1750 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$223246[esp+376], ebp
$LN99@readNextCo@2:
	mov	eax, DWORD PTR _currentBank$223277[esp+376]

; 1751 : 							}
; 1752 : 						}
; 1753 : 					}
; 1754 : 
; 1755 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1756 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1757 : 					isRefreshCommand = false;

	mov	BYTE PTR _isRefreshCommand$223266[esp+376], 0
	test	eax, eax
	jne	SHORT $LN1755@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN707@readNextCo@2:
	mov	edx, DWORD PTR _currentBank$223277[esp+380]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN698@readNextCo@2

; 1701 : 
; 1702 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN698@readNextCo@2:
	add	DWORD PTR _currentBank$223277[esp+380], 168 ; 000000a8H
	mov	ebx, DWORD PTR tv7523[esp+376]
	mov	edi, DWORD PTR _currentBank$223277[esp+380]
	mov	esi, DWORD PTR _currentBank$223277[esp+376]
	mov	ebp, DWORD PTR $T648436[esp+376]
	jmp	$LL700@readNextCo@2
$LN1755@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN707@readNextCo@2
$LN1754@readNextCo@2:

; 1695 : 
; 1696 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN627@readNextCo@2
$LN95@readNextCo@2:

; 1758 : 				}				
; 1759 : 			}
; 1760 : 
; 1761 : 			if (candidateCommand)
; 1762 : 			{
; 1763 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1764 : 
; 1765 : #ifdef DEBUG_GREEDY
; 1766 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1767 : #endif
; 1768 : 			}
; 1769 : 
; 1770 : 			return candidateCommand;
; 1771 : 		}
; 1772 : 		break;
; 1773 : 
; 1774 : 		// this strategy executes all commands in the order they were entered
; 1775 : 	case STRICT_ORDER:
; 1776 : 		{
; 1777 : 			tick oldestCommandTime = TICK_MAX;
; 1778 : 			const Command *oldestCommand = NULL;
; 1779 : 
; 1780 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ebx, DWORD PTR [ebp+416]
	mov	DWORD PTR _oldestCommandTime$223300[esp+376], -1
	mov	DWORD PTR _oldestCommandTime$223300[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR _oldestCommand$223303[esp+376], 0
	mov	DWORD PTR $T648912[esp+376], ebx
	cmp	DWORD PTR [ebp+412], ebx
	jbe	SHORT $LN822@readNextCo@2
	call	__invalid_parameter_noinfo
$LN822@readNextCo@2:

; 1781 : 
; 1782 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+412]
	mov	eax, DWORD PTR [ebp+400]
	mov	DWORD PTR _rankEnd$223308[esp+376], eax
	cmp	esi, DWORD PTR [ebp+416]
	jbe	SHORT $LN836@readNextCo@2
	call	__invalid_parameter_noinfo
$LN836@readNextCo@2:
	mov	ebp, DWORD PTR [ebp+400]
	mov	DWORD PTR _currentRank$223314[esp+376], ebp
	mov	edi, esi
$LN1840@readNextCo@2:
	mov	DWORD PTR _currentRank$223314[esp+380], edi
	test	ebp, ebp
	je	SHORT $LN863@readNextCo@2
	cmp	ebp, DWORD PTR _rankEnd$223308[esp+376]
	je	SHORT $LN864@readNextCo@2
$LN863@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN864@readNextCo@2:
	cmp	edi, ebx
	je	$LN92@readNextCo@2

; 1783 : 			{
; 1784 : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$223320[esp+376], 0

; 1785 : 
; 1786 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	ebp, ebp
	jne	$LN1753@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN882@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN873@readNextCo@2
	call	__invalid_parameter_noinfo
$LN873@readNextCo@2:
	mov	eax, DWORD PTR [edi+416]
	mov	DWORD PTR $T649124[esp+376], eax
	cmp	DWORD PTR [edi+412], eax
	jbe	SHORT $LN888@readNextCo@2
	call	__invalid_parameter_noinfo
$LN888@readNextCo@2:
	mov	ecx, DWORD PTR [edi+400]
	mov	DWORD PTR _bankEnd$223325[esp+376], ecx

; 1787 : 
; 1788 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	ebp, ebp
	jne	$LN1752@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN910@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN901@readNextCo@2
	call	__invalid_parameter_noinfo
$LN901@readNextCo@2:
	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN916@readNextCo@2
	call	__invalid_parameter_noinfo
$LN916@readNextCo@2:
	mov	ebp, DWORD PTR [edi+400]
	lea	ebx, DWORD PTR [esi+36]
$LL931@readNextCo@2:
	test	ebp, ebp
	je	SHORT $LN943@readNextCo@2
	cmp	ebp, DWORD PTR _bankEnd$223325[esp+376]
	je	SHORT $LN944@readNextCo@2
$LN943@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN944@readNextCo@2:
	lea	esi, DWORD PTR [ebx-36]
	cmp	esi, DWORD PTR $T649124[esp+376]
	je	$LN93@readNextCo@2

; 1789 : 				{
; 1790 : 					if (const Command *challengerCommand = currentBank->front())

	test	ebp, ebp
	jne	$LN1751@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN962@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN953@readNextCo@2
	call	__invalid_parameter_noinfo
$LN953@readNextCo@2:
	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN969@readNextCo@2
	call	__invalid_parameter_noinfo
$LN969@readNextCo@2:
	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+esi*4]
	test	edi, edi
	je	$LN83@readNextCo@2

; 1791 : 					{
; 1792 : #ifndef NDEBUG
; 1793 : 						{
; 1794 : 							const tick executeTime = earliestExecuteTime(challengerCommand);
; 1795 : 							if (executeTime != time + minProtocolGap(challengerCommand))
; 1796 : 							{							
; 1797 : 								assert(executeTime == time + minProtocolGap(challengerCommand));
; 1798 : 							}
; 1799 : 						}						
; 1800 : #endif
; 1801 : 						// choose the oldest command that can be executed
; 1802 : 						if (challengerCommand->getEnqueueTime() < oldestCommandTime)

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR _oldestCommandTime$223300[esp+380]
	mov	ecx, DWORD PTR [edi+16]
	jg	$LN83@readNextCo@2
	jl	SHORT $LN1800@readNextCo@2
	cmp	ecx, DWORD PTR _oldestCommandTime$223300[esp+376]
	jae	$LN83@readNextCo@2
$LN1800@readNextCo@2:

; 1803 : 						{
; 1804 : 							// if it's a refresh command and
; 1805 : 							// we haven't proved that all the queues aren't refresh_all commands, search
; 1806 : 							if (challengerCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	jne	SHORT $LN86@readNextCo@2

; 1807 : 							{
; 1808 : 								if (!notAllRefresh)

	cmp	BYTE PTR _notAllRefresh$223320[esp+376], 0
	jne	SHORT $LN83@readNextCo@2

; 1809 : 								{
; 1810 : 									// if all are known now to be refresh commands
; 1811 : 									if (currentRank->refreshAllReady())

	lea	esi, DWORD PTR _currentRank$223314[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	push	eax
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	SHORT $LN83@readNextCo@2

; 1812 : 									{
; 1813 : 										oldestCommandTime = challengerCommand->getEnqueueTime();

	mov	ecx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+20]

; 1814 : 										oldestCommand = challengerCommand;

	mov	DWORD PTR _oldestCommand$223303[esp+376], edi
	mov	edi, DWORD PTR _currentRank$223314[esp+380]
	mov	DWORD PTR _oldestCommandTime$223300[esp+376], ecx
	mov	DWORD PTR _oldestCommandTime$223300[esp+380], edx
$LN93@readNextCo@2:
	mov	eax, DWORD PTR _currentRank$223314[esp+376]
	test	eax, eax
	jne	SHORT $LN1749@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN858@readNextCo@2:

; 1781 : 
; 1782 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN849@readNextCo@2
	call	__invalid_parameter_noinfo
$LN849@readNextCo@2:
	mov	ebx, DWORD PTR $T648912[esp+376]
	mov	ebp, DWORD PTR _currentRank$223314[esp+376]
	add	edi, 424				; 000001a8H
	jmp	$LN1840@readNextCo@2
$LN1753@readNextCo@2:

; 1785 : 
; 1786 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebp]
	jmp	$LN882@readNextCo@2
$LN1752@readNextCo@2:

; 1787 : 
; 1788 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [ebp]
	jmp	$LN910@readNextCo@2
$LN1751@readNextCo@2:

; 1789 : 				{
; 1790 : 					if (const Command *challengerCommand = currentBank->front())

	mov	eax, DWORD PTR [ebp]
	jmp	$LN962@readNextCo@2
$LN86@readNextCo@2:

; 1815 : 										// don't need to check other banks again
; 1816 : 										break;
; 1817 : 									}
; 1818 : 								}
; 1819 : 							}
; 1820 : 							else
; 1821 : 							{
; 1822 : 								oldestCommandTime = challengerCommand->getEnqueueTime();

	mov	DWORD PTR _oldestCommandTime$223300[esp+376], ecx
	mov	DWORD PTR _oldestCommandTime$223300[esp+380], eax

; 1823 : 								oldestCommand = challengerCommand;

	mov	DWORD PTR _oldestCommand$223303[esp+376], edi
$LN83@readNextCo@2:

; 1824 : 							}
; 1825 : 						}
; 1826 : 					}
; 1827 : 
; 1828 : 					notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$223320[esp+376], 1
	test	ebp, ebp
	jne	SHORT $LN1750@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN938@readNextCo@2:
	lea	ecx, DWORD PTR [ebx-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN929@readNextCo@2

; 1787 : 
; 1788 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN929@readNextCo@2:
	mov	edi, DWORD PTR _currentRank$223314[esp+380]
	add	ebx, 168				; 000000a8H
	jmp	$LL931@readNextCo@2
$LN1750@readNextCo@2:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN938@readNextCo@2
$LN1749@readNextCo@2:

; 1781 : 
; 1782 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN858@readNextCo@2
$LN92@readNextCo@2:

; 1829 : 				}
; 1830 : 			}
; 1831 : 
; 1832 : 			// if any executable command was found, prioritize it over those which must wait
; 1833 : 
; 1834 : 			return oldestCommand;

	mov	eax, DWORD PTR _oldestCommand$223303[esp+376]

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@readNextCo@2:

; 1835 : 		}
; 1836 : 		break;
; 1837 : 
; 1838 : 		// alternate ranks as we go down banks
; 1839 : 	case RANK_ROUND_ROBIN:
; 1840 : 		{
; 1841 : 			// the command type to look for first
; 1842 : 			bool readSweep = true;
; 1843 : 
; 1844 : 			// look at the most recently retired command in this channel's history
; 1845 : 			//const unsigned lastBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;
; 1846 : 			//const vector<Rank>::const_iterator lastRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);
; 1847 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN156@readNextCo@2
	mov	ecx, DWORD PTR [eax+80]

; 1848 : 
; 1849 : 			// attempt to group RAS/CAS pairs together
; 1850 : 			switch (lastCommandType)

	cmp	ecx, 12					; 0000000cH
	ja	$LN66@readNextCo@2
$LN1784@readNextCo@2:
	movzx	ecx, BYTE PTR $LN1801@readNextCo@2[ecx]
	jmp	DWORD PTR $LN1844@readNextCo@2[ecx*4]
$LN156@readNextCo@2:

; 1835 : 		}
; 1836 : 		break;
; 1837 : 
; 1838 : 		// alternate ranks as we go down banks
; 1839 : 	case RANK_ROUND_ROBIN:
; 1840 : 		{
; 1841 : 			// the command type to look for first
; 1842 : 			bool readSweep = true;
; 1843 : 
; 1844 : 			// look at the most recently retired command in this channel's history
; 1845 : 			//const unsigned lastBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;
; 1846 : 			//const vector<Rank>::const_iterator lastRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);
; 1847 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	ecx, 1

; 1848 : 
; 1849 : 			// attempt to group RAS/CAS pairs together
; 1850 : 			switch (lastCommandType)

	jmp	SHORT $LN1784@readNextCo@2
$LN79@readNextCo@2:

; 1851 : 			{
; 1852 : 				// if it was RAS before and you want to finish doing the read/write
; 1853 : 			case Command::ACTIVATE:
; 1854 : 				{
; 1855 : 					// look at the command just after the RAS, it should be some sort of CAS
; 1856 : 
; 1857 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	edx, DWORD PTR $T646851[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T646849[esp+384]
	push	eax
	lea	edi, DWORD PTR [ecx+400]
	lea	esi, DWORD PTR $T646848[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646850[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1858 : 
; 1859 : 					if (nextCommand && nextCommand->isReadOrWrite())

	test	esi, esi
	je	SHORT $LN78@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	je	SHORT $LN78@readNextCo@2
$LN73@readNextCo@2:

; 1860 : 					{
; 1861 : 						return nextCommand;

	mov	eax, esi

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@readNextCo@2:

; 1862 : 					}
; 1863 : 					else
; 1864 : 					{
; 1865 : 						cerr << "error: Found a row activate not followed by a column command." << endl;

	push	OFFSET ??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 1866 : 						exit(2);

	push	2
	call	_exit
$LN1846@readNextCo@2:
$LN76@readNextCo@2:

; 1867 : 					}
; 1868 : 				}
; 1869 : 				break;
; 1870 : 
; 1871 : 			case Command::READ:
; 1872 : 				// try to reuse open rows
; 1873 : 				if (lastCommand)

	test	eax, eax
	je	$LN74@readNextCo@2

; 1874 : 				{
; 1875 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	eax, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [eax+60]
	mov	ebx, DWORD PTR [eax+64]
	lea	edx, DWORD PTR $T646855[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T646853[esp+384]
	push	eax
	lea	edi, DWORD PTR [ebp+400]
	lea	esi, DWORD PTR $T646852[esp+388]
	mov	DWORD PTR $T649428[esp+388], ecx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, DWORD PTR $T649428[esp+388]
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646854[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1876 : 
; 1877 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN74@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 1878 : 					{
; 1879 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN74@readNextCo@2:

; 1880 : 					}
; 1881 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 1882 : 				}	
; 1883 : 			case Command::READ_AND_PRECHARGE:
; 1884 : 			case Command::PRECHARGE:
; 1885 : 			case Command::REFRESH_ALL:
; 1886 : 				readSweep = true;

	mov	BYTE PTR _readSweep$223345[esp+376], 1

; 1887 : 				break;

	jmp	$LN80@readNextCo@2
$LN71@readNextCo@2:

; 1888 : 
; 1889 : 			case Command::WRITE:
; 1890 : 				// try to reuse open rows
; 1891 : 				if (lastCommand)

	test	eax, eax
	je	$LN69@readNextCo@2

; 1892 : 				{
; 1893 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	edx, DWORD PTR $T646859[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T646857[esp+384]
	push	eax
	lea	edi, DWORD PTR [ecx+400]
	lea	esi, DWORD PTR $T646856[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646858[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1894 : 
; 1895 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN69@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 1896 : 					{
; 1897 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN69@readNextCo@2:

; 1898 : 					}
; 1899 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 1900 : 				}		
; 1901 : 			case Command::WRITE_AND_PRECHARGE:
; 1902 : 
; 1903 : 				readSweep = false;
; 1904 : 				break;	

	mov	ebp, DWORD PTR _this$[esp+376]
	mov	BYTE PTR _readSweep$223345[esp+376], 0
	jmp	SHORT $LN80@readNextCo@2
$LN66@readNextCo@2:

; 1905 : 
; 1906 : 			default:
; 1907 : 				readSweep = true;
; 1908 : 				cerr << "warn: Unhandled command type." << endl;

	push	OFFSET ??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	BYTE PTR _readSweep$223345[esp+384], 1
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN80@readNextCo@2:

; 1909 : 				break;
; 1910 : 			}
; 1911 : 
; 1912 : 			unsigned currentBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN158@readNextCo@2
	mov	ecx, DWORD PTR [eax+64]
	jmp	SHORT $LN159@readNextCo@2
$LN158@readNextCo@2:
	xor	ecx, ecx
$LN159@readNextCo@2:
	mov	DWORD PTR _currentBankOffset$223400[esp+376], ecx

; 1913 : 
; 1914 : 			vector<Rank>::const_iterator currentRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0) + 1;

	test	eax, eax
	je	SHORT $LN160@readNextCo@2
	mov	edi, DWORD PTR [eax+60]
	jmp	SHORT $LN161@readNextCo@2
$LN160@readNextCo@2:
	xor	edi, edi
$LN161@readNextCo@2:
	mov	esi, DWORD PTR [ebp+412]
	lea	ebx, DWORD PTR [ebp+400]
	mov	DWORD PTR tv5223[esp+376], ebx
	cmp	esi, DWORD PTR [ebx+16]
	jbe	SHORT $LN1027@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1027@readNextCo@2:
	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR _currentRank$223405[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T646865[esp+384]
	mov	DWORD PTR $T646862[esp+384], ecx
	push	eax
	mov	ecx, edi
	lea	eax, DWORD PTR $T646862[esp+388]
	mov	DWORD PTR $T646862[esp+392], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	ecx, 1
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+

; 1915 : 			if (currentRank == rank.end())

	mov	esi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], esi
	jbe	SHORT $LN1041@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1041@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$223405[esp+376]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN1052@readNextCo@2
	cmp	ecx, eax
	je	SHORT $LN1053@readNextCo@2
$LN1052@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1053@readNextCo@2:
	mov	ebx, DWORD PTR _currentRank$223405[esp+380]
	cmp	ebx, esi
	jne	SHORT $LN65@readNextCo@2

; 1916 : 			{
; 1917 : 				currentBankOffset = (currentBankOffset + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _currentBankOffset$223400[esp+376]
	mov	ecx, DWORD PTR [ebp+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]

; 1918 : 				currentRank = rank.begin();

	mov	edi, DWORD PTR tv5223[esp+376]
	lea	esi, DWORD PTR $T646867[esp+376]
	mov	DWORD PTR _currentBankOffset$223400[esp+376], edx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _currentRank$223405[esp+376], edx
	mov	DWORD PTR _currentRank$223405[esp+380], ebx
$LN65@readNextCo@2:

; 1919 : 			}
; 1920 : 
; 1921 : 			// set original values to know when a full sweep is finished
; 1922 : 			const vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ecx, DWORD PTR tv5223[esp+376]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [ecx+12], eax
	jbe	SHORT $LN1065@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1065@readNextCo@2:

; 1923 : 			const unsigned startingBankOffset = currentBankOffset;

	mov	eax, DWORD PTR _currentBankOffset$223400[esp+376]

; 1924 : 			const vector<Rank>::const_iterator startingRank = currentRank;

	mov	ecx, DWORD PTR _currentRank$223405[esp+376]

; 1925 : 			const bool originalReadSweep = readSweep;

	mov	dl, BYTE PTR _readSweep$223345[esp+376]
	mov	DWORD PTR _startingBankOffset$223418[esp+376], eax
	mov	DWORD PTR _startingRank$223423[esp+376], ecx
	mov	DWORD PTR _startingRank$223423[esp+380], ebx
	mov	BYTE PTR _originalReadSweep$223424[esp+376], dl
$LN64@readNextCo@2:

; 1926 : 
; 1927 : 			while (true)
; 1928 : 			{		
; 1929 : 				const Command *potentialCommand = (currentRank->bank.begin() + currentBankOffset)->front();

	mov	eax, DWORD PTR _currentRank$223405[esp+376]
	test	eax, eax
	jne	SHORT $LN1748@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1087@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1078@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1078@readNextCo@2:
	mov	ebp, DWORD PTR [ebx+412]
	cmp	ebp, DWORD PTR [ebx+416]
	jbe	SHORT $LN1093@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1093@readNextCo@2:
	mov	esi, DWORD PTR [ebx+400]
	mov	edi, esi
	mov	DWORD PTR __Tmp$649781[esp+380], ebp
	test	esi, esi
	jne	SHORT $LN1747@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1116@readNextCo@2:
	mov	ecx, DWORD PTR _currentBankOffset$223400[esp+376]
	imul	ecx, 168				; 000000a8H
	add	ebp, ecx
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN1106@readNextCo@2
	test	esi, esi
	je	SHORT $LN1121@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1122@readNextCo@2
$LN1748@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1087@readNextCo@2
$LN1747@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1116@readNextCo@2
$LN1121@readNextCo@2:
	xor	esi, esi
$LN1122@readNextCo@2:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN1107@readNextCo@2
$LN1106@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1107@readNextCo@2:
	test	edi, edi
	jne	$LN1746@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1136@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1127@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1127@readNextCo@2:
	mov	edx, DWORD PTR [ebp+40]
	sub	edx, DWORD PTR [ebp+36]
	mov	esi, DWORD PTR [ebp+16]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1143@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1143@readNextCo@2:
	mov	eax, DWORD PTR [ebp+36]
	mov	edi, DWORD PTR [eax+esi*4]

; 1930 : 
; 1931 : 				// refresh commands are considered elsewhere
; 1932 : 				if (potentialCommand && !potentialCommand->isRefresh() )

	test	edi, edi
	je	$LN59@readNextCo@2
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	$LN59@readNextCo@2

; 1933 : 				{
; 1934 : 					// group reads and writes with each other
; 1935 : 					if (systemConfig.isReadWriteGrouping())

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+176]
	cmp	BYTE PTR [edx+345], 0
	je	$LN58@readNextCo@2

; 1936 : 					{
; 1937 : 						if (potentialCommand->isActivate())
; 1938 : 							assert((currentRank->bank.begin() + currentBankOffset)->read(1));
; 1939 : 
; 1940 : 						const Command *secondCommand = potentialCommand->isActivate() ? (currentRank->bank.begin() + currentBankOffset)->read(1) : potentialCommand;

	test	eax, eax
	je	SHORT $LN1158@readNextCo@2
	cmp	eax, 8
	jne	SHORT $LN162@readNextCo@2
$LN1158@readNextCo@2:
	lea	esi, DWORD PTR _currentRank$223405[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	ebp, DWORD PTR [esi+412]
	add	esi, 400				; 00000190H
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN1163@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1163@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T646871[esp+376]
	mov	DWORD PTR $T646870[esp+376], eax
	push	ecx
	mov	ecx, DWORD PTR _currentBankOffset$223400[esp+380]
	lea	eax, DWORD PTR $T646870[esp+380]
	mov	DWORD PTR $T646870[esp+384], ebp
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	jmp	SHORT $LN163@readNextCo@2
$LN1746@readNextCo@2:

; 1926 : 
; 1927 : 			while (true)
; 1928 : 			{		
; 1929 : 				const Command *potentialCommand = (currentRank->bank.begin() + currentBankOffset)->front();

	mov	eax, DWORD PTR [edi]
	jmp	$LN1136@readNextCo@2
$LN162@readNextCo@2:

; 1936 : 					{
; 1937 : 						if (potentialCommand->isActivate())
; 1938 : 							assert((currentRank->bank.begin() + currentBankOffset)->read(1));
; 1939 : 
; 1940 : 						const Command *secondCommand = potentialCommand->isActivate() ? (currentRank->bank.begin() + currentBankOffset)->read(1) : potentialCommand;

	mov	eax, edi
$LN163@readNextCo@2:

; 1941 : 						assert(secondCommand->isReadOrWrite() || secondCommand->isBasicPrecharge());
; 1942 : 
; 1943 : 						if ((secondCommand->isRead() && readSweep) ||
; 1944 : 							(secondCommand->isWrite() && !readSweep) ||
; 1945 : 							secondCommand->isBasicPrecharge())

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN1176@readNextCo@2
	cmp	eax, 2
	jne	SHORT $LN57@readNextCo@2
$LN1176@readNextCo@2:
	cmp	BYTE PTR _readSweep$223345[esp+376], 0
	jne	$LN58@readNextCo@2
$LN57@readNextCo@2:
	cmp	eax, 3
	je	SHORT $LN1180@readNextCo@2
	cmp	eax, 4
	jne	SHORT $LN56@readNextCo@2
$LN1180@readNextCo@2:
	cmp	BYTE PTR _readSweep$223345[esp+376], 0
	je	$LN58@readNextCo@2
$LN56@readNextCo@2:
	cmp	eax, 6
	je	$LN58@readNextCo@2
$LN59@readNextCo@2:

; 1949 : 						}
; 1950 : 					}
; 1951 : 					else // don't have to follow read_write grouping considerations
; 1952 : 					{
; 1953 : 						return potentialCommand;
; 1954 : 					}
; 1955 : 				}
; 1956 : 
; 1957 : 				// before switching to the next rank, see if all the queues are refreshes in any rank
; 1958 : 				if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR _currentRank$223405[esp+376]
	test	eax, eax
	jne	$LN1745@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1195@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1186@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1186@readNextCo@2:
	push	ebx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN1727@readNextCo@2

; 1961 : 				}
; 1962 : 
; 1963 : 				// move on to the next rank
; 1964 : 				currentRank++;

	mov	ebp, DWORD PTR _currentRank$223405[esp+376]
	test	ebp, ebp
	jne	$LN1744@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1209@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1200@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1200@readNextCo@2:

; 1965 : 
; 1966 : 				if (currentRank == rank.end())

	mov	edi, DWORD PTR tv5223[esp+376]
	mov	esi, DWORD PTR [edi+16]
	add	ebx, 424				; 000001a8H
	mov	DWORD PTR _currentRank$223405[esp+380], ebx
	cmp	DWORD PTR [edi+12], esi
	jbe	SHORT $LN1215@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1215@readNextCo@2:
	mov	eax, DWORD PTR [edi]
	test	ebp, ebp
	je	SHORT $LN1226@readNextCo@2
	cmp	ebp, eax
	je	SHORT $LN1227@readNextCo@2
$LN1226@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1227@readNextCo@2:
	cmp	ebx, esi
	jne	SHORT $LN53@readNextCo@2

; 1967 : 				{
; 1968 : 					currentRank = rank.begin();

	mov	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN1237@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1237@readNextCo@2:
	mov	edx, DWORD PTR [edi]

; 1969 : 
; 1970 : 					// select the next bank
; 1971 : 					currentBankOffset = (currentBankOffset + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _currentBankOffset$223400[esp+376]
	mov	ecx, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [ecx+176]
	mov	DWORD PTR _currentRank$223405[esp+376], edx
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]
	mov	ebx, esi
	mov	DWORD PTR _currentRank$223405[esp+380], ebx
	mov	DWORD PTR _currentBankOffset$223400[esp+376], edx
$LN53@readNextCo@2:

; 1972 : 				}
; 1973 : 
; 1974 : 				// swap R/W for W/R when doing read/write grouping
; 1975 : 				if (currentBankOffset == startingBankOffset && currentRank == startingRank)

	mov	edx, DWORD PTR _currentBankOffset$223400[esp+376]
	cmp	edx, DWORD PTR _startingBankOffset$223418[esp+376]
	jne	$LN64@readNextCo@2
	mov	eax, DWORD PTR _currentRank$223405[esp+376]
	test	eax, eax
	je	SHORT $LN1250@readNextCo@2
	cmp	eax, DWORD PTR _startingRank$223423[esp+376]
	je	SHORT $LN1251@readNextCo@2
$LN1250@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1251@readNextCo@2:
	cmp	ebx, DWORD PTR _startingRank$223423[esp+380]
	jne	$LN64@readNextCo@2

; 1976 : 				{				
; 1977 : 					if (systemConfig.isReadWriteGrouping())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [eax+176]
	cmp	BYTE PTR [ecx+345], 0
	je	SHORT $LN1728@readNextCo@2

; 1978 : 					{
; 1979 : 						// try other types
; 1980 : 						readSweep = !readSweep;

	cmp	BYTE PTR _readSweep$223345[esp+376], 0
	sete	al
	mov	BYTE PTR _readSweep$223345[esp+376], al

; 1981 : 
; 1982 : 						if (readSweep == originalReadSweep)

	cmp	al, BYTE PTR _originalReadSweep$223424[esp+376]
	jne	$LN64@readNextCo@2
$LN1728@readNextCo@2:

; 1983 : 						{
; 1984 : #ifndef NDEBUG
; 1985 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 1986 : 							{
; 1987 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 1988 : 								{
; 1989 : 									assert(j->isEmpty());
; 1990 : 								}
; 1991 : 							}
; 1992 : #endif
; 1993 : 							return NULL;

	xor	eax, eax

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1745@readNextCo@2:

; 1949 : 						}
; 1950 : 					}
; 1951 : 					else // don't have to follow read_write grouping considerations
; 1952 : 					{
; 1953 : 						return potentialCommand;
; 1954 : 					}
; 1955 : 				}
; 1956 : 
; 1957 : 				// before switching to the next rank, see if all the queues are refreshes in any rank
; 1958 : 				if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1195@readNextCo@2
$LN1744@readNextCo@2:

; 1961 : 				}
; 1962 : 
; 1963 : 				// move on to the next rank
; 1964 : 				currentRank++;

	mov	eax, DWORD PTR [ebp]
	jmp	$LN1209@readNextCo@2
$LN58@readNextCo@2:

; 1946 : 						{
; 1947 : 							assert((currentRank->bank.begin() + currentBankOffset)->front() == potentialCommand);
; 1948 : 							return potentialCommand;

	mov	eax, edi

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1727@readNextCo@2:

; 1959 : 				{
; 1960 : 					return currentRank->bank.begin()->front();

	lea	esi, DWORD PTR _currentRank$223405[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	lea	esi, DWORD PTR $T646874[esp+376]
$LN1842@readNextCo@2:
	mov	edi, eax
	add	edi, 400				; 00000190H
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@readNextCo@2:

; 1994 : 						}						
; 1995 : 					}
; 1996 : 					else
; 1997 : 					{
; 1998 : 						return NULL;
; 1999 : 					}
; 2000 : 				}
; 2001 : 			}
; 2002 : 		}
; 2003 : 		break;
; 2004 : 
; 2005 : 		// keep rank id as long as possible, go round robin down a given rank
; 2006 : 	case BANK_ROUND_ROBIN:
; 2007 : 		{			
; 2008 : 			bool readSweep = true;
; 2009 : 
; 2010 : 			// look at the most recently retired command in this channel's history
; 2011 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN164@readNextCo@2
	mov	ecx, DWORD PTR [eax+80]

; 2012 : 
; 2013 : 			// attempt to issue RAS and CAS together
; 2014 : 			switch (lastCommandType)

	cmp	ecx, 12					; 0000000cH
	ja	$LN32@readNextCo@2
$LN1785@readNextCo@2:
	movzx	edx, BYTE PTR $LN1802@readNextCo@2[ecx]
	jmp	DWORD PTR $LN1845@readNextCo@2[edx*4]
$LN164@readNextCo@2:

; 1994 : 						}						
; 1995 : 					}
; 1996 : 					else
; 1997 : 					{
; 1998 : 						return NULL;
; 1999 : 					}
; 2000 : 				}
; 2001 : 			}
; 2002 : 		}
; 2003 : 		break;
; 2004 : 
; 2005 : 		// keep rank id as long as possible, go round robin down a given rank
; 2006 : 	case BANK_ROUND_ROBIN:
; 2007 : 		{			
; 2008 : 			bool readSweep = true;
; 2009 : 
; 2010 : 			// look at the most recently retired command in this channel's history
; 2011 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	ecx, 1

; 2012 : 
; 2013 : 			// attempt to issue RAS and CAS together
; 2014 : 			switch (lastCommandType)

	jmp	SHORT $LN1785@readNextCo@2
$LN45@readNextCo@2:

; 2015 : 			{
; 2016 : 			case Command::ACTIVATE:
; 2017 : 				{
; 2018 : 					// look at the command just after the RAS, it should be some sort of CAS
; 2019 : 
; 2020 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T646883[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T646881[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+400]
	lea	esi, DWORD PTR $T646880[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646882[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 2021 : 
; 2022 : 					if (nextCommand && nextCommand->isReadOrWrite())

	test	esi, esi
	je	SHORT $LN44@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al

; 2023 : 					{
; 2024 : 						return nextCommand;

	jne	$LN73@readNextCo@2
$LN44@readNextCo@2:

; 2025 : 					}
; 2026 : 					else
; 2027 : 					{
; 2028 : 						cerr << "error: row activate command not followed by a column command." << endl;

	push	OFFSET ??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 2029 : 						exit(2);

	push	2
	call	_exit
$LN1847@readNextCo@2:
$LN42@readNextCo@2:

; 2030 : 					}
; 2031 : 				}
; 2032 : 				break;
; 2033 : 				// doing read sweeping
; 2034 : 			case Command::READ:
; 2035 : 				// try to reuse open rows
; 2036 : 				if (lastCommand)

	test	eax, eax
	je	$LN40@readNextCo@2

; 2037 : 				{
; 2038 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T646887[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T646885[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+400]
	lea	esi, DWORD PTR $T646884[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646886[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 2039 : 
; 2040 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN40@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 2041 : 					{
; 2042 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN40@readNextCo@2:

; 2043 : 					}
; 2044 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 2045 : 				}			
; 2046 : 			case Command::REFRESH_ALL:
; 2047 : 			case Command::READ_AND_PRECHARGE:
; 2048 : 			case Command::PRECHARGE:
; 2049 : 				readSweep = true;

	mov	BYTE PTR _readSweep$223456[esp+376], 1

; 2050 : 				break;

	jmp	$LN46@readNextCo@2
$LN37@readNextCo@2:

; 2051 : 
; 2052 : 				// doing write sweeping
; 2053 : 			case Command::WRITE:
; 2054 : 				// try to reuse open rows
; 2055 : 				if (lastCommand)

	test	eax, eax
	je	$LN35@readNextCo@2

; 2056 : 				{
; 2057 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T646891[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T646889[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+400]
	lea	esi, DWORD PTR $T646888[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646890[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 2058 : 
; 2059 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN35@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 2060 : 					{
; 2061 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN35@readNextCo@2:

; 2062 : 					}
; 2063 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 2064 : 				}			
; 2065 : 			case Command::WRITE_AND_PRECHARGE:
; 2066 : 				readSweep = false;

	mov	BYTE PTR _readSweep$223456[esp+376], 0

; 2067 : 				break;

	jmp	SHORT $LN46@readNextCo@2
$LN32@readNextCo@2:

; 2068 : 
; 2069 : 			default:
; 2070 : 				readSweep = true; // FIXME: added this to ensure no uninit vars
; 2071 : 				cerr << "warn: unhandled command type" << endl;

	push	OFFSET ??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	BYTE PTR _readSweep$223456[esp+384], 1
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN46@readNextCo@2:

; 2072 : 				break;
; 2073 : 			}
; 2074 : 
; 2075 : 			vector<Rank>::const_iterator currentRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);

	mov	ebx, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN166@readNextCo@2
	mov	edi, DWORD PTR [eax+60]
	jmp	SHORT $LN167@readNextCo@2
$LN166@readNextCo@2:
	xor	edi, edi
$LN167@readNextCo@2:
	mov	esi, DWORD PTR [ebx+412]
	cmp	esi, DWORD PTR [ebx+416]
	jbe	SHORT $LN1301@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1301@readNextCo@2:
	mov	eax, DWORD PTR [ebx+400]
	lea	ecx, DWORD PTR _currentRank$223515[esp+376]
	mov	DWORD PTR $T646892[esp+376], eax
	push	ecx
	mov	ecx, edi
	lea	eax, DWORD PTR $T646892[esp+380]
	mov	DWORD PTR $T646892[esp+384], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+

; 2076 : 			vector<Bank>::const_iterator currentBank = currentRank->bank.begin() + (lastCommand ? lastCommand->getAddress().getBank() : 0) + 1;

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN168@readNextCo@2
	mov	ebp, DWORD PTR [eax+64]
	jmp	SHORT $LN169@readNextCo@2
$LN168@readNextCo@2:
	xor	ebp, ebp
$LN169@readNextCo@2:
	lea	esi, DWORD PTR _currentRank$223515[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	edi, DWORD PTR [esi+412]
	add	esi, 400				; 00000190H
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN1319@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1319@readNextCo@2:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _currentBank$223522[esp+376]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T646898[esp+384]
	push	ecx
	mov	ecx, ebp
	lea	eax, DWORD PTR $T646895[esp+388]
	mov	DWORD PTR $T646895[esp+388], edx
	mov	DWORD PTR $T646895[esp+392], edi
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	add	esp, 4
	mov	ecx, 1
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+

; 2077 : 			if (currentBank == currentRank->bank.end())

	lea	esi, DWORD PTR _currentRank$223515[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	edi, DWORD PTR [esi+416]
	add	esi, 400				; 00000190H
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN1333@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1333@readNextCo@2:
	mov	ebx, DWORD PTR _currentBank$223522[esp+376]
	mov	esi, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN1344@readNextCo@2
	cmp	ebx, esi
	je	SHORT $LN1345@readNextCo@2
$LN1344@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1345@readNextCo@2:
	mov	ebp, DWORD PTR _currentBank$223522[esp+380]
	cmp	ebp, edi
	jne	SHORT $LN31@readNextCo@2

; 2078 : 			{
; 2079 : 				currentRank++;

	lea	edi, DWORD PTR $T646900[esp+376]
	lea	esi, DWORD PTR _currentRank$223515[esp+376]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++

; 2080 : 				if (currentRank == rank.end())

	mov	ebx, DWORD PTR _this$[esp+376]
	add	ebx, 400				; 00000190H
	lea	esi, DWORD PTR $T646901[esp+376]
	mov	edi, ebx
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	esi, eax
	lea	edi, DWORD PTR _currentRank$223515[esp+376]
	call	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
	test	al, al
	je	SHORT $LN30@readNextCo@2

; 2081 : 					currentRank = rank.begin();

	lea	esi, DWORD PTR $T646902[esp+376]
	mov	edi, ebx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _currentRank$223515[esp+376], edx
	mov	DWORD PTR _currentRank$223515[esp+380], eax
$LN30@readNextCo@2:

; 2082 : 				currentBank = currentRank->bank.begin();

	lea	esi, DWORD PTR _currentRank$223515[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T646903[esp+376]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ebx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _currentBank$223522[esp+376], ebx
	mov	DWORD PTR _currentBank$223522[esp+380], ebp
$LN31@readNextCo@2:

; 2083 : 			}
; 2084 : 
; 2085 : 			// set original values to know when a full sweep is finished
; 2086 : 			const vector<Rank>::const_iterator rankEnd = rank.end();

	mov	esi, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [esi+416]
	add	esi, 400				; 00000190H
	mov	DWORD PTR $T650460[esp+376], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN1355@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1355@readNextCo@2:
	mov	ecx, DWORD PTR [esi]

; 2087 : 			const vector<Bank>::const_iterator startingBank = currentBank;
; 2088 : 			const vector<Rank>::const_iterator startingRank = currentRank;

	mov	edx, DWORD PTR _currentRank$223515[esp+376]
	mov	eax, DWORD PTR _currentRank$223515[esp+380]
	mov	DWORD PTR _rankEnd$223537[esp+376], ecx

; 2089 : 			const bool originalReadSweep = readSweep;

	mov	cl, BYTE PTR _readSweep$223456[esp+376]
	mov	DWORD PTR _startingBank$223543[esp+376], ebx
	mov	DWORD PTR _startingBank$223543[esp+380], ebp
	mov	DWORD PTR _startingRank$223548[esp+376], edx
	mov	DWORD PTR _startingRank$223548[esp+380], eax
	mov	BYTE PTR _originalReadSweep$223549[esp+376], cl
$LL29@readNextCo@2:

; 2090 : 
; 2091 : 			while (true)
; 2092 : 			{
; 2093 : 				const Command *potentialCommand = currentBank->front();

	test	ebx, ebx
	jne	$LN1743@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1377@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1368@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1368@readNextCo@2:
	mov	edx, DWORD PTR [ebp+40]
	sub	edx, DWORD PTR [ebp+36]
	mov	esi, DWORD PTR [ebp+16]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1384@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1384@readNextCo@2:
	mov	eax, DWORD PTR [ebp+36]
	mov	edi, DWORD PTR [eax+esi*4]

; 2094 : 
; 2095 : 				// see if this command could be used
; 2096 : 				if (potentialCommand && !potentialCommand->isRefresh())

	test	edi, edi
	je	$LN24@readNextCo@2
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	$LN24@readNextCo@2

; 2097 : 				{	
; 2098 : 					if (systemConfig.isReadWriteGrouping())

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+176]
	cmp	BYTE PTR [edx+345], 0
	je	$LN58@readNextCo@2

; 2099 : 					{
; 2100 : 						if (potentialCommand->isActivate())
; 2101 : 							assert(currentBank->read(1));
; 2102 : 
; 2103 : 						const Command *secondCommand = (potentialCommand->isActivate() && currentBank->read(1)) ? currentBank->read(1) : potentialCommand;

	test	eax, eax
	je	SHORT $LN1399@readNextCo@2
	cmp	eax, 8
	jne	SHORT $LN170@readNextCo@2
$LN1399@readNextCo@2:
	lea	esi, DWORD PTR _currentBank$223522[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	test	eax, eax
	je	SHORT $LN170@readNextCo@2
	lea	esi, DWORD PTR _currentBank$223522[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	jmp	SHORT $LN171@readNextCo@2
$LN1743@readNextCo@2:

; 2090 : 
; 2091 : 			while (true)
; 2092 : 			{
; 2093 : 				const Command *potentialCommand = currentBank->front();

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1377@readNextCo@2
$LN170@readNextCo@2:

; 2099 : 					{
; 2100 : 						if (potentialCommand->isActivate())
; 2101 : 							assert(currentBank->read(1));
; 2102 : 
; 2103 : 						const Command *secondCommand = (potentialCommand->isActivate() && currentBank->read(1)) ? currentBank->read(1) : potentialCommand;

	mov	eax, edi
$LN171@readNextCo@2:

; 2104 : 						assert(secondCommand->isReadOrWrite() || secondCommand->isBasicPrecharge());
; 2105 : 
; 2106 : 						if ((secondCommand->isRead() && readSweep) ||
; 2107 : 							(secondCommand->isWrite() && !readSweep) || 
; 2108 : 							secondCommand->isBasicPrecharge())

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN1403@readNextCo@2
	cmp	eax, 2
	jne	SHORT $LN22@readNextCo@2
$LN1403@readNextCo@2:
	cmp	BYTE PTR _readSweep$223456[esp+376], 0
	jne	$LN58@readNextCo@2
$LN22@readNextCo@2:
	cmp	eax, 3
	je	SHORT $LN1407@readNextCo@2
	cmp	eax, 4
	jne	SHORT $LN21@readNextCo@2
$LN1407@readNextCo@2:
	cmp	BYTE PTR _readSweep$223456[esp+376], 0
	je	$LN58@readNextCo@2
$LN21@readNextCo@2:
	cmp	eax, 6
	je	$LN58@readNextCo@2
$LN24@readNextCo@2:

; 2109 : 						{
; 2110 : 							assert(currentBank->front()->getAddress().getRank() == currentRank->getRankID());
; 2111 : 							assert(currentBank->front() == potentialCommand);
; 2112 : 							return potentialCommand;
; 2113 : 						}
; 2114 : 					}
; 2115 : 					else // don't have to follow read_write grouping considerations
; 2116 : 					{
; 2117 : 						return potentialCommand;
; 2118 : 					}
; 2119 : 				}
; 2120 : 
; 2121 : 				// then switch to the next bank
; 2122 : 				currentBank++;

	test	ebx, ebx
	jne	$LN1742@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1422@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1413@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1413@readNextCo@2:

; 2123 : 				if (currentBank == currentRank->bank.end())

	mov	eax, DWORD PTR _currentRank$223515[esp+376]
	add	ebp, 168				; 000000a8H
	mov	DWORD PTR _currentBank$223522[esp+380], ebp
	test	eax, eax
	jne	$LN1741@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1436@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$223515[esp+380]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1427@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1427@readNextCo@2:
	mov	eax, DWORD PTR _currentRank$223515[esp+380]
	mov	esi, DWORD PTR [eax+416]
	cmp	DWORD PTR [eax+412], esi
	jbe	SHORT $LN1442@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1442@readNextCo@2:
	mov	edx, DWORD PTR _currentRank$223515[esp+380]
	mov	eax, DWORD PTR [edx+400]
	test	ebx, ebx
	je	SHORT $LN1453@readNextCo@2
	cmp	ebx, eax
	je	SHORT $LN1454@readNextCo@2
$LN1453@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1454@readNextCo@2:
	cmp	ebp, esi
	jne	$LN19@readNextCo@2

; 2124 : 				{
; 2125 : 					// before switching to the next rank, see if all the queues are refreshes in any rank
; 2126 : 					if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR _currentRank$223515[esp+376]
	test	eax, eax
	jne	$LN1740@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1472@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$223515[esp+380]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1463@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1463@readNextCo@2:
	mov	edi, DWORD PTR _currentRank$223515[esp+380]
	push	edi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN1729@readNextCo@2

; 2129 : 					}
; 2130 : 
; 2131 : 					currentRank++;

	mov	ebx, DWORD PTR _currentRank$223515[esp+376]
	test	ebx, ebx
	jne	$LN1739@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1486@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1477@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1477@readNextCo@2:
	add	edi, 424				; 000001a8H
	mov	DWORD PTR _currentRank$223515[esp+380], edi

; 2132 : 					if (currentRank == rankEnd)

	test	ebx, ebx
	je	SHORT $LN1489@readNextCo@2
	cmp	ebx, DWORD PTR _rankEnd$223537[esp+376]
	je	SHORT $LN1490@readNextCo@2
$LN1489@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1490@readNextCo@2:
	cmp	edi, DWORD PTR $T650460[esp+376]
	jne	SHORT $LN17@readNextCo@2

; 2133 : 						currentRank = rank.begin();

	mov	edi, DWORD PTR _this$[esp+376]
	mov	esi, DWORD PTR [edi+412]
	add	edi, 400				; 00000190H
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN1500@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1500@readNextCo@2:
	mov	ebx, DWORD PTR [edi]
	mov	edi, esi
	mov	DWORD PTR _currentRank$223515[esp+376], ebx
	mov	DWORD PTR _currentRank$223515[esp+380], edi
$LN17@readNextCo@2:

; 2134 : 					currentBank = currentRank->bank.begin();		

	test	ebx, ebx
	jne	$LN1738@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1522@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1513@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1513@readNextCo@2:
	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN1528@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1528@readNextCo@2:
	mov	ebx, DWORD PTR [edi+400]
	mov	ebp, esi
	mov	DWORD PTR _currentBank$223522[esp+376], ebx
	mov	DWORD PTR _currentBank$223522[esp+380], ebp
$LN19@readNextCo@2:

; 2135 : 				}
; 2136 : 
; 2137 : 				// back to the beginning, either no result or look for the opposite type
; 2138 : 				// n.b. must compare rank iterators first, otherwise comparing bank iterators based on unequal rank iterators is a runtime error
; 2139 : 				if (currentRank == startingRank && currentBank == startingBank)

	mov	eax, DWORD PTR _currentRank$223515[esp+376]
	test	eax, eax
	je	SHORT $LN1539@readNextCo@2
	cmp	eax, DWORD PTR _startingRank$223548[esp+376]
	je	SHORT $LN1540@readNextCo@2
$LN1539@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1540@readNextCo@2:
	mov	edx, DWORD PTR _currentRank$223515[esp+380]
	cmp	edx, DWORD PTR _startingRank$223548[esp+380]
	jne	$LL29@readNextCo@2
	test	ebx, ebx
	je	SHORT $LN1547@readNextCo@2
	cmp	ebx, DWORD PTR _startingBank$223543[esp+376]
	je	SHORT $LN1548@readNextCo@2
$LN1547@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1548@readNextCo@2:
	cmp	ebp, DWORD PTR _startingBank$223543[esp+380]
	jne	$LL29@readNextCo@2

; 2140 : 				{						
; 2141 : 					if (systemConfig.isReadWriteGrouping())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [eax+176]
	cmp	BYTE PTR [ecx+345], 0
	je	$LN1728@readNextCo@2

; 2142 : 					{
; 2143 : 						// try other types
; 2144 : 						readSweep = !readSweep;

	cmp	BYTE PTR _readSweep$223456[esp+376], 0
	sete	al
	mov	BYTE PTR _readSweep$223456[esp+376], al

; 2145 : 
; 2146 : 						if (readSweep == originalReadSweep)

	cmp	al, BYTE PTR _originalReadSweep$223549[esp+376]
	jne	$LL29@readNextCo@2

; 1983 : 						{
; 1984 : #ifndef NDEBUG
; 1985 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 1986 : 							{
; 1987 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 1988 : 								{
; 1989 : 									assert(j->isEmpty());
; 1990 : 								}
; 1991 : 							}
; 1992 : #endif
; 1993 : 							return NULL;

	xor	eax, eax

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1742@readNextCo@2:

; 2109 : 						{
; 2110 : 							assert(currentBank->front()->getAddress().getRank() == currentRank->getRankID());
; 2111 : 							assert(currentBank->front() == potentialCommand);
; 2112 : 							return potentialCommand;
; 2113 : 						}
; 2114 : 					}
; 2115 : 					else // don't have to follow read_write grouping considerations
; 2116 : 					{
; 2117 : 						return potentialCommand;
; 2118 : 					}
; 2119 : 				}
; 2120 : 
; 2121 : 				// then switch to the next bank
; 2122 : 				currentBank++;

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1422@readNextCo@2
$LN1741@readNextCo@2:

; 2123 : 				if (currentBank == currentRank->bank.end())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1436@readNextCo@2
$LN1740@readNextCo@2:

; 2124 : 				{
; 2125 : 					// before switching to the next rank, see if all the queues are refreshes in any rank
; 2126 : 					if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1472@readNextCo@2
$LN1739@readNextCo@2:

; 2129 : 					}
; 2130 : 
; 2131 : 					currentRank++;

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1486@readNextCo@2
$LN1738@readNextCo@2:

; 2134 : 					currentBank = currentRank->bank.begin();		

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1522@readNextCo@2
$LN1729@readNextCo@2:

; 2127 : 					{
; 2128 : 						return currentRank->bank.begin()->front();

	lea	esi, DWORD PTR _currentRank$223515[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	lea	esi, DWORD PTR $T646908[esp+376]
	jmp	$LN1842@readNextCo@2
$LN12@readNextCo@2:

; 2147 : 						{
; 2148 : #ifndef NDEBUG
; 2149 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 2150 : 							{
; 2151 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 2152 : 								{
; 2153 : 									assert(j->isEmpty());
; 2154 : 								}
; 2155 : 							}
; 2156 : #endif
; 2157 : 							return NULL;
; 2158 : 						}	
; 2159 : 					}					
; 2160 : 					else
; 2161 : 					{
; 2162 : 
; 2163 : 						return NULL;
; 2164 : 					}
; 2165 : 				}			
; 2166 : 			}
; 2167 : 		}
; 2168 : 		break;
; 2169 : 
; 2170 : 	case COMMAND_PAIR_RANK_HOPPING:
; 2171 : 		{	
; 2172 : 			// determine
; 2173 : 			bool isActivate;
; 2174 : 			unsigned nextRank, nextBank;
; 2175 : 
; 2176 : 			if (lastCommand)

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN11@readNextCo@2

; 2177 : 			{
; 2178 : 				isActivate = lastCommand->isActivate();

	call	?isActivate@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isActivate
	mov	bl, al

; 2179 : 				nextRank = lastCommand->getAddress().getRank();

	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR [eax+60]

; 2180 : 				nextBank = lastCommand->getAddress().getBank();

	mov	eax, DWORD PTR [eax+64]
	mov	BYTE PTR _isActivate$223581[esp+376], bl

; 2181 : 				getNextCPRHValues(nextRank, nextBank, isActivate);

	mov	ecx, DWORD PTR _isActivate$223581[esp+376]
	mov	DWORD PTR _nextRank$223582[esp+376], edx
	push	ecx
	mov	DWORD PTR _nextBank$223583[esp+380], eax
	lea	edx, DWORD PTR _nextBank$223583[esp+380]
	push	edx
	lea	eax, DWORD PTR _nextRank$223582[esp+384]
	push	eax
	mov	eax, ebp
	call	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues

; 2182 : 				assert(nextRank < systemConfig.getRankCount());
; 2183 : 				assert(nextBank < systemConfig.getBankCount());
; 2184 : 				isActivate = !isActivate;

	test	bl, bl

; 2185 : 			}
; 2186 : 			else // special case, must reset to the first value in the pattern

	mov	ebx, DWORD PTR _nextBank$223583[esp+376]
	sete	BYTE PTR _isActivate$223581[esp+376]
	jmp	SHORT $LN10@readNextCo@2
$LN11@readNextCo@2:

; 2187 : 			{
; 2188 : 				isActivate = true;
; 2189 : 				nextRank = 0;
; 2190 : 				nextBank = systemConfig.getBankCount() / 2;

	mov	ebx, DWORD PTR [ecx+364]
	shr	ebx, 1
	mov	BYTE PTR _isActivate$223581[esp+376], 1
	mov	DWORD PTR _nextRank$223582[esp+376], 0
	mov	DWORD PTR _nextBank$223583[esp+376], ebx
$LN10@readNextCo@2:

; 2191 : 			}
; 2192 : 
; 2193 : 			const unsigned originalRank = nextRank;

	mov	ecx, DWORD PTR _nextRank$223582[esp+376]

; 2194 : 			const unsigned originalBank = nextBank;
; 2195 : 			const bool originalActivate = isActivate;

	mov	dl, BYTE PTR _isActivate$223581[esp+376]
	mov	DWORD PTR _originalRank$223588[esp+376], ecx
	mov	DWORD PTR _originalBank$223589[esp+376], ebx
	mov	BYTE PTR _originalActivate$223590[esp+376], dl
	npad	4
$LL9@readNextCo@2:

; 2196 : 
; 2197 : 			while (true)
; 2198 : 			{
; 2199 : 				const Command *potentialCommand = 						
; 2200 : 					((rank.begin() + nextRank)->bank.begin() + nextBank)->front();

	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [esi+412]
	cmp	edi, DWORD PTR [esi+416]
	jbe	SHORT $LN1570@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1570@readNextCo@2:
	mov	esi, DWORD PTR [esi+400]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$651140[esp+380], edi
	test	esi, esi
	jne	SHORT $LN1737@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1593@readNextCo@2:
	mov	ecx, DWORD PTR _nextRank$223582[esp+376]
	imul	ecx, 424				; 000001a8H
	add	edi, ecx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN1583@readNextCo@2
	test	esi, esi
	je	SHORT $LN1598@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1599@readNextCo@2
$LN1737@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1593@readNextCo@2
$LN1598@readNextCo@2:
	xor	esi, esi
$LN1599@readNextCo@2:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN1584@readNextCo@2
$LN1583@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1584@readNextCo@2:
	test	ebp, ebp
	jne	SHORT $LN1736@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1613@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1604@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1604@readNextCo@2:
	mov	ebp, DWORD PTR [edi+412]
	cmp	ebp, DWORD PTR [edi+416]
	jbe	SHORT $LN1619@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1619@readNextCo@2:
	mov	esi, DWORD PTR [edi+400]
	mov	DWORD PTR __Tmp$651325[esp+376], esi
	mov	DWORD PTR __Tmp$651325[esp+380], ebp
	test	esi, esi
	jne	SHORT $LN1735@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1642@readNextCo@2:
	imul	ebx, 168				; 000000a8H
	lea	edi, DWORD PTR [ebx+ebp]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN1632@readNextCo@2
	test	esi, esi
	je	SHORT $LN1647@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1648@readNextCo@2
$LN1736@readNextCo@2:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN1613@readNextCo@2
$LN1735@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1642@readNextCo@2
$LN1647@readNextCo@2:
	xor	esi, esi
$LN1648@readNextCo@2:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN1633@readNextCo@2
$LN1632@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1633@readNextCo@2:
	mov	eax, DWORD PTR __Tmp$651325[esp+376]
	test	eax, eax
	jne	SHORT $LN1734@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1662@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1653@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1653@readNextCo@2:
	mov	edx, DWORD PTR [edi+40]
	sub	edx, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [edi+16]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1669@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1669@readNextCo@2:
	mov	eax, DWORD PTR [edi+36]
	mov	edi, DWORD PTR [eax+esi*4]

; 2201 : 
; 2202 : 				// see if this command could be used
; 2203 : 				if (potentialCommand)

	test	edi, edi
	je	$LN3@readNextCo@2

; 2204 : 				{
; 2205 : 					if (!potentialCommand->isRefresh())

	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN6@readNextCo@2

; 2206 : 					{
; 2207 : 						if (potentialCommand->isActivate() == isActivate)

	test	eax, eax
	je	SHORT $LN1678@readNextCo@2
	cmp	eax, 8
	je	SHORT $LN1678@readNextCo@2
	xor	eax, eax
	jmp	SHORT $LN1679@readNextCo@2
$LN1734@readNextCo@2:

; 2196 : 
; 2197 : 			while (true)
; 2198 : 			{
; 2199 : 				const Command *potentialCommand = 						
; 2200 : 					((rank.begin() + nextRank)->bank.begin() + nextBank)->front();

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1662@readNextCo@2

; 2206 : 					{
; 2207 : 						if (potentialCommand->isActivate() == isActivate)

$LN1678@readNextCo@2:
	mov	eax, 1
$LN1679@readNextCo@2:
	cmp	al, BYTE PTR _isActivate$223581[esp+376]
	je	$LN58@readNextCo@2

; 2208 : 						{							
; 2209 : 							return potentialCommand;
; 2210 : 						}
; 2211 : 					}
; 2212 : 					else

	jmp	SHORT $LN3@readNextCo@2
$LN6@readNextCo@2:

; 2213 : 					{
; 2214 : 						// look for refreshes
; 2215 : 						if ((rank.begin() + nextRank)->refreshAllReady())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	esi, DWORD PTR [eax+412]
	cmp	esi, DWORD PTR [eax+416]
	jbe	SHORT $LN1683@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1683@readNextCo@2:
	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+400]
	mov	ecx, DWORD PTR _nextRank$223582[esp+376]
	lea	eax, DWORD PTR $T646917[esp+376]
	push	eax
	lea	eax, DWORD PTR $T646916[esp+380]
	mov	DWORD PTR $T646916[esp+380], edx
	mov	DWORD PTR $T646916[esp+384], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN1783@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1704@readNextCo@2
$LN1783@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1705@readNextCo@2
$LN1704@readNextCo@2:
	xor	eax, eax
$LN1705@readNextCo@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1696@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1696@readNextCo@2:
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN58@readNextCo@2
$LN3@readNextCo@2:

; 2216 : 						{
; 2217 : 							return potentialCommand;
; 2218 : 						}
; 2219 : 					}
; 2220 : 				}
; 2221 : 
; 2222 : 				// then switch command
; 2223 : 				getNextCPRHValues(nextRank, nextBank, isActivate);

	mov	edx, DWORD PTR _isActivate$223581[esp+376]
	push	edx
	lea	eax, DWORD PTR _nextBank$223583[esp+380]
	push	eax
	mov	eax, DWORD PTR _this$[esp+384]
	lea	ecx, DWORD PTR _nextRank$223582[esp+384]
	push	ecx
	call	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues

; 2224 : 				isActivate = !isActivate;	

	cmp	BYTE PTR _isActivate$223581[esp+376], 0

; 2225 : 
; 2226 : 				// quit if already checked every rank/bank combination
; 2227 : 				if (nextRank == originalRank && nextBank == originalBank && originalActivate == isActivate)

	mov	eax, DWORD PTR _nextRank$223582[esp+376]
	mov	ebx, DWORD PTR _nextBank$223583[esp+376]
	sete	dl
	mov	BYTE PTR _isActivate$223581[esp+376], dl
	cmp	eax, DWORD PTR _originalRank$223588[esp+376]
	jne	$LL9@readNextCo@2
	cmp	ebx, DWORD PTR _originalBank$223589[esp+376]
	jne	$LL9@readNextCo@2
	mov	cl, dl
	cmp	BYTE PTR _originalActivate$223590[esp+376], cl
	jne	$LL9@readNextCo@2

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@readNextCo@2:

; 2228 : 				{
; 2229 : 					return NULL;
; 2230 : 				}							
; 2231 : 			}
; 2232 : 		}
; 2233 : 		break;
; 2234 : 
; 2235 : 	default:
; 2236 : 		{
; 2237 : 			cerr << "This configuration and algorithm combination is not supported" << endl;

	push	OFFSET ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 2238 : 			exit(-2);

	push	-2					; fffffffeH
	call	_exit
$LN1848@readNextCo@2:
$LN1831@readNextCo@2:
	npad	1
$LN1843@readNextCo@2:

; 2239 : 		}
; 2240 : 		break;
; 2241 : 	}
; 2242 : 	return NULL;
; 2243 : }

	DD	$LN95@readNextCo@2
	DD	$LN82@readNextCo@2
	DD	$LN48@readNextCo@2
	DD	$LN151@readNextCo@2
	DD	$LN135@readNextCo@2
	DD	$LN113@readNextCo@2
	DD	$LN12@readNextCo@2
$LN1844@readNextCo@2:
	DD	$LN79@readNextCo@2
	DD	$LN76@readNextCo@2
	DD	$LN74@readNextCo@2
	DD	$LN71@readNextCo@2
	DD	$LN69@readNextCo@2
	DD	$LN66@readNextCo@2
$LN1801@readNextCo@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	npad	3
$LN1845@readNextCo@2:
	DD	$LN45@readNextCo@2
	DD	$LN42@readNextCo@2
	DD	$LN40@readNextCo@2
	DD	$LN37@readNextCo@2
	DD	$LN35@readNextCo@2
	DD	$LN32@readNextCo@2
$LN1802@readNextCo@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ ENDP ; DRAMsimII::Channel::readNextCommand
_TEXT	ENDS
PUBLIC	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_i$222821 = -16						; size = 8
_currentBank$222800 = -16				; size = 8
_destinationBank$ = -16					; size = 4
$T651660 = -8						; size = 8
$T651658 = -8						; size = 8
_this$ = 8						; size = 4
?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z PROC ; DRAMsimII::Channel::checkForAvailableCommandSlots
; _incomingTransaction$ = eax

; 990  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax

; 991  : 	if (incomingTransaction == NULL)

	test	edi, edi

; 992  : 	{
; 993  : 		return false;

	je	$LN235@checkForAv

; 994  : 	}
; 995  : 	// ensure that this transaction belongs on this channel
; 996  : 	assert (incomingTransaction->getAddress().getChannel() == channelID || incomingTransaction->isRefresh());
; 997  : 
; 998  : 	/// @todo switch to iterator arithmetic
; 999  : 	const Bank &destinationBank = rank[incomingTransaction->getAddress().getRank()].bank[incomingTransaction->getAddress().getBank()];

	mov	ebx, DWORD PTR _this$[esp+28]
	mov	edx, DWORD PTR [ebx+416]
	sub	edx, DWORD PTR [ebx+412]
	mov	ebp, DWORD PTR [edi+60]
	mov	esi, DWORD PTR [edi+64]
	add	ebx, 400				; 00000190H
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN46@checkForAv
	call	__invalid_parameter_noinfo
$LN46@checkForAv:
	mov	ecx, DWORD PTR [ebx+12]
	imul	ebp, 424				; 000001a8H
	mov	edx, DWORD PTR [ecx+ebp+416]
	sub	edx, DWORD PTR [ecx+ebp+412]
	lea	ebp, DWORD PTR [ecx+ebp+400]
	mov	eax, 818089009				; 30c30c31H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN51@checkForAv
	call	__invalid_parameter_noinfo
$LN51@checkForAv:
	imul	esi, 168				; 000000a8H
	add	esi, DWORD PTR [ebp+12]

; 1000 : 
; 1001 : 	unsigned availableCommandSlots = (incomingTransaction->isRefresh()) ? 0 : rank[incomingTransaction->getAddress().getRank()].bank[incomingTransaction->getAddress().getBank()].freeCommandSlots();

	cmp	DWORD PTR [edi+80], 4
	mov	ecx, esi
	mov	DWORD PTR _destinationBank$[esp+32], ecx
	jne	SHORT $LN36@checkForAv
	xor	ebp, ebp
	jmp	SHORT $LN37@checkForAv
$LN36@checkForAv:
	mov	edx, DWORD PTR [ebx+16]
	sub	edx, DWORD PTR [ebx+12]
	mov	ebp, DWORD PTR [edi+60]
	mov	esi, DWORD PTR [edi+64]
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN66@checkForAv
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN66@checkForAv:
	mov	edx, DWORD PTR [ebx+12]
	imul	ebp, 424				; 000001a8H
	lea	ebp, DWORD PTR [edx+ebp+400]
	mov	edx, DWORD PTR [ebp+16]
	sub	edx, DWORD PTR [ebp+12]
	mov	eax, 818089009				; 30c30c31H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN71@checkForAv
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN71@checkForAv:
	mov	edx, DWORD PTR [ebp+12]
	imul	esi, 168				; 000000a8H
	mov	ebp, DWORD PTR [esi+edx+40]
	sub	ebp, DWORD PTR [esi+edx+36]
	lea	esi, DWORD PTR [esi+edx+12]
	sar	ebp, 2
	sub	ebp, DWORD PTR [esi]
$LN37@checkForAv:

; 1002 : 
; 1003 : 	// with closed page, all transactions convert into one of the following:
; 1004 : 	// RAS, CAS, Precharge
; 1005 : 	// RAS, CAS+Precharge
; 1006 : 	switch (systemConfig.getRowBufferManagementPolicy())

	mov	eax, DWORD PTR _this$[esp+28]
	mov	edx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR [edx+328]
	lea	esi, DWORD PTR [edx-1]
	cmp	esi, 3
	ja	$LN1@checkForAv
	jmp	DWORD PTR $LN238@checkForAv[esi*4]
$LN30@checkForAv:

; 1007 : 	{
; 1008 : 	case CLOSE_PAGE_AGGRESSIVE:
; 1009 : 	case CLOSE_PAGE:	
; 1010 : 		// refresh transactions become only one command and are handled differently
; 1011 : 		if (incomingTransaction->isRefresh())

	cmp	DWORD PTR [edi+80], 4
	jne	SHORT $LN29@checkForAv

; 1012 : 		{
; 1013 : 			const Rank &destinationRank = rank[incomingTransaction->getAddress().getRank()];

	mov	edi, DWORD PTR [edi+60]
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]

; 1014 : 			// make sure that there is room in all the queues for one command
; 1015 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1016 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1017 : 			// are available
; 1018 : 			for (vector<Bank>::const_iterator currentBank = destinationRank.bank.begin(); currentBank != destinationRank.bank.end(); currentBank++)

	lea	ebx, DWORD PTR [eax+400]
	lea	esi, DWORD PTR _currentBank$222800[esp+32]
	mov	edi, ebx
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
$LL28@checkForAv:
	mov	ebp, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN93@checkForAv
	call	__invalid_parameter_noinfo
$LN93@checkForAv:
	mov	esi, DWORD PTR _currentBank$222800[esp+32]
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN106@checkForAv
	cmp	esi, eax
	je	SHORT $LN107@checkForAv
$LN106@checkForAv:
	call	__invalid_parameter_noinfo
$LN107@checkForAv:
	mov	edi, DWORD PTR _currentBank$222800[esp+36]
	cmp	edi, ebp
	je	SHORT $LN19@checkForAv

; 1019 : 			{
; 1020 : 				if (currentBank->isFull())

	test	esi, esi
	jne	SHORT $LN229@checkForAv
	call	__invalid_parameter_noinfo
$LN125@checkForAv:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN116@checkForAv
	call	__invalid_parameter_noinfo
$LN116@checkForAv:
	mov	eax, DWORD PTR [edi+40]
	sub	eax, DWORD PTR [edi+36]
	sar	eax, 2
	cmp	eax, DWORD PTR [edi+12]
	je	$LN235@checkForAv
	lea	edi, DWORD PTR $T651658[esp+32]
	lea	esi, DWORD PTR _currentBank$222800[esp+32]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	jmp	SHORT $LL28@checkForAv
$LN229@checkForAv:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN125@checkForAv
$LN29@checkForAv:

; 1021 : 					return false;
; 1022 : 			}
; 1023 : 		}
; 1024 : 		// must know that there is >0 slots open or the result may not be accurate
; 1025 : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 1026 : 			destinationBank.closePageAggressiveInsertCheck(incomingTransaction, time))

	cmp	edx, 4
	jne	SHORT $LN23@checkForAv
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR _destinationBank$[esp+32]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?closePageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::closePageAggressiveInsertCheck
	test	al, al

; 1027 : 		{
; 1028 : 			return true;

	jne	$LN3@checkForAv

; 1021 : 					return false;
; 1022 : 			}
; 1023 : 		}
; 1024 : 		// must know that there is >0 slots open or the result may not be accurate
; 1025 : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 1026 : 			destinationBank.closePageAggressiveInsertCheck(incomingTransaction, time))

	mov	eax, DWORD PTR _this$[esp+28]
$LN23@checkForAv:

; 1029 : 		}	
; 1030 : 		// every transaction translates into at least two commands
; 1031 : 		else if (availableCommandSlots < 2)

	cmp	ebp, 2

; 1032 : 		{
; 1033 : 			return false;

	jb	$LN235@checkForAv

; 1034 : 		}
; 1035 : 		// or three commands if the CAS+Precharge command is not available
; 1036 : 		else if (!systemConfig.isAutoPrecharge() && (availableCommandSlots < 3))

	mov	eax, DWORD PTR [eax+176]
	cmp	BYTE PTR [eax+346], 0
	jne	SHORT $LN19@checkForAv
	cmp	ebp, 3

; 1037 : 		{
; 1038 : 			return false;

	jb	$LN235@checkForAv
$LN19@checkForAv:

; 1104 : 		break;
; 1105 : 	}
; 1106 : 	return true;

	mov	al, 1

; 1107 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN18@checkForAv:

; 1039 : 		}
; 1040 : 		break;
; 1041 : 
; 1042 : 		// open page systems may, in the best case, add a CAS command to an already open row
; 1043 : 		// closing the row and precharging may be delayed
; 1044 : 
; 1045 : 		// all break down into PRE,RAS,CAS
; 1046 : 		// or CAS
; 1047 : 	case OPEN_PAGE:
; 1048 : 	case OPEN_PAGE_AGGRESSIVE:
; 1049 : 
; 1050 : 		// refresh transactions become only one command and are handled differently
; 1051 : 		if (incomingTransaction->isRefresh())

	cmp	DWORD PTR [edi+80], 4
	jne	$LN17@checkForAv

; 1052 : 		{
; 1053 : 			const Rank &currentRank = rank[incomingTransaction->getAddress().getRank()];

	mov	edi, DWORD PTR [edi+60]
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]

; 1054 : 			// make sure that there is room in all the queues for one command
; 1055 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1056 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1057 : 			// are available
; 1058 : 			for (vector<Bank>::const_iterator i = currentRank.bank.begin(); i != currentRank.bank.end(); i++)

	lea	ebx, DWORD PTR [eax+400]
	lea	esi, DWORD PTR _i$222821[esp+32]
	mov	edi, ebx
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	npad	6
$LL16@checkForAv:
	mov	ebp, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN147@checkForAv
	call	__invalid_parameter_noinfo
$LN147@checkForAv:
	mov	esi, DWORD PTR _i$222821[esp+32]
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN160@checkForAv
	cmp	esi, eax
	je	SHORT $LN161@checkForAv
$LN160@checkForAv:
	call	__invalid_parameter_noinfo
$LN161@checkForAv:
	mov	edi, DWORD PTR _i$222821[esp+36]
	cmp	edi, ebp
	je	$LN3@checkForAv

; 1059 : 			{					
; 1060 : 				if (i->freeCommandSlots() < 2)

	test	esi, esi
	jne	SHORT $LN228@checkForAv
	call	__invalid_parameter_noinfo
$LN179@checkForAv:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN170@checkForAv
	call	__invalid_parameter_noinfo
$LN170@checkForAv:
	mov	ecx, DWORD PTR [edi+40]
	sub	ecx, DWORD PTR [edi+36]
	sar	ecx, 2
	sub	ecx, DWORD PTR [edi+12]
	cmp	ecx, 2
	jb	$LN235@checkForAv
	lea	edi, DWORD PTR $T651660[esp+32]
	lea	esi, DWORD PTR _i$222821[esp+32]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	jmp	SHORT $LL16@checkForAv
$LN228@checkForAv:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN179@checkForAv
$LN17@checkForAv:

; 1061 : 					return false;
; 1062 : 			}
; 1063 : 			return true;
; 1064 : 		}
; 1065 : 		else if (!destinationBank.isFull())

	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+36]
	sar	esi, 2
	cmp	esi, DWORD PTR [ecx+12]
	je	$LN235@checkForAv

; 1066 : 		{	
; 1067 : 			// try to do a normal open page insert on this transaction
; 1068 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1069 : 				(destinationBank.openPageAggressiveInsertCheck(incomingTransaction, time)))

	cmp	edx, 2
	jne	SHORT $LN10@checkForAv
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	push	edi
	mov	esi, ecx
	call	?openPageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::openPageAggressiveInsertCheck
	test	al, al

; 1070 : 			{					
; 1071 : 				return true;

	jne	SHORT $LN3@checkForAv

; 1066 : 		{	
; 1067 : 			// try to do a normal open page insert on this transaction
; 1068 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1069 : 				(destinationBank.openPageAggressiveInsertCheck(incomingTransaction, time)))

	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN10@checkForAv:

; 1072 : 			}
; 1073 : 			else
; 1074 : 			{
; 1075 : 				// first, the precharge command, if necessary
; 1076 : 				if (((destinationBank.isEmpty() && destinationBank.isActivated()) || (!destinationBank.isEmpty() && !destinationBank.back()->isRefresh())))

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN237@checkForAv
	cmp	BYTE PTR [ecx+132], al
	jne	SHORT $LN7@checkForAv
	test	eax, eax
	je	SHORT $LN8@checkForAv
$LN237@checkForAv:
	mov	esi, ecx
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
	je	SHORT $LN8@checkForAv
$LN7@checkForAv:

; 1077 : 				{
; 1078 : 					if (destinationBank.freeCommandSlots() < 3)

	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR [ecx+36]
	sar	edx, 2
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 3
	jae	SHORT $LN3@checkForAv

; 1103 : 		return false;

	xor	al, al

; 1107 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN8@checkForAv:

; 1079 : 					{
; 1080 : 						return false;
; 1081 : 					}
; 1082 : 					assert(!destinationBank.back() || destinationBank.back()->getCommandType() != Command::REFRESH_ALL);
; 1083 : 					assert(!destinationBank.back() || destinationBank.back()->getCommandType() != Command::PRECHARGE);
; 1084 : 				}
; 1085 : 				else if (destinationBank.freeCommandSlots() < 2)

	mov	eax, DWORD PTR [ecx+40]
	sub	eax, DWORD PTR [ecx+36]
	sar	eax, 2
	sub	eax, DWORD PTR [ecx+12]
	cmp	eax, 2

; 1086 : 				{
; 1087 : 					return false;

	jb	SHORT $LN235@checkForAv
$LN3@checkForAv:

; 1088 : 				}
; 1089 : 
; 1090 : 				return true;	

	mov	al, 1

; 1107 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN1@checkForAv:

; 1091 : 			}
; 1092 : 		}
; 1093 : 		else
; 1094 : 		{
; 1095 : 			return false;
; 1096 : 		}
; 1097 : 
; 1098 : 		break;
; 1099 : 
; 1100 : 	default:
; 1101 : 
; 1102 : 		cerr << "Unhandled row buffer management policy" << endl;

	push	OFFSET ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN235@checkForAv:

; 1107 : }

	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN238@checkForAv:
	DD	$LN18@checkForAv
	DD	$LN18@checkForAv
	DD	$LN30@checkForAv
	DD	$LN30@checkForAv
?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ENDP ; DRAMsimII::Channel::checkForAvailableCommandSlots
_TEXT	ENDS
PUBLIC	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv83 = -8						; size = 4
tv69 = -4						; size = 4
_j$222632 = 8						; size = 4
_bufferDelay$ = 8					; size = 1
?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z PROC ; DRAMsimII::Channel::readAvailableTransaction
; _this$ = esi

; 818  : {

	sub	esp, 12					; 0000000cH

; 819  : 	const unsigned delay = bufferDelay ? timingSpecification.tBufferDelay() : 0;

	cmp	BYTE PTR _bufferDelay$[esp+8], 0
	push	ebx
	push	ebp
	push	edi
	je	SHORT $LN14@readAvaila
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR tv69[esp+24], eax
	jmp	SHORT $LN15@readAvaila
$LN14@readAvaila:
	mov	DWORD PTR tv69[esp+24], 0
$LN15@readAvaila:

; 820  : 
; 821  : 	unsigned limit = min(systemConfig.getDecodeWindow(), transactionQueue.size());

	mov	ecx, DWORD PTR [esi+176]
	mov	eax, DWORD PTR [ecx+376]
	mov	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR tv83[esp+24], eax
	cmp	eax, ecx
	jb	SHORT $LN26@readAvaila
	mov	DWORD PTR tv83[esp+24], ecx
$LN26@readAvaila:

; 822  : 
; 823  : 	for (unsigned i = 0; i < limit; i++)

	xor	ebp, ebp
	cmp	DWORD PTR tv83[esp+24], ebp
	jbe	$LN126@readAvaila
$LL11@readAvaila:

; 824  : 	{
; 825  : 		// if it's ready to decode
; 826  : 		if ((transactionQueue[i]->getEnqueueTime() + delay <= time) &&
; 827  : 			checkForAvailableCommandSlots(transactionQueue[i]))

	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN33@readAvaila
	test	ebp, ebp
	jl	SHORT $LN33@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN39@readAvaila
	call	__invalid_parameter_noinfo
$LN39@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN32@readAvaila
$LN33@readAvaila:
	xor	eax, eax
$LN32@readAvaila:
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR tv69[esp+24]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, 0
	adc	eax, edx
	cmp	eax, DWORD PTR [esi+12]
	jg	$LN8@readAvaila
	jl	SHORT $LN134@readAvaila
	cmp	ecx, DWORD PTR [esi+8]
	ja	$LN8@readAvaila
$LN134@readAvaila:
	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN51@readAvaila
	test	ebp, ebp
	jl	SHORT $LN51@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN57@readAvaila
	call	__invalid_parameter_noinfo
$LN57@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN50@readAvaila
$LN51@readAvaila:
	xor	edi, edi
$LN50@readAvaila:
	push	esi
	mov	eax, edi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	$LN8@readAvaila

; 828  : 		{
; 829  : 			bool conflict = false;
; 830  : 			// make sure not to create a RAW, WAR, WAW problem
; 831  : 			for (unsigned j = 0; j < i; j++)

	xor	ecx, ecx
	mov	DWORD PTR _j$222632[esp+20], ecx
	test	ebp, ebp
	jbe	$LN125@readAvaila
$LL7@readAvaila:

; 832  : 			{
; 833  : 				if (transactionQueue[i]->getAddress() == transactionQueue[j]->getAddress())

	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN67@readAvaila
	test	ecx, ecx
	jl	SHORT $LN67@readAvaila
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	edi, 2
	add	eax, ecx
	div	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN73@readAvaila
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _j$222632[esp+20]
$LN73@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	ebx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN66@readAvaila
$LN67@readAvaila:
	xor	ebx, ebx
$LN66@readAvaila:
	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN85@readAvaila
	test	ebp, ebp
	jl	SHORT $LN85@readAvaila
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	edi, 2
	add	eax, ebp
	div	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN91@readAvaila
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _j$222632[esp+20]
$LN91@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN84@readAvaila
$LN85@readAvaila:
	xor	eax, eax
$LN84@readAvaila:
	mov	edx, DWORD PTR [eax+56]
	cmp	edx, DWORD PTR [ebx+56]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+60]
	cmp	edx, DWORD PTR [ebx+60]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+64]
	cmp	edx, DWORD PTR [ebx+64]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+68]
	cmp	edx, DWORD PTR [ebx+68]
	jne	SHORT $LN100@readAvaila
	mov	eax, DWORD PTR [eax+72]
	cmp	eax, DWORD PTR [ebx+72]
	je	$LN10@readAvaila
$LN100@readAvaila:
	inc	ecx
	mov	DWORD PTR _j$222632[esp+20], ecx
	cmp	ecx, ebp
	jb	$LL7@readAvaila
$LN125@readAvaila:

; 834  : 				{
; 835  : 					conflict = true;
; 836  : 					break;
; 837  : 				}
; 838  : 			}
; 839  : 			if (!conflict)
; 840  : 				return i;

	mov	eax, ebp

; 843  : 			break;
; 844  : 	}
; 845  : 	return UINT_MAX;
; 846  : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN8@readAvaila:

; 841  : 		}
; 842  : 		else if (time - transactionQueue[i]->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN107@readAvaila
	test	ebp, ebp
	jl	SHORT $LN107@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN113@readAvaila
	call	__invalid_parameter_noinfo
$LN113@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN106@readAvaila
$LN107@readAvaila:
	xor	edx, edx
$LN106@readAvaila:
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi+12]
	sbb	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [esi+176]
	mov	edi, DWORD PTR [edx+320]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN126@readAvaila
	jl	SHORT $LN10@readAvaila
	cmp	ecx, edi
	ja	SHORT $LN126@readAvaila
$LN10@readAvaila:

; 822  : 
; 823  : 	for (unsigned i = 0; i < limit; i++)

	inc	ebp
	cmp	ebp, DWORD PTR tv83[esp+24]
	jb	$LL11@readAvaila
$LN126@readAvaila:

; 843  : 			break;
; 844  : 	}
; 845  : 	return UINT_MAX;
; 846  : }

	pop	edi
	pop	ebp
	or	eax, -1
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ENDP ; DRAMsimII::Channel::readAvailableTransaction
_TEXT	ENDS
PUBLIC	?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::enqueue
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_incomingTransaction$ = 12				; size = 4
?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Channel::enqueue

; 413  : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 414  : 	if (transactionQueue.isFull())

	mov	eax, DWORD PTR [ebx+140]
	sub	eax, DWORD PTR [ebx+136]
	push	ebp
	push	esi
	lea	esi, DWORD PTR [ebx+112]
	sar	eax, 2
	push	edi
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN13@enqueue

; 415  : 		return false;

	xor	al, al

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN13@enqueue:

; 416  : 
; 417  : 	incomingTransaction->setEnqueueTime(time);

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _incomingTransaction$[esp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ecx+20], eax

; 418  : 
; 419  : 	assert(!incomingTransaction->isRefresh());
; 420  : 
; 421  : 	assert(incomingTransaction->getAddress().getChannel() == channelID);
; 422  : 
; 423  : 	bool result;
; 424  : 
; 425  : 	switch (systemConfig.getTransactionOrderingAlgorithm())

	mov	edx, DWORD PTR [ebx+176]
	mov	eax, DWORD PTR [edx+292]
	sub	eax, 0
	je	SHORT $LN9@enqueue
	sub	eax, 1
	je	$LN8@enqueue

; 453  : 		}
; 454  : 		break;
; 455  : 	default:
; 456  : 		cerr << "Unknown transaction ordering algorithm." << endl;

	push	OFFSET ??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 457  : 		exit(-1);		

	push	-1
	call	_exit
$LN74@enqueue:
$LN9@enqueue:

; 426  : 	{
; 427  : 	case STRICT:
; 428  : 		result = transactionQueue.push(incomingTransaction);
; 429  : 		break;
; 430  : 	case RIFF:
; 431  : 		// search from back to front
; 432  : 		// insert right after a conflict, any transaction over the seniority limit or any read
; 433  : 		if (incomingTransaction->isRead())

	mov	eax, DWORD PTR [ecx+80]
	test	eax, eax
	je	SHORT $LN26@enqueue
	cmp	eax, 2
	je	SHORT $LN26@enqueue
	cmp	eax, 3
	jne	$LN8@enqueue
$LN26@enqueue:

; 434  : 		{
; 435  : 			for (int currentIndex = transactionQueue.size() - 1; currentIndex >= 0; --currentIndex)

	mov	edi, DWORD PTR [esi]
	sub	edi, 1
	js	$LN5@enqueue
	npad	2
$LL7@enqueue:

; 436  : 			{
; 437  : 				// prevent against starvation and RAW errors, reads do not switch their ordering
; 438  : 				if (transactionQueue[currentIndex]->isRead() ||
; 439  : 					(time - transactionQueue[currentIndex]->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()) ||
; 440  : 					transactionQueue[currentIndex]->getAddress() == incomingTransaction->getAddress())

	cmp	edi, DWORD PTR [esi]
	jge	SHORT $LN35@enqueue
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebp, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN41@enqueue
	call	__invalid_parameter_noinfo
$LN41@enqueue:
	mov	eax, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR [eax+ebp*4]
	jmp	SHORT $LN34@enqueue
$LN35@enqueue:
	xor	ebp, ebp
$LN34@enqueue:
	mov	eax, DWORD PTR [ebp+80]
	test	eax, eax
	je	SHORT $LN63@enqueue
	cmp	eax, 2
	je	SHORT $LN63@enqueue
	cmp	eax, 3
	je	SHORT $LN63@enqueue
	mov	ecx, edi
	call	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [ebx+12]
	sbb	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [ebx+176]
	mov	ebp, DWORD PTR [eax+320]
	xor	eax, eax
	cmp	ecx, eax
	jg	SHORT $LN63@enqueue
	jl	SHORT $LN68@enqueue
	cmp	edx, ebp
	ja	SHORT $LN63@enqueue
$LN68@enqueue:
	mov	ecx, edi
	call	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _incomingTransaction$[esp+16]
	add	eax, 40					; 00000028H
	add	ecx, 40					; 00000028H
	call	??8Address@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Address::operator==
	test	al, al
	jne	SHORT $LN63@enqueue

; 434  : 		{
; 435  : 			for (int currentIndex = transactionQueue.size() - 1; currentIndex >= 0; --currentIndex)

	sub	edi, 1
	jns	$LL7@enqueue
$LN5@enqueue:

; 443  : 					assert(result);
; 444  : 					return result;
; 445  : 				}				
; 446  : 			}
; 447  : 			// if there were no conditions to force it to choose another location, insert at the head
; 448  : 			result = transactionQueue.push_front(incomingTransaction);

	mov	edx, DWORD PTR _incomingTransaction$[esp+16]
	push	edx
	mov	eax, esi
	call	?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN63@enqueue:

; 441  : 				{
; 442  : 					result = transactionQueue.insert(incomingTransaction, currentIndex + 1);					

	mov	ecx, DWORD PTR _incomingTransaction$[esp+16]
	inc	edi
	push	edi
	push	ecx
	mov	eax, esi
	call	?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN8@enqueue:

; 449  : 		}
; 450  : 		else
; 451  : 		{
; 452  : 			result = transactionQueue.push(incomingTransaction);

	push	ecx
	mov	eax, esi
	call	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN73@enqueue:
?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Channel::enqueue
_TEXT	ENDS
PUBLIC	??1Channel@DRAMsimII@@UAE@XZ			; DRAMsimII::Channel::~Channel
__unwindtable$??1Channel@DRAMsimII@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$3
__ehfuncinfo$??1Channel@DRAMsimII@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1Channel@DRAMsimII@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Channel@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::Channel::~Channel
; _this$ = ecx

; 163  : {

	push	-1
	push	__ehhandler$??1Channel@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+36], edi
	mov	DWORD PTR [edi], OFFSET ??_7Channel@DRAMsimII@@6B@

; 164  : 	// must remove commands this way to prevent queues from being automatically deleted, thus creating double frees on refresh commands
; 165  : 	while (Command *cmd = getNextCommand())

	xor	ebx, ebx
	push	ebx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+52], 3
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
	mov	esi, eax
	cmp	esi, ebx
	je	SHORT $LN2@Channel
	npad	7
$LL3@Channel:

; 166  : 	{
; 167  : 		delete lastCommand;

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, ebx
	je	SHORT $LN6@Channel
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN6@Channel:
	push	ebx
	push	edi

; 168  : 
; 169  : 		lastCommand = cmd;

	mov	DWORD PTR [edi+24], esi
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
	mov	esi, eax
	cmp	esi, ebx
	jne	SHORT $LL3@Channel
$LN2@Channel:

; 170  : 	}
; 171  : 	if (lastCommand)

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, ebx
	je	SHORT $LN1@Channel

; 172  : 	{
; 173  : 		delete lastCommand;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 174  : 		lastCommand = NULL;

	mov	DWORD PTR [edi+24], ebx
$LN1@Channel:

; 175  : 	}
; 176  : }

	lea	esi, DWORD PTR [edi+424]
	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
	mov	esi, DWORD PTR [esi]
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	eax, DWORD PTR [edi+400]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	mov	eax, DWORD PTR [edi+164]
	cmp	eax, ebx
	je	SHORT $LN35@Channel
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@Channel:
	mov	eax, DWORD PTR [edi+152]
	push	eax
	mov	DWORD PTR [edi+164], ebx
	mov	DWORD PTR [edi+168], ebx
	mov	DWORD PTR [edi+172], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	edi, 112				; 00000070H
	push	edi
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 424				; 000001a8H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??1Channel@DRAMsimII@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Channel@DRAMsimII@@UAE@XZ
	jmp	___CxxFrameHandler3
??1Channel@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::Channel::~Channel
; Function compile flags: /Ogtpy
;	COMDAT ??_GChannel@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GChannel@DRAMsimII@@UAEPAXI@Z PROC			; DRAMsimII::Channel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@101
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@101:
	mov	eax, esi
	pop	esi
	ret	4
??_GChannel@DRAMsimII@@UAEPAXI@Z ENDP			; DRAMsimII::Channel::`scalar deleting destructor'
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1
__ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T665589 = 12						; size = 4
_preallocate$ = 12					; size = 1
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>, COMDAT
; _size$ = ecx

; 88   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _this$[esp+32]
	xor	ebx, ebx
	lea	esi, DWORD PTR [ebp+12]
	push	esi
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	call	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	mov	al, BYTE PTR _preallocate$[esp+32]

; 89   : 			entry.reserve(size);

	push	edi
	mov	BYTE PTR [ebp+36], al
	call	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve

; 90   : 
; 91   : 			if (preallocate)

	cmp	BYTE PTR _preallocate$[esp+32], bl
	je	SHORT $LN24@Queue@5

; 92   : 			{
; 93   : 				while (!isFull())

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp]
	je	SHORT $LN24@Queue@5
	or	edi, -1
$LL2@Queue@5:

; 94   : 				{
; 95   : 					push(::new T());

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T665589[esp+32], esi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	cmp	esi, ebx
	je	SHORT $LN6@Queue@5
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	DWORD PTR [esi+80], 7
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], edi
	jmp	SHORT $LN7@Queue@5
$LN6@Queue@5:
	xor	esi, esi
$LN7@Queue@5:
	push	esi
	mov	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+48], bl
	call	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
	mov	edx, DWORD PTR [ebp+28]
	sub	edx, DWORD PTR [ebp+24]
	sar	edx, 2
	cmp	edx, DWORD PTR [ebp]
	jne	SHORT $LL2@Queue@5
$LN24@Queue@5:

; 96   : 				}
; 97   : 			}
; 98   : 		}

	mov	eax, ebp
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T665589[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv1327 = -28						; size = 8
_i$223689 = -28						; size = 8
tv1332 = -20						; size = 8
$T665633 = -20						; size = 8
$T665632 = -12						; size = 8
tv1360 = 8						; size = 4
$T666375 = 8						; size = 4
$T665958 = 8						; size = 4
_currentBank$ = 8					; size = 4
_this$ = 8						; size = 4
_currentRank$ = 12					; size = 4
_thisCommand$ = 12					; size = 4
?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z PROC ; DRAMsimII::Channel::executeCommand

; 2283 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+28]

; 2284 : 	Rank &currentRank = rank[thisCommand->getAddress().getRank()];

	mov	ecx, DWORD PTR [ebx+416]
	sub	ecx, DWORD PTR [ebx+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	push	ebp
	mov	ebp, DWORD PTR _thisCommand$[esp+32]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR [ebp+60]
	add	eax, edx
	push	edi
	cmp	esi, eax
	jb	SHORT $LN44@executeCom
	call	__invalid_parameter_noinfo
$LN44@executeCom:
	imul	esi, 424				; 000001a8H
	add	esi, DWORD PTR [ebx+412]
	mov	eax, esi

; 2285 : 
; 2286 : 	Bank &currentBank = currentRank.bank[thisCommand->getAddress().getBank()];

	mov	ecx, DWORD PTR [eax+416]
	sub	ecx, DWORD PTR [eax+412]
	mov	esi, DWORD PTR [ebp+64]
	mov	DWORD PTR _currentRank$[esp+40], eax
	add	eax, 400				; 00000190H
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN53@executeCom
	call	__invalid_parameter_noinfo
$LN53@executeCom:
	mov	eax, DWORD PTR _currentRank$[esp+40]
	imul	esi, 168				; 000000a8H
	add	esi, DWORD PTR [eax+412]

; 2287 : 
; 2288 : 	currentRank.setLastBankID(thisCommand->getAddress().getBank());

	mov	edx, DWORD PTR [ebp+64]
	mov	DWORD PTR [eax+140], edx

; 2289 : 
; 2290 : 	thisCommand->setStartTime(time);

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebp+24], eax
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+28], edx

; 2291 : 
; 2292 : 	assert(canIssue(thisCommand));
; 2293 : 
; 2294 : 	bool wasActivated = currentBank.isActivated();
; 2295 : 
; 2296 : 	lastCommandIssueTime = time;

	mov	edi, DWORD PTR [ebx+8]
	mov	ecx, esi
	mov	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+16], edi
	mov	DWORD PTR [ebx+20], esi

; 2297 : 
; 2298 : 	switch(thisCommand->getCommandType())

	mov	eax, DWORD PTR [ebp+80]
	mov	DWORD PTR _currentBank$[esp+40], ecx
	cmp	eax, 16					; 00000010H
	ja	$LN1@executeCom
	movzx	eax, BYTE PTR $LN422@executeCom[eax]
	jmp	DWORD PTR $LN425@executeCom[eax*4]
$LN33@executeCom:

; 2299 : 	{
; 2300 : 	case Command::ACTIVATE:
; 2301 : 		{
; 2302 : 			assert(!currentBank.isActivated());
; 2303 : 
; 2304 : 			// see if this was held due to tFAW (or at least tied with other restrictions)
; 2305 : 			if (time - currentRank.lastActivateTimes.back() == timingSpecification.tFAW())

	mov	eax, DWORD PTR _currentRank$[esp+40]
	add	eax, 376				; 00000178H
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
	sub	edi, DWORD PTR [eax]
	sbb	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+52]
	cdq
	cmp	edi, eax
	jne	SHORT $LN72@executeCom
	cmp	esi, edx
	jne	SHORT $LN72@executeCom

; 2306 : 				statistics.reportTFawCommand();

	mov	eax, DWORD PTR [ebx+180]
	inc	DWORD PTR [eax+104]
$LN72@executeCom:

; 2307 : 			
; 2308 : 			currentRank.issueRAS(time, thisCommand);			

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ebp
	push	ecx
	push	edx
	call	?issueRAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueRAS

; 2309 : 
; 2310 : 			// specific for RAS command
; 2311 : 			thisCommand->setCompletionTime(thisCommand->getStartTime() + timingSpecification.tCMD() + timingSpecification.tRAS());

	mov	eax, DWORD PTR [ebx+56]
$LN424@executeCom:
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax
	adc	esi, edx
	add	ecx, DWORD PTR [ebp+24]

; 2440 : 		break;
; 2441 : 	}	
; 2442 : 
; 2443 : 	// inserts into a queue which dequeues into the command pool
; 2444 : 	retireCommand(thisCommand);

	push	ebx
	adc	esi, DWORD PTR [ebp+28]
	mov	eax, ebp
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2445 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
$LN31@executeCom:

; 2312 : 			assert(!thisCommand->getHost());
; 2313 : 		}
; 2314 : 		break;
; 2315 : 
; 2316 : 	case Command::READ_AND_PRECHARGE:
; 2317 : 
; 2318 : 		// precharge may be issued first because timings are based on time, not the last time at which a read command was issued		
; 2319 : 		assert(currentBank.isActivated());
; 2320 : 		currentRank.issuePRE(time, thisCommand);

	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ebp
	push	esi
	push	edi
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE
	mov	ecx, DWORD PTR _currentBank$[esp+40]
$LN30@executeCom:

; 2321 : 		// lack of break is intentional
; 2322 : 
; 2323 : 	case Command::READ:
; 2324 : 
; 2325 : 		//currentRank.issueCAS(time, thisCommand);
; 2326 : 
; 2327 : 		// specific for CAS command
; 2328 : 		// should account for tAL buffering the CAS command until the right moment
; 2329 : 		//thisCommand->setCompletionTime(max(currentBank.getLastRASTime() + timingSpecification.tRCD() + timingSpecification.tCAS() + timingSpecification.tBurst(), time + timingSpecification.tCMD() + timingSpecification.tCAS() + timingSpecification.tBurst()));
; 2330 : 		assert(wasActivated);
; 2331 : 		assert(currentBank.getOpenRowID() == thisCommand->getAddress().getRow());
; 2332 : 		thisCommand->setCompletionTime(max(currentBank.getLastRASTime() + timingSpecification.tRCD() + timingSpecification.tCAS() + timingSpecification.tBurst(), time + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst()));

	mov	eax, DWORD PTR [ebx+36]
	cdq
	mov	DWORD PTR tv1327[esp+44], eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR tv1327[esp+48], edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR [ebx+64]
	mov	esi, edx
	cdq
	add	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR tv1332[esp+48], esi
	adc	edx, DWORD PTR [ecx+60]
	add	eax, edi
	adc	edx, esi
	mov	esi, eax
	add	esi, DWORD PTR tv1327[esp+44]
	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, edx
	adc	ecx, DWORD PTR tv1327[esp+48]
	cdq
	add	eax, edi
	adc	edx, DWORD PTR tv1332[esp+48]
	add	eax, DWORD PTR tv1327[esp+44]
	adc	edx, DWORD PTR tv1327[esp+48]
	mov	DWORD PTR tv1360[esp+40], edx
	mov	edx, eax
	add	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR tv1360[esp+40]
	adc	eax, DWORD PTR [ebx+12]
	cmp	ecx, eax
	jl	SHORT $LN38@executeCom
	jg	SHORT $LN423@executeCom
	cmp	esi, edx
	jbe	SHORT $LN38@executeCom
$LN423@executeCom:
	mov	edx, esi
	mov	eax, ecx
$LN38@executeCom:

; 2333 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebp+32], edx
	mov	DWORD PTR [ebp+36], eax
	mov	DWORD PTR [ecx+32], edx
	mov	DWORD PTR [ecx+36], eax

; 2334 : 
; 2335 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2336 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+412]
	cmp	edi, DWORD PTR [ebx+416]
	jbe	SHORT $LN123@executeCom
	call	__invalid_parameter_noinfo
$LN123@executeCom:
	mov	esi, DWORD PTR [ebx+400]
	npad	5
$LL140@executeCom:
	mov	eax, DWORD PTR [ebx+416]
	mov	DWORD PTR $T665958[esp+40], eax
	cmp	DWORD PTR [ebx+412], eax
	jbe	SHORT $LN155@executeCom
	call	__invalid_parameter_noinfo
$LN155@executeCom:
	mov	eax, DWORD PTR [ebx+400]
	test	esi, esi
	je	SHORT $LN168@executeCom
	cmp	esi, eax
	je	SHORT $LN169@executeCom
$LN168@executeCom:
	call	__invalid_parameter_noinfo
$LN169@executeCom:
	cmp	edi, DWORD PTR $T665958[esp+40]
	je	$LN34@executeCom

; 2337 : 		{
; 2338 : 			if (&currentRank != &*i)

	test	esi, esi
	jne	SHORT $LN421@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN187@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN178@executeCom
	call	__invalid_parameter_noinfo
$LN178@executeCom:
	cmp	DWORD PTR _currentRank$[esp+40], edi
	je	SHORT $LN26@executeCom

; 2339 : 			{
; 2340 : 				//i->setOtherLastCAS(time + timingSpecification.tAL(),thisCommand->getLength());
; 2341 : 				i->issueCASother(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN420@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN203@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN194@executeCom
	call	__invalid_parameter_noinfo
$LN194@executeCom:
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	push	edi
	mov	ecx, ebp
	call	?issueCASother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASother

; 2342 : 			}
; 2343 : 			else

	jmp	SHORT $LN28@executeCom
$LN421@executeCom:

; 2337 : 		{
; 2338 : 			if (&currentRank != &*i)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN187@executeCom
$LN420@executeCom:

; 2339 : 			{
; 2340 : 				//i->setOtherLastCAS(time + timingSpecification.tAL(),thisCommand->getLength());
; 2341 : 				i->issueCASother(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN203@executeCom
$LN26@executeCom:

; 2344 : 			{
; 2345 : 				const bool hit = i->issueCAS(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN419@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN219@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN210@executeCom
	call	__invalid_parameter_noinfo
$LN210@executeCom:
	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+8]
	push	ebp
	push	eax
	push	ecx
	push	edi
	call	?issueCAS@Rank@DRAMsimII@@QAE_N_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCAS

; 2346 : 				thisCommand->setHit(hit);

	mov	BYTE PTR [ebp+92], al
$LN28@executeCom:

; 2334 : 
; 2335 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2336 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN418@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN147@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN138@executeCom
	call	__invalid_parameter_noinfo
$LN138@executeCom:
	add	edi, 424				; 000001a8H
	jmp	$LL140@executeCom
$LN419@executeCom:

; 2344 : 			{
; 2345 : 				const bool hit = i->issueCAS(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN219@executeCom
$LN418@executeCom:

; 2334 : 
; 2335 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2336 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN147@executeCom
$LN24@executeCom:

; 2347 : 			}
; 2348 : 		}
; 2349 : 		break;
; 2350 : 
; 2351 : 	case Command::WRITE_AND_PRECHARGE:
; 2352 : 
; 2353 : 		// precharge may be issued first because timings are based on time, not the last time at which a read command was issued
; 2354 : 		currentRank.issuePRE(time, thisCommand);		

	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ebp
	push	esi
	push	edi
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE
$LN23@executeCom:

; 2355 : 		// missing break is intentional
; 2356 : 
; 2357 : 	case Command::WRITE:
; 2358 : 
; 2359 : 		//currentRank.issueCASW(time, thisCommand);
; 2360 : 
; 2361 : 		// for the CAS write command
; 2362 : 		//thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2363 : 		assert(wasActivated);
; 2364 : 		assert(currentBank.getOpenRowID() == thisCommand->getAddress().getRow());
; 2365 : 		thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tCWD() + timingSpecification.tBurst());

	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+32]
	adc	esi, edx
	cdq
	add	ecx, eax

; 2366 : 		//thisCommand->getHost()->setCompletionTime(time);
; 2367 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	eax, DWORD PTR [ebp+84]
	adc	esi, edx
	add	ecx, DWORD PTR [ebx+8]
	adc	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	mov	edx, ecx
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [eax+36], ecx

; 2368 : 
; 2369 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2370 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+412]
	cmp	edi, DWORD PTR [ebx+416]
	jbe	SHORT $LN243@executeCom
	call	__invalid_parameter_noinfo
$LN243@executeCom:
	mov	esi, DWORD PTR [ebx+400]
	npad	12
$LL260@executeCom:
	mov	eax, DWORD PTR [ebx+416]
	mov	DWORD PTR $T666375[esp+40], eax
	cmp	DWORD PTR [ebx+412], eax
	jbe	SHORT $LN275@executeCom
	call	__invalid_parameter_noinfo
$LN275@executeCom:
	mov	eax, DWORD PTR [ebx+400]
	test	esi, esi
	je	SHORT $LN288@executeCom
	cmp	esi, eax
	je	SHORT $LN289@executeCom
$LN288@executeCom:
	call	__invalid_parameter_noinfo
$LN289@executeCom:
	cmp	edi, DWORD PTR $T666375[esp+40]
	je	$LN34@executeCom

; 2371 : 		{
; 2372 : 			if (&currentRank != &*i)

	test	esi, esi
	jne	SHORT $LN417@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN307@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN298@executeCom
	call	__invalid_parameter_noinfo
$LN298@executeCom:
	cmp	DWORD PTR _currentRank$[esp+40], edi
	je	SHORT $LN19@executeCom

; 2373 : 			{
; 2374 : 				//i->setOtherLastCASW(time + timingSpecification.tAL(),thisCommand->getLength());
; 2375 : 				i->issueCASWother(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN416@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN323@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN314@executeCom
	call	__invalid_parameter_noinfo
$LN314@executeCom:
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	push	edx
	push	eax
	push	edi
	mov	ecx, ebp
	call	?issueCASWother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASWother

; 2376 : 			}
; 2377 : 			else

	jmp	SHORT $LN21@executeCom
$LN417@executeCom:

; 2371 : 		{
; 2372 : 			if (&currentRank != &*i)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN307@executeCom
$LN416@executeCom:

; 2373 : 			{
; 2374 : 				//i->setOtherLastCASW(time + timingSpecification.tAL(),thisCommand->getLength());
; 2375 : 				i->issueCASWother(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN323@executeCom
$LN19@executeCom:

; 2378 : 			{
; 2379 : 				const bool hit = i->issueCASW(time,thisCommand);

	test	esi, esi
	jne	SHORT $LN415@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN339@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN330@executeCom
	call	__invalid_parameter_noinfo
$LN330@executeCom:
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	mov	eax, ebp
	mov	ecx, edi
	call	?issueCASW@Rank@DRAMsimII@@QAE_N_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASW

; 2380 : 				thisCommand->setHit(hit);

	mov	BYTE PTR [ebp+92], al
$LN21@executeCom:

; 2368 : 
; 2369 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2370 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN414@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN267@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN258@executeCom
	call	__invalid_parameter_noinfo
$LN258@executeCom:
	add	edi, 424				; 000001a8H
	jmp	$LL260@executeCom
$LN415@executeCom:

; 2378 : 			{
; 2379 : 				const bool hit = i->issueCASW(time,thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN339@executeCom
$LN414@executeCom:

; 2368 : 
; 2369 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2370 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN267@executeCom
$LN17@executeCom:

; 2381 : 			}
; 2382 : 		}
; 2383 : 		break;
; 2384 : 
; 2385 : 	case Command::PRECHARGE:
; 2386 : 
; 2387 : 		assert(currentBank.isActivated());
; 2388 : 
; 2389 : 		// issued to the rank which issues to banks
; 2390 : 		currentRank.issuePRE(time, thisCommand);

	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ebp
	push	esi
	push	edi
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE

; 2391 : 
; 2392 : 		thisCommand->setCompletionTime(thisCommand->getStartTime() + timingSpecification.tCMD() + timingSpecification.tRP());

	mov	eax, DWORD PTR [ebx+72]

; 2393 : 
; 2394 : 		break;

	jmp	$LN424@executeCom
$LN16@executeCom:

; 2395 : 
; 2396 : 	case Command::REFRESH_ALL:
; 2397 : 
; 2398 : 		for (vector<Bank>::const_iterator i = currentRank.bank.begin(); i != currentRank.bank.end(); i++)

	mov	edi, DWORD PTR _currentRank$[esp+40]
	lea	esi, DWORD PTR $T665632[esp+44]
	add	edi, 400				; 00000190H
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$223689[esp+44], esi
	mov	DWORD PTR _i$223689[esp+48], edx
	npad	13
$LL15@executeCom:
	mov	eax, DWORD PTR _currentRank$[esp+40]
	mov	edi, DWORD PTR [eax+416]
	cmp	DWORD PTR [eax+412], edi
	jbe	SHORT $LN357@executeCom
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _currentRank$[esp+40]
$LN357@executeCom:
	mov	eax, DWORD PTR [eax+400]
	test	esi, esi
	je	SHORT $LN370@executeCom
	cmp	esi, eax
	je	SHORT $LN371@executeCom
$LN370@executeCom:
	call	__invalid_parameter_noinfo
$LN371@executeCom:
	cmp	DWORD PTR _i$223689[esp+48], edi
	je	SHORT $LN13@executeCom

; 2399 : 			if (i->isActivated())

	test	esi, esi
	jne	SHORT $LN413@executeCom
	call	__invalid_parameter_noinfo
$LN389@executeCom:
	mov	eax, DWORD PTR _i$223689[esp+48]
	cmp	eax, DWORD PTR [esi+16]
	jb	SHORT $LN380@executeCom
	call	__invalid_parameter_noinfo
$LN380@executeCom:
	lea	edi, DWORD PTR $T665633[esp+44]
	lea	esi, DWORD PTR _i$223689[esp+44]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	mov	esi, DWORD PTR _i$223689[esp+44]
	jmp	SHORT $LL15@executeCom
$LN413@executeCom:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN389@executeCom
$LN13@executeCom:

; 2400 : 				assert(!i->isActivated());
; 2401 : 
; 2402 : 		currentRank.issueREF(time);

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ecx
	push	edx
	call	?issueREF@Rank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Rank::issueREF

; 2403 : 
; 2404 : 		thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tRFC());

	mov	eax, DWORD PTR [ebx+68]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax

; 2405 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	eax, DWORD PTR [ebp+84]
	adc	esi, edx
	add	ecx, DWORD PTR [ebx+8]

; 2440 : 		break;
; 2441 : 	}	
; 2442 : 
; 2443 : 	// inserts into a queue which dequeues into the command pool
; 2444 : 	retireCommand(thisCommand);

	push	ebx
	adc	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	mov	edx, ecx
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [eax+36], ecx
	mov	eax, ebp
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2445 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
$LN1@executeCom:

; 2406 : 		break;
; 2407 : 
; 2408 : 	case Command::RETIRE_COMMAND:
; 2409 : 		break;	
; 2410 : 
; 2411 : 	case Command::PRECHARGE_ALL:
; 2412 : 		break;
; 2413 : 
; 2414 : 	case Command::ACTIVATE_ALL:
; 2415 : 		break;
; 2416 : 
; 2417 : 	case Command::DRIVE_COMMAND:
; 2418 : 		break;
; 2419 : 
; 2420 : 	case Command::DATA_COMMAND:
; 2421 : 		break;
; 2422 : 
; 2423 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2424 : 		break;	
; 2425 : 
; 2426 : 	case Command::SELF_REFRESH:
; 2427 : 		break;
; 2428 : 
; 2429 : 	case Command::DESELECT:
; 2430 : 		break;
; 2431 : 
; 2432 : 	case Command::NOOP:
; 2433 : 		break;
; 2434 : 
; 2435 : 	case Command::INVALID_COMMAND:
; 2436 : 		break;
; 2437 : 
; 2438 : 	default:
; 2439 : 		cerr << "Unknown command type" << endl;

	push	OFFSET ??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN34@executeCom:

; 2440 : 		break;
; 2441 : 	}	
; 2442 : 
; 2443 : 	// inserts into a queue which dequeues into the command pool
; 2444 : 	retireCommand(thisCommand);

	push	ebx
	mov	eax, ebp
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2445 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
	npad	3
$LN425@executeCom:
	DD	$LN33@executeCom
	DD	$LN30@executeCom
	DD	$LN31@executeCom
	DD	$LN23@executeCom
	DD	$LN24@executeCom
	DD	$LN34@executeCom
	DD	$LN17@executeCom
	DD	$LN16@executeCom
$LN422@executeCom:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	7
	DB	5
	DB	5
	DB	5
	DB	5
?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ENDP ; DRAMsimII::Channel::executeCommand
_TEXT	ENDS
PUBLIC	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
;	COMDAT ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
; File c:\program files\microsoft visual studio 9.0\vc\include\new
_BSS	SEGMENT
?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A DB 070H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::newRefreshTransaction
_BSS	ENDS
;	COMDAT ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
_BSS	SEGMENT
?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A DB 028H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::address
_BSS	ENDS
;	COMDAT ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
_BSS	SEGMENT
?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::$S1
__unwindtable$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ$1
__ehfuncinfo$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_earliestRank$ = -28					; size = 4
_earliestTime$ = -24					; size = 8
__$EHRec$ = -12						; size = 12
_currentRank$ = 8					; size = 4
_this$ = 8						; size = 4
?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ PROC ; DRAMsimII::Channel::readNextRefresh

; 933  : {

	push	-1
	push	__ehhandler$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+44]

; 934  : 	assert(rank.size() >= 1);
; 935  : 
; 936  : 	unsigned currentRank = 0;

	xor	eax, eax
	mov	DWORD PTR _currentRank$[esp+44], eax

; 937  : 	unsigned earliestRank = 0;

	mov	DWORD PTR _earliestRank$[esp+48], eax

; 938  : 	tick earliestTime = refreshCounter[0];

	mov	eax, DWORD PTR [ebp+168]
	sub	eax, DWORD PTR [ebp+164]
	sar	eax, 3
	test	eax, eax
	ja	SHORT $LN14@readNextRe
	call	__invalid_parameter_noinfo
$LN14@readNextRe:
	mov	eax, DWORD PTR [ebp+164]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 939  : 
; 940  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	mov	esi, eax
	mov	DWORD PTR _earliestTime$[esp+48], ecx
	mov	DWORD PTR _earliestTime$[esp+52], edx
	cmp	esi, DWORD PTR [ebp+168]
	jbe	SHORT $LN22@readNextRe
	call	__invalid_parameter_noinfo
$LN22@readNextRe:
	mov	edi, DWORD PTR [ebp+152]
	npad	11
$LL6@readNextRe:
	mov	ebx, DWORD PTR [ebp+168]
	cmp	DWORD PTR [ebp+164], ebx
	jbe	SHORT $LN50@readNextRe
	call	__invalid_parameter_noinfo
$LN50@readNextRe:
	mov	eax, DWORD PTR [ebp+152]
	test	edi, edi
	je	SHORT $LN63@readNextRe
	cmp	edi, eax
	je	SHORT $LN64@readNextRe
$LN63@readNextRe:
	call	__invalid_parameter_noinfo
$LN64@readNextRe:
	cmp	esi, ebx
	je	SHORT $LN4@readNextRe

; 941  : 	{
; 942  : 		if (*i < earliestTime)

	test	edi, edi
	jne	SHORT $LN111@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN80@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN71@readNextRe
	call	__invalid_parameter_noinfo
$LN71@readNextRe:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR _earliestTime$[esp+52]
	jg	SHORT $LN5@readNextRe
	jl	SHORT $LN112@readNextRe
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR _earliestTime$[esp+48]
	jae	SHORT $LN5@readNextRe
$LN112@readNextRe:

; 943  : 		{
; 944  : 			earliestRank = currentRank;

	mov	edx, DWORD PTR _currentRank$[esp+44]
	mov	DWORD PTR _earliestRank$[esp+48], edx

; 945  : 			earliestTime = *i;

	test	edi, edi
	jne	SHORT $LN110@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN92@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN83@readNextRe
	call	__invalid_parameter_noinfo
$LN83@readNextRe:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _earliestTime$[esp+48], eax
	mov	DWORD PTR _earliestTime$[esp+52], ecx
$LN5@readNextRe:

; 939  : 
; 940  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	test	edi, edi
	jne	SHORT $LN109@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN44@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN35@readNextRe
	call	__invalid_parameter_noinfo
$LN35@readNextRe:
	add	esi, 8
	inc	DWORD PTR _currentRank$[esp+44]
	jmp	$LL6@readNextRe
$LN111@readNextRe:

; 941  : 	{
; 942  : 		if (*i < earliestTime)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN80@readNextRe
$LN110@readNextRe:

; 945  : 			earliestTime = *i;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN92@readNextRe
$LN109@readNextRe:

; 939  : 
; 940  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN44@readNextRe
$LN4@readNextRe:

; 946  : 		}
; 947  : 	}
; 948  : 
; 949  : 	static Address address;

	mov	ebx, DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
	or	edi, -1
	test	bl, 1
	jne	SHORT $LN95@readNextRe
	or	ebx, 1
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, ebx
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+8, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+12, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+16, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+20, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+24, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+28, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+32, edi
$LN95@readNextRe:

; 950  : 
; 951  : 	address.setAddress(channelID,earliestRank,0,0,0);

	mov	edx, DWORD PTR [ebp+392]
	mov	eax, DWORD PTR _earliestRank$[esp+48]
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+20, eax
	xor	eax, eax
	mov	esi, OFFSET ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+16, edx
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+24, eax
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+32, eax
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+28, eax
	call	?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::reverseAddressTranslation

; 952  : 
; 953  : 	static Transaction newRefreshTransaction;

	test	bl, 2
	jne	SHORT $LN1@readNextRe
	or	ebx, 2
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, ebx
	xor	ebx, ebx
	mov	esi, OFFSET ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	push	OFFSET ??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction''
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A, OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+80, 7
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+84, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+88, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+92, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+96, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+100, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+104, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+108, edi
	call	_atexit
	add	esp, 4
$LN1@readNextRe:

; 954  : 	::new(&newRefreshTransaction)Transaction(Transaction::AUTO_REFRESH_TRANSACTION, earliestTime, 8, address, 0, 0, UINT_MAX);

	mov	ecx, DWORD PTR _earliestTime$[esp+52]
	mov	edx, DWORD PTR _earliestTime$[esp+48]
	push	edi
	push	8
	push	ecx
	push	edx
	push	4
	mov	edx, OFFSET ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
	mov	eax, OFFSET ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
	call	??0Transaction@DRAMsimII@@QAE@W4TransactionType@01@_JIABVAddress@1@_KHI@Z ; DRAMsimII::Transaction::Transaction

; 955  : 
; 956  : 	return &newRefreshTransaction;
; 957  : 
; 958  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	4
__unwindfunclet$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ$1:
	mov	eax, DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, eax
	ret	0
__ehhandler$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	jmp	___CxxFrameHandler3
?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ENDP ; DRAMsimII::Channel::readNextRefresh
PUBLIC	?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ; DRAMsimII::Channel::getAvailableTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z PROC ; DRAMsimII::Channel::getAvailableTransaction
; _this$ = ecx
; _useThis$ = eax

; 855  : {

	push	esi
	mov	esi, ecx

; 856  : 	if (useThis < UINT_MAX)

	cmp	eax, -1
	jae	SHORT $LN4@getAvailab
$LN7@getAvailab:

; 857  : 		return transactionQueue.remove(useThis);

	add	esi, 112				; 00000070H
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 865  : 	}
; 866  : }

	pop	esi
	ret	0
$LN4@getAvailab:

; 858  : 	else
; 859  : 	{
; 860  : 		unsigned val = readAvailableTransaction(true);

	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction

; 861  : 		if (val < UINT_MAX)

	cmp	eax, -1

; 862  : 			return transactionQueue.remove(val);

	jb	SHORT $LN7@getAvailab

; 863  : 		else
; 864  : 			return NULL;

	xor	eax, eax

; 865  : 	}
; 866  : }

	pop	esi
	ret	0
?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ENDP ; DRAMsimII::Channel::getAvailableTransaction
_TEXT	ENDS
PUBLIC	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_nextRefresh$222615 = -8				; size = 8
_bufferDelay$ = 8					; size = 1
?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z PROC ; DRAMsimII::Channel::readTransaction
; _this$ = eax

; 775  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 776  : 	const unsigned delay = bufferDelay ? timingSpecification.tBufferDelay() : 0;

	mov	eax, DWORD PTR _bufferDelay$[esp+16]
	push	edi
	test	al, al
	je	SHORT $LN10@readTransa
	mov	ebx, DWORD PTR [esi+104]
	jmp	SHORT $LN11@readTransa
$LN10@readTransa:
	xor	ebx, ebx
$LN11@readTransa:

; 777  : 
; 778  : 	unsigned val = readAvailableTransaction(bufferDelay);

	push	eax
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	mov	ecx, eax

; 779  : 
; 780  : 	const Transaction *nextTransaction = (val < UINT_MAX) ? transactionQueue[val] : NULL;

	cmp	ecx, -1
	jae	SHORT $LN12@readTransa
	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN12@readTransa
	test	ecx, ecx
	jl	SHORT $LN12@readTransa
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+140]
	sub	eax, DWORD PTR [esi+136]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN27@readTransa
	call	__invalid_parameter_noinfo
$LN27@readTransa:
	mov	ecx, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN13@readTransa
$LN12@readTransa:
	xor	edi, edi
$LN13@readTransa:

; 781  : 
; 782  : 	if (systemConfig.getRefreshPolicy() == NO_REFRESH)

	mov	edx, DWORD PTR [esi+176]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN7@readTransa

; 783  : 	{
; 784  : 		if ((nextTransaction) && (time >= nextTransaction->getEnqueueTime() + delay))

	test	edi, edi
	je	$LN2@readTransa
	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+12]
	xor	ecx, ecx
	add	ebx, DWORD PTR [edi+16]
	adc	eax, ecx
	cmp	edx, eax
	jl	$LN2@readTransa
	jg	SHORT $LN40@readTransa
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	jb	$LN2@readTransa
$LN40@readTransa:

; 785  : 		{
; 786  : 			return nextTransaction;

	mov	eax, edi

; 805  : 		}
; 806  : 	}
; 807  : 	return NULL;
; 808  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN7@readTransa:

; 787  : 		}
; 788  : 	}
; 789  : 	else
; 790  : 	{
; 791  : 		const tick nextRefresh = nextRefreshTime();

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	mov	DWORD PTR _nextRefresh$222615[esp+24], eax
	mov	DWORD PTR _nextRefresh$222615[esp+28], edx

; 792  : 
; 793  : 		// give an advantage to normal transactions, but prevent starvation for refresh operations
; 794  : 		// if there is a normal transaction ready to go, it's ready to go and the refresh command isn't starving
; 795  : 		if (nextTransaction &&
; 796  : 			((time < nextRefresh + systemConfig.getSeniorityAgeLimit()) &&
; 797  : 			(time >= nextTransaction->getEnqueueTime() + delay)))

	test	edi, edi
	je	SHORT $LN4@readTransa
	mov	ecx, DWORD PTR [esi+176]
	mov	ebp, DWORD PTR [ecx+320]
	mov	eax, DWORD PTR [esi+12]
	xor	ecx, ecx
	add	ebp, DWORD PTR _nextRefresh$222615[esp+24]
	adc	ecx, edx
	cmp	eax, ecx
	jg	SHORT $LN4@readTransa
	jl	SHORT $LN41@readTransa
	cmp	DWORD PTR [esi+8], ebp
	jae	SHORT $LN4@readTransa
$LN41@readTransa:
	mov	ecx, DWORD PTR [edi+20]
	xor	ebp, ebp
	add	ebx, DWORD PTR [edi+16]
	adc	ecx, ebp
	cmp	eax, ecx
	jl	SHORT $LN4@readTransa
	jg	SHORT $LN40@readTransa
	cmp	DWORD PTR [esi+8], ebx

; 798  : 		{
; 799  : 			return nextTransaction;

	jae	SHORT $LN40@readTransa
$LN4@readTransa:

; 800  : 		}
; 801  : 		// either there is no transaction or the refresh command will starve
; 802  : 		else if (((time >= nextRefresh) || !bufferDelay) && (checkForAvailableCommandSlots(readNextRefresh())))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edx
	jg	SHORT $LN1@readTransa
	jl	SHORT $LN43@readTransa
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _nextRefresh$222615[esp+24]
	jae	SHORT $LN1@readTransa
$LN43@readTransa:
	cmp	BYTE PTR _bufferDelay$[esp+20], 0
	jne	SHORT $LN2@readTransa
$LN1@readTransa:
	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	push	esi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	SHORT $LN2@readTransa

; 803  : 		{
; 804  : 			return readNextRefresh();

	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh

; 805  : 		}
; 806  : 	}
; 807  : 	return NULL;
; 808  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN2@readTransa:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 8
	ret	4
?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ENDP ; DRAMsimII::Channel::readTransaction
_TEXT	ENDS
PUBLIC	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextTransactionDecodeTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ PROC ; DRAMsimII::Channel::nextTransactionDecodeTime
; _this$ = esi

; 287  : {	

	push	ecx

; 288  : 	if (const Transaction *nextTrans = readTransaction(false))

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN1@nextTransa

; 289  : 	{
; 290  : 		if (nextTrans)
; 291  : 		{
; 292  : 			if (nextTrans->isRefresh())

	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN2@nextTransa

; 293  : 				return nextTrans->getArrivalTime();

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	pop	ecx

; 300  : }

	ret	0
$LN2@nextTransa:

; 294  : 			else
; 295  : 				return nextTrans->getEnqueueTime() + timingSpecification.tBufferDelay();

	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	pop	ecx

; 300  : }

	ret	0
$LN1@nextTransa:

; 296  : 		}
; 297  : 	}
; 298  : 
; 299  : 	return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
	pop	ecx

; 300  : }

	ret	0
?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ENDP ; DRAMsimII::Channel::nextTransactionDecodeTime
; Function compile flags: /Ogtpy
?nextTick@Channel@DRAMsimII@@UBE_JXZ PROC		; DRAMsimII::Channel::nextTick
; _this$ = ecx

; 276  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	mov	ebp, 4
	test	ecx, ecx
	je	SHORT $LN17@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN18@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN21@nextTick@2
$LN18@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN21@nextTick@2
$LN17@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN21@nextTick@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN32@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN31@nextTick@2
$LN32@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN31@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN3@nextTick@2
	jl	SHORT $LN154@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN3@nextTick@2
$LN154@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN50@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN36@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN49@nextTick@2
$LN36@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN49@nextTick@2
$LN3@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN50@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	mov	ebx, eax
	mov	edi, edx
	jmp	SHORT $LN49@nextTick@2
$LN50@nextTick@2:
	mov	edi, 2147483647				; 7fffffffH
	or	ebx, -1
$LN49@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	cmp	edi, edx
	jg	$LN7@nextTick@2
	jl	SHORT $LN155@nextTick@2
	cmp	ebx, eax
	jae	$LN7@nextTick@2
$LN155@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN53@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN54@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN57@nextTick@2
$LN54@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN57@nextTick@2
$LN53@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN57@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN68@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN67@nextTick@2
$LN68@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN67@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN5@nextTick@2
	jl	SHORT $LN156@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN5@nextTick@2
$LN156@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN86@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN72@nextTick@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN8@nextTick@2
$LN72@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN8@nextTick@2
$LN5@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN86@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN8@nextTick@2
$LN86@nextTick@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
	jmp	SHORT $LN8@nextTick@2
$LN7@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
$LN8@nextTick@2:
	mov	edi, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	add	edi, 1
	adc	ecx, 0
	cmp	edx, ecx
	jl	$LN15@nextTick@2
	jg	SHORT $LN157@nextTick@2
	cmp	eax, edi
	jbe	$LN15@nextTick@2
$LN157@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN89@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN90@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN93@nextTick@2
$LN90@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN93@nextTick@2
$LN89@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN93@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN104@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN103@nextTick@2
$LN104@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN103@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN9@nextTick@2
	jl	SHORT $LN158@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN9@nextTick@2
$LN158@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN122@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN108@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN121@nextTick@2
$LN108@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN121@nextTick@2
$LN9@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN122@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	mov	ebx, eax
	mov	edi, edx
	jmp	SHORT $LN121@nextTick@2
$LN122@nextTick@2:
	mov	edi, 2147483647				; 7fffffffH
	or	ebx, -1
$LN121@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	cmp	edi, edx
	jg	$LN13@nextTick@2
	jl	SHORT $LN159@nextTick@2
	cmp	ebx, eax
	jae	$LN13@nextTick@2
$LN159@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN125@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN126@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN129@nextTick@2
$LN126@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN129@nextTick@2
$LN125@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN129@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN140@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN139@nextTick@2
$LN140@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN139@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN11@nextTick@2
	jl	SHORT $LN160@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN11@nextTick@2
$LN160@nextTick@2:
	call	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextTransactionDecodeTime

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN144@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

$LN144@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	eax, edi

; 278  : }

	pop	edi
	mov	edx, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?nextTick@Channel@DRAMsimII@@UBE_JXZ ENDP		; DRAMsimII::Channel::nextTick
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapdramsimwssoaphttpproxy.h
_TEXT	ENDS
;	COMDAT ??1DRAMsimWSSoapHttp@@UAE@XZ
_TEXT	SEGMENT
??1DRAMsimWSSoapHttp@@UAE@XZ PROC			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp, COMDAT
; _this$ = ecx

; 31   : 	virtual ~DRAMsimWSSoapHttp() { if (soap) { soap_destroy(soap); soap_end(soap); soap_free(soap); } };

	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], OFFSET ??_7DRAMsimWSSoapHttp@@6B@
	test	esi, esi
	je	SHORT $LN17@DRAMsimWSS@2
	movzx	eax, WORD PTR [esi+4]
	cmp	ax, 1
	je	SHORT $LN14@DRAMsimWSS@2
	cmp	ax, 2
	jne	SHORT $LN13@DRAMsimWSS@2
$LN14@DRAMsimWSS@2:
	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN5@DRAMsimWSS@2
	push	edi
$LL6@DRAMsimWSS@2:
	mov	edi, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+16]
	push	edi
	call	ecx
	push	edi
	call	_free
	add	esp, 8
	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LL6@DRAMsimWSS@2
	pop	edi
$LN5@DRAMsimWSS@2:
	mov	DWORD PTR [esi+12208], 0
	mov	DWORD PTR [esi+12204], 0
$LN13@DRAMsimWSS@2:
	mov	eax, DWORD PTR [ebx+4]
	call	_soap_end
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, ebx
	call	_soap_done
	push	ebx
	call	_free
	add	esp, 4
$LN17@DRAMsimWSS@2:
	pop	esi
	pop	ebx
	ret	0
??1DRAMsimWSSoapHttp@@UAE@XZ ENDP			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DRAMsimWSSoapHttp@@QAE@XZ
_TEXT	SEGMENT
??0DRAMsimWSSoapHttp@@QAE@XZ PROC			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp, COMDAT
; _this$ = edi

; 18   : 	DRAMsimWSSoapHttp()

	push	esi
	push	95832					; 00017658H
	mov	DWORD PTR [edi], OFFSET ??_7DRAMsimWSSoapHttp@@6B@
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN9@DRAMsimWSS@3
	mov	edx, esi
	call	_soap_init
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], 0
$LN9@DRAMsimWSS@3:
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@

; 19   : 	{ soap = soap_new(); endpoint = "http://id2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort"; if (soap && !soap->namespaces) { static const struct Namespace namespaces[] = 
; 20   : {
; 21   : 	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
; 22   : 	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
; 23   : 	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
; 24   : 	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
; 25   : 	{"ns1", "http://DRAMsimReporter/", NULL, NULL},
; 26   : 	{"ns2", "http://DRAMsimReporter/types/", NULL, NULL},
; 27   : 	{NULL, NULL, NULL, NULL}
; 28   : };
; 29   : 	soap->namespaces = namespaces; } };

	mov	eax, edi
	test	esi, esi
	je	SHORT $LN1@DRAMsimWSS@3

; 18   : 	DRAMsimWSSoapHttp()

	cmp	DWORD PTR [esi+80], 0
	jne	SHORT $LN1@DRAMsimWSS@3

; 19   : 	{ soap = soap_new(); endpoint = "http://id2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort"; if (soap && !soap->namespaces) { static const struct Namespace namespaces[] = 
; 20   : {
; 21   : 	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
; 22   : 	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
; 23   : 	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
; 24   : 	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
; 25   : 	{"ns1", "http://DRAMsimReporter/", NULL, NULL},
; 26   : 	{"ns2", "http://DRAMsimReporter/types/", NULL, NULL},
; 27   : 	{NULL, NULL, NULL, NULL}
; 28   : };
; 29   : 	soap->namespaces = namespaces; } };

	mov	DWORD PTR [esi+80], OFFSET ?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
$LN1@DRAMsimWSS@3:
	pop	esi
	ret	0
??0DRAMsimWSSoapHttp@@QAE@XZ ENDP			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z PROC		; DRAMsimII::Bank::push, COMDAT
; _value$ = eax

; 107  : 		bool push(Command *value) { return perBankQueue.push(value); }

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	ret	4
?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z ENDP		; DRAMsimII::Bank::push
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
$T679362 = 12						; size = 4
_rhs$ = 12						; size = 4
??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=, COMDAT

; 416  : 		{

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]
	push	edi

; 417  : 			if (&rhs == this)

	mov	edi, DWORD PTR _this$[esp+4]
	cmp	ebx, edi

; 418  : 				return *this;

	je	$LN41@operator@432

; 419  : 
; 420  : 			count = rhs.count;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax

; 421  : 			head = rhs.head;

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+4], ecx

; 422  : 			tail = rhs.tail;

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], edx

; 423  : 			const_cast<bool&>(pool) = rhs.pool;

	mov	al, BYTE PTR [ebx+36]
	mov	BYTE PTR [edi+36], al

; 424  : 
; 425  : 			entry.resize(rhs.entry.size());

	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	push	ebp
	sar	ecx, 2
	lea	eax, DWORD PTR [edi+12]
	push	ecx
	call	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize

; 426  : 
; 427  : 			for (unsigned i = 0; i < rhs.count; i++)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx], ebp
	jbe	$LN1@operator@432
	push	esi
$LL3@operator@432:

; 428  : 			{
; 429  : 				assert(rhs.at(i));
; 430  : 
; 431  : 				entry[(head + i) % entry.size()] = new T(*(rhs.at(i)));

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	esi, eax
	test	esi, esi
	je	$LN7@operator@432
	cmp	ebp, DWORD PTR [ebx]
	jge	SHORT $LN19@operator@432
	test	ebp, ebp
	jl	SHORT $LN19@operator@432
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [ebx+28]
	sub	edx, DWORD PTR [ebx+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN25@operator@432
	call	__invalid_parameter_noinfo
$LN25@operator@432:
	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN18@operator@432
$LN19@operator@432:
	xor	edi, edi
$LN18@operator@432:
	mov	ecx, edi
	mov	eax, esi
	call	??0Event@DRAMsimII@@IAE@ABV01@@Z	; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], edx
	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], eax
	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], ecx
	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], eax
	mov	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], ecx
	mov	edx, DWORD PTR [edi+108]
	mov	edi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR [esi+108], edx
	mov	DWORD PTR $T679362[esp+12], esi
	jmp	SHORT $LN8@operator@432
$LN7@operator@432:
	mov	DWORD PTR $T679362[esp+12], 0
$LN8@operator@432:
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [edi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	esi, edx
	mov	edx, DWORD PTR [edi+28]
	sub	edx, DWORD PTR [edi+24]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN34@operator@432
	call	__invalid_parameter_noinfo
$LN34@operator@432:
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR $T679362[esp+12]
	inc	ebp
	mov	DWORD PTR [eax+esi*4], ecx
	cmp	ebp, DWORD PTR [ebx]
	jb	$LL3@operator@432
	pop	esi
$LN1@operator@432:
	pop	ebp
$LN41@operator@432:

; 432  : 			}
; 433  : 
; 434  : 			return *this;

	mov	eax, edi
	pop	edi
	pop	ebx

; 435  : 		}

	ret	8
??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T679483 = 12						; size = 4
$T679448 = 12						; size = 4
_rhs$ = 12						; size = 4
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>, COMDAT

; 64   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _rhs$[esp+32]
	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR _this$[esp+32]
	mov	DWORD PTR [ebp], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+4], ecx
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebp+8], edx
	mov	edi, DWORD PTR [ebx+28]
	sub	edi, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR [ebp+12]
	sar	edi, 2
	push	esi
	call	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	al, BYTE PTR [ebx+36]
	mov	BYTE PTR [ebp+36], al

; 65   : 			entry.reserve(rhs.entry.size());

	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	sar	ecx, 2
	push	ecx
	call	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve

; 66   : 
; 67   : 			for (unsigned i = 0; i < rhs.count; i++)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx], ebp
	jbe	$LN48@Queue@8
$LL6@Queue@8:

; 68   : 			{
; 69   : 				assert(rhs.at(i) != NULL);
; 70   : 				// attempt to copy the contents of this queue
; 71   : 				entry[(head + i) % entry.size()] = new T(*rhs.at(i));

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	edi, eax
	xor	eax, eax
	cmp	edi, eax
	je	$LN9@Queue@8
	cmp	ebp, DWORD PTR [ebx]
	jge	SHORT $LN22@Queue@8
	cmp	ebp, eax
	jl	SHORT $LN22@Queue@8
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+4]
	add	eax, ebp
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [ebx+28]
	sub	eax, DWORD PTR [ebx+24]
	sar	eax, 2
	mov	DWORD PTR $T679483[esp+32], edx
	cmp	edx, eax
	jb	SHORT $LN28@Queue@8
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR $T679483[esp+32]
$LN28@Queue@8:
	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN22@Queue@8:
	mov	DWORD PTR [edi], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], edx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edi+20], ecx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [edi+24], edx
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edi+28], ecx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edi+32], edx
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edi+36], ecx
	movq	xmm0, QWORD PTR [eax+40]
	movq	QWORD PTR [edi+40], xmm0
	movq	xmm0, QWORD PTR [eax+48]
	movq	QWORD PTR [edi+48], xmm0
	movq	xmm0, QWORD PTR [eax+56]
	movq	QWORD PTR [edi+56], xmm0
	movq	xmm0, QWORD PTR [eax+64]
	movq	QWORD PTR [edi+64], xmm0
	movq	xmm0, QWORD PTR [eax+72]
	movq	QWORD PTR [edi+72], xmm0
	mov	DWORD PTR [edi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	edx, DWORD PTR [eax+80]
	mov	DWORD PTR [edi+80], edx
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [edi+84], ecx
	mov	edx, DWORD PTR [eax+88]
	mov	DWORD PTR [edi+88], edx
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edi+92], ecx
	mov	edx, DWORD PTR [eax+96]
	mov	DWORD PTR [edi+96], edx
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edi+100], ecx
	mov	edx, DWORD PTR [eax+104]
	mov	DWORD PTR [edi+104], edx
	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR [edi+108], eax
	mov	DWORD PTR $T679448[esp+32], edi
	jmp	SHORT $LN10@Queue@8
$LN9@Queue@8:
	mov	DWORD PTR $T679448[esp+32], eax
$LN10@Queue@8:
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR _this$[esp+32]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ebp
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN39@Queue@8
	call	__invalid_parameter_noinfo
$LN39@Queue@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR $T679448[esp+32]
	inc	ebp
	mov	DWORD PTR [ecx+edi*4], edx
	cmp	ebp, DWORD PTR [ebx]
	jb	$LL6@Queue@8
$LN48@Queue@8:

; 72   : 			}
; 73   : 
; 74   : 			for (unsigned i = 0; i < count; i++)
; 75   : 				assert(at(i) && rhs.at(i));
; 76   : 		}	

	mov	eax, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::createNextRefresh
__unwindtable$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ$0
__ehfuncinfo$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T679581 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T679550 = 8						; size = 4
$T679549 = 8						; size = 4
_this$ = 8						; size = 4
?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ PROC ; DRAMsimII::Channel::createNextRefresh

; 916  : {

	push	-1
	push	__ehhandler$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+36]

; 917  : 	Transaction *newRefreshTransaction = new Transaction(*readNextRefresh());

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	esi, eax
	mov	DWORD PTR $T679550[esp+36], esi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+48], eax
	cmp	esi, eax
	je	SHORT $LN3@createNext
	push	ebx
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	mov	edi, eax
	mov	ecx, edi
	mov	eax, esi
	call	??0Event@DRAMsimII@@IAE@ABV01@@Z	; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], ecx
	mov	edx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], eax
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax
	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], ecx
	mov	DWORD PTR $T679549[esp+36], esi
	jmp	SHORT $LN4@createNext
$LN3@createNext:
	mov	DWORD PTR $T679549[esp+36], eax
$LN4@createNext:

; 918  : 
; 919  : 	unsigned rank = newRefreshTransaction->getAddress().getRank();
; 920  : 
; 921  : 	refreshCounter[rank] = refreshCounter[rank] + timingSpecification.tREFI();

	mov	eax, DWORD PTR [ebx+168]
	sub	eax, DWORD PTR [ebx+164]
	mov	edx, DWORD PTR $T679549[esp+36]
	mov	esi, DWORD PTR [edx+60]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN14@createNext
	call	__invalid_parameter_noinfo
$LN14@createNext:
	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	mov	edi, DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR [ebx+108]
	lea	ebp, DWORD PTR [esi*8]
	sar	edx, 3
	add	edi, ebp
	mov	DWORD PTR $T679581[esp+40], ecx
	cmp	esi, edx
	jb	SHORT $LN21@createNext
	call	__invalid_parameter_noinfo
$LN21@createNext:
	mov	eax, DWORD PTR $T679581[esp+40]
	mov	ebx, DWORD PTR [ebx+164]
	cdq
	add	eax, DWORD PTR [edi]
	adc	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+ebp], eax

; 922  : 
; 923  : 	return newRefreshTransaction;

	mov	eax, DWORD PTR $T679549[esp+36]
	mov	DWORD PTR [ebx+ebp+4], edx

; 924  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
__unwindfunclet$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ$0:
	mov	esi, DWORD PTR $T679550[ebp-4]
	jmp	??3Transaction@DRAMsimII@@SAXPAX@Z	; DRAMsimII::Transaction::operator delete
__ehhandler$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	jmp	___CxxFrameHandler3
?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Channel::createNextRefresh
PUBLIC	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_val$ = -12						; size = 4
_nextRefresh$222657 = -8				; size = 8
?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ PROC ; DRAMsimII::Channel::getTransaction
; _this$ = eax

; 875  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 876  : 	unsigned val = readAvailableTransaction(true);

	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	mov	ebx, eax
	mov	DWORD PTR _val$[esp+28], ebx

; 877  : 
; 878  : 	const Transaction *nextTransaction = (val < UINT_MAX) ? transactionQueue[val] : NULL;

	cmp	ebx, -1
	jae	SHORT $LN9@getTransac
	cmp	ebx, DWORD PTR [esi+112]
	jge	SHORT $LN9@getTransac
	test	ebx, ebx
	jl	SHORT $LN9@getTransac
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN22@getTransac
	call	__invalid_parameter_noinfo
$LN22@getTransac:
	mov	eax, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN10@getTransac
$LN9@getTransac:
	xor	edi, edi
$LN10@getTransac:

; 879  : 
; 880  : 	// no refresh transactions, just see if normal transactions are decoded
; 881  : 	if (systemConfig.getRefreshPolicy() == NO_REFRESH)

	mov	ecx, DWORD PTR [esi+176]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN6@getTransac

; 882  : 	{
; 883  : 		if ((nextTransaction) && (time >= nextTransaction->getEnqueueTime() + timingSpecification.tBufferDelay()))

	test	edi, edi
	je	$LN1@getTransac
	mov	eax, DWORD PTR [esi+104]
	mov	ecx, DWORD PTR [esi+12]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	cmp	ecx, edx
	jl	$LN1@getTransac
	jg	SHORT $LN45@getTransac
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, eax
	jb	$LN1@getTransac
$LN45@getTransac:

; 884  : 		{
; 885  : 			return getAvailableTransaction(val);

	cmp	ebx, -1
	jae	SHORT $LN36@getTransac
	add	esi, 112				; 00000070H
	mov	eax, ebx
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 903  : 		}
; 904  : 	}
; 905  : 	return NULL;
; 906  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0

; 884  : 		{
; 885  : 			return getAvailableTransaction(val);

$LN36@getTransac:
	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	cmp	eax, -1
	jae	$LN1@getTransac
	add	esi, 112				; 00000070H
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 903  : 		}
; 904  : 	}
; 905  : 	return NULL;
; 906  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN6@getTransac:

; 886  : 		}
; 887  : 	}
; 888  : 	else
; 889  : 	{
; 890  : 		const tick nextRefresh = nextRefreshTime();

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	mov	DWORD PTR _nextRefresh$222657[esp+28], eax
	mov	ebp, edx

; 891  : 
; 892  : 		// give an advantage to normal transactions, but prevent starvation for refresh operations
; 893  : 		// if there is a normal transaction ready to go, it's ready to go and the refresh command isn't starving
; 894  : 		if (nextTransaction &&
; 895  : 			((time < nextRefresh + systemConfig.getSeniorityAgeLimit()) &&
; 896  : 			(time >= nextTransaction->getEnqueueTime() + timingSpecification.tBufferDelay())))

	test	edi, edi
	je	SHORT $LN3@getTransac
	mov	eax, DWORD PTR [esi+176]
	mov	ecx, DWORD PTR [eax+320]
	mov	ebx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	xor	eax, eax
	add	ecx, DWORD PTR _nextRefresh$222657[esp+28]
	adc	eax, ebp
	cmp	ebx, eax
	jg	SHORT $LN3@getTransac
	jl	SHORT $LN46@getTransac
	cmp	edx, ecx
	jae	SHORT $LN3@getTransac
$LN46@getTransac:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	cmp	ebx, edx
	jl	SHORT $LN3@getTransac
	jg	SHORT $LN47@getTransac
	cmp	DWORD PTR [esi+8], eax
	jb	SHORT $LN3@getTransac
$LN47@getTransac:

; 897  : 		{
; 898  : 			return getAvailableTransaction(val);

	mov	eax, DWORD PTR _val$[esp+28]
	mov	ecx, esi

; 903  : 		}
; 904  : 	}
; 905  : 	return NULL;
; 906  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH

; 897  : 		{
; 898  : 			return getAvailableTransaction(val);

	jmp	?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ; DRAMsimII::Channel::getAvailableTransaction
$LN3@getTransac:

; 899  : 		}
; 900  : 		else if ((time >= nextRefresh) && (checkForAvailableCommandSlots(readNextRefresh())))

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, ebp
	jl	SHORT $LN1@getTransac
	jg	SHORT $LN48@getTransac
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, DWORD PTR _nextRefresh$222657[esp+28]
	jb	SHORT $LN1@getTransac
$LN48@getTransac:
	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	push	esi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	SHORT $LN1@getTransac

; 901  : 		{
; 902  : 			return createNextRefresh();

	push	esi
	call	?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::createNextRefresh

; 903  : 		}
; 904  : 	}
; 905  : 	return NULL;
; 906  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN1@getTransac:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Channel::getTransaction
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GDRAMsimWSSoapHttp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDRAMsimWSSoapHttp@@UAEPAXI@Z PROC			; DRAMsimWSSoapHttp::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@106
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@106:
	mov	eax, esi
	pop	esi
	ret	4
??_GDRAMsimWSSoapHttp@@UAEPAXI@Z ENDP			; DRAMsimWSSoapHttp::`scalar deleting destructor'
PUBLIC	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands
__unwindtable$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$8
__ehfuncinfo$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv4803 = -108						; size = 4
$T686839 = -108						; size = 4
_bankNumber$222987 = -104				; size = 4
$T686811 = -104						; size = 4
_destinationBank$ = -104				; size = 8
$T688237 = -96						; size = 4
__Tmp$687263 = -96					; size = 8
$T686822 = -96						; size = 4
$T686812 = -96						; size = 4
_currentBank$222887 = -96				; size = 8
$T687907 = -88						; size = 1
$T687434 = -88						; size = 1
$T686854 = -88						; size = 4
$T686850 = -88						; size = 4
$T686846 = -88						; size = 4
$T686834 = -88						; size = 4
$T686833 = -88						; size = 4
_i$222950 = -88						; size = 8
$T686826 = -88						; size = 4
$T686818 = -88						; size = 4
_destinationRank$ = -88					; size = 8
__Tmp$687011 = -80					; size = 8
$T686830 = -72						; size = 8
_bankEnd$222944 = -72					; size = 8
$T686809 = -72						; size = 8
$T686808 = -64						; size = 8
_tempAddr$222986 = -56					; size = 40
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_incomingTransaction$ = 12				; size = 4
?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Channel::transaction2commands

; 1119 : {

	push	-1
	push	__ehhandler$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	esi, DWORD PTR _this$[esp+128]

; 1120 : 	if (incomingTransaction == NULL)

	test	eax, eax

; 1121 : 	{
; 1122 : 		return false;

	je	$LN1110@transactio

; 1123 : 	}
; 1124 : 	// ensure that this transaction belongs on this channel
; 1125 : 	assert(incomingTransaction->getAddress().getChannel() == channelID);
; 1126 : 	assert(incomingTransaction->getAddress().getChannel() < systemConfig.getChannelCount());
; 1127 : 	assert(incomingTransaction->getAddress().getRank() < systemConfig.getRankCount());
; 1128 : 
; 1129 : 	vector<Rank>::iterator destinationRank = rank.begin() + incomingTransaction->getAddress().getRank();

	mov	edi, DWORD PTR [esi+412]
	mov	ebx, DWORD PTR [eax+60]
	cmp	edi, DWORD PTR [esi+416]
	jbe	SHORT $LN101@transactio
	call	__invalid_parameter_noinfo
$LN101@transactio:
	mov	esi, DWORD PTR [esi+400]
	mov	DWORD PTR __Tmp$687011[esp+132], esi
	mov	DWORD PTR __Tmp$687011[esp+136], edi
	test	esi, esi
	jne	SHORT $LN1100@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN126@transactio:
	imul	ebx, 424				; 000001a8H
	lea	ebp, DWORD PTR [ebx+edi]
	mov	DWORD PTR tv4803[esp+132], ebp
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN116@transactio
	test	esi, esi
	je	SHORT $LN131@transactio
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN132@transactio
$LN1100@transactio:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN126@transactio
$LN131@transactio:
	xor	esi, esi
$LN132@transactio:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN117@transactio
$LN116@transactio:
	call	__invalid_parameter_noinfo
$LN117@transactio:
	mov	eax, DWORD PTR __Tmp$687011[esp+132]

; 1130 : 
; 1131 : 	vector<Bank>::iterator destinationBank = destinationRank->bank.begin() + incomingTransaction->getAddress().getBank();

	mov	ecx, DWORD PTR _incomingTransaction$[esp+128]
	mov	ebx, DWORD PTR [ecx+64]
	mov	DWORD PTR _destinationRank$[esp+132], eax
	mov	DWORD PTR _destinationRank$[esp+136], ebp
	test	eax, eax
	jne	SHORT $LN1099@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN152@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN143@transactio
	call	__invalid_parameter_noinfo
$LN143@transactio:
	mov	edi, DWORD PTR [ebp+412]
	cmp	edi, DWORD PTR [ebp+416]
	jbe	SHORT $LN160@transactio
	call	__invalid_parameter_noinfo
$LN160@transactio:
	mov	esi, DWORD PTR [ebp+400]
	mov	DWORD PTR __Tmp$687263[esp+132], esi
	mov	DWORD PTR __Tmp$687263[esp+136], edi
	test	esi, esi
	jne	SHORT $LN1098@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN185@transactio:
	imul	ebx, 168				; 000000a8H
	lea	ebp, DWORD PTR [ebx+edi]
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN175@transactio
	test	esi, esi
	je	SHORT $LN190@transactio
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN191@transactio
$LN1099@transactio:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN152@transactio
$LN1098@transactio:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN185@transactio
$LN190@transactio:
	xor	esi, esi
$LN191@transactio:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN176@transactio
$LN175@transactio:
	call	__invalid_parameter_noinfo
$LN176@transactio:

; 1132 : 
; 1133 : 	assert(incomingTransaction->getAddress().getBank() < systemConfig.getBankCount());
; 1134 : 	assert(incomingTransaction->getAddress().getRow() < systemConfig.getRowCount());
; 1135 : 	assert(incomingTransaction->getAddress().getColumn() < systemConfig.getColumnCount());
; 1136 : 
; 1137 : 	// with closed page, all transactions convert into one of the following:
; 1138 : 	// RAS, CAS, Precharge
; 1139 : 	// RAS, CAS+Precharge
; 1140 : 	switch (systemConfig.getRowBufferManagementPolicy())

	mov	eax, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [eax+176]
	mov	ecx, DWORD PTR [ecx+328]
	mov	edx, DWORD PTR __Tmp$687263[esp+132]
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _destinationBank$[esp+132], edx
	mov	DWORD PTR _destinationBank$[esp+136], ebp
	cmp	eax, 3
	ja	$LN1@transactio
	jmp	DWORD PTR $LN1112@transactio[eax*4]
$LN59@transactio:

; 1141 : 	{
; 1142 : 		// will either convert a CAS+P into CAS, CAS+P by appending a new command or will add a CAS before a PRE (when autoprecharge is not available)
; 1143 : 	case CLOSE_PAGE:
; 1144 : 	case CLOSE_PAGE_AGGRESSIVE:
; 1145 : 
; 1146 : 		// refresh transactions become only one command and are handled differently
; 1147 : 		if (incomingTransaction->isRefresh())

	mov	edx, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [edx+80], 4
	jne	$LN58@transactio

; 1148 : 		{
; 1149 : 			// check to see if every per bank command queue has room for one command
; 1150 : 			// make sure that there is room in all the queues for one command
; 1151 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1152 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1153 : 			// are available
; 1154 : 			for (vector<Bank>::const_iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR $T686808[esp+132]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	edi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _currentBank$222887[esp+132], edi
	mov	DWORD PTR _currentBank$222887[esp+136], ebp
$LL57@transactio:
	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	ebx, DWORD PTR [esi+416]
	add	esi, 400				; 00000190H
	cmp	DWORD PTR [esi+12], ebx
	jbe	SHORT $LN203@transactio
	call	__invalid_parameter_noinfo
$LN203@transactio:
	mov	esi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN216@transactio
	cmp	edi, esi
	je	SHORT $LN217@transactio
$LN216@transactio:
	call	__invalid_parameter_noinfo
$LN217@transactio:
	cmp	ebp, ebx
	je	SHORT $LN55@transactio

; 1155 : 			{
; 1156 : 				if (currentBank->isFull())

	test	edi, edi
	jne	SHORT $LN1097@transactio
	call	__invalid_parameter_noinfo
$LN235@transactio:
	cmp	ebp, DWORD PTR [edi+16]
	jb	SHORT $LN226@transactio
	call	__invalid_parameter_noinfo
$LN226@transactio:
	mov	eax, DWORD PTR [ebp+40]
	sub	eax, DWORD PTR [ebp+36]
	sar	eax, 2
	cmp	eax, DWORD PTR [ebp+12]
	je	$LN1110@transactio
	lea	edi, DWORD PTR $T686809[esp+132]
	lea	esi, DWORD PTR _currentBank$222887[esp+132]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	mov	ebp, DWORD PTR _currentBank$222887[esp+136]
	mov	edi, DWORD PTR _currentBank$222887[esp+132]
	jmp	SHORT $LL57@transactio
$LN1097@transactio:
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN235@transactio
$LN55@transactio:

; 1157 : 					return false;
; 1158 : 			}
; 1159 : 			// then add the command to all queues
; 1160 : 			Command *refreshCommand = new Command(incomingTransaction, time,  systemConfig.isAutoPrecharge(), timingSpecification.tBurst());

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686812[esp+132], eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+140], edi
	cmp	eax, edi
	je	SHORT $LN65@transactio
	mov	esi, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [esi+176]
	mov	dl, BYTE PTR [edx+346]
	mov	ecx, DWORD PTR [esi+32]
	push	ecx
	mov	BYTE PTR $T687434[esp+136], dl
	mov	ecx, DWORD PTR $T687434[esp+136]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+144]
	push	eax
	lea	edx, DWORD PTR [edi+1]
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	DWORD PTR $T686811[esp+132], eax
	jmp	SHORT $LN66@transactio
$LN65@transactio:
	mov	DWORD PTR $T686811[esp+132], edi
$LN66@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1

; 1161 : 
; 1162 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	mov	ebx, DWORD PTR __Tmp$687011[esp+132]
	cmp	ebx, edi
	jne	$LN1096@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN263@transactio:
	mov	ebp, DWORD PTR tv4803[esp+132]
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN254@transactio
	call	__invalid_parameter_noinfo
$LN254@transactio:
	mov	edi, DWORD PTR [ebp+412]
	cmp	edi, DWORD PTR [ebp+416]
	jbe	SHORT $LN271@transactio
	call	__invalid_parameter_noinfo
$LN271@transactio:
	mov	esi, DWORD PTR [ebp+400]
$LL288@transactio:
	test	ebx, ebx
	jne	$LN1095@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN311@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN302@transactio
	call	__invalid_parameter_noinfo
$LN302@transactio:
	mov	ebx, DWORD PTR [ebp+416]
	cmp	DWORD PTR [ebp+412], ebx
	jbe	SHORT $LN319@transactio
	call	__invalid_parameter_noinfo
$LN319@transactio:
	mov	eax, DWORD PTR [ebp+400]
	test	esi, esi
	je	SHORT $LN332@transactio
	cmp	esi, eax
	je	SHORT $LN333@transactio
$LN332@transactio:
	call	__invalid_parameter_noinfo
$LN333@transactio:
	cmp	edi, ebx
	je	$LN1056@transactio

; 1163 : 			{
; 1164 : #ifndef NDEBUG
; 1165 : 				bool result =
; 1166 : #endif // NDEBUG
; 1167 : 					currentBank->push(refreshCommand);

	test	esi, esi
	jne	SHORT $LN1094@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN353@transactio:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN344@transactio
	call	__invalid_parameter_noinfo
$LN344@transactio:
	mov	edx, DWORD PTR $T686811[esp+132]
	push	edx
	lea	eax, DWORD PTR [edi+12]
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	test	esi, esi
	jne	SHORT $LN1093@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN295@transactio:

; 1161 : 
; 1162 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN286@transactio
	call	__invalid_parameter_noinfo
$LN286@transactio:
	mov	ebx, DWORD PTR __Tmp$687011[esp+132]
	mov	ebp, DWORD PTR tv4803[esp+132]
	add	edi, 168				; 000000a8H
	jmp	$LL288@transactio
$LN1096@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN263@transactio
$LN1095@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN311@transactio
$LN1094@transactio:

; 1163 : 			{
; 1164 : #ifndef NDEBUG
; 1165 : 				bool result =
; 1166 : #endif // NDEBUG
; 1167 : 					currentBank->push(refreshCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN353@transactio
$LN1093@transactio:

; 1161 : 
; 1162 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN295@transactio
$LN58@transactio:

; 1168 : 				assert(result);
; 1169 : 				assert(currentBank->back() == refreshCommand);
; 1170 : 			}
; 1171 : 		}
; 1172 : 		// need at least one free command slot
; 1173 : 		// or three commands if the CAS+Precharge command is not available
; 1174 : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 1175 : 			destinationBank->aggressiveInsert(incomingTransaction,time))

	mov	ebp, DWORD PTR _this$[esp+128]
	mov	ebx, edx
	cmp	ecx, 4
	jne	SHORT $LN49@transactio
	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+8]
	push	eax
	push	ecx
	push	ebx
	lea	esi, DWORD PTR _destinationBank$[esp+144]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	eax
	call	?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ; DRAMsimII::Bank::aggressiveInsert
	test	al, al

; 1176 : 		{
; 1177 : 			statistics.reportRowBufferAccess(incomingTransaction,true);
; 1178 : 			//statistics.reportHit();
; 1179 : 		}
; 1180 : 		// every transaction translates into at least two commands
; 1181 : 		// or three commands if the CAS+Precharge command is not available
; 1182 : 		else if ((destinationBank->freeCommandSlots() < 2) ||

	jne	$LN1111@transactio
$LN49@transactio:

; 1183 : 			(!systemConfig.isAutoPrecharge() && (destinationBank->freeCommandSlots() < 3)))

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	edx, DWORD PTR [eax+40]
	sub	edx, DWORD PTR [eax+36]
	sar	edx, 2
	sub	edx, DWORD PTR [eax+12]
	cmp	edx, 2
	jb	$LN1110@transactio
	mov	eax, DWORD PTR [ebp+176]
	cmp	BYTE PTR [eax+346], 0
	jne	SHORT $LN47@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 3
	jb	$LN1110@transactio
$LN47@transactio:

; 1184 : 		{
; 1185 : 			return false;
; 1186 : 		}
; 1187 : 		// then it can be piggybacked on an existing R, C, P or R, C+P chain
; 1188 : 		// also make sure not to starve		
; 1189 : 		// R C1 P => R C1 C2 P
; 1190 : 		// R C1+P => R C1 C2+P
; 1191 : 		// TODO: look for the last non-refresh command in the per-bank queue
; 1192 : 		else
; 1193 : 		{
; 1194 : 			// didn't find place to issue command
; 1195 : 			//statistics.reportMiss();
; 1196 : 			statistics.reportRowBufferAccess(incomingTransaction,false);

	mov	ecx, DWORD PTR [ebp+180]
	push	0
	mov	eax, ebx
	call	?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z ; DRAMsimII::Statistics::reportRowBufferAccess

; 1197 : 
; 1198 : 			// command one, the RAS command to activate the row
; 1199 : #ifndef NDEBUG
; 1200 : 			bool result =
; 1201 : #endif
; 1202 : 				destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::ACTIVATE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686818[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 1
	test	eax, eax
	je	SHORT $LN67@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	0
	push	edx
	push	ecx
	push	eax
	xor	edx, edx
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN68@transactio
$LN67@transactio:
	xor	edi, edi
$LN68@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1203 : 			assert(result);
; 1204 : 			assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1205 : 
; 1206 : 			// command two, CAS or CAS+Precharge			
; 1207 : #ifndef NDEBUG
; 1208 : 			result =
; 1209 : #endif
; 1210 : 				destinationBank->push(new Command(incomingTransaction, time, systemConfig.isAutoPrecharge(), timingSpecification.tBurst()));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686822[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 2
	test	eax, eax
	je	SHORT $LN69@transactio
	mov	edx, DWORD PTR [ebp+176]
	mov	dl, BYTE PTR [edx+346]
	mov	ecx, DWORD PTR [ebp+32]
	push	ecx
	mov	BYTE PTR $T687907[esp+136], dl
	mov	ecx, DWORD PTR $T687907[esp+136]
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	edx
	push	ecx
	push	eax
	mov	edx, 1
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN70@transactio
$LN69@transactio:
	xor	edi, edi
$LN70@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1211 : 			assert(result);
; 1212 : 			assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1213 : 
; 1214 : 			// possible command three, Precharge
; 1215 : 			if (!systemConfig.isAutoPrecharge())

	mov	edx, DWORD PTR [ebp+176]
	cmp	BYTE PTR [edx+346], 0
	jne	$LN1056@transactio

; 1216 : 			{				
; 1217 : #ifndef NDEBUG
; 1218 : 				result =
; 1219 : #endif
; 1220 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686826[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 3
	test	eax, eax
	je	$LN81@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	mov	edx, 6
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	$LN82@transactio
$LN43@transactio:

; 1221 : 				assert(result);
; 1222 : 				assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1223 : 			}
; 1224 : 		}
; 1225 : 		break;
; 1226 : 
; 1227 : 		// open page systems may, in the best case, add a CAS command to an already open row
; 1228 : 		// closing the row and precharging may be pushed back one slot
; 1229 : 	case OPEN_PAGE_AGGRESSIVE:
; 1230 : 		// look to see if this queue or queues are getting too full and collapse CAS(W), Pre into
; 1231 : 		// CAS+P commands to relieve congestion
; 1232 : 		if (incomingTransaction->isRefresh())

	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [eax+80], 4
	jne	$LN42@transactio

; 1233 : 		{
; 1234 : 			vector<Bank>::iterator bankEnd = destinationRank->bank.end();

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR _bankEnd$222944[esp+132]
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end

; 1235 : 			// evaluate every per bank queue in this rank and collapse
; 1236 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 400				; 00000190H
	lea	esi, DWORD PTR _i$222950[esp+132]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	edi, DWORD PTR _i$222950[esp+132]
	mov	ebx, DWORD PTR _i$222950[esp+136]
$LL404@transactio:
	test	edi, edi
	je	SHORT $LN416@transactio
	cmp	edi, DWORD PTR _bankEnd$222944[esp+132]
	je	SHORT $LN417@transactio
$LN416@transactio:
	call	__invalid_parameter_noinfo
$LN417@transactio:
	cmp	ebx, DWORD PTR _bankEnd$222944[esp+136]
	je	$LN36@transactio

; 1237 : 			{
; 1238 : 				if (i->isHighUtilization())

	test	edi, edi
	jne	SHORT $LN1092@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN437@transactio:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN428@transactio
	call	__invalid_parameter_noinfo
$LN428@transactio:
	mov	ecx, DWORD PTR [ebx+40]
	sub	ecx, DWORD PTR [ebx+36]
	sar	ecx, 2
	shr	ecx, 1
	cmp	DWORD PTR [ebx+12], ecx
	jbe	SHORT $LN40@transactio

; 1239 : 				{
; 1240 : 					i->collapse();

	lea	esi, DWORD PTR _i$222950[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	call	?collapse@Bank@DRAMsimII@@QAEXXZ	; DRAMsimII::Bank::collapse
$LN40@transactio:

; 1235 : 			// evaluate every per bank queue in this rank and collapse
; 1236 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	edi, edi
	jne	SHORT $LN1091@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN411@transactio:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN402@transactio
	call	__invalid_parameter_noinfo
$LN402@transactio:
	add	ebx, 168				; 000000a8H
	mov	DWORD PTR _i$222950[esp+136], ebx
	jmp	SHORT $LL404@transactio
$LN1092@transactio:

; 1237 : 			{
; 1238 : 				if (i->isHighUtilization())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN437@transactio
$LN1091@transactio:

; 1235 : 			// evaluate every per bank queue in this rank and collapse
; 1236 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN411@transactio
$LN42@transactio:

; 1241 : 				}
; 1242 : 			}
; 1243 : 		}
; 1244 : 		else
; 1245 : 		{
; 1246 : 			if (destinationBank->isHighUtilization())

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	edx, DWORD PTR [eax+40]
	sub	edx, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [eax+12]
	sar	edx, 2
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN36@transactio

; 1247 : 			{
; 1248 : 				destinationBank->collapse();

	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	call	?collapse@Bank@DRAMsimII@@QAEXXZ	; DRAMsimII::Bank::collapse
$LN36@transactio:

; 1249 : 			}
; 1250 : 		}
; 1251 : 
; 1252 : 		// lack of break it intentional
; 1253 : 	case OPEN_PAGE:
; 1254 : 
; 1255 : 		// refresh transactions become only one command and are handled differently
; 1256 : 		if (incomingTransaction->isRefresh())

	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [ebx+80], 4
	jne	$LN34@transactio

; 1257 : 		{
; 1258 : 			// make sure that there is room in all the queues for one command
; 1259 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1260 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1261 : 			// are available
; 1262 : 			vector<Bank>::const_iterator bankEnd = destinationRank->bank.end();

	mov	esi, DWORD PTR __Tmp$687011[esp+132]
	test	esi, esi
	jne	$LN1090@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN471@transactio:
	mov	edi, DWORD PTR tv4803[esp+132]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN462@transactio
	call	__invalid_parameter_noinfo
$LN462@transactio:
	mov	eax, DWORD PTR [edi+416]
	mov	DWORD PTR $T688237[esp+132], eax
	cmp	DWORD PTR [edi+412], eax
	jbe	SHORT $LN479@transactio
	call	__invalid_parameter_noinfo
$LN479@transactio:
	mov	ebp, DWORD PTR [edi+400]
	mov	DWORD PTR $T686830[esp+132], ebp

; 1263 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	esi, esi
	jne	$LN1089@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN503@transactio:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN494@transactio
	call	__invalid_parameter_noinfo
$LN494@transactio:
	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN511@transactio
	call	__invalid_parameter_noinfo
$LN511@transactio:
	mov	eax, edi
	mov	edi, DWORD PTR [eax+400]
	lea	ebx, DWORD PTR [esi+36]
	npad	5
$LL526@transactio:
	test	edi, edi
	je	SHORT $LN538@transactio
	cmp	edi, ebp
	je	SHORT $LN539@transactio
$LN538@transactio:
	call	__invalid_parameter_noinfo
$LN539@transactio:
	cmp	esi, DWORD PTR $T688237[esp+132]
	je	$LN31@transactio

; 1264 : 			{
; 1265 : 				if (i->back())

	test	edi, edi
	jne	$LN1088@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN557@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN548@transactio
	call	__invalid_parameter_noinfo
$LN548@transactio:
	mov	eax, DWORD PTR [ebx-24]
	test	eax, eax
	je	SHORT $LN568@transactio
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx-20]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	cmp	edx, ecx
	jb	SHORT $LN568@transactio
	call	__invalid_parameter_noinfo
$LN568@transactio:

; 1266 : 					assert(i->back()->isRefresh() || i->back()->isReadOrWrite());
; 1267 : 
; 1268 : 				// either cannot fit a single REF command or cannot fit Pre + REF
; 1269 : 				if (i->isFull() ||
; 1270 : 					(i->freeCommandSlots() < 2 && !i->back()->isPrecharge()))

	test	edi, edi
	jne	$LN1087@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN584@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN575@transactio
	call	__invalid_parameter_noinfo
$LN575@transactio:
	mov	eax, DWORD PTR [ebx+4]
	sub	eax, DWORD PTR [ebx]
	sar	eax, 2
	cmp	eax, DWORD PTR [ebx-24]
	je	$LN1110@transactio
	test	edi, edi
	jne	$LN1086@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN604@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN595@transactio
	call	__invalid_parameter_noinfo
$LN595@transactio:
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	sar	ecx, 2
	sub	ecx, DWORD PTR [ebx-24]
	cmp	ecx, 2
	jae	SHORT $LN32@transactio
	test	edi, edi
	jne	SHORT $LN1085@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN624@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN615@transactio
	call	__invalid_parameter_noinfo
$LN615@transactio:
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 2
	je	SHORT $LN32@transactio
	cmp	eax, 4
	je	SHORT $LN32@transactio
	cmp	eax, 6
	jne	$LN1110@transactio
$LN32@transactio:

; 1263 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	edi, edi
	jne	SHORT $LN1084@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN533@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN524@transactio
	call	__invalid_parameter_noinfo
$LN524@transactio:
	add	esi, 168				; 000000a8H
	add	ebx, 168				; 000000a8H
	jmp	$LL526@transactio
$LN1090@transactio:

; 1257 : 		{
; 1258 : 			// make sure that there is room in all the queues for one command
; 1259 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1260 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1261 : 			// are available
; 1262 : 			vector<Bank>::const_iterator bankEnd = destinationRank->bank.end();

	mov	eax, DWORD PTR [esi]
	jmp	$LN471@transactio
$LN1089@transactio:

; 1263 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [esi]
	jmp	$LN503@transactio
$LN1088@transactio:

; 1264 : 			{
; 1265 : 				if (i->back())

	mov	eax, DWORD PTR [edi]
	jmp	$LN557@transactio
$LN1087@transactio:

; 1266 : 					assert(i->back()->isRefresh() || i->back()->isReadOrWrite());
; 1267 : 
; 1268 : 				// either cannot fit a single REF command or cannot fit Pre + REF
; 1269 : 				if (i->isFull() ||
; 1270 : 					(i->freeCommandSlots() < 2 && !i->back()->isPrecharge()))

	mov	eax, DWORD PTR [edi]
	jmp	$LN584@transactio
$LN1086@transactio:
	mov	eax, DWORD PTR [edi]
	jmp	$LN604@transactio
$LN1085@transactio:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN624@transactio
$LN1084@transactio:

; 1263 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN533@transactio
$LN31@transactio:

; 1271 : 					return false;
; 1272 : 			}
; 1273 : 			// then add the command to all queues
; 1274 : 			Command *refreshCommand = new Command(incomingTransaction, time, false, timingSpecification.tBurst());

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686834[esp+132], eax
	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+140], 4
	cmp	eax, esi
	je	SHORT $LN73@transactio
	mov	edx, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edx+32]
	push	ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [edx+8]
	push	esi
	push	ecx
	push	edx
	push	eax
	lea	edx, DWORD PTR [esi+1]
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	DWORD PTR $T686833[esp+132], eax
	jmp	SHORT $LN74@transactio
$LN73@transactio:
	mov	DWORD PTR $T686833[esp+132], esi
$LN74@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1

; 1275 : 
; 1276 : 			Address tempAddr(incomingTransaction->getAddress());

	movq	xmm0, QWORD PTR [ebx+40]

; 1277 : 			unsigned bankNumber = 0;
; 1278 : 
; 1279 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR __Tmp$687011[esp+132]
	movq	QWORD PTR _tempAddr$222986[esp+132], xmm0
	movq	xmm0, QWORD PTR [ebx+48]
	movq	QWORD PTR _tempAddr$222986[esp+140], xmm0
	movq	xmm0, QWORD PTR [ebx+56]
	movq	QWORD PTR _tempAddr$222986[esp+148], xmm0
	movq	xmm0, QWORD PTR [ebx+64]
	movq	QWORD PTR _tempAddr$222986[esp+156], xmm0
	movq	xmm0, QWORD PTR [ebx+72]
	movq	QWORD PTR _tempAddr$222986[esp+164], xmm0
	mov	DWORD PTR _bankNumber$222987[esp+132], esi
	cmp	eax, esi
	jne	$LN1083@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN650@transactio:
	mov	edi, DWORD PTR tv4803[esp+132]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN641@transactio
	call	__invalid_parameter_noinfo
$LN641@transactio:
	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN658@transactio
	call	__invalid_parameter_noinfo
$LN658@transactio:
	mov	ebp, DWORD PTR [edi+400]
	lea	edi, DWORD PTR [esi+36]
$LL675@transactio:
	test	ebp, ebp
	je	SHORT $LN687@transactio
	cmp	ebp, DWORD PTR $T686830[esp+132]
	je	SHORT $LN688@transactio
$LN687@transactio:
	call	__invalid_parameter_noinfo
$LN688@transactio:
	lea	esi, DWORD PTR [edi-36]
	cmp	esi, DWORD PTR $T688237[esp+132]
	je	$LN25@transactio

; 1280 : 			{
; 1281 : 				// can only refresh banks that are in the precharged state
; 1282 : 				if (i->back() && i->back()->isReadOrWrite())

	test	ebp, ebp
	jne	$LN1082@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN708@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN699@transactio
	call	__invalid_parameter_noinfo
$LN699@transactio:
	mov	eax, DWORD PTR [edi-24]
	lea	ebx, DWORD PTR [edi-24]
	test	eax, eax
	je	$LN24@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN719@transactio
	call	__invalid_parameter_noinfo
$LN719@transactio:
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+esi*4], 0
	je	$LN24@transactio
	test	ebp, ebp
	jne	SHORT $LN1081@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN737@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN728@transactio
	call	__invalid_parameter_noinfo
$LN728@transactio:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN744@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN748@transactio
	call	__invalid_parameter_noinfo
$LN748@transactio:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN745@transactio
$LN1083@transactio:

; 1277 : 			unsigned bankNumber = 0;
; 1278 : 
; 1279 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN650@transactio
$LN1082@transactio:

; 1280 : 			{
; 1281 : 				// can only refresh banks that are in the precharged state
; 1282 : 				if (i->back() && i->back()->isReadOrWrite())

	mov	eax, DWORD PTR [ebp]
	jmp	$LN708@transactio
$LN1081@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN737@transactio
$LN744@transactio:
	xor	esi, esi
$LN745@transactio:
	mov	eax, DWORD PTR [esi+80]
	cmp	eax, 1
	je	SHORT $LN755@transactio
	cmp	eax, 2
	je	SHORT $LN755@transactio
	cmp	eax, 3
	je	SHORT $LN755@transactio
	cmp	eax, 4
	jne	SHORT $LN24@transactio
$LN755@transactio:

; 1283 : 				{
; 1284 : 					i->back()->setAutoPrecharge(true);

	test	ebp, ebp
	jne	SHORT $LN1080@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN778@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN769@transactio
	call	__invalid_parameter_noinfo
$LN769@transactio:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN785@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN789@transactio
	call	__invalid_parameter_noinfo
$LN789@transactio:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN786@transactio
$LN1080@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN778@transactio
$LN785@transactio:
	xor	eax, eax
$LN786@transactio:
	mov	ecx, DWORD PTR [eax+80]
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, 3
	ja	$LN869@transactio
	jmp	DWORD PTR $LN1113@transactio[edx*4]
$LN796@transactio:
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [eax+80], edx
	jmp	$LN869@transactio
$LN24@transactio:

; 1285 : 				}
; 1286 : 				// add a Pre command before the REF to flush written data back to the banks before executing a refresh
; 1287 : 				else if (i->isEmpty() && i->isActivated())

	test	ebp, ebp
	jne	$LN1079@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN816@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN807@transactio
	call	__invalid_parameter_noinfo
$LN807@transactio:
	cmp	DWORD PTR [ebx], 0
	jne	$LN22@transactio
	test	ebp, ebp
	jne	SHORT $LN1078@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN836@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN827@transactio
	call	__invalid_parameter_noinfo
$LN827@transactio:
	cmp	BYTE PTR [edi+96], 0
	je	$LN22@transactio

; 1288 : 				{
; 1289 : 					// then need to precharge before
; 1290 : 					tempAddr.setBank(bankNumber);

	mov	eax, DWORD PTR _bankNumber$222987[esp+132]
	mov	DWORD PTR _tempAddr$222986[esp+156], eax

; 1291 : 
; 1292 : 					assert(i->freeCommandSlots() >= 2);
; 1293 : #ifndef NDEBUG
; 1294 : 					bool result =
; 1295 : #endif // NDEBUG
; 1296 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686839[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 5
	test	eax, eax
	je	SHORT $LN75@transactio
	mov	edx, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edx+32]
	push	ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [edx+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _tempAddr$222986[esp+148]
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	esi, eax
	jmp	SHORT $LN76@transactio
$LN1079@transactio:

; 1285 : 				}
; 1286 : 				// add a Pre command before the REF to flush written data back to the banks before executing a refresh
; 1287 : 				else if (i->isEmpty() && i->isActivated())

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN816@transactio
$LN1078@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN836@transactio
$LN75@transactio:

; 1291 : 
; 1292 : 					assert(i->freeCommandSlots() >= 2);
; 1293 : #ifndef NDEBUG
; 1294 : 					bool result =
; 1295 : #endif // NDEBUG
; 1296 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	xor	esi, esi
$LN76@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1
	test	ebp, ebp
	jne	SHORT $LN1077@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN860@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN851@transactio
	call	__invalid_parameter_noinfo
$LN851@transactio:
	push	esi
	mov	eax, ebx
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1297 : 					assert(result);
; 1298 : 					assert(&(rank[tempAddr.getRank()].bank[bankNumber]) == &*i);
; 1299 : 				}
; 1300 : 				else

	jmp	SHORT $LN869@transactio
$LN1077@transactio:

; 1291 : 
; 1292 : 					assert(i->freeCommandSlots() >= 2);
; 1293 : #ifndef NDEBUG
; 1294 : 					bool result =
; 1295 : #endif // NDEBUG
; 1296 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN860@transactio
$LN22@transactio:

; 1301 : 				{
; 1302 : 					if (i->isEmpty())

	test	ebp, ebp
	jne	SHORT $LN1076@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN878@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN869@transactio
	call	__invalid_parameter_noinfo
$LN869@transactio:

; 1303 : 						assert(!i->isActivated());
; 1304 : 					else 
; 1305 : 						assert(i->back()->isRefresh());
; 1306 : 				}
; 1307 : 				
; 1308 : #ifndef NDEBUG
; 1309 : 				bool result =
; 1310 : #endif // NDEBUG
; 1311 : 					i->push(refreshCommand);

	test	ebp, ebp
	jne	SHORT $LN1075@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN898@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN889@transactio
	call	__invalid_parameter_noinfo
$LN889@transactio:
	mov	eax, DWORD PTR $T686833[esp+132]
	push	eax
	mov	eax, ebx
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1312 : 				assert (result);
; 1313 : 				bankNumber++;

	inc	DWORD PTR _bankNumber$222987[esp+132]
	test	ebp, ebp
	jne	SHORT $LN1074@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN682@transactio:
	lea	ecx, DWORD PTR [edi-36]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN673@transactio

; 1277 : 			unsigned bankNumber = 0;
; 1278 : 
; 1279 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	call	__invalid_parameter_noinfo
$LN673@transactio:
	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	add	edi, 168				; 000000a8H
	jmp	$LL675@transactio
$LN1076@transactio:

; 1301 : 				{
; 1302 : 					if (i->isEmpty())

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN878@transactio
$LN1075@transactio:

; 1303 : 						assert(!i->isActivated());
; 1304 : 					else 
; 1305 : 						assert(i->back()->isRefresh());
; 1306 : 				}
; 1307 : 				
; 1308 : #ifndef NDEBUG
; 1309 : 				bool result =
; 1310 : #endif // NDEBUG
; 1311 : 					i->push(refreshCommand);

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN898@transactio
$LN1074@transactio:

; 1277 : 			unsigned bankNumber = 0;
; 1278 : 
; 1279 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN682@transactio
$LN25@transactio:

; 1314 : 			}
; 1315 : 
; 1316 : 			for (vector<Bank>::const_iterator i = rank[incomingTransaction->getAddress().getRank()].bank.begin(); 

	mov	edi, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edi+416]
	sub	ecx, DWORD PTR [edi+412]
	mov	esi, DWORD PTR [ebx+60]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN907@transactio
	call	__invalid_parameter_noinfo
$LN907@transactio:
	mov	edx, DWORD PTR [edi+412]
	imul	esi, 424				; 000001a8H
	mov	edi, DWORD PTR [esi+edx+412]
	cmp	edi, DWORD PTR [esi+edx+416]
	lea	esi, DWORD PTR [esi+edx+400]
	jbe	SHORT $LN917@transactio
	call	__invalid_parameter_noinfo
$LN917@transactio:
	mov	ebx, DWORD PTR [esi]
	mov	ebp, edi

; 1317 : 				i != rank[incomingTransaction->getAddress().getRank()].bank.end(); i++)

$LL932@transactio:
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	esi, DWORD PTR [eax+60]
	mov	eax, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [eax+416]
	sub	ecx, DWORD PTR [eax+412]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN946@transactio
	call	__invalid_parameter_noinfo
$LN946@transactio:
	mov	edx, DWORD PTR _this$[esp+128]
	imul	esi, 424				; 000001a8H
	mov	eax, DWORD PTR [edx+412]
	mov	edi, DWORD PTR [esi+eax+416]
	cmp	DWORD PTR [esi+eax+412], edi
	lea	esi, DWORD PTR [esi+eax+400]
	jbe	SHORT $LN956@transactio
	call	__invalid_parameter_noinfo
$LN956@transactio:
	mov	esi, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN969@transactio
	cmp	ebx, esi
	je	SHORT $LN970@transactio
$LN969@transactio:
	call	__invalid_parameter_noinfo
$LN970@transactio:
	cmp	ebp, edi
	je	$LN16@transactio
	test	ebx, ebx
	jne	SHORT $LN1073@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN939@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN930@transactio
	call	__invalid_parameter_noinfo
$LN930@transactio:
	add	ebp, 168				; 000000a8H
	jmp	$LL932@transactio
$LN1073@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN939@transactio
$LN34@transactio:

; 1318 : 			{
; 1319 : 				assert(i->back() == refreshCommand);
; 1320 : 			}
; 1321 : 
; 1322 : 			return true;
; 1323 : 		}
; 1324 : 		else if (!destinationBank->isFull())

	mov	eax, DWORD PTR __Tmp$687263[esp+132]
	test	eax, eax
	jne	SHORT $LN1072@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN990@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN981@transactio
	call	__invalid_parameter_noinfo
$LN981@transactio:
	mov	ecx, DWORD PTR [ebp+40]
	sub	ecx, DWORD PTR [ebp+36]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp+12]
	je	$LN1110@transactio

; 1325 : 		{	
; 1326 : 			// try to do a normal open page insert on this transaction
; 1327 : 			if (destinationBank->aggressiveInsert(incomingTransaction, time))

	mov	ebp, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+8]
	push	edx
	push	eax
	push	ebx
	lea	esi, DWORD PTR _destinationBank$[esp+144]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	eax
	call	?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ; DRAMsimII::Bank::aggressiveInsert
	test	al, al
	je	SHORT $LN13@transactio
$LN1111@transactio:

; 1328 : 			{
; 1329 : 				// found place to insert, hit
; 1330 : 				//statistics.reportHit();
; 1331 : 				statistics.reportRowBufferAccess(incomingTransaction,true);

	mov	ecx, DWORD PTR [ebp+180]
	push	1
	mov	eax, ebx
	call	?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z ; DRAMsimII::Statistics::reportRowBufferAccess

; 1332 : 			}
; 1333 : 			else

	jmp	$LN1056@transactio
$LN1072@transactio:

; 1318 : 			{
; 1319 : 				assert(i->back() == refreshCommand);
; 1320 : 			}
; 1321 : 
; 1322 : 			return true;
; 1323 : 		}
; 1324 : 		else if (!destinationBank->isFull())

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN990@transactio
$LN13@transactio:

; 1334 : 			{
; 1335 : 				// first, the precharge command, if necessary
; 1336 : 				if (((destinationBank->isEmpty() && destinationBank->isActivated()) || 
; 1337 : 					(!destinationBank->isEmpty() && !destinationBank->back()->isRefresh())))

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	BYTE PTR [eax+132], 0
	jne	SHORT $LN10@transactio
$LN9@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+12], 0
	je	$LN11@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	je	$LN11@transactio
$LN10@transactio:

; 1338 : 				{
; 1339 : 					assert(!destinationBank->back() || !destinationBank->back()->isPrecharge());
; 1340 : 
; 1341 : 					if (destinationBank->freeCommandSlots() < 3) 

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 3
	jae	SHORT $LN8@transactio

; 1342 : 					{
; 1343 : 						// for aggressive mode, set CAS(W) to CAS(W)+P when there are only two slots left
; 1344 : 						if (systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE &&
; 1345 : 							destinationBank->freeCommandSlots() == 2 && 
; 1346 : 							destinationBank->back()->isReadOrWrite())

	mov	edx, DWORD PTR [ebp+176]
	mov	eax, DWORD PTR [edx+328]
	cmp	eax, 2
	jne	$LN1110@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, DWORD PTR [eax+36]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 2
	jne	$LN1110@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	je	$LN1110@transactio

; 1347 : 						{
; 1348 : 							assert(!destinationBank->back()->isPrecharge());
; 1349 : 							assert(destinationBank->back()->isReadOrWrite());
; 1350 : 							destinationBank->back()->setAutoPrecharge(true);

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	mov	ecx, DWORD PTR [eax+80]
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, 3
	ja	$LN3@transactio
	jmp	DWORD PTR $LN1114@transactio[edx*4]
$LN1027@transactio:
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [eax+80], edx

; 1351 : 						}
; 1352 : 						// not enough slots left
; 1353 : 						else
; 1354 : 						{
; 1355 : 							return false;
; 1356 : 						}
; 1357 : 					}
; 1358 : 					else

	jmp	SHORT $LN3@transactio
$LN8@transactio:

; 1359 : 					{
; 1360 : 						assert(!destinationBank->back() || !destinationBank->back()->isRefresh());
; 1361 : 						assert(!destinationBank->isFull());
; 1362 : #ifndef NDEBUG
; 1363 : 						bool result =
; 1364 : #endif // NDEBUG
; 1365 : 							destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686846[esp+132], eax
	mov	edx, 6
	mov	DWORD PTR __$EHRec$[esp+140], edx
	test	eax, eax
	je	SHORT $LN77@transactio
	mov	ecx, DWORD PTR [ebp+32]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN78@transactio
$LN77@transactio:
	xor	edi, edi
$LN78@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1366 : 						assert(result);
; 1367 : 					}

	jmp	SHORT $LN3@transactio
$LN11@transactio:

; 1368 : 				}
; 1369 : 				else if (destinationBank->freeCommandSlots() < 2)

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	edx, DWORD PTR [eax+40]
	sub	edx, DWORD PTR [eax+36]
	sar	edx, 2
	sub	edx, DWORD PTR [eax+12]
	cmp	edx, 2

; 1370 : 				{
; 1371 : 					return false;

	jb	$LN1110@transactio
$LN3@transactio:

; 1372 : 				}
; 1373 : 
; 1374 : 				// did not find place to insert
; 1375 : 				//statistics.reportMiss();
; 1376 : 				statistics.reportRowBufferAccess(incomingTransaction,false);

	mov	ecx, DWORD PTR [ebp+180]
	push	0
	mov	eax, ebx
	call	?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z ; DRAMsimII::Statistics::reportRowBufferAccess

; 1377 : 
; 1378 : 				// RAS command
; 1379 : 				assert(!destinationBank->isFull());
; 1380 : #ifndef NDEBUG
; 1381 : 				bool result =
; 1382 : #endif // NDEBUG
; 1383 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::ACTIVATE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686850[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 7
	test	eax, eax
	je	SHORT $LN79@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	xor	edx, edx
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN80@transactio
$LN79@transactio:
	xor	edi, edi
$LN80@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1384 : 				assert(result);
; 1385 : 
; 1386 : 				// CAS/CASW command
; 1387 : 				assert(!destinationBank->isFull());
; 1388 : #ifndef NDEBUG
; 1389 : 				result =
; 1390 : #endif // NDEBUG
; 1391 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst()));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T686854[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 8
	test	eax, eax
	je	SHORT $LN81@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	mov	edx, 1
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN82@transactio
$LN81@transactio:
	xor	edi, edi
$LN82@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 12					; 0000000cH
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
$LN1056@transactio:

; 1406 : 
; 1407 : 	}
; 1408 : 
; 1409 : 	incomingTransaction->setDecodeTime(time);

	mov	ecx, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	DWORD PTR [eax+88], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+92], ecx
$LN16@transactio:

; 1410 : 
; 1411 : 	return true;

	mov	al, 1
	jmp	SHORT $LN63@transactio
$LN1@transactio:

; 1392 : 				assert(result);
; 1393 : 			}
; 1394 : 		}
; 1395 : 		else
; 1396 : 		{
; 1397 : 			return false;
; 1398 : 		}
; 1399 : 
; 1400 : 		break;
; 1401 : 
; 1402 : 	default:
; 1403 : 
; 1404 : 		cerr << "Unhandled row buffer management policy" << endl;

	push	OFFSET ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1110@transactio:

; 1405 : 		return false;

	xor	al, al
$LN63@transactio:

; 1412 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 112				; 00000070H
	ret	8
	npad	2
$LN1112@transactio:
	DD	$LN36@transactio
	DD	$LN43@transactio
	DD	$LN59@transactio
	DD	$LN59@transactio
$LN1113@transactio:
	DD	$LN796@transactio
	DD	$LN869@transactio
	DD	$LN796@transactio
	DD	$LN869@transactio
$LN1114@transactio:
	DD	$LN1027@transactio
	DD	$LN3@transactio
	DD	$LN1027@transactio
	DD	$LN3@transactio
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$0:
	mov	esi, DWORD PTR $T686812[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$1:
	mov	esi, DWORD PTR $T686818[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$2:
	mov	esi, DWORD PTR $T686822[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$3:
	mov	esi, DWORD PTR $T686826[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$4:
	mov	esi, DWORD PTR $T686834[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$5:
	mov	esi, DWORD PTR $T686839[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$6:
	mov	esi, DWORD PTR $T686846[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$7:
	mov	esi, DWORD PTR $T686850[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$8:
	mov	esi, DWORD PTR $T686854[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-116]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	jmp	___CxxFrameHandler3
?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Channel::transaction2commands
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_currentTime$ = 8					; size = 8
?moveToTime@Channel@DRAMsimII@@UAEX_J@Z PROC		; DRAMsimII::Channel::moveToTime
; _this$ = ecx

; 184  : {	

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 185  : 	assert(finishedTransactions.size() == 0);
; 186  : 
; 187  : 	/// @todo continue until no events are processed, no commands issued, no transactions decoded
; 188  : 	while (time < currentTime)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _currentTime$[ebp+4]
	push	edi
	jg	$LN191@moveToTime@2
	jl	SHORT $LL6@moveToTime@2
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _currentTime$[ebp]
	jae	$LN191@moveToTime@2
$LL6@moveToTime@2:

; 189  : 	{	
; 190  : 		// move time to either when the next command executes or the next transaction decodes, whichever is earlier
; 191  : 		// otherwise just go to the end
; 192  : #ifndef NDEBUG
; 193  : 		tick oldTime = time;
; 194  : #endif
; 195  : 		/// @todo verify that this is right
; 196  : 		//time = max(min(currentTime,min(nextTransactionDecodeTime(),min(nextCommandExecuteTime(),nextRefreshTime()))),time);
; 197  : 		time = max(min(currentTime,min(nextTransactionDecodeTime(),nextCommandExecuteTime())),time);

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN23@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN24@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN27@moveToTime@2
$LN24@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN27@moveToTime@2
$LN23@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN27@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN38@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN37@moveToTime@2
$LN38@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN37@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN9@moveToTime@2
	jl	SHORT $LN183@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN9@moveToTime@2
$LN183@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN56@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN42@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN55@moveToTime@2
$LN42@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN55@moveToTime@2
$LN9@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN56@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN55@moveToTime@2
$LN56@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN55@moveToTime@2:
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	cmp	ecx, edx
	jg	SHORT $LN13@moveToTime@2
	jl	SHORT $LN184@moveToTime@2
	cmp	DWORD PTR _currentTime$[ebp], eax
	jae	SHORT $LN13@moveToTime@2
$LN184@moveToTime@2:
	mov	eax, DWORD PTR _currentTime$[ebp]
	mov	edx, ecx
	jmp	$LN91@moveToTime@2
$LN13@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN59@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN60@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN63@moveToTime@2
$LN60@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN63@moveToTime@2
$LN59@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN63@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN74@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN73@moveToTime@2
$LN74@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN73@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN11@moveToTime@2
	jl	SHORT $LN185@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN11@moveToTime@2
$LN185@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN92@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN78@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN91@moveToTime@2
$LN78@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN91@moveToTime@2
$LN11@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN92@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN91@moveToTime@2
$LN92@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN91@moveToTime@2:
	mov	ecx, DWORD PTR [esi+12]
	cmp	edx, ecx
	mov	edi, DWORD PTR [esi+8]
	jl	$LN21@moveToTime@2
	jg	SHORT $LN186@moveToTime@2
	cmp	eax, edi
	jbe	$LN21@moveToTime@2
$LN186@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN95@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN96@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN99@moveToTime@2
$LN96@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN99@moveToTime@2
$LN95@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN99@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN110@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN109@moveToTime@2
$LN110@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN109@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN15@moveToTime@2
	jl	SHORT $LN187@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN15@moveToTime@2
$LN187@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN128@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN114@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN127@moveToTime@2
$LN114@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN127@moveToTime@2
$LN15@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN128@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN127@moveToTime@2
$LN128@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN127@moveToTime@2:
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	cmp	ecx, edx
	jg	SHORT $LN19@moveToTime@2
	jl	SHORT $LN188@moveToTime@2
	cmp	DWORD PTR _currentTime$[ebp], eax
	jae	SHORT $LN19@moveToTime@2
$LN188@moveToTime@2:
	mov	eax, DWORD PTR _currentTime$[ebp]
	jmp	$LN201@moveToTime@2
$LN19@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN131@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN132@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN135@moveToTime@2
$LN132@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN135@moveToTime@2
$LN131@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN135@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN146@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN145@moveToTime@2
$LN146@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN145@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN17@moveToTime@2
	jl	SHORT $LN189@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN17@moveToTime@2
$LN189@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN164@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN150@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN22@moveToTime@2
$LN150@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN22@moveToTime@2
$LN17@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN164@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN22@moveToTime@2
$LN164@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
	jmp	SHORT $LN22@moveToTime@2
$LN21@moveToTime@2:
	mov	eax, edi
$LN201@moveToTime@2:
	mov	edx, ecx
$LN22@moveToTime@2:
	mov	DWORD PTR [esi+8], eax

; 198  : 		assert(time <= currentTime);
; 199  : 		assert(time >= oldTime);
; 200  : 
; 201  : 		// has room to decode an available transaction, as many as are ready
; 202  : 		// 		unsigned decodedCount = 0;
; 203  : 		// 		unsigned decodedRefreshCount = 0;
; 204  : 
; 205  : 		while (Transaction *nextTransaction = getTransaction())

	mov	eax, esi
	mov	DWORD PTR [esi+12], edx
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN3@moveToTime@2
$LL4@moveToTime@2:

; 206  : 		{
; 207  : 			// actually remove it from the queue now
; 208  : 			//Transaction *decodedTransaction = getTransaction();
; 209  : 			assert(nextTransaction);
; 210  : 
; 211  : 			// 			if (nextTransaction->isRefresh())
; 212  : 			// 				decodedRefreshCount++;
; 213  : 			// 			else
; 214  : 			// 				decodedCount++;
; 215  : 			// then break into commands and insert into per bank command queues			
; 216  : 			assert(checkForAvailableCommandSlots(nextTransaction));
; 217  : 
; 218  : #ifndef NDEBUG
; 219  : 			bool t2cResult =
; 220  : #endif
; 221  : 				transaction2commands(nextTransaction);

	push	edi
	push	esi
	call	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands

; 222  : 
; 223  : 
; 224  : 			assert(t2cResult);
; 225  : 
; 226  : 			nextTransaction->setDecodeTime(time);

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+88], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	eax, esi
	mov	DWORD PTR [edi+92], edx
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@moveToTime@2
$LN3@moveToTime@2:

; 227  : 			// checkForAvailablecommandSlots() should not have returned true if there was not enough space
; 228  : 
; 229  : 			DEBUG_TRANSACTION_LOG("T->C [" << std::dec << time << "] Q[" << std::dec << getTransactionQueueCount() << "/" << std::dec << transactionQueue.depth() << "]->[" << std::dec <<
; 230  : 				rank[nextTransaction->getAddress().getRank()].bank[nextTransaction->getAddress().getBank()].size() << "/" << std::dec <<
; 231  : 				rank[nextTransaction->getAddress().getRank()].bank[nextTransaction->getAddress().getBank()].depth() << "] " << *nextTransaction);
; 232  : 
; 233  : 			//nextToDecode = readAvailableTransaction();
; 234  : 			//nextTransaction = readTransaction(true);
; 235  : 		}		
; 236  : #ifndef NDEBUG
; 237  : 		//if (decodedCount > 3 || decodedRefreshCount > 1)
; 238  : 		//cerr << "decoded " << decodedCount << "/" << decodedRefreshCount << endl;
; 239  : #endif
; 240  : 
; 241  : 		// execute commands for this time, reevaluate what the next command is since this may have changed after decoding the transaction
; 242  : 		const Command *nextCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 243  : 
; 244  : 		while (nextCommand && (earliestExecuteTime(nextCommand) <= time))

	test	edi, edi
	je	SHORT $LN1@moveToTime@2
$LL2@moveToTime@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	mov	ecx, esi
	call	edx
	cmp	edx, DWORD PTR [esi+12]
	jg	SHORT $LN1@moveToTime@2
	jl	SHORT $LN190@moveToTime@2
	cmp	eax, DWORD PTR [esi+8]
	ja	SHORT $LN1@moveToTime@2
$LN190@moveToTime@2:

; 245  : 		{
; 246  : 			Command *executingCommand = getNextCommand(nextCommand);

	push	edi
	push	esi
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand

; 247  : 
; 248  : 			assert(executingCommand == nextCommand);
; 249  : 
; 250  : 			assert(earliestExecuteTimeLog(nextCommand) <= time);
; 251  : 
; 252  : 			executeCommand(executingCommand);	

	push	eax
	push	esi
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand

; 253  : 
; 254  : 			DEBUG_COMMAND_LOG("C " << *executingCommand);
; 255  : 
; 256  : #ifndef NDEBUG
; 257  : 			printVerilogCommand(executingCommand);
; 258  : #endif
; 259  : 
; 260  : 			nextCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL2@moveToTime@2
$LN1@moveToTime@2:

; 185  : 	assert(finishedTransactions.size() == 0);
; 186  : 
; 187  : 	/// @todo continue until no events are processed, no commands issued, no transactions decoded
; 188  : 	while (time < currentTime)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _currentTime$[ebp+4]
	jl	$LL6@moveToTime@2
	jg	SHORT $LN191@moveToTime@2
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _currentTime$[ebp]
	jb	$LL6@moveToTime@2
$LN191@moveToTime@2:

; 261  : 		}
; 262  : 	}
; 263  : 
; 264  : 	//transFinishTime = currentTime;
; 265  : 	//M5_TIMING_LOG("ch[" << channelID << "] @ " << dec << time);
; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?moveToTime@Channel@DRAMsimII@@UAEX_J@Z ENDP		; DRAMsimII::Channel::moveToTime
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
_TEXT	SEGMENT
$T691772 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z PROC ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>, COMDAT
; __Val$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+20], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T691772[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@Construct@30
	push	eax
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN3@Construct@30:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T691772[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z ENDP ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	esi, ebx
	je	SHORT $LN1@Copy_opt@10
	npad	1
$LL3@Copy_opt@10:

; 2472 : 		*_Dest = *_First;

	push	esi
	call	??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Rank::operator=
	add	esi, 424				; 000001a8H
	add	edi, 424				; 000001a8H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@10

; 2473 : 	return (_Dest);

	mov	eax, edi
$LN1@Copy_opt@10:

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z$0
__ehfuncinfo$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
_TEXT	SEGMENT
$T691806 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$691807 = 8					; size = 4
__Ptr$ = 8						; size = 4
?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z PROC ; std::allocator<DRAMsimII::Rank>::construct, COMDAT
; __Val$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$691807[esp+20], eax
	mov	DWORD PTR $T691806[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN5@construct@25
	push	eax
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN5@construct@25:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z$0:
	mov	eax, DWORD PTR __Vptr$691807[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T691806[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z ENDP ; std::allocator<DRAMsimII::Rank>::construct
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T691850 = -28						; size = 4
__Vptr$691847 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Count$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_fil@23:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@23

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$691847[ebp], esi
	mov	DWORD PTR $T691850[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@23
	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_fil@23:
	dec	edi
	add	esi, 424				; 000001a8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@23
__catch$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@23
	npad	4
$LL3@Uninit_fil@23:

; 407  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@23
$LN1@Uninit_fil@23:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_fil@23:
$LN4@Uninit_fil@23:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_fil@23:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$691847[ebp]
	push	eax
	mov	ecx, DWORD PTR $T691850[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv148 = 8						; size = 4
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+8]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	ecx, ebp
	sub	ecx, esi
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
	imul	ebx, 424				; 000001a8H
	add	ebx, edi

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ebp
	je	SHORT $LN14@Copy_opt@11
	mov	eax, edi
	sub	eax, esi
	mov	DWORD PTR tv148[esp+16], eax
	jmp	SHORT $LN9@Copy_opt@11
	npad	6
$LL15@Copy_opt@11:
	mov	eax, DWORD PTR tv148[esp+16]
$LN9@Copy_opt@11:
	push	esi
	lea	edi, DWORD PTR [eax+esi]
	call	??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Rank::operator=
	add	esi, 424				; 000001a8H
	cmp	esi, ebp
	jne	SHORT $LL15@Copy_opt@11
$LN14@Copy_opt@11:

; 2486 : 	return _Result;
; 2487 : 	}

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	0
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T691918 = -4						; size = 1
__Cat$691922 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Val$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T691918[esp+4], 0
	mov	eax, DWORD PTR $T691918[esp+4]
	mov	ecx, DWORD PTR __Cat$691922[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z
_TEXT	SEGMENT
$T691927 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$691932 = 12					; size = 1
$T691929 = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	sub	esp, 8

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$691932[esp+4]
	mov	edx, DWORD PTR $T691929[esp+4]
	mov	BYTE PTR $T691927[esp+8], 0
	mov	eax, DWORD PTR $T691927[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 3607 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z
_TEXT	SEGMENT
$T691969 = -4						; size = 1
__Cat$691972 = -4					; size = 1
?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T691969[esp+4], 0
	mov	eax, DWORD PTR $T691969[esp+4]
	mov	ecx, DWORD PTR __Cat$691972[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 424				; 000001a8H
	add	eax, edi

; 1256 : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
$T692165 = -4						; size = 1
__Cat$692169 = 8					; size = 1
$T692167 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ecx
	push	ebx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+4]
	push	ebp
	push	edi
	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@34
	mov	eax, DWORD PTR __First_arg$[esp+16]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@34
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@34
$LN8@erase@34:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+16]
$LN9@erase@34:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+16]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@34
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@34
$LN24@erase@34:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+16]
$LN25@erase@34:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@34
	cmp	eax, ecx
	je	SHORT $LN39@erase@34
$LN38@erase@34:
	call	__invalid_parameter_noinfo
$LN39@erase@34:
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, edi
	je	SHORT $LN80@erase@34

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+16]
	mov	BYTE PTR $T692165[esp+16], 0
	mov	edx, DWORD PTR $T692165[esp+16]
	push	edx
	mov	edx, DWORD PTR __Cat$692169[esp+16]
	push	edx
	mov	edx, DWORD PTR $T692167[esp+20]
	push	edx
	push	ecx
	mov	ecx, edi
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebp, DWORD PTR [esi+16]
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	edi, ebx
	cmp	ebx, ebp
	je	SHORT $LN66@erase@34
	npad	4
$LL68@erase@34:
	push	edi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	edi, 424				; 000001a8H
	cmp	edi, ebp
	jne	SHORT $LL68@erase@34
$LN66@erase@34:

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebx

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]

; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
$LN80@erase@34:
	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T692278 = -12						; size = 8
?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN8@clear@24
	call	__invalid_parameter_noinfo
$LN8@clear@24:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@24
	call	__invalid_parameter_noinfo
$LN24@clear@24:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T692278[esp+44]
	push	eax
	call	?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$0
__tryblocktable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
$T692464 = -20						; size = 1
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Cat$692468 = 12					; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	mov	ebx, DWORD PTR __Count$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@18
	cmp	ebx, 10129639				; 009a90e7H
	jbe	SHORT $LN10@Construct_@18
	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN32@Construct_@18:
$LN10@Construct_@18:
	mov	ecx, ebx
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
	imul	ebx, 424				; 000001a8H
	mov	edi, eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Cat$692468[ebp]
	mov	BYTE PTR $T692464[ebp], 0
	mov	ecx, DWORD PTR $T692464[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ebx+edi]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	edx
	push	eax
	push	edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	add	esp, 16					; 00000010H
	add	ebx, edi
	mov	DWORD PTR [esi+16], ebx
$LN7@Construct_@18:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@18:
$LN31@Construct_@18:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z$0
__ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@76
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@76
$LN13@vector@76:
	xor	eax, eax
$LN14@vector@76:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv537 = -444						; size = 4
$T692614 = -440						; size = 424
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_settings$ = 12						; size = 4
_sysConfig$ = 16					; size = 4
_stats$ = 20						; size = 4
??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::Channel::Channel

; 66   : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 436				; 000001b4H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+468]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _settings$[esp+464]
	mov	ebx, DWORD PTR _this$[esp+464]
	xor	esi, esi
	lea	eax, DWORD PTR [ebx+28]
	mov	ecx, ebp
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	DWORD PTR [ebx+8], esi
	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+16], -100		; ffffff9cH
	mov	DWORD PTR [ebx+20], -1
	mov	DWORD PTR [ebx+24], esi
	call	??0TimingSpecification@DRAMsimII@@QAE@ABVSettings@1@@Z ; DRAMsimII::TimingSpecification::TimingSpecification
	mov	ecx, DWORD PTR [ebp+256]
	push	esi
	lea	eax, DWORD PTR [ebx+112]
	push	eax
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	eax, DWORD PTR [ebx+152]
	mov	DWORD PTR __$EHRec$[esp+476], esi
	mov	edi, DWORD PTR [ebp+304]
	push	eax
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	ecx, DWORD PTR _stats$[esp+464]
	mov	edi, DWORD PTR _sysConfig$[esp+464]
	mov	BYTE PTR __$EHRec$[esp+476], 1
	mov	DWORD PTR [ebx+180], ecx
	lea	esi, DWORD PTR [ebx+184]
	mov	ecx, ebp
	mov	DWORD PTR [ebx+176], edi
	call	??0PowerConfig@DRAMsimII@@QAE@ABVSettings@1@@Z ; DRAMsimII::PowerConfig::PowerConfig
	mov	eax, DWORD PTR _stats$[esp+464]
	mov	dl, BYTE PTR [ebp+291]
	push	eax
	push	edi
	lea	eax, DWORD PTR [ebx+28]
	push	eax
	lea	ecx, DWORD PTR $T692614[esp+480]
	push	ecx
	mov	ecx, ebp
	mov	BYTE PTR [ebx+396], dl
	call	??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Rank::Rank
	mov	BYTE PTR __$EHRec$[esp+476], 2
	mov	edi, DWORD PTR [edi+360]
	push	eax
	push	edi
	lea	esi, DWORD PTR [ebx+400]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	edx, DWORD PTR $T692614[esp+468]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+480], 4
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+424]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN37@Channel@2
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN38@Channel@2
$LN37@Channel@2:
	xor	eax, eax
$LN38@Channel@2:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 67   : 	// assign an id to each channel (normally done with commands)
; 68   : 	for (unsigned i = 0; i < settings.rankCount; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebp+304], ecx
	jbe	SHORT $LN5@Channel@2

; 66   : {

	mov	DWORD PTR tv537[esp+468], ecx
	npad	9
$LL7@Channel@2:

; 69   : 	{
; 70   : 		rank[i].setRankID(i);

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN66@Channel@2
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN66@Channel@2:
	mov	eax, DWORD PTR tv537[esp+468]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+edx+136], edi
	inc	edi
	add	eax, 424				; 000001a8H
	mov	DWORD PTR tv537[esp+468], eax
	cmp	edi, DWORD PTR [ebp+304]
	jb	SHORT $LL7@Channel@2
$LN5@Channel@2:

; 71   : 	}
; 72   : 
; 73   : 	// initialize the refresh counters per rank
; 74   : 	if (settings.refreshPolicy != NO_REFRESH)

	cmp	DWORD PTR [ebp+196], ecx
	je	SHORT $LN85@Channel@2

; 75   : 	{
; 76   : 		// stagger the times that each rank will be refreshed so they don't all arrive incomingTransaction a burst
; 77   : 		unsigned step = settings.tREFI / settings.rankCount;

	mov	eax, DWORD PTR [ebp+356]
	xor	edx, edx
	div	DWORD PTR [ebp+304]

; 78   : 
; 79   : 		for (unsigned j = 0; j < refreshCounter.size(); ++j)

	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	xor	esi, esi
	sar	edx, 3
	test	edx, edx
	jbe	SHORT $LN85@Channel@2
	xor	edi, edi
	lea	ebp, DWORD PTR [eax+1]
	npad	14
$LL3@Channel@2:

; 80   : 		{
; 81   : 			refreshCounter[j] = j * (step + 1);

	mov	eax, DWORD PTR [ebx+168]
	sub	eax, DWORD PTR [ebx+164]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN75@Channel@2
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN75@Channel@2:
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR [eax+esi*8], edi
	mov	DWORD PTR [eax+esi*8+4], ecx
	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	inc	esi
	sar	edx, 3
	add	edi, ebp
	cmp	esi, edx
	jb	SHORT $LL3@Channel@2
$LN85@Channel@2:

; 82   : 		}
; 83   : 	}
; 84   : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+468]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 448				; 000001c0H
	ret	16					; 00000010H
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2:
	lea	eax, DWORD PTR $T692614[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 400				; 00000190H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__ehhandler$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-452]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::Channel::Channel
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapdramsimwssoaphttpproxy.h
;	COMDAT ?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z
_TEXT	SEGMENT
_ns2__submitEpochResultElement$ = 8			; size = 4
_ns2__submitEpochResultResponseElement$ = 12		; size = 4
?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__submitEpochResult, COMDAT
; _this$ = ecx

; 37   : 	virtual int __ns1__submitEpochResult(_ns2__submitEpochResultElement *ns2__submitEpochResultElement, _ns2__submitEpochResultResponseElement *ns2__submitEpochResultResponseElement) { return soap ? soap_call___ns1__submitEpochResult(soap, endpoint, NULL, ns2__submitEpochResultElement, ns2__submitEpochResultResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__submi
	mov	edx, DWORD PTR _ns2__submitEpochResultResponseElement$[esp]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__submitEpochResultElement$[esp+8]
	call	?soap_call___ns1__submitEpochResult@@YAHPAUsoap@@PBD1PAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; soap_call___ns1__submitEpochResult
	add	esp, 8
	pop	ecx
	ret	8
$LN3@ns1__submi:
	mov	eax, 20					; 00000014H
	pop	ecx
	ret	8
?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z
_TEXT	SEGMENT
_ns2__getSettingsFileElement$ = 8			; size = 4
_ns2__getSettingsFileResponseElement$ = 12		; size = 4
?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__getSettingsFile, COMDAT
; _this$ = ecx

; 35   : 	virtual int __ns1__getSettingsFile(_ns2__getSettingsFileElement *ns2__getSettingsFileElement, _ns2__getSettingsFileResponseElement *ns2__getSettingsFileResponseElement) { return soap ? soap_call___ns1__getSettingsFile(soap, endpoint, NULL, ns2__getSettingsFileElement, ns2__getSettingsFileResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__getSe
	mov	edx, DWORD PTR _ns2__getSettingsFileResponseElement$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__getSettingsFileElement$[esp+4]
	call	?soap_call___ns1__getSettingsFile@@YAHPAUsoap@@PBD1PAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ; soap_call___ns1__getSettingsFile
	add	esp, 8
	ret	8
$LN3@ns1__getSe:
	mov	eax, 20					; 00000014H
	ret	8
?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z
_TEXT	SEGMENT
_ns2__getSessionIDElement$ = 8				; size = 4
_ns2__getSessionIDResponseElement$ = 12			; size = 4
?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__getSessionID, COMDAT
; _this$ = ecx

; 33   : 	virtual int __ns1__getSessionID(_ns2__getSessionIDElement *ns2__getSessionIDElement, _ns2__getSessionIDResponseElement *ns2__getSessionIDResponseElement) { return soap ? soap_call___ns1__getSessionID(soap, endpoint, NULL, ns2__getSessionIDElement, ns2__getSessionIDResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__getSe@2
	mov	edx, DWORD PTR _ns2__getSessionIDResponseElement$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__getSessionIDElement$[esp+4]
	call	?soap_call___ns1__getSessionID@@YAHPAUsoap@@PBD1PAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ; soap_call___ns1__getSessionID
	add	esp, 8
	ret	8
$LN3@ns1__getSe@2:
	mov	eax, 20					; 00000014H
	ret	8
?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__getSessionID
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T692973 = -28						; size = 4
__Vptr$692970 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@17:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@17

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$692970[ebp], esi
	mov	DWORD PTR $T692973[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@17
	push	esi
	mov	ecx, edi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_cop@17:
	add	esi, 424				; 000001a8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 424				; 000001a8H
	jmp	SHORT $LL6@Uninit_cop@17
__catch$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@17
$LL3@Uninit_cop@17:

; 134  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@17
$LN1@Uninit_cop@17:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_cop@17:
$LN4@Uninit_cop@17:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_cop@17:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$692970[ebp]
	push	eax
	mov	ecx, DWORD PTR $T692973[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T693041 = -28						; size = 4
__Vptr$693038 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@18:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@18

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$693038[ebp], esi
	mov	DWORD PTR $T693041[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@18
	push	esi
	mov	ecx, edi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_cop@18:
	add	esi, 424				; 000001a8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 424				; 000001a8H
	jmp	SHORT $LL6@Uninit_cop@18
__catch$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@18
$LL3@Uninit_cop@18:

; 134  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 424				; 000001a8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@18
$LN1@Uninit_cop@18:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_cop@18:
$LN4@Uninit_cop@18:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_cop@18:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$693038[ebp]
	push	eax
	mov	ecx, DWORD PTR $T693041[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T693080 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$693084 = 12					; size = 1
__Last$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$693084[esp]
	mov	BYTE PTR $T693080[esp+4], 0
	mov	eax, DWORD PTR $T693080[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
$T693109 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$693113 = 16					; size = 1
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$693113[esp]
	mov	BYTE PTR $T693109[esp+4], 0
	mov	eax, DWORD PTR $T693109[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z
_TEXT	SEGMENT
$T693181 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$693184 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$693184[esp]
	mov	BYTE PTR $T693181[esp+4], 0
	mov	eax, DWORD PTR $T693181[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	8
??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z
_TEXT	SEGMENT
$T693245 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$693248 = 16					; size = 1
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$693248[esp]
	mov	BYTE PTR $T693245[esp+4], 0
	mov	eax, DWORD PTR $T693245[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T693312 = 8						; size = 1
__Cat$693317 = 8					; size = 1
$T693314 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=, COMDAT
; _this$ = esi

; 563  : 		{	// assign _Right

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+8]
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN67@operator@435

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, eax
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	jne	SHORT $LN8@operator@435

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN8@operator@435:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	sub	edx, ecx
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	cmp	edi, ebx
	ja	SHORT $LN6@operator@435

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T693312[esp+12], 0
	mov	eax, DWORD PTR $T693312[esp+12]
	mov	edx, DWORD PTR __Cat$693317[esp+12]
	push	eax
	mov	eax, DWORD PTR $T693314[esp+16]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp+16]
	push	eax
	mov	eax, ecx
	mov	ecx, DWORD PTR [ebp+12]
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ebx, DWORD PTR [esi+16]
	add	esp, 16					; 00000010H
	mov	edi, eax
	cmp	eax, ebx
	je	SHORT $LN38@operator@435
$LL40@operator@435:
	push	edi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	edi, 424				; 000001a8H
	cmp	edi, ebx
	jne	SHORT $LL40@operator@435
$LN38@operator@435:

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	imul	ecx, 424				; 000001a8H
	add	ecx, DWORD PTR [esi+12]

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	mov	DWORD PTR [esi+16], ecx

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN6@operator@435:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN56@operator@435
	xor	eax, eax
	jmp	SHORT $LN57@operator@435
$LN56@operator@435:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, ecx
	mov	eax, 1296593901				; 4d4873edH
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN57@operator@435:
	cmp	edi, eax
	ja	SHORT $LN4@operator@435

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [ebp+12]
	imul	ebx, 424				; 000001a8H

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	add	ebx, eax
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [ebp+16]
	add	esp, 12					; 0000000cH
	push	edx
	mov	edx, DWORD PTR [esi+16]
	push	ebx

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	call	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@435:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN60@operator@435

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [esi+16]
	mov	eax, ecx
	call	?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@operator@435:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, esi
	call	?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
	test	al, al
	je	SHORT $LN67@operator@435

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [esi+12]
	call	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
	mov	DWORD PTR [esi+16], eax
$LN67@operator@435:

; 599  : 		}

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	pop	ecx
	ret	4
??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T693640 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$693774 = 8					; size = 1
_this$ = 8						; size = 4
$T693771 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Right$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@vector@77
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@77
$LN19@vector@77:
	xor	eax, eax
$LN20@vector@77:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	je	SHORT $LN8@vector@77
	cmp	edi, 10129639				; 009a90e7H
	jbe	SHORT $LN46@vector@77
	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN107@vector@77:
$LN46@vector@77:
	mov	ecx, edi
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
	imul	edi, 424				; 000001a8H
	add	edi, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], edi

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T693640[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN60@vector@77
	call	__invalid_parameter_noinfo
$LN60@vector@77:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@77
	call	__invalid_parameter_noinfo
$LN74@vector@77:
	mov	edx, DWORD PTR __Cat$693774[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR $T693771[ebp], 0
	mov	ecx, DWORD PTR $T693771[ebp]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR $T693640[ebp]
	push	eax
	mov	ecx, edi
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+16], eax
$LN8@vector@77:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@vector@77:
$LN106@vector@77:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z		; DRAMsimII::Channel::operator=
__unwindtable$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T693810 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z PROC		; DRAMsimII::Channel::operator=
; _this$ = edi
; _rhs$ = ecx

; 3087 : {

	push	-1
	push	__ehhandler$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 3088 : 	time = rhs.time;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], ecx

; 3089 : 	lastCommandIssueTime = rhs.lastCommandIssueTime;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], edx
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 3090 : 	lastCommand = rhs.lastCommand ? new Command(*(rhs.lastCommand)) : NULL;

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN5@operator@436
	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T693810[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@operator@436
	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR __$EHRec$[esp+32], -1
	jmp	SHORT $LN6@operator@436
$LN3@operator@436:
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], -1
	jmp	SHORT $LN6@operator@436
$LN5@operator@436:
	xor	eax, eax
$LN6@operator@436:

; 3091 : 	transactionQueue = rhs.transactionQueue;

	lea	edx, DWORD PTR [esi+112]
	mov	DWORD PTR [edi+24], eax
	push	edx
	lea	eax, DWORD PTR [edi+112]
	push	eax
	call	??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=

; 3092 : 	refreshCounter = rhs.refreshCounter;

	lea	ecx, DWORD PTR [esi+152]
	push	ecx
	lea	eax, DWORD PTR [edi+152]
	call	??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::operator=

; 3093 : 	channelID = rhs.channelID;

	mov	edx, DWORD PTR [esi+392]

; 3094 : 	rank = rhs.rank;

	add	esi, 400				; 00000190H
	push	esi
	lea	esi, DWORD PTR [edi+400]
	mov	DWORD PTR [edi+392], edx
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 3095 : 
; 3096 : 	return *this;

	mov	eax, edi

; 3097 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z$0:
	mov	esi, DWORD PTR $T693810[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP		; DRAMsimII::Channel::operator=
PUBLIC	__$ArrayPad$
__ehfuncinfo$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$10
	DD	07H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$9
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T693825 = -285						; size = 1
_ACTArray$ = -284					; size = 24
$T694108 = -260						; size = 4
_ACTSTBYArray$ = -256					; size = 24
_response$ = -232					; size = 12
_service$ = -220					; size = 12
_channelArray$ = -208					; size = 24
_submit$ = -184						; size = 136
_session$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_PsysRD$ = 8						; size = 8
_PsysWR$ = 16						; size = 8
_rankArray$ = 24					; size = 24
_PsysACTSTBYArray$ = 48					; size = 24
_PsysACTArray$ = 72					; size = 24
_currentTime$ = 96					; size = 8
?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z PROC ; DRAMsimII::Channel::sendPower
; _this$ = ecx

; 737  : {

	push	-1
	push	__ehhandler$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+292], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+308]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+316], ebx

; 738  : 	DRAMsimWSSoapHttp service;

	lea	edi, DWORD PTR _service$[esp+308]
	call	??0DRAMsimWSSoapHttp@@QAE@XZ		; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp

; 739  : 	_ns2__submitEpochResultElement submit;

	lea	ecx, DWORD PTR _submit$[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	??0_ns2__submitEpochResultElement@@QAE@XZ ; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
	mov	BYTE PTR __$EHRec$[esp+316], 4

; 740  : 
; 741  : 	string session(systemConfig.getSessionID());

	mov	eax, DWORD PTR [esi+176]
	push	-1
	add	eax, 400				; 00000190H
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _session$[esp+320]
	mov	DWORD PTR _session$[esp+344], 15	; 0000000fH
	mov	DWORD PTR _session$[esp+340], ebx
	mov	BYTE PTR _session$[esp+324], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 742  : 	submit.sessionID = &session;
; 743  : 
; 744  : 	submit.epoch = currentTime;

	mov	ecx, DWORD PTR _currentTime$[esp+304]
	mov	edx, DWORD PTR _currentTime$[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	mov	DWORD PTR _submit$[esp+324], ecx

; 745  : 
; 746  : 	vector<int> channelArray(rank.size(),channelID);	

	mov	ecx, DWORD PTR [esi+416]
	sub	ecx, DWORD PTR [esi+412]
	lea	eax, DWORD PTR _session$[esp+308]
	mov	DWORD PTR _submit$[esp+316], eax
	mov	DWORD PTR _submit$[esp+328], edx
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	mov	eax, DWORD PTR [esi+392]
	sar	edx, 7
	mov	edi, edx
	push	eax
	lea	ecx, DWORD PTR _channelArray$[esp+312]
	shr	edi, 31					; 0000001fH
	add	edi, edx
	push	ecx
	call	??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>

; 747  : 	submit.channel = channelArray;

	lea	edx, DWORD PTR _channelArray$[esp+308]
	push	edx
	lea	eax, DWORD PTR _submit$[esp+336]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 748  : 
; 749  : 	submit.rank = rankArray;

	lea	eax, DWORD PTR _rankArray$[esp+304]
	push	eax
	lea	eax, DWORD PTR _submit$[esp+360]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 750  : 
; 751  : 	vector<float> ACTSTBYArray(PsysACTSTBYArray.size());

	mov	edi, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	edi, DWORD PTR _PsysACTSTBYArray$[esp+316]
	lea	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	sar	edi, 3
	push	ecx
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	mov	BYTE PTR __$EHRec$[esp+316], 7

; 752  : 	for (vector<float>::size_type i = 0; i < PsysACTSTBYArray.size(); ++i)

	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTSTBYArray$[esp+316]
	xor	esi, esi
	sar	eax, 3
	cmp	eax, ebx
	jbe	SHORT $LN4@sendPower

; 753  : 		ACTSTBYArray[i] = PsysACTSTBYArray[i];

	cmp	esi, eax
	jb	SHORT $LN53@sendPower
	call	__invalid_parameter_noinfo
$LN53@sendPower:
	mov	eax, DWORD PTR _ACTSTBYArray$[esp+324]
	sub	eax, DWORD PTR _ACTSTBYArray$[esp+320]
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+316]
	sar	eax, 2
	lea	edi, DWORD PTR [edx+esi*8]
	cmp	esi, eax
	jb	SHORT $LN58@sendPower
	call	__invalid_parameter_noinfo
$LN58@sendPower:
	movsd	xmm0, QWORD PTR [edi]
	mov	ecx, DWORD PTR _ACTSTBYArray$[esp+320]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx+esi*4], xmm0
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTSTBYArray$[esp+316]
	inc	esi
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN53@sendPower
$LN4@sendPower:

; 754  : 	vector<float> ACTArray(PsysACTArray.size());

	mov	edi, DWORD PTR _PsysACTArray$[esp+320]
	sub	edi, DWORD PTR _PsysACTArray$[esp+316]
	push	4
	sar	edi, 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN77@sendPower
	lea	edx, DWORD PTR _ACTArray$[esp+308]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN78@sendPower
$LN77@sendPower:
	xor	eax, eax
$LN78@sendPower:
	mov	DWORD PTR _ACTArray$[esp+308], eax
	mov	BYTE PTR __$EHRec$[esp+316], 8
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR $T694108[esp+308]
	push	eax
	lea	esi, DWORD PTR _ACTArray$[esp+312]
	movss	DWORD PTR $T694108[esp+312], xmm0
	call	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n
	mov	BYTE PTR __$EHRec$[esp+316], 9

; 755  : 	for (vector<float>::size_type i = 0; i < PsysACTArray.size() ; ++i)

	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTArray$[esp+316]
	xor	esi, esi
	sar	eax, 3
	cmp	eax, ebx
	jbe	SHORT $LN1@sendPower

; 756  : 		ACTArray[i] = PsysACTArray[i];

	cmp	esi, eax
	jb	SHORT $LN104@sendPower
	call	__invalid_parameter_noinfo
$LN104@sendPower:
	mov	edx, DWORD PTR _ACTArray$[esp+324]
	sub	edx, DWORD PTR _ACTArray$[esp+320]
	mov	ecx, DWORD PTR _PsysACTArray$[esp+316]
	sar	edx, 2
	lea	edi, DWORD PTR [ecx+esi*8]
	cmp	esi, edx
	jb	SHORT $LN109@sendPower
	call	__invalid_parameter_noinfo
$LN109@sendPower:
	movsd	xmm0, QWORD PTR [edi]
	mov	eax, DWORD PTR _ACTArray$[esp+320]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTArray$[esp+316]
	inc	esi
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN104@sendPower
$LN1@sendPower:

; 757  : 	submit.PsysACTSTBY = ACTSTBYArray;

	lea	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	push	ecx
	lea	eax, DWORD PTR _submit$[esp+384]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=

; 758  : 	submit.PsysACT = ACTArray;

	lea	edx, DWORD PTR _ACTArray$[esp+308]
	push	edx
	lea	eax, DWORD PTR _submit$[esp+408]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=

; 759  : 	submit.PsysRD = (float)PsysRD;

	movsd	xmm0, QWORD PTR _PsysRD$[esp+304]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _submit$[esp+428], xmm0

; 760  : 	submit.PsysWR = (float)PsysWR;

	movsd	xmm0, QWORD PTR _PsysWR$[esp+304]

; 761  : 	_ns2__submitEpochResultResponseElement response;

	mov	esi, OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _submit$[esp+432], xmm0
	mov	DWORD PTR _response$[esp+308], esi
	mov	BYTE PTR _response$[esp+312], bl
	mov	DWORD PTR _response$[esp+316], ebx
	mov	BYTE PTR __$EHRec$[esp+316], 10		; 0000000aH

; 762  : 	int retVal = service.__ns1__submitEpochResult(&submit,&response);

	mov	ecx, DWORD PTR _service$[esp+312]
	cmp	ecx, ebx
	je	SHORT $LN118@sendPower
	mov	edx, DWORD PTR _service$[esp+316]
	lea	eax, DWORD PTR _response$[esp+308]
	push	eax
	push	edx
	lea	eax, DWORD PTR _submit$[esp+316]
	call	?soap_call___ns1__submitEpochResult@@YAHPAUsoap@@PBD1PAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; soap_call___ns1__submitEpochResult
	add	esp, 8
	jmp	SHORT $LN119@sendPower
$LN118@sendPower:
	mov	eax, 20					; 00000014H
$LN119@sendPower:

; 763  : 	return (retVal == 0);

	cmp	eax, ebx
	mov	eax, DWORD PTR _ACTArray$[esp+320]
	sete	BYTE PTR $T693825[esp+308]
	mov	DWORD PTR _response$[esp+308], esi
	cmp	eax, ebx
	je	SHORT $LN127@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN127@sendPower:
	mov	eax, DWORD PTR _ACTArray$[esp+308]
	push	eax
	mov	DWORD PTR _ACTArray$[esp+324], ebx
	mov	DWORD PTR _ACTArray$[esp+328], ebx
	mov	DWORD PTR _ACTArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _ACTSTBYArray$[esp+324]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN142@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN142@sendPower:
	mov	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	push	ecx
	mov	DWORD PTR _ACTSTBYArray$[esp+324], ebx
	mov	DWORD PTR _ACTSTBYArray$[esp+328], ebx
	mov	DWORD PTR _ACTSTBYArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _channelArray$[esp+324]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN157@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN157@sendPower:
	mov	edx, DWORD PTR _channelArray$[esp+308]
	push	edx
	mov	DWORD PTR _channelArray$[esp+324], ebx
	mov	DWORD PTR _channelArray$[esp+328], ebx
	mov	DWORD PTR _channelArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	DWORD PTR _session$[esp+332], 16	; 00000010H
	jb	SHORT $LN183@sendPower
	mov	eax, DWORD PTR _session$[esp+312]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN183@sendPower:
	lea	ecx, DWORD PTR _submit$[esp+308]
	mov	DWORD PTR _session$[esp+332], 15	; 0000000fH
	mov	DWORD PTR _session$[esp+328], ebx
	mov	BYTE PTR _session$[esp+312], bl
	call	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	lea	ecx, DWORD PTR _service$[esp+308]
	call	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
	mov	eax, DWORD PTR _rankArray$[esp+316]
	cmp	eax, ebx
	je	SHORT $LN198@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@sendPower:
	mov	ecx, DWORD PTR _rankArray$[esp+304]
	push	ecx
	mov	DWORD PTR _rankArray$[esp+320], ebx
	mov	DWORD PTR _rankArray$[esp+324], ebx
	mov	DWORD PTR _rankArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN213@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN213@sendPower:
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+304]
	push	edx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+320], ebx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+324], ebx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN228@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN228@sendPower:
	mov	eax, DWORD PTR _PsysACTArray$[esp+304]
	push	eax
	mov	DWORD PTR _PsysACTArray$[esp+320], ebx
	mov	DWORD PTR _PsysACTArray$[esp+324], ebx
	mov	DWORD PTR _PsysACTArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	al, BYTE PTR $T693825[esp+312]
	add	esp, 4

; 764  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+308]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+292]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 292				; 00000124H
	ret	96					; 00000060H
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$0:
	lea	esi, DWORD PTR _PsysACTArray$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$1:
	lea	esi, DWORD PTR _PsysACTSTBYArray$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$2:
	lea	ecx, DWORD PTR _rankArray$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$3:
	lea	ecx, DWORD PTR _service$[ebp]
	jmp	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$4:
	lea	ecx, DWORD PTR _submit$[ebp]
	jmp	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$5:
	lea	ecx, DWORD PTR _session$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$6:
	lea	ecx, DWORD PTR _channelArray$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$7:
	lea	ecx, DWORD PTR _ACTSTBYArray$[ebp]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$10:
	lea	eax, DWORD PTR _ACTArray$[ebp]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$8:
	lea	ecx, DWORD PTR _ACTArray$[ebp]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$9:
	lea	ecx, DWORD PTR _response$[ebp]
	jmp	??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
__ehhandler$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-292]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	jmp	___CxxFrameHandler3
?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ENDP ; DRAMsimII::Channel::sendPower
PUBLIC	__real@3fee666660000000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3fa9999a00000000
PUBLIC	__real@3fefae147b000000
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; DRAMsimII::Channel::doPowerCalculation
;	COMDAT __real@3fee666660000000
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@3fee666660000000 DQ 03fee666660000000r	; 0.95
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3fa9999a00000000
CONST	SEGMENT
__real@3fa9999a00000000 DQ 03fa9999a00000000r	; 0.05
CONST	ENDS
;	COMDAT __real@3fefae147b000000
CONST	SEGMENT
__real@3fefae147b000000 DQ 03fefae147b000000r	; 0.99
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
__unwindtable$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$4
__ehfuncinfo$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv4172 = -312						; size = 4
$T697574 = -312						; size = 4
$T694618 = -312						; size = 4
_k$220704 = -312					; size = 8
$T697558 = -304						; size = 4
$T697208 = -304						; size = 4
_allBankRASCount$220711 = -304				; size = 4
tv4349 = -300						; size = 4
tv4335 = -300						; size = 4
tv4324 = -300						; size = 4
tv4300 = -300						; size = 4
tv4295 = -300						; size = 4
tv4283 = -300						; size = 4
tv4267 = -300						; size = 4
tv4216 = -300						; size = 4
tv4213 = -300						; size = 4
tv4168 = -300						; size = 4
tv3500 = -300						; size = 8
tv3449 = -300						; size = 8
$T697578 = -300						; size = 4
$T694617 = -300						; size = 4
$T694616 = -300						; size = 4
tv4174 = -292						; size = 4
$T697566 = -292						; size = 4
$T697278 = -292						; size = 4
$T694619 = -292						; size = 4
_tRRDsch$221155 = -292					; size = 8
_percentActive$221144 = -292				; size = 8
$T694601 = -292						; size = 4
_totalReadHits$ = -280					; size = 4
_PsysACT$ = -276					; size = 8
_PsysACT_STBY$ = -268					; size = 8
_PsysWR$ = -260						; size = 8
_PsysRD$ = -252						; size = 8
$T697014 = -240						; size = 8
$T694615 = -240						; size = 12
$T694614 = -240						; size = 8
$T694613 = -240						; size = 8
$T694611 = -240						; size = 8
$T694610 = -240						; size = 8
$T694609 = -240						; size = 8
_PsysPRE_STBY$ = -228					; size = 8
_rankArray$ = -220					; size = 24
_PsysACTSTBYArray$ = -196				; size = 24
_PsysACTArray$ = -172					; size = 24
$T697582 = -148						; size = 8
tv398 = -148						; size = 8
_PsysACT_PDN$ = -140					; size = 8
_PsysRdAdjusted$ = -132					; size = 8
$T697570 = -124						; size = 8
_RDschPct$221170 = -124					; size = 8
_PsysPRE_PDN$ = -116					; size = 8
tv4356 = -108						; size = 8
tv4222 = -100						; size = 8
tv4234 = -92						; size = 8
$T696555 = -84						; size = 8
$T694612 = -84						; size = 8
$T694608 = -84						; size = 8
tv4377 = -76						; size = 8
tv4317 = -68						; size = 8
tv4207 = -60						; size = 8
tv4277 = -52						; size = 8
tv267 = -44						; size = 8
tv4237 = -36						; size = 8
$T695160 = -24						; size = 8
__$EHRec$ = -12						; size = 12
_systemTime$ = 8					; size = 8
_os$ = 16						; size = 4
?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z PROC ; DRAMsimII::Channel::doPowerCalculation
; _this$ = edi

; 518  : {	

	push	-1
	push	__ehhandler$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 300				; 0000012cH
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+328]
	mov	DWORD PTR fs:0, eax

; 519  : 	// the counts for the total number of operations
; 520  : 	//unsigned entireRAS = 1;
; 521  : 	//unsigned entireCAS = 1;
; 522  : 	//unsigned entireCASW = 1;
; 523  : 
; 524  : 	// the counts for the operations this epoch
; 525  : 	//unsigned totalRAS = 1;
; 526  : 
; 527  : 	//double PsysACTTotal = 0.0;
; 528  : 	double PsysRD = 0.0;

	xorps	xmm0, xmm0

; 529  : 	double PsysRdAdjusted = 0.0;
; 530  : 	double PsysWR = 0.0;
; 531  : 
; 532  : 	double PsysACT_STBY = 0.0;
; 533  : 	double PsysPRE_STBY = 0.0;
; 534  : 	double PsysPRE_PDN = 0.0;
; 535  : 	double PsysACT_PDN = 0.0;
; 536  : 	double PsysACT = 0.0;
; 537  : 	double PsysACTAdjusted = 0.0;
; 538  : 
; 539  : 	//float tRRDsch = 0.0F;
; 540  : 	float tRRDschAdjusted = 0.0F;
; 541  : 
; 542  : 	vector<int> rankArray;

	lea	ecx, DWORD PTR _rankArray$[esp+328]
	movsd	QWORD PTR _PsysRD$[esp+328], xmm0
	movsd	QWORD PTR _PsysRdAdjusted$[esp+328], xmm0
	movsd	QWORD PTR _PsysWR$[esp+328], xmm0
	movsd	QWORD PTR _PsysACT_STBY$[esp+328], xmm0
	movsd	QWORD PTR _PsysPRE_STBY$[esp+328], xmm0
	movsd	QWORD PTR _PsysPRE_PDN$[esp+328], xmm0
	movsd	QWORD PTR _PsysACT_PDN$[esp+328], xmm0
	movsd	QWORD PTR _PsysACT$[esp+328], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 543  : 	vector<double> PsysACTSTBYArray, PsysACTArray;

	lea	eax, DWORD PTR _PsysACTSTBYArray$[esp+328]
	xor	esi, esi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+340], esi
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	lea	ecx, DWORD PTR _PsysACTArray$[esp+328]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+340], 1
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	BYTE PTR __$EHRec$[esp+336], 2

; 544  : 	unsigned totalReadHits = 0;

	mov	DWORD PTR _totalReadHits$[esp+328], esi

; 545  : 	
; 546  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	mov	esi, DWORD PTR [edi+412]
	cmp	esi, DWORD PTR [edi+416]
	jbe	SHORT $LN28@doPowerCal
	call	__invalid_parameter_noinfo
$LN28@doPowerCal:
	mov	ebx, DWORD PTR [edi+400]
	mov	DWORD PTR _k$220704[esp+328], ebx
	mov	DWORD PTR _k$220704[esp+332], esi
	npad	7
$LL45@doPowerCal:
	mov	ebp, DWORD PTR [edi+416]
	cmp	DWORD PTR [edi+412], ebp
	jbe	SHORT $LN60@doPowerCal
	call	__invalid_parameter_noinfo
$LN60@doPowerCal:
	mov	eax, DWORD PTR [edi+400]
	test	ebx, ebx
	je	SHORT $LN73@doPowerCal
	cmp	ebx, eax
	je	SHORT $LN74@doPowerCal
$LN73@doPowerCal:
	call	__invalid_parameter_noinfo
$LN74@doPowerCal:
	cmp	esi, ebp
	je	$LN6@doPowerCal

; 547  : 	{
; 548  : 		unsigned allBankRASCount = 1;

	mov	DWORD PTR _allBankRASCount$220711[esp+328], 1

; 549  : 		//unsigned perRankAdjustedRASCount = 1;
; 550  : 		//unsigned thisRankRasCount;
; 551  : 		//unsigned totalCAS = 1;
; 552  : 		//unsigned totalCASW = 1; // ensure no div/0
; 553  : 
; 554  : 		rankArray.push_back(k->getRankID());

	test	ebx, ebx
	jne	SHORT $LN1010@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN94@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN85@doPowerCal
	call	__invalid_parameter_noinfo
$LN85@doPowerCal:
	mov	edx, DWORD PTR _rankArray$[esp+340]
	mov	ebp, DWORD PTR [esi+136]
	mov	DWORD PTR $T694601[esp+328], ebp
	test	edx, edx
	jne	SHORT $LN107@doPowerCal
	xor	ecx, ecx
	jmp	SHORT $LN108@doPowerCal
$LN1010@doPowerCal:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN94@doPowerCal
$LN107@doPowerCal:
	mov	ecx, DWORD PTR _rankArray$[esp+348]
	sub	ecx, edx
	sar	ecx, 2
$LN108@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+344]
	mov	esi, eax
	sub	esi, edx
	sar	esi, 2
	cmp	esi, ecx
	jae	SHORT $LN100@doPowerCal
	mov	DWORD PTR [eax], ebp
	add	eax, 4
	mov	DWORD PTR _rankArray$[esp+344], eax
	jmp	SHORT $LN99@doPowerCal
$LN100@doPowerCal:
	mov	ebp, eax
	cmp	edx, eax
	jbe	SHORT $LN137@doPowerCal
	call	__invalid_parameter_noinfo
$LN137@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+328]
	push	ebp
	push	eax
	lea	edx, DWORD PTR $T694601[esp+336]
	push	edx
	lea	eax, DWORD PTR $T695160[esp+340]
	push	eax
	lea	eax, DWORD PTR _rankArray$[esp+344]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN99@doPowerCal:

; 555  : 
; 556  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	test	ebx, ebx
	jne	$LN1009@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN161@doPowerCal:
	mov	esi, DWORD PTR _k$220704[esp+332]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN152@doPowerCal
	call	__invalid_parameter_noinfo
$LN152@doPowerCal:
	mov	ebp, DWORD PTR [esi+412]
	cmp	ebp, DWORD PTR [esi+416]
	jbe	SHORT $LN169@doPowerCal
	call	__invalid_parameter_noinfo
$LN169@doPowerCal:
	mov	esi, DWORD PTR [esi+400]
	add	ebp, 148				; 00000094H
	npad	2
$LL186@doPowerCal:
	test	ebx, ebx
	jne	$LN1008@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN209@doPowerCal:
	mov	ecx, DWORD PTR _k$220704[esp+332]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN200@doPowerCal
	call	__invalid_parameter_noinfo
$LN200@doPowerCal:
	mov	eax, DWORD PTR _k$220704[esp+332]
	mov	ebx, DWORD PTR [eax+416]
	cmp	DWORD PTR [eax+412], ebx
	jbe	SHORT $LN217@doPowerCal
	call	__invalid_parameter_noinfo
$LN217@doPowerCal:
	mov	edx, DWORD PTR _k$220704[esp+332]
	mov	eax, DWORD PTR [edx+400]
	test	esi, esi
	je	SHORT $LN230@doPowerCal
	cmp	esi, eax
	je	SHORT $LN231@doPowerCal
$LN230@doPowerCal:
	call	__invalid_parameter_noinfo
$LN231@doPowerCal:
	lea	eax, DWORD PTR [ebp-148]
	cmp	eax, ebx
	je	$LN3@doPowerCal

; 557  : 		{
; 558  : 			//totalRAS += l->getRASCount();			
; 559  : 			allBankRASCount += l->getRASCount();

	test	esi, esi
	jne	$LN1007@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN251@doPowerCal:
	lea	ecx, DWORD PTR [ebp-148]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN242@doPowerCal
	call	__invalid_parameter_noinfo
$LN242@doPowerCal:
	mov	eax, DWORD PTR [ebp-12]
	add	DWORD PTR _allBankRASCount$220711[esp+328], eax

; 560  : 			//totalCAS += l->getCASCount();
; 561  : 			//totalCASW += l->getCASWCount();
; 562  : 			l->accumulateAndResetCounts();

	test	esi, esi
	jne	SHORT $LN1006@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN269@doPowerCal:
	lea	ecx, DWORD PTR [ebp-148]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN260@doPowerCal
	call	__invalid_parameter_noinfo
$LN260@doPowerCal:
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp-12]
	mov	edx, DWORD PTR [ebp-4]
	add	DWORD PTR [ebp+8], eax
	add	DWORD PTR [ebp-8], ecx
	add	DWORD PTR [ebp], edx
	xor	eax, eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp-12], eax
	cmp	esi, eax
	jne	SHORT $LN1005@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN193@doPowerCal:
	lea	ecx, DWORD PTR [ebp-148]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN184@doPowerCal

; 555  : 
; 556  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	call	__invalid_parameter_noinfo
$LN184@doPowerCal:
	mov	ebx, DWORD PTR _k$220704[esp+328]
	add	ebp, 168				; 000000a8H
	jmp	$LL186@doPowerCal
$LN1009@doPowerCal:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN161@doPowerCal
$LN1008@doPowerCal:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN209@doPowerCal
$LN1007@doPowerCal:

; 557  : 		{
; 558  : 			//totalRAS += l->getRASCount();			
; 559  : 			allBankRASCount += l->getRASCount();

	mov	eax, DWORD PTR [esi]
	jmp	$LN251@doPowerCal
$LN1006@doPowerCal:

; 560  : 			//totalCAS += l->getCASCount();
; 561  : 			//totalCASW += l->getCASWCount();
; 562  : 			l->accumulateAndResetCounts();

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN269@doPowerCal
$LN1005@doPowerCal:

; 555  : 
; 556  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN193@doPowerCal
$LN3@doPowerCal:

; 563  : 		}
; 564  : 
; 565  : 		// what if the RAS could be reduced by specific caching
; 566  : 		unsigned perRankAdjustedRASCount = allBankRASCount - statistics.getRowReduction()[getChannelID()][k->getRankID()]; 

	mov	eax, DWORD PTR _k$220704[esp+328]
	test	eax, eax
	jne	$LN1004@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN287@doPowerCal:
	mov	ecx, DWORD PTR _k$220704[esp+332]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN278@doPowerCal
	call	__invalid_parameter_noinfo
$LN278@doPowerCal:
	mov	esi, DWORD PTR [edi+180]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR _k$220704[esp+332]
	sub	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [edx+136]
	mov	ebp, DWORD PTR [edi+392]
	add	esi, 80					; 00000050H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN296@doPowerCal
	call	__invalid_parameter_noinfo
$LN296@doPowerCal:
	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [ebp+ebp*2]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	cmp	ebx, ecx
	jb	SHORT $LN301@doPowerCal
	call	__invalid_parameter_noinfo
$LN301@doPowerCal:

; 567  : 		if (allBankRASCount < statistics.getRowReduction()[getChannelID()][k->getRankID()])

	mov	eax, DWORD PTR _k$220704[esp+328]
	test	eax, eax
	jne	$LN1003@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN319@doPowerCal:
	mov	edx, DWORD PTR _k$220704[esp+332]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN310@doPowerCal
	call	__invalid_parameter_noinfo
$LN310@doPowerCal:
	mov	esi, DWORD PTR [edi+180]
	mov	eax, DWORD PTR _k$220704[esp+332]
	mov	ecx, DWORD PTR [esi+96]
	sub	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [eax+136]
	mov	ebp, DWORD PTR [edi+392]
	add	esi, 80					; 00000050H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	jb	SHORT $LN328@doPowerCal
	call	__invalid_parameter_noinfo
$LN328@doPowerCal:
	mov	eax, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [ebp+ebp*2]
	mov	ecx, DWORD PTR [eax+edx*8+16]
	sub	ecx, DWORD PTR [eax+edx*8+12]
	lea	esi, DWORD PTR [eax+edx*8]
	sar	ecx, 2
	cmp	ebx, ecx
	jb	SHORT $LN333@doPowerCal
	call	__invalid_parameter_noinfo
$LN333@doPowerCal:
	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _allBankRASCount$220711[esp+328]
	cmp	eax, DWORD PTR [edx+ebx*4]
	jae	$LN390@doPowerCal

; 568  : 			cerr << allBankRASCount << " " << statistics.getRowReduction()[getChannelID()][k->getRankID()] << endl;

	mov	eax, DWORD PTR _k$220704[esp+328]
	test	eax, eax
	jne	$LN1002@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN351@doPowerCal:
	mov	ecx, DWORD PTR _k$220704[esp+332]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN342@doPowerCal
	call	__invalid_parameter_noinfo
$LN342@doPowerCal:
	mov	esi, DWORD PTR [edi+180]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR _k$220704[esp+332]
	sub	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [edx+136]
	mov	ebp, DWORD PTR [edi+392]
	add	esi, 80					; 00000050H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN360@doPowerCal
	call	__invalid_parameter_noinfo
$LN360@doPowerCal:
	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [ebp+ebp*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	esi, DWORD PTR [edx+ecx*8]
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LN365@doPowerCal
	call	__invalid_parameter_noinfo
$LN365@doPowerCal:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR _allBankRASCount$220711[esp+328]
	lea	ebx, DWORD PTR [ecx+ebx*4]
	push	edx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	eax
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebp, eax
	push	10					; 0000000aH
	mov	ecx, ebp
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+ebp]
	xor	esi, esi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN374@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN374@doPowerCal
	mov	esi, 4
$LN374@doPowerCal:
	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, ebp
	test	esi, esi
	je	SHORT $LN390@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, esi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN392@doPowerCal
	or	eax, 4
$LN392@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN390@doPowerCal:

; 569  : #if 0
; 570  : 		cerr << "!!! rasCount " << allBankRASCount << " reduxBy " << statistics.getRowReduction()[getChannelID()][k->getRankID()] << 
; 571  : 			" reducedTo " << allBankRASCount - statistics.getRowReduction()[getChannelID()][k->getRankID()] << " totalReadHits " <<
; 572  : 			statistics.getHitRate()[getChannelID()][k->getRankID()].first.first << endl;
; 573  : #endif
; 574  : 		totalReadHits += statistics.getHitRate()[getChannelID()][k->getRankID()].first.first;

	mov	eax, DWORD PTR _k$220704[esp+328]
	test	eax, eax
	jne	$LN1001@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN407@doPowerCal:
	mov	edx, DWORD PTR _k$220704[esp+332]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN398@doPowerCal
	call	__invalid_parameter_noinfo
$LN398@doPowerCal:
	mov	esi, DWORD PTR [edi+180]
	mov	eax, DWORD PTR _k$220704[esp+332]
	mov	ecx, DWORD PTR [esi+596]
	sub	ecx, DWORD PTR [esi+592]
	mov	ebx, DWORD PTR [eax+136]
	mov	ebp, DWORD PTR [edi+392]
	add	esi, 580				; 00000244H
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	jb	SHORT $LN416@doPowerCal
	call	__invalid_parameter_noinfo
$LN416@doPowerCal:
	mov	eax, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [ebp+ebp*2]
	mov	ecx, DWORD PTR [eax+edx*8+16]
	sub	ecx, DWORD PTR [eax+edx*8+12]
	lea	esi, DWORD PTR [eax+edx*8]
	sar	ecx, 5
	cmp	ebx, ecx
	jb	SHORT $LN421@doPowerCal
	call	__invalid_parameter_noinfo
$LN421@doPowerCal:
	mov	edx, DWORD PTR [esi+12]

; 575  : 		BOOST_ASSERT(perRankAdjustedRASCount >= 0);
; 576  : 		BOOST_ASSERT(perRankAdjustedRASCount <= allBankRASCount);
; 577  : 
; 578  : 		// FIXME: assumes CKE is always high, so (1 - CKE_LOW_PRE%) = 1
; 579  : 		double percentActive = 1.0F - (k->getPrechargeTime(time) / max((double)(time - powerModel.getLastCalculation()), 0.00000001));

	mov	ecx, DWORD PTR [edi+8]
	shl	ebx, 5
	mov	eax, DWORD PTR [ebx+edx]
	add	DWORD PTR _totalReadHits$[esp+328], eax
	sub	ecx, DWORD PTR [edi+384]
	mov	edx, DWORD PTR [edi+12]
	sbb	edx, DWORD PTR [edi+388]
	mov	DWORD PTR tv4377[esp+328], ecx
	mov	DWORD PTR tv4377[esp+332], edx
	fild	QWORD PTR tv4377[esp+328]
	fst	QWORD PTR tv3449[esp+328]
	fld	QWORD PTR __real@3e45798ee2308c3a
	fxch	ST(1)
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN11@doPowerCal
	movsd	xmm0, QWORD PTR tv3449[esp+328]
	jmp	SHORT $LN1043@doPowerCal
$LN1004@doPowerCal:

; 563  : 		}
; 564  : 
; 565  : 		// what if the RAS could be reduced by specific caching
; 566  : 		unsigned perRankAdjustedRASCount = allBankRASCount - statistics.getRowReduction()[getChannelID()][k->getRankID()]; 

	mov	eax, DWORD PTR [eax]
	jmp	$LN287@doPowerCal
$LN1003@doPowerCal:

; 567  : 		if (allBankRASCount < statistics.getRowReduction()[getChannelID()][k->getRankID()])

	mov	eax, DWORD PTR [eax]
	jmp	$LN319@doPowerCal
$LN1002@doPowerCal:

; 568  : 			cerr << allBankRASCount << " " << statistics.getRowReduction()[getChannelID()][k->getRankID()] << endl;

	mov	eax, DWORD PTR [eax]
	jmp	$LN351@doPowerCal
$LN1001@doPowerCal:

; 569  : #if 0
; 570  : 		cerr << "!!! rasCount " << allBankRASCount << " reduxBy " << statistics.getRowReduction()[getChannelID()][k->getRankID()] << 
; 571  : 			" reducedTo " << allBankRASCount - statistics.getRowReduction()[getChannelID()][k->getRankID()] << " totalReadHits " <<
; 572  : 			statistics.getHitRate()[getChannelID()][k->getRankID()].first.first << endl;
; 573  : #endif
; 574  : 		totalReadHits += statistics.getHitRate()[getChannelID()][k->getRankID()].first.first;

	mov	eax, DWORD PTR [eax]
	jmp	$LN407@doPowerCal
$LN11@doPowerCal:

; 575  : 		BOOST_ASSERT(perRankAdjustedRASCount >= 0);
; 576  : 		BOOST_ASSERT(perRankAdjustedRASCount <= allBankRASCount);
; 577  : 
; 578  : 		// FIXME: assumes CKE is always high, so (1 - CKE_LOW_PRE%) = 1
; 579  : 		double percentActive = 1.0F - (k->getPrechargeTime(time) / max((double)(time - powerModel.getLastCalculation()), 0.00000001));

	movsd	xmm0, QWORD PTR __real@3e45798ee2308c3a
$LN1043@doPowerCal:
	mov	eax, DWORD PTR _k$220704[esp+328]
	movsd	QWORD PTR tv267[esp+328], xmm0
	test	eax, eax
	jne	$LN1000@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN443@doPowerCal:
	mov	ecx, DWORD PTR _k$220704[esp+332]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN434@doPowerCal
	call	__invalid_parameter_noinfo
$LN434@doPowerCal:
	mov	edx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR _k$220704[esp+332]
	push	edx
	push	eax
	call	?getPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z ; DRAMsimII::Rank::getPrechargeTime
	mov	DWORD PTR tv4356[esp+328], eax
	mov	DWORD PTR tv4356[esp+332], edx
	fild	QWORD PTR tv4356[esp+328]

; 580  : 
; 581  : 		assert(percentActive >= 0.0F && percentActive <= 1.0F);
; 582  : 		assert(k->getPrechargeTime(time) <= time - powerModel.getLastCalculation());
; 583  : 
; 584  : 		/// @todo actually simulate CKE, per rank
; 585  : 		double CKE_LO_PRE = 0.95F;
; 586  : 		double CKE_LO_ACT = 0.01F;
; 587  : 
; 588  : 		// calculate background power
; 589  : 		// calculate PsysACT-STBY	
; 590  : 		double PschACT_STBY = powerModel.getPdsACT_STBY() * percentActive * (1 - CKE_LO_ACT);
; 591  : 		PsysACT_STBY += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() *
; 592  : 			powerModel.getFrequencyScaleFactor() * PschACT_STBY;

	mov	ecx, DWORD PTR [edi+356]
	fdiv	QWORD PTR tv267[esp+328]
	fld1
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _percentActive$221144[esp+328]
	fild	DWORD PTR [edi+356]
	test	ecx, ecx
	jge	SHORT $LN1031@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1031@doPowerCal:
	fmul	QWORD PTR [edi+288]

; 593  : 
; 594  : 		PsysACTSTBYArray.push_back(PsysACT_STBY);

	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+340]
	fmul	QWORD PTR [edi+296]
	fld	QWORD PTR [edi+240]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR __real@3fefae147b000000
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysACT_STBY$[esp+328]
	fstp	QWORD PTR _PsysACT_STBY$[esp+328]
	test	edx, edx
	jne	SHORT $LN462@doPowerCal
	xor	ecx, ecx
	jmp	SHORT $LN463@doPowerCal
$LN1000@doPowerCal:

; 575  : 		BOOST_ASSERT(perRankAdjustedRASCount >= 0);
; 576  : 		BOOST_ASSERT(perRankAdjustedRASCount <= allBankRASCount);
; 577  : 
; 578  : 		// FIXME: assumes CKE is always high, so (1 - CKE_LOW_PRE%) = 1
; 579  : 		double percentActive = 1.0F - (k->getPrechargeTime(time) / max((double)(time - powerModel.getLastCalculation()), 0.00000001));

	mov	eax, DWORD PTR [eax]
	jmp	$LN443@doPowerCal

; 593  : 
; 594  : 		PsysACTSTBYArray.push_back(PsysACT_STBY);

$LN462@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTSTBYArray$[esp+348]
	sub	ecx, edx
	sar	ecx, 3
$LN463@doPowerCal:
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+344]
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 3
	cmp	ebx, ecx
	jae	SHORT $LN1027@doPowerCal
	movsd	xmm0, QWORD PTR _PsysACT_STBY$[esp+328]
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	mov	DWORD PTR _PsysACTSTBYArray$[esp+344], eax
	jmp	SHORT $LN454@doPowerCal
$LN1027@doPowerCal:
	fstp	ST(0)
	mov	ebx, eax
	cmp	edx, eax
	jbe	SHORT $LN492@doPowerCal
	call	__invalid_parameter_noinfo
$LN492@doPowerCal:
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+328]
	push	ebx
	push	eax
	lea	edx, DWORD PTR _PsysACT_STBY$[esp+336]
	push	edx
	lea	eax, DWORD PTR $T696555[esp+340]
	push	eax
	lea	eax, DWORD PTR _PsysACTSTBYArray$[esp+344]
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
	fld	QWORD PTR _percentActive$221144[esp+328]
$LN454@doPowerCal:

; 595  : 
; 596  : 		// calculate PsysPRE-STBY
; 597  : 		double PschPRE_STBY = powerModel.getPdsPRE_STBY() * (1.0 - percentActive) * (1 - CKE_LO_PRE);
; 598  : 		PsysPRE_STBY += powerModel.getDevicesPerRank() * powerModel.getFrequencyScaleFactor() *
; 599  : 			powerModel.getVoltageScaleFactor() * PschPRE_STBY;

	mov	ecx, DWORD PTR [edi+356]
	fild	DWORD PTR [edi+356]
	test	ecx, ecx
	jge	SHORT $LN1032@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1032@doPowerCal:
	fmul	QWORD PTR [edi+296]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _percentActive$221144[esp+328]
	movsd	xmm2, QWORD PTR [edi+248]
	fmul	QWORD PTR [edi+288]

; 600  : 
; 601  : 		// calculate PsysPRE-PDN
; 602  : 		double PschPRE_PDN = powerModel.getPdsPRE_PDN() * (1.0 - percentActive) * (CKE_LO_PRE);
; 603  : 		PsysPRE_PDN += powerModel.getDevicesPerRank() * powerModel.getFrequencyScaleFactor() *
; 604  : 			powerModel.getVoltageScaleFactor() * PschPRE_PDN;
; 605  : 
; 606  : 		// calculate PsysACT-PDN
; 607  : 		double PschACT_PDN = powerModel.getPdsACT_PDN() * percentActive * CKE_LO_ACT;
; 608  : 		PsysACT_PDN += powerModel.getDevicesPerRank() * powerModel.getFrequencyScaleFactor() * 
; 609  : 			powerModel.getVoltageScaleFactor() * PschACT_PDN;
; 610  : 
; 611  : 		// calculate PsysACT
; 612  : 		double tRRDsch = ((double)(time - powerModel.getLastCalculation())) / (allBankRASCount > 0 ? allBankRASCount : 0.00000001);

	mov	eax, DWORD PTR _allBankRASCount$220711[esp+328]
	mulsd	xmm2, xmm0
	mulsd	xmm2, QWORD PTR __real@3fa9999a00000000
	fst	QWORD PTR tv3500[esp+328]
	movsd	xmm1, QWORD PTR tv3500[esp+328]
	fld	QWORD PTR [edi+256]
	mulsd	xmm2, xmm1
	addsd	xmm2, QWORD PTR _PsysPRE_STBY$[esp+328]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	movsd	QWORD PTR _PsysPRE_STBY$[esp+328], xmm2
	movsd	xmm2, QWORD PTR [edi+264]
	fmul	QWORD PTR __real@3f847ae140000000
	mulsd	xmm2, xmm0
	mulsd	xmm2, QWORD PTR __real@3fee666660000000
	mulsd	xmm2, xmm1
	addsd	xmm2, QWORD PTR _PsysPRE_PDN$[esp+328]
	fmulp	ST(1), ST(0)
	movsd	QWORD PTR _PsysPRE_PDN$[esp+328], xmm2
	fadd	QWORD PTR _PsysACT_PDN$[esp+328]
	fstp	QWORD PTR _PsysACT_PDN$[esp+328]
	test	eax, eax
	jbe	SHORT $LN13@doPowerCal
	mov	DWORD PTR tv4324[esp+328], eax
	fild	DWORD PTR tv4324[esp+328]
	jge	SHORT $LN14@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
	jmp	SHORT $LN14@doPowerCal
$LN13@doPowerCal:
	movsd	xmm0, QWORD PTR __real@3e45798ee2308c3a
	movsd	QWORD PTR tv398[esp+328], xmm0
	fld	QWORD PTR tv398[esp+328]
$LN14@doPowerCal:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+384]
	mov	eax, DWORD PTR [edi+12]
	sbb	eax, DWORD PTR [edi+388]
	mov	DWORD PTR tv4317[esp+328], edx
	mov	DWORD PTR tv4317[esp+332], eax
	fild	QWORD PTR tv4317[esp+328]

; 613  : 	
; 614  : 		cerr << "rrd " << tRRDsch << " " << powerModel.gettRC() << endl;

	mov	eax, DWORD PTR [edi+372]
	push	eax
	push	ecx
	fdivrp	ST(1), ST(0)
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	sub	esp, 12					; 0000000cH
	fst	QWORD PTR _tRRDsch$221155[esp+352]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04KBKDJEAE@rrd?5?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebp, eax
	push	10					; 0000000aH
	mov	ecx, ebp
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+ebp]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN535@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN535@doPowerCal
	mov	ebx, 4
$LN535@doPowerCal:
	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, ebp
	test	ebx, ebx
	je	SHORT $LN551@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN553@doPowerCal
	or	eax, 4
$LN553@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN551@doPowerCal:

; 616  : 
; 617  : 
; 618  : 		tRRDschAdjusted = ((float)(time - powerModel.getLastCalculation()) / perRankAdjustedRASCount);
; 619  : #if 0
; 620  : 		if (tRRDsch > 200.0F)
; 621  : 			cerr << "t=" << time << ", last t=" << powerModel.getLastCalculation() << ", #RAS=" << perRankRASCount << endl;
; 622  : #endif
; 623  : 		PsysACT += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * PschACT;

	mov	edx, DWORD PTR [edi+372]
	fild	DWORD PTR [edi+372]
	test	edx, edx
	jge	SHORT $LN1034@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1034@doPowerCal:

; 615  : 		double PschACT = powerModel.getPdsACT() * powerModel.gettRC() / tRRDsch;

	fmul	QWORD PTR [edi+232]

; 616  : 
; 617  : 
; 618  : 		tRRDschAdjusted = ((float)(time - powerModel.getLastCalculation()) / perRankAdjustedRASCount);
; 619  : #if 0
; 620  : 		if (tRRDsch > 200.0F)
; 621  : 			cerr << "t=" << time << ", last t=" << powerModel.getLastCalculation() << ", #RAS=" << perRankRASCount << endl;
; 622  : #endif
; 623  : 		PsysACT += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * PschACT;

	mov	eax, DWORD PTR [edi+356]
	fdiv	QWORD PTR _tRRDsch$221155[esp+328]
	fild	DWORD PTR [edi+356]
	test	eax, eax
	jge	SHORT $LN1035@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1035@doPowerCal:
	fmul	QWORD PTR [edi+288]

; 624  : 
; 625  : 		PsysACTAdjusted += powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDschAdjusted) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 626  : 
; 627  : 		PsysACTArray.push_back(PsysACT);

	mov	edx, DWORD PTR _PsysACTArray$[esp+340]
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysACT$[esp+328]
	fstp	QWORD PTR _PsysACT$[esp+328]
	test	edx, edx
	jne	SHORT $LN581@doPowerCal
	xor	ecx, ecx
	jmp	SHORT $LN582@doPowerCal
$LN581@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTArray$[esp+348]
	sub	ecx, edx
	sar	ecx, 3
$LN582@doPowerCal:
	mov	eax, DWORD PTR _PsysACTArray$[esp+344]
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 3
	cmp	ebx, ecx
	jae	SHORT $LN574@doPowerCal
	movsd	xmm0, QWORD PTR _PsysACT$[esp+328]
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	mov	DWORD PTR _PsysACTArray$[esp+344], eax
	jmp	SHORT $LN573@doPowerCal
$LN574@doPowerCal:
	mov	ebx, eax
	cmp	edx, eax
	jbe	SHORT $LN611@doPowerCal
	call	__invalid_parameter_noinfo
$LN611@doPowerCal:
	mov	eax, DWORD PTR _PsysACTArray$[esp+328]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _PsysACT$[esp+336]
	push	ecx
	lea	edx, DWORD PTR $T697014[esp+340]
	push	edx
	lea	eax, DWORD PTR _PsysACTArray$[esp+344]
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
$LN573@doPowerCal:

; 628  : 
; 629  : 		//PsysACTTotal += ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 630  : 
; 631  : 		// calculate PdsRD
; 632  : 		double RDschPct = k->getReadCycles() / (double)(time - powerModel.getLastCalculation());

	mov	ebx, DWORD PTR _k$220704[esp+328]
	test	ebx, ebx
	jne	$LN999@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN635@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN626@doPowerCal
	call	__invalid_parameter_noinfo
$LN626@doPowerCal:
	mov	eax, DWORD PTR [esi+128]
	fild	DWORD PTR [esi+128]
	test	eax, eax
	jge	SHORT $LN1036@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1036@doPowerCal:
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+384]
	mov	edx, DWORD PTR [edi+12]
	sbb	edx, DWORD PTR [edi+388]
	mov	DWORD PTR tv4277[esp+328], ecx
	mov	DWORD PTR tv4277[esp+332], edx
	fild	QWORD PTR tv4277[esp+328]
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _RDschPct$221170[esp+328]

; 633  : 
; 634  : 		double RDschPctAdjusted = (k->getReadCycles() - timingSpecification.tBurst() * statistics.getHitRate()[getChannelID()][k->getRankID()].first.first) / (double)(time - powerModel.getLastCalculation());

	test	ebx, ebx
	jne	$LN998@doPowerCal
	call	__invalid_parameter_noinfo
$LN655@doPowerCal:
	cmp	esi, DWORD PTR [ebx+16]
	jb	SHORT $LN646@doPowerCal
	call	__invalid_parameter_noinfo
$LN646@doPowerCal:
	mov	eax, DWORD PTR [edi+32]
	mov	esi, DWORD PTR _k$220704[esp+332]
	mov	ebx, DWORD PTR [esi+128]
	mov	DWORD PTR $T697208[esp+328], eax
	mov	eax, DWORD PTR _k$220704[esp+328]
	test	eax, eax
	jne	$LN997@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN675@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN666@doPowerCal
	call	__invalid_parameter_noinfo
$LN666@doPowerCal:
	mov	esi, DWORD PTR [edi+180]
	mov	edx, DWORD PTR [esi+596]
	sub	edx, DWORD PTR [esi+592]
	mov	ecx, DWORD PTR _k$220704[esp+332]
	mov	ebp, DWORD PTR [ecx+136]
	mov	ecx, DWORD PTR [edi+392]
	add	esi, 580				; 00000244H
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T697278[esp+328], ecx
	cmp	ecx, eax
	jb	SHORT $LN684@doPowerCal
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T697278[esp+328]
$LN684@doPowerCal:
	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	esi, DWORD PTR [edx+ecx*8]
	sar	eax, 5
	cmp	ebp, eax
	jb	SHORT $LN689@doPowerCal
	call	__invalid_parameter_noinfo
$LN689@doPowerCal:

; 635  : 
; 636  : 		BOOST_ASSERT(RDschPctAdjusted >= 0.0);
; 637  : 
; 638  : 		PsysRD += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsRD() * RDschPct;

	mov	ecx, DWORD PTR [edi+356]
	fild	DWORD PTR [edi+356]
	test	ecx, ecx
	jge	SHORT $LN1037@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1037@doPowerCal:
	fmul	QWORD PTR [edi+288]

; 639  : 
; 640  : 		PsysRdAdjusted += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsRD() * RDschPctAdjusted;

	mov	eax, DWORD PTR $T697208[esp+328]
	cdq
	push	edx
	fmul	QWORD PTR [edi+296]
	push	eax
	mov	eax, DWORD PTR [esi+12]
	shl	ebp, 5
	fmul	QWORD PTR [edi+272]
	mov	edx, DWORD PTR [eax+ebp+4]
	fld	QWORD PTR _RDschPct$221170[esp+336]
	mov	eax, DWORD PTR [eax+ebp]
	push	edx
	fmul	ST(0), ST(1)
	push	eax
	fadd	QWORD PTR _PsysRD$[esp+344]
	fstp	QWORD PTR _PsysRD$[esp+344]
	call	__allmul
	xor	ecx, ecx
	sub	ebx, eax
	sbb	ecx, edx
	mov	edx, DWORD PTR [edi+12]
	mov	eax, ecx
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR tv4237[esp+332], ecx
	mov	ecx, DWORD PTR [edi+8]
	and	eax, -2147483648			; 80000000H
	xor	ebp, ebp
	sub	ecx, DWORD PTR [edi+384]
	mov	DWORD PTR tv4237[esp+328], ebx
	fild	QWORD PTR tv4237[esp+328]
	sbb	edx, DWORD PTR [edi+388]
	mov	DWORD PTR tv4234[esp+332], eax
	mov	DWORD PTR tv4234[esp+328], ebp
	fild	QWORD PTR tv4234[esp+328]
	mov	DWORD PTR tv4222[esp+328], ecx
	mov	DWORD PTR tv4222[esp+332], edx

; 641  : 
; 642  : 		// calculate PdsWR
; 643  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	mov	ebx, DWORD PTR _k$220704[esp+328]
	fchs
	faddp	ST(1), ST(0)
	fild	QWORD PTR tv4222[esp+328]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysRdAdjusted$[esp+328]
	fstp	QWORD PTR _PsysRdAdjusted$[esp+328]
	cmp	ebx, ebp
	jne	$LN996@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN725@doPowerCal:
	mov	esi, DWORD PTR _k$220704[esp+332]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN716@doPowerCal
	call	__invalid_parameter_noinfo
$LN716@doPowerCal:

; 644  : 
; 645  : 		// using a write-through cache, no help for writes
; 646  : 
; 647  : 		PsysWR += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsWR() * WRschPct;

	mov	eax, DWORD PTR [edi+356]
	fild	DWORD PTR [edi+356]
	test	eax, eax
	jge	SHORT $LN1038@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1038@doPowerCal:
	fmul	QWORD PTR [edi+288]
	mov	ecx, DWORD PTR [esi+132]
	fmul	QWORD PTR [edi+296]
	fmul	QWORD PTR [edi+280]
	fild	DWORD PTR [esi+132]
	test	ecx, ecx
	jge	SHORT $LN1039@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1039@doPowerCal:

; 641  : 
; 642  : 		// calculate PdsWR
; 643  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+384]
	mov	eax, DWORD PTR [edi+12]
	sbb	eax, DWORD PTR [edi+388]

; 644  : 
; 645  : 		// using a write-through cache, no help for writes
; 646  : 
; 647  : 		PsysWR += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsWR() * WRschPct;

	mov	DWORD PTR tv4207[esp+328], edx
	mov	DWORD PTR tv4207[esp+332], eax
	fild	QWORD PTR tv4207[esp+328]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysWR$[esp+328]
	fstp	QWORD PTR _PsysWR$[esp+328]

; 648  : 
; 649  : 		k->resetPrechargeTime(time);

	cmp	ebx, ebp
	jne	$LN995@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN753@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN744@doPowerCal
	call	__invalid_parameter_noinfo
$LN744@doPowerCal:
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+56], ebp
	mov	DWORD PTR [esi+60], ebp
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], ecx

; 650  : 		k->resetCycleCounts();

	cmp	ebx, ebp
	jne	SHORT $LN994@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN771@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN762@doPowerCal
	call	__invalid_parameter_noinfo
$LN762@doPowerCal:
	mov	DWORD PTR [esi+132], ebp
	mov	DWORD PTR [esi+128], ebp
	cmp	ebx, ebp
	jne	SHORT $LN993@doPowerCal
	call	__invalid_parameter_noinfo
	xor	ebx, ebx
$LN52@doPowerCal:

; 545  : 	
; 546  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	cmp	esi, DWORD PTR [ebx+16]
	jb	SHORT $LN43@doPowerCal
	call	__invalid_parameter_noinfo
$LN43@doPowerCal:
	mov	ebx, DWORD PTR _k$220704[esp+328]
	add	esi, 424				; 000001a8H
	mov	DWORD PTR _k$220704[esp+332], esi
	jmp	$LL45@doPowerCal
$LN999@doPowerCal:

; 628  : 
; 629  : 		//PsysACTTotal += ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 630  : 
; 631  : 		// calculate PdsRD
; 632  : 		double RDschPct = k->getReadCycles() / (double)(time - powerModel.getLastCalculation());

	mov	eax, DWORD PTR [ebx]
	jmp	$LN635@doPowerCal
$LN998@doPowerCal:

; 633  : 
; 634  : 		double RDschPctAdjusted = (k->getReadCycles() - timingSpecification.tBurst() * statistics.getHitRate()[getChannelID()][k->getRankID()].first.first) / (double)(time - powerModel.getLastCalculation());

	mov	ebx, DWORD PTR [ebx]
	jmp	$LN655@doPowerCal
$LN997@doPowerCal:
	mov	eax, DWORD PTR [eax]
	jmp	$LN675@doPowerCal
$LN996@doPowerCal:

; 641  : 
; 642  : 		// calculate PdsWR
; 643  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	mov	eax, DWORD PTR [ebx]
	jmp	$LN725@doPowerCal
$LN995@doPowerCal:

; 648  : 
; 649  : 		k->resetPrechargeTime(time);

	mov	eax, DWORD PTR [ebx]
	jmp	$LN753@doPowerCal
$LN994@doPowerCal:

; 650  : 		k->resetCycleCounts();

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN771@doPowerCal
$LN993@doPowerCal:

; 545  : 	
; 546  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN52@doPowerCal
$LN6@doPowerCal:

; 651  : 	}
; 652  : 
; 653  : 	os << "-Psys(ACT_STBY) ch[" << channelID << "] {" << setprecision(5) << PsysACT_STBY << "} mW EsysAdjusted {" << setprecision(5) <<
; 654  : 		(PsysRD + PsysWR + PsysACT + PsysACT_STBY + PsysACT_PDN + PsysPRE_STBY + PsysPRE_PDN) * systemConfig.getEpoch() / systemConfig.getDatarate() << "/" <<
; 655  : 		powerModel.getDevicesPerRank() * powerModel.getIDD1() * ((float)timingSpecification.tRC() / systemConfig.getDatarate()) * powerModel.getVDD() * totalReadHits << "} mJ" <<
; 656  : 		endl;

	mov	ecx, DWORD PTR [edi+356]
	mov	eax, DWORD PTR [edi+176]
	movsd	xmm0, QWORD PTR [eax+336]
	mov	edx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [eax+380]
	movss	xmm1, DWORD PTR [edi+184]
	mov	esi, DWORD PTR [edi+196]
	mov	DWORD PTR $T697558[esp+328], ecx
	lea	ecx, DWORD PTR $T694609[esp+328]
	push	5
	push	ecx
	mov	DWORD PTR $T697566[esp+336], edx
	movsd	QWORD PTR $T697570[esp+336], xmm0
	movss	DWORD PTR $T697574[esp+336], xmm1
	mov	DWORD PTR $T697578[esp+336], eax
	movsd	QWORD PTR $T697582[esp+336], xmm0
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	mov	edx, DWORD PTR [edi+392]
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	push	edx
	push	ecx
	mov	ebp, eax
	mov	eax, DWORD PTR _os$[esp+340]
	push	OFFSET ??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN793@doPowerCal
$LN792@doPowerCal:
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, ebx
$LN793@doPowerCal:
	mov	edx, DWORD PTR [ebp+4]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp]
	call	eax
	lea	ecx, DWORD PTR $T694608[esp+336]
	push	5
	push	ecx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	fld	QWORD PTR _PsysACT_STBY$[esp+344]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_0BE@HJDEMIMJ@?$HN?5mW?5EsysAdjusted?5?$HL?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	ebx
	mov	ebp, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN797@doPowerCal
$LN796@doPowerCal:
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
$LN797@doPowerCal:
	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	push	ecx
	push	eax
	call	edx
	imul	esi, DWORD PTR $T697558[esp+336]
	fild	DWORD PTR $T697566[esp+336]
	fdiv	QWORD PTR $T697570[esp+336]
	add	esp, 8
	push	OFFSET ??_C@_04NCDEHMFO@?$HN?5mJ?$AA@
	mov	DWORD PTR tv4174[esp+332], esi
	push	ecx
	fild	DWORD PTR tv4174[esp+336]
	test	esi, esi
	jge	SHORT $LN1040@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1040@doPowerCal:
	mov	eax, DWORD PTR _totalReadHits$[esp+336]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR $T697574[esp+336]
	fild	DWORD PTR _totalReadHits$[esp+336]
	test	eax, eax
	jge	SHORT $LN1041@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1041@doPowerCal:
	fmulp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	fld	QWORD PTR _PsysWR$[esp+348]
	push	ecx
	fadd	QWORD PTR _PsysRD$[esp+352]
	mov	ecx, DWORD PTR $T697578[esp+352]
	fadd	QWORD PTR _PsysACT$[esp+352]
	fadd	QWORD PTR _PsysACT_STBY$[esp+352]
	fadd	QWORD PTR _PsysACT_PDN$[esp+352]
	fadd	QWORD PTR _PsysPRE_STBY$[esp+352]
	fadd	QWORD PTR _PsysPRE_PDN$[esp+352]
	fild	DWORD PTR $T697578[esp+352]
	test	ecx, ecx
	jge	SHORT $LN1042@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN1042@doPowerCal:
	fmulp	ST(1), ST(0)
	sub	esp, 8
	fdiv	QWORD PTR $T697582[esp+360]
	fstp	QWORD PTR [esp]
	push	ebx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ebp, ebp
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN802@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN802@doPowerCal
	mov	ebx, 4
$LN802@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	ebx, ebp
	je	SHORT $LN818@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], ebp
	jne	SHORT $LN820@doPowerCal
	or	eax, 4
$LN820@doPowerCal:
	push	ebp
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN818@doPowerCal:

; 657  : 	//Pre(" << k->getPrechargeTime() << "/" << time - powerModel.getLastCalculation() << ")" << endl;
; 658  : 
; 659  : 	os << "-Psys(ACT) ch[" << channelID << "] {"<< setprecision(5) << PsysACT << "} mW" << endl;

	lea	edx, DWORD PTR $T694610[esp+328]
	push	5
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+392]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+340]
	push	OFFSET ??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	cmp	esi, ebp
	jne	SHORT $LN824@doPowerCal
	xor	eax, eax
	jmp	SHORT $LN825@doPowerCal
$LN824@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN825@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysACT$[esp+336]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN830@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN830@doPowerCal
	mov	ebx, 4
$LN830@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	ebx, ebp
	je	SHORT $LN846@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], ebp
	jne	SHORT $LN848@doPowerCal
	or	eax, 4
$LN848@doPowerCal:
	push	ebp
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN846@doPowerCal:

; 660  : 	//tRRD[" << tRRDsch << "]" <<
; 661  : 		//<<Psys(ACT)adjusted {" << setprecision(5) << PsysACTAdjusted << "} mW" << 
; 662  : 	//	endl;
; 663  : 
; 664  : 	os << "-Psys(PRE_STBY) ch[" << channelID << "] {" << setprecision(5) << PsysPRE_STBY << "} mW" << endl;

	lea	edx, DWORD PTR $T694611[esp+328]
	push	5
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+392]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+340]
	push	OFFSET ??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	cmp	esi, ebp
	jne	SHORT $LN852@doPowerCal
	xor	eax, eax
	jmp	SHORT $LN853@doPowerCal
$LN852@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN853@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysPRE_STBY$[esp+336]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN858@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN858@doPowerCal
	mov	ebx, 4
$LN858@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	ebx, ebp
	je	SHORT $LN874@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], ebp
	jne	SHORT $LN876@doPowerCal
	or	eax, 4
$LN876@doPowerCal:
	push	ebp
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN874@doPowerCal:

; 665  : 	//Pre(" << k->getPrechargeTime() << "/" << time - powerModel.getLastCalculation() << ")" << endl;
; 666  : 
; 667  : 	os << "-Psys(RD) ch[" << channelID << "] {" << setprecision(5) << PsysRD << "} mW Psys(RD)adjusted {" << 
; 668  : 		setprecision(5) << PsysRdAdjusted << "} mW " << endl;

	lea	edx, DWORD PTR $T694613[esp+328]
	push	5
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+392]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+340]
	push	OFFSET ??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	cmp	esi, ebp
	jne	SHORT $LN880@doPowerCal
	xor	eax, eax
	jmp	SHORT $LN881@doPowerCal
$LN880@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN881@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	lea	eax, DWORD PTR $T694612[esp+336]
	push	5
	push	eax
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	fld	QWORD PTR _PsysRD$[esp+344]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_0BI@HAJENKCA@?$HN?5mW?5Psys?$CIRD?$CJadjusted?5?$HL?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	mov	ebx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	cmp	esi, ebp
	jne	SHORT $LN884@doPowerCal
	xor	eax, eax
	jmp	SHORT $LN885@doPowerCal
$LN884@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, esi
$LN885@doPowerCal:
	mov	edx, DWORD PTR [ebx+4]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebx]
	call	eax
	fld	QWORD PTR _PsysRdAdjusted$[esp+336]
	add	esp, 8
	push	OFFSET ??_C@_05NHLFMAO@?$HN?5mW?5?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN890@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN890@doPowerCal
	mov	ebx, 4
$LN890@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	ebx, ebp
	je	SHORT $LN906@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], ebp
	jne	SHORT $LN908@doPowerCal
	or	eax, 4
$LN908@doPowerCal:
	push	ebp
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN906@doPowerCal:

; 669  : // 	cerr << PsysRD * systemConfig.getEpoch() / systemConfig.getDatarate() << " " <<
; 670  : // 		powerModel.getIDD1() << " " <<  ((float)timingSpecification.tRC() / systemConfig.getDatarate()) << " " << powerModel.getVDD() << " " << totalReadHits << endl;
; 671  : 
; 672  : 	os << "-Psys(WR) ch[" << channelID << "] {" << setprecision(5) << PsysWR << "} mW" << endl;

	lea	edx, DWORD PTR $T694614[esp+328]
	push	5
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+392]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+340]
	push	OFFSET ??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	cmp	esi, ebp
	jne	SHORT $LN912@doPowerCal
	xor	eax, eax
	jmp	SHORT $LN913@doPowerCal
$LN912@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN913@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysWR$[esp+336]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN918@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN918@doPowerCal
	mov	ebx, 4
$LN918@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	ebx, ebp
	je	SHORT $LN934@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], ebp
	jne	SHORT $LN936@doPowerCal
	or	eax, 4
$LN936@doPowerCal:
	push	ebp
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN934@doPowerCal:

; 673  : 
; 674  : 	// report these results
; 675  : 	if (dbReporting)

	cmp	BYTE PTR [edi+396], 0
	je	$LN1@doPowerCal

; 676  : 	{
; 677  : 		boost::thread(boost::bind(&DRAMsimII::Channel::sendPower,this,PsysRD, PsysWR, rankArray, PsysACTSTBYArray, PsysACTArray, systemTime));

	sub	esp, 112				; 00000070H
	mov	DWORD PTR $T694616[esp+440], esp
	mov	esi, esp
	sub	esp, 24					; 00000018H
	mov	edx, esp
	mov	DWORD PTR $T694617[esp+464], esp
	lea	eax, DWORD PTR _PsysACTArray$[esp+464]
	push	eax
	push	edx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+496], 3
	mov	ecx, esp
	mov	DWORD PTR $T694618[esp+488], esp
	lea	edx, DWORD PTR _PsysACTSTBYArray$[esp+488]
	push	edx
	push	ecx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+520], 4
	mov	eax, esp
	mov	DWORD PTR $T694619[esp+512], esp
	lea	ecx, DWORD PTR _rankArray$[esp+512]
	push	ecx
	push	eax
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	fld	QWORD PTR _PsysWR$[esp+512]
	mov	edx, DWORD PTR _systemTime$[esp+512]
	mov	eax, DWORD PTR _systemTime$[esp+508]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	mov	BYTE PTR __$EHRec$[esp+536], 2
	fld	QWORD PTR _PsysRD$[esp+528]
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	push	edi
	push	esi
	call	??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
	add	esp, 104				; 00000068H
	lea	ecx, DWORD PTR $T694615[esp+440]
	push	ecx
	call	??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
	lea	ecx, DWORD PTR $T694615[esp+328]
	call	??1thread@boost@@QAE@XZ			; boost::thread::~thread
$LN1@doPowerCal:

; 678  : 	}
; 679  : 
; 680  : 	//////////////////////////////////////////////////////////////////////////
; 681  : 	// do speculative power calcs that leave out cache hits
; 682  : 
; 683  : 
; 684  : 	// no total power calcs for now
; 685  : #if 0
; 686  : 	powerOutStream << "++++++++++++++++++++++ total ++++++++++++++++++++++" << endl;
; 687  : 
; 688  : 	PsysACTTotal = 0;
; 689  : 
; 690  : 	for (vector<Rank>::const_iterator k = rank.begin(); k != rank.end(); k++)
; 691  : 	{
; 692  : 		unsigned perRankRASCount = 1;
; 693  : 
; 694  : 		for (vector<Bank>::const_iterator l = k->bank.begin(); l != k->bank.end(); l++)
; 695  : 		{
; 696  : 			entireRAS += l->getTotalRASCount();
; 697  : 			entireCAS += l->getTotalCASCount();
; 698  : 			entireCASW += l->getTotalCASWCount();
; 699  : 			perRankRASCount += l->getTotalRASCount();
; 700  : 		}
; 701  : 
; 702  : 		float percentActive = 1.0F - (double)(k->getTotalPrechargeTime())/(double)time;
; 703  : 
; 704  : 		powerOutStream << "+Psys(ACT_STBY) ch[" << channelID << "] r[" << k->getRankID() << "] {" << setprecision(5) <<
; 705  : 			powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getIDD3N() * powerModel.getVDDmax() * percentActive << "} mW P(" << k->getTotalPrechargeTime() << "/" << time  << ")" << endl;
; 706  : 
; 707  : 		float tRRDsch = ((double)time) / perRankRASCount;
; 708  : 
; 709  : 		powerOutStream << "+Psys(ACT) ch[" << channelID << "] r[" << k->getRankID() << "] {"<< setprecision(5) <<
; 710  : 			powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT() << "} mW" << endl;
; 711  : 
; 712  : 		PsysACTTotal += powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 713  : 	}
; 714  : 
; 715  : 	double RDschPct = entireCAS * timingSpecification.tBurst() / (double)(time);
; 716  : 	double WRschPct = entireCAS * timingSpecification.tBurst() / (double)(time);
; 717  : 
; 718  : 	//cerr << RDschPct * 100 << "%\t" << WRschPct * 100 << "%"<< endl;
; 719  : 
; 720  : 	powerOutStream << "+Psys(ACT) ch[" << channelID << "] " << setprecision(5) <<
; 721  : 		PsysACTTotal << " mW" << endl;
; 722  : 
; 723  : 	powerOutStream << "+Psys(RD) ch[" << channelID << "] {" << setprecision(5) <<
; 724  : 		powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * (powerModel.getIDD4R() - powerModel.getIDD3N()) * RDschPct << "} mW" << endl;
; 725  : 
; 726  : 	powerOutStream << "+Psys(WR) ch[" << channelID << "] {" << setprecision(5) <<
; 727  : 		powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * (powerModel.getIDD4W() - powerModel.getIDD3N()) * WRschPct << "} mW" << endl;
; 728  : #endif
; 729  : 	powerModel.setLastCalculation(time);

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+388], eax

; 730  : }

	mov	eax, DWORD PTR _PsysACTArray$[esp+340]
	mov	DWORD PTR [edi+384], edx
	cmp	eax, ebp
	je	SHORT $LN945@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN945@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTArray$[esp+328]
	push	ecx
	mov	DWORD PTR _PsysACTArray$[esp+344], ebp
	mov	DWORD PTR _PsysACTArray$[esp+348], ebp
	mov	DWORD PTR _PsysACTArray$[esp+352], ebp
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+344]
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN960@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN960@doPowerCal:
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+328]
	push	edx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+344], ebp
	mov	DWORD PTR _PsysACTSTBYArray$[esp+348], ebp
	mov	DWORD PTR _PsysACTSTBYArray$[esp+352], ebp
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _rankArray$[esp+344]
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN975@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN975@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+328]
	push	eax
	mov	DWORD PTR _rankArray$[esp+344], ebp
	mov	DWORD PTR _rankArray$[esp+348], ebp
	mov	DWORD PTR _rankArray$[esp+352], ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+328]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 312				; 00000138H
	ret	12					; 0000000cH
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _rankArray$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$1:
	lea	esi, DWORD PTR _PsysACTSTBYArray$[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$2:
	lea	esi, DWORD PTR _PsysACTArray$[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$3:
	mov	esi, DWORD PTR $T694617[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z$4:
	mov	esi, DWORD PTR $T694618[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-312]
	mov	ecx, DWORD PTR [edx-316]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z
	jmp	___CxxFrameHandler3
?doPowerCalculation@Channel@DRAMsimII@@QAEX_JAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ENDP ; DRAMsimII::Channel::doPowerCalculation
PUBLIC	??0Channel@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$4
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T698433 = -440						; size = 424
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??0Channel@DRAMsimII@@QAE@ABV01@@Z PROC			; DRAMsimII::Channel::Channel

; 150  : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 428				; 000001acH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+456]
	mov	ebx, DWORD PTR _this$[esp+456]
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], edx
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], eax
	mov	ecx, DWORD PTR [ebp+24]
	lea	edx, DWORD PTR [ebp+112]
	mov	DWORD PTR [ebx+24], ecx
	push	edx
	lea	eax, DWORD PTR [ebx+112]
	lea	edi, DWORD PTR [ebx+28]
	lea	esi, DWORD PTR [ebp+28]
	mov	ecx, 21					; 00000015H
	push	eax
	rep movsd
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebp+152]
	push	ecx
	lea	edx, DWORD PTR [ebx+152]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+476], 0
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	BYTE PTR __$EHRec$[esp+468], 1
	mov	eax, DWORD PTR [ebp+176]
	mov	DWORD PTR [ebx+176], eax
	mov	ecx, DWORD PTR [ebp+180]
	mov	DWORD PTR [ebx+180], ecx
	lea	esi, DWORD PTR [ebp+184]
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 52					; 00000034H
	rep movsd
	mov	edx, DWORD PTR [ebp+392]
	mov	DWORD PTR [ebx+392], edx
	mov	al, BYTE PTR [ebp+396]
	mov	BYTE PTR [ebx+396], al
	mov	ecx, DWORD PTR [ebp+416]
	sub	ecx, DWORD PTR [ebp+412]
	add	ebp, 400				; 00000190H
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN8@Channel@3
	call	__invalid_parameter_noinfo
$LN8@Channel@3:
	mov	eax, DWORD PTR [ebx+180]
	mov	ecx, DWORD PTR [ebx+176]
	mov	edx, DWORD PTR [ebp+12]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T698433[esp+468]
	push	eax
	lea	ecx, DWORD PTR [ebx+28]
	call	??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Rank::Rank
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+468], 2
	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx
	push	eax
	lea	esi, DWORD PTR [ebx+400]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	ecx, DWORD PTR $T698433[esp+460]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+472], 4
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+424]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN35@Channel@3
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN36@Channel@3
$LN35@Channel@3:
	xor	eax, eax
$LN36@Channel@3:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 151  : 	// TODO: copy over values incomingTransaction ranks now that reference members are init
; 152  : 	// assign an id to each channel (normally done with commands)
; 153  : 	rank = rhs.rank;

	push	ebp
	mov	BYTE PTR __$EHRec$[esp+472], 5
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 154  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 440				; 000001b8H
	ret	8
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$2:
	lea	eax, DWORD PTR $T698433[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 400				; 00000190H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 424				; 000001a8H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-444]
	mov	ecx, DWORD PTR [edx-448]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABV01@@Z ENDP			; DRAMsimII::Channel::Channel
PUBLIC	??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$2
__ehfuncinfo$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_settings$ = 12						; size = 4
_sysConf$ = 16						; size = 4
_stats$ = 20						; size = 4
_power$ = 24						; size = 4
_newRank$ = 28						; size = 4
??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z PROC ; DRAMsimII::Channel::Channel
; _timing$ = edx

; 129  : {}

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+28]
	xor	ebp, ebp
	mov	esi, edx
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	DWORD PTR [ebx+8], ebp
	mov	DWORD PTR [ebx+12], ebp
	mov	DWORD PTR [ebx+16], ebp
	mov	DWORD PTR [ebx+20], ebp
	mov	DWORD PTR [ebx+24], ebp
	lea	edi, DWORD PTR [ebx+28]
	mov	ecx, 21					; 00000015H
	push	ebp
	lea	eax, DWORD PTR [ebx+112]
	rep movsd
	push	eax
	xor	ecx, ecx
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebx+152]
	push	ecx
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	edx, DWORD PTR _sysConf$[esp+28]
	mov	eax, DWORD PTR _stats$[esp+28]
	mov	esi, DWORD PTR _power$[esp+28]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ebx+180], eax
	mov	eax, DWORD PTR _newRank$[esp+28]
	mov	DWORD PTR [ebx+176], edx
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 52					; 00000034H
	rep movsd
	mov	ecx, DWORD PTR _settings$[esp+28]
	mov	DWORD PTR [ebx+392], -1
	mov	dl, BYTE PTR [ecx+291]
	push	eax
	lea	ecx, DWORD PTR [ebx+400]
	push	ecx
	mov	BYTE PTR [ebx+396], dl
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	push	4
	mov	BYTE PTR __$EHRec$[esp+44], 2
	lea	esi, DWORD PTR [ebx+424]
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN27@Channel@4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN28@Channel@4
$LN27@Channel@4:
	xor	eax, eax
$LN28@Channel@4:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+28], ebp
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 400				; 00000190H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__ehhandler$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z ENDP ; DRAMsimII::Channel::Channel
PUBLIC	??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$5
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T698988 = -440						; size = 4
$T698993 = -436						; size = 424
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
_systemConfig$ = 16					; size = 4
_stats$ = 20						; size = 4
??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::Channel::Channel

; 106  : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 428				; 000001acH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+456]
	mov	ebx, DWORD PTR _this$[esp+456]
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], edx
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], eax
	cmp	DWORD PTR [ebp+24], 0
	je	SHORT $LN5@Channel@5
	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T698988[esp+460], eax
	mov	DWORD PTR __$EHRec$[esp+468], 0
	test	eax, eax
	je	SHORT $LN3@Channel@5
	mov	ecx, DWORD PTR [ebp+24]
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR __$EHRec$[esp+468], -1
	jmp	SHORT $LN6@Channel@5
$LN3@Channel@5:
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+468], -1
	jmp	SHORT $LN6@Channel@5
$LN5@Channel@5:
	xor	eax, eax
$LN6@Channel@5:
	mov	DWORD PTR [ebx+24], eax
	lea	edx, DWORD PTR [ebp+112]
	push	edx
	lea	eax, DWORD PTR [ebx+112]
	lea	edi, DWORD PTR [ebx+28]
	lea	esi, DWORD PTR [ebp+28]
	mov	ecx, 21					; 00000015H
	push	eax
	rep movsd
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebp+152]
	push	ecx
	lea	edx, DWORD PTR [ebx+152]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+476], 1
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	ecx, DWORD PTR _stats$[esp+456]
	mov	eax, DWORD PTR _systemConfig$[esp+456]
	mov	BYTE PTR __$EHRec$[esp+468], 2
	mov	DWORD PTR [ebx+180], ecx
	mov	DWORD PTR [ebx+176], eax
	lea	esi, DWORD PTR [ebp+184]
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 52					; 00000034H
	rep movsd
	mov	edx, DWORD PTR [ebp+392]
	mov	DWORD PTR [ebx+392], edx
	mov	al, BYTE PTR [ebp+396]
	mov	BYTE PTR [ebx+396], al
	mov	ecx, DWORD PTR [ebp+416]
	sub	ecx, DWORD PTR [ebp+412]
	add	ebp, 400				; 00000190H
	mov	eax, 1296593901				; 4d4873edH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN15@Channel@5
	call	__invalid_parameter_noinfo
$LN15@Channel@5:
	mov	eax, DWORD PTR _stats$[esp+456]
	mov	esi, DWORD PTR _systemConfig$[esp+456]
	mov	edx, DWORD PTR [ebp+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR $T698993[esp+468]
	push	ecx
	lea	ecx, DWORD PTR [ebx+28]
	call	??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Rank::Rank
	mov	BYTE PTR __$EHRec$[esp+468], 3
	mov	ecx, DWORD PTR [esi+360]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [ebx+400]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	edx, DWORD PTR $T698993[esp+460]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+472], 5
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+424]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN42@Channel@5
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN43@Channel@5
$LN42@Channel@5:
	xor	eax, eax
$LN43@Channel@5:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 107  : 	// to fill incomingTransaction the values
; 108  : 	rank = rhs.rank;

	push	ebp
	mov	BYTE PTR __$EHRec$[esp+472], 6
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 109  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 440				; 000001b8H
	ret	16					; 00000010H
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	esi, DWORD PTR $T698988[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3:
	lea	eax, DWORD PTR $T698993[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 400				; 00000190H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 424				; 000001a8H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-444]
	mov	ecx, DWORD PTR [edx-448]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::Channel::Channel
; Function compile flags: /Ogtpy
;	COMDAT ??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ
text$yd	SEGMENT
??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ PROC ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction'', COMDAT
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A, OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ ENDP ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction''
__6	DB	01H DUP (?)
	ALIGN	4

__3	DB	01H DUP (?)
	ALIGN	4

__4	DB	01H DUP (?)
	ALIGN	4

__1	DB	01H DUP (?)
	ALIGN	4

__8	DB	01H DUP (?)
	ALIGN	4

__5	DB	01H DUP (?)
	ALIGN	4

__7	DB	01H DUP (?)
	ALIGN	4

__2	DB	01H DUP (?)
	ALIGN	4

__9	DB	01H DUP (?)
END
