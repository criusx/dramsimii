; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\fbdChannel.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::fbdChannel::minProtocolGap
PUBLIC	??_R4fbdChannel@DRAMsimII@@6B@			; DRAMsimII::fbdChannel::`RTTI Complete Object Locator'
PUBLIC	??_R3fbdChannel@DRAMsimII@@8			; DRAMsimII::fbdChannel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2fbdChannel@DRAMsimII@@8			; DRAMsimII::fbdChannel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EN@Channel@DRAMsimII@@8		; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,77)'
PUBLIC	??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8		; DRAMsimII::fbdChannel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfbdChannel@DRAMsimII@@@8		; DRAMsimII::fbdChannel `RTTI Type Descriptor'
PUBLIC	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
PUBLIC	??$?0PAVfbdFrame@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::fbdFrame *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
PUBLIC	??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy
PUBLIC	??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::fbdFrame * *>
PUBLIC	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
PUBLIC	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
PUBLIC	??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
PUBLIC	??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill
PUBLIC	?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n
PUBLIC	??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::fbdFrame *>
PUBLIC	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
PUBLIC	?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity
PUBLIC	?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::fbdFrame *>::max_size
PUBLIC	?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
PUBLIC	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEPAPAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::fbdFrame * *>
PUBLIC	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
PUBLIC	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
PUBLIC	??$_Uninit_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Uninit_move@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve
PUBLIC	?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull
PUBLIC	??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
PUBLIC	??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy
PUBLIC	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
PUBLIC	??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
PUBLIC	??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==
PUBLIC	??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
PUBLIC	??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
PUBLIC	??1fbdChannel@DRAMsimII@@UAE@XZ			; DRAMsimII::fbdChannel::~fbdChannel
PUBLIC	??_GfbdChannel@DRAMsimII@@UAEPAXI@Z		; DRAMsimII::fbdChannel::`scalar deleting destructor'
PUBLIC	?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandA
PUBLIC	?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandC
PUBLIC	?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandAType
PUBLIC	?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandBType
PUBLIC	?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandCType
PUBLIC	??_GfbdFrame@DRAMsimII@@QAEPAXI@Z		; DRAMsimII::fbdFrame::`scalar deleting destructor'
PUBLIC	??$min@_J@std@@YAAB_JAB_J0@Z			; std::min<__int64>
PUBLIC	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
PUBLIC	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
PUBLIC	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
PUBLIC	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
PUBLIC	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
PUBLIC	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
PUBLIC	?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read
PUBLIC	?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandA
PUBLIC	?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandB
PUBLIC	?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandC
PUBLIC	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ	; DRAMsimII::fbdFrame::getExecuteTime
PUBLIC	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@ ; `string'
PUBLIC	??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@ ; `string'
PUBLIC	??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@ ; `string'
PUBLIC	??_7fbdChannel@DRAMsimII@@6B@			; DRAMsimII::fbdChannel::`vftable'
EXTRN	??_EfbdChannel@DRAMsimII@@UAEPAXI@Z:PROC	; DRAMsimII::fbdChannel::`vector deleting destructor'
;	COMDAT ??_7fbdChannel@DRAMsimII@@6B@
CONST	SEGMENT
??_7fbdChannel@DRAMsimII@@6B@ DD FLAT:??_R4fbdChannel@DRAMsimII@@6B@ ; DRAMsimII::fbdChannel::`vftable'
	DD	FLAT:?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ
	DD	FLAT:?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:??_EfbdChannel@DRAMsimII@@UAEPAXI@Z
	DD	FLAT:?nextTick@Channel@DRAMsimII@@UBE_JXZ
	DD	FLAT:?moveToTime@Channel@DRAMsimII@@UAEX_J@Z
CONST	ENDS
;	COMDAT ??_R4fbdChannel@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4fbdChannel@DRAMsimII@@6B@ DD 00H			; DRAMsimII::fbdChannel::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfbdChannel@DRAMsimII@@@8
	DD	FLAT:??_R3fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R3fbdChannel@DRAMsimII@@8 DD 00H			; DRAMsimII::fbdChannel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R2fbdChannel@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8 ; DRAMsimII::fbdChannel::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EN@Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EN@Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EN@Channel@DRAMsimII@@8 DD FLAT:??_R0?AVChannel@DRAMsimII@@@8 ; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,77)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8 DD FLAT:??_R0?AVfbdChannel@DRAMsimII@@@8 ; DRAMsimII::fbdChannel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfbdChannel@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVfbdChannel@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::fbdChannel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfbdChannel@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@
CONST	SEGMENT
??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@ DB 'Serious pro'
	DB	'blems. RAS not followed by CAS.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
CONST	SEGMENT
??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@ DB 'Did not f'
	DB	'ind a CAS or RAS command when it was expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@
CONST	SEGMENT
??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@ DB 'Serious pro'
	DB	'blems. RAS not followed by CAS', 00H	; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::fbdFrame * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@3
	push	esi
	npad	7
$LL3@Fill_n@3:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@3
	pop	esi
$LN1@Fill_n@3:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::fbdFrame * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEPAPAVfbdFrame@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEPAPAVfbdFrame@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEPAPAVfbdFrame@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@4
	push	esi
	npad	7
$LL9@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@4
	pop	esi
$LN7@Fill_n@4:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z PROC ; std::_Iter_cat<DRAMsimII::fbdFrame * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ENDP ; std::_Iter_cat<DRAMsimII::fbdFrame * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@3
	push	esi
	npad	7
$LL13@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@3
	pop	esi
$LN11@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z PROC ; std::_Move_cat<DRAMsimII::fbdFrame * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ENDP ; std::_Move_cat<DRAMsimII::fbdFrame * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@2
	push	esi
	npad	7
$LL15@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@2
	pop	esi
$LN13@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVfbdFrame@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0PAVfbdFrame@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::fbdFrame *>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0PAVfbdFrame@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@4
	push	esi
	npad	7
$LL19@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@4
	pop	esi
$LN17@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$min@_J@std@@YAAB_JAB_J0@Z
_TEXT	SEGMENT
??$min@_J@std@@YAAB_JAB_J0@Z PROC			; std::min<__int64>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN3@min@3
	jl	SHORT $LN4@min@3
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min@3
$LN3@min@3:
	mov	eax, ecx
$LN4@min@3:

; 3400 : 	}

	ret	0
??$min@_J@std@@YAAB_JAB_J0@Z ENDP			; std::min<__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::fbdFrame *>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::fbdFrame *>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill
	push	ebx
	npad	7
$LL21@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill
	pop	ebx
$LN26@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@8
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@8:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull, COMDAT
; _this$ = eax

; 369  : 			return (entry.size() == count);

	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [eax+24]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax]
	sete	dl
	mov	al, dl

; 370  : 		}

	ret	0
?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull
_TEXT	ENDS
PUBLIC	?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z	; DRAMsimII::fbdChannel::executeFrame
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
_TEXT	SEGMENT
?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z PROC	; DRAMsimII::fbdChannel::executeFrame

; 463  : 	return true;

	mov	al, 1

; 464  : }

	ret	0
?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ENDP	; DRAMsimII::fbdChannel::executeFrame
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GfbdFrame@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GfbdFrame@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::fbdFrame::`scalar deleting destructor', COMDAT
; _this$ = esi
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $LN109@scalar
	push	esi
	mov	ecx, OFFSET ?freeFramePool@fbdFrame@DRAMsimII@@0V?$Queue@VfbdFrame@DRAMsimII@@@2@A ; DRAMsimII::fbdFrame::freeFramePool
	call	?releaseItem@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEXPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::releaseItem
$LN109@scalar:
	mov	eax, esi
	ret	4
??_GfbdFrame@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::fbdFrame::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.h
_TEXT	ENDS
;	COMDAT ?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandCType, COMDAT
; _this$ = eax

; 88   : 		Command::CommandType getCommandCType() const { return commandSlotType[2]; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandCType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandBType, COMDAT
; _this$ = eax

; 87   : 		Command::CommandType getCommandBType() const { return commandSlotType[1]; }

	mov	eax, DWORD PTR [eax+20]
	ret	0
?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandBType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandAType, COMDAT
; _this$ = eax

; 86   : 		Command::CommandType getCommandAType() const { return commandSlotType[0]; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandAType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandC, COMDAT
; _this$ = eax

; 80   : 		Command* getCommandC() const { return (Command*)slots[2]; }

	mov	eax, DWORD PTR [eax+12]
	ret	0
?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandB, COMDAT
; _this$ = eax

; 79   : 		Command* getCommandB() const { return (Command*)slots[1]; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandB
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandA, COMDAT
; _this$ = eax

; 78   : 		Command* getCommandA() const { return (Command*)slots[0]; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandA
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::fbdFrame::getExecuteTime, COMDAT
; _this$ = ecx

; 76   : 		tick getExecuteTime() const { return executeTime; }

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	ret	0
?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::fbdFrame::getExecuteTime
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@19
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@19:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@2
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@2:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVfbdFrame@DRAMsimII@@PAPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVfbdFrame@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z
_TEXT	SEGMENT
$T337456 = -16						; size = 4
$T337448 = -12						; size = 12
??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z PROC ; std::_Allocate<DRAMsimII::fbdFrame *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@16

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T337456[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T337448[esp+20]
	mov	DWORD PTR $T337456[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T337448[esp+20]
	push	ecx
	mov	DWORD PTR $T337448[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@16:
$LN1@Allocate@16:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@16:
??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::fbdFrame *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@2
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@2:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@7
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@7
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@87
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@87
$LN1@operator@87:
	call	__invalid_parameter_noinfo
$LN2@operator@87:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@4
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@4
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@4
$LN3@Vector_ite@4:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@4:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T337728 = -16						; size = 4
$T337734 = -12						; size = 12
?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@7
	xor	ecx, ecx
$LN3@allocate@7:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@7:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@7
	lea	eax, DWORD PTR $T337728[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T337734[esp+20]
	mov	DWORD PTR $T337728[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T337734[esp+20]
	push	ecx
	mov	DWORD PTR $T337734[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@7:
$LN11@allocate@7:
	int	3
?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@13

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@13:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@88
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@88
$LN3@operator@88:
	call	__invalid_parameter_noinfo
$LN4@operator@88:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@89
	call	__invalid_parameter_noinfo
$LN1@operator@89:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@90
	call	__invalid_parameter_noinfo
$LN1@operator@90:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@8
	call	__invalid_parameter_noinfo
$LN6@end@8:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@10
	call	__invalid_parameter_noinfo
$LN6@begin@10:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@11:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z
_TEXT	SEGMENT
?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read, COMDAT
; _this$ = esi
; _offset$ = ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN2@read@6
	test	ecx, ecx
	jl	SHORT $LN2@read@6

; 258  : 			else
; 259  : 				return entry[(head + offset) % entry.size()];

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN8@read@6
	call	__invalid_parameter_noinfo
$LN8@read@6:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 260  : 		}

	ret	0
$LN2@read@6:

; 257  : 				return NULL;

	xor	eax, eax

; 260  : 		}

	ret	0
?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ
_TEXT	SEGMENT
?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front, COMDAT
; _this$ = esi

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN8@front
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
$LN8@front:

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ
_TEXT	SEGMENT
?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop, COMDAT
; _this$ = esi

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN2@pop@2

; 202  : 			}
; 203  : 		}

	ret	0
$LN2@pop@2:

; 190  : 				return NULL;
; 191  : 			else
; 192  : 			{
; 193  : 				count--;

	dec	eax
	mov	DWORD PTR [esi], eax

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN5@pop@2
	call	__invalid_parameter_noinfo
$LN5@pop@2:
	mov	ecx, DWORD PTR [esi+24]

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@pop@2
	call	__invalid_parameter_noinfo
$LN10@pop@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 198  : 
; 199  : 				head = (head + 1) % entry.size();	//advance head_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	pop	edi

; 200  : 
; 201  : 				return item;

	mov	eax, ebx
	pop	ebx
	mov	DWORD PTR [esi+4], edx

; 202  : 			}
; 203  : 		}

	ret	0
?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
_TEXT	ENDS
PUBLIC	?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ ; DRAMsimII::fbdChannel::getNextFrame
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
_TEXT	SEGMENT
?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ PROC ; DRAMsimII::fbdChannel::getNextFrame
; _this$ = eax

; 335  : {

	push	esi

; 336  : 	assert(frameQueue.front()->getExecuteTime() == time);
; 337  : 	return frameQueue.pop();

	mov	esi, eax
	add	esi, 424				; 000001a8H
	call	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
	pop	esi

; 338  : }

	ret	0
?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ ENDP ; DRAMsimII::fbdChannel::getNextFrame
_TEXT	ENDS
PUBLIC	?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ ; DRAMsimII::fbdChannel::nextFrameExecuteTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ PROC ; DRAMsimII::fbdChannel::nextFrameExecuteTime
; _this$ = esi

; 330  : 	assert(frameQueue.front()->getExecuteTime() > time);
; 331  : 	return frameQueue.front()->getExecuteTime();

	mov	eax, DWORD PTR [esi+452]
	sub	eax, DWORD PTR [esi+448]
	push	edi
	mov	edi, DWORD PTR [esi+428]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN5@nextFrameE
	call	__invalid_parameter_noinfo
$LN5@nextFrameE:
	mov	ecx, DWORD PTR [esi+448]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	pop	edi

; 332  : }

	ret	0
?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ ENDP ; DRAMsimII::fbdChannel::nextFrameExecuteTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.h
_TEXT	ENDS
;	COMDAT ?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandC, COMDAT
; _this$ = edx
; _value$ = eax

; 68   : 			slots[2] = value;
; 69   : 			if (!value)
; 70   : 				commandSlotType[2] = Command::DATA_COMMAND;
; 71   : 			else
; 72   : 				commandSlotType[2] = value->getCommandType();

	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+24], ecx

; 73   : 		}

	ret	0
?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandB, COMDAT
; _this$ = edx
; _value$ = eax

; 59   : 			slots[1] = value; 
; 60   : 			if (!value)
; 61   : 				// assume that an empty command is data
; 62   : 				commandSlotType[1] = Command::DATA_COMMAND;
; 63   : 			else
; 64   : 				commandSlotType[1] = value->getCommandType();

	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+20], ecx

; 65   : 		}

	ret	0
?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandB
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandA, COMDAT
; _this$ = edx
; _value$ = eax

; 50   : 			slots[0] = value;
; 51   : 			if (!value)
; 52   : 				// can be empty or a command, but never data
; 53   : 				commandSlotType[0] = Command::INVALID_COMMAND;
; 54   : 			else
; 55   : 				commandSlotType[0] = value->getCommandType();

	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+16], ecx

; 56   : 		}

	ret	0
?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandA
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@188
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@188
$LN13@operator@188:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@188
$LN9@operator@188:
	xor	eax, eax
$LN10@operator@188:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@188
	call	__invalid_parameter_noinfo
$LN14@operator@188:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@17
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@17:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@189
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@189
$LN15@operator@189:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@189
$LN11@operator@189:
	xor	eax, eax
$LN12@operator@189:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@189
	call	__invalid_parameter_noinfo
$LN16@operator@189:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@10
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@10:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@190
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@190
$LN17@operator@190:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@190
$LN13@operator@190:
	xor	eax, eax
$LN14@operator@190:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@190
	call	__invalid_parameter_noinfo
$LN18@operator@190:
	add	DWORD PTR [esi+4], 4

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = eax

; 62   : 	_Vector_const_iterator()

	mov	DWORD PTR [eax], 0

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax+4], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$0
__ehfuncinfo$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ PROC	; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>, COMDAT

; 103  : 		{

	push	-1
	push	__ehhandler$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
$LL7@Queue:

; 104  : 			while (T* value = pop())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN187@Queue
	mov	edi, DWORD PTR [esi+4]
	dec	eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN19@Queue
	call	__invalid_parameter_noinfo
$LN19@Queue:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN24@Queue
	call	__invalid_parameter_noinfo
$LN24@Queue:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	DWORD PTR [esi+4], edx
	test	ebp, ebp
	je	SHORT $LN187@Queue

; 105  : 			{
; 106  : 				if (pool)

	cmp	BYTE PTR [esi+36], 0

; 107  : 					::delete value;

	push	ebp
	je	SHORT $LN5@Queue
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 				else

	jmp	SHORT $LL7@Queue
$LN5@Queue:

; 109  : 					delete value;			

	mov	ecx, OFFSET ?freeFramePool@fbdFrame@DRAMsimII@@0V?$Queue@VfbdFrame@DRAMsimII@@@2@A ; DRAMsimII::fbdFrame::freeFramePool
	call	?releaseItem@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEXPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::releaseItem

; 110  : 			}

	jmp	SHORT $LL7@Queue
$LN187@Queue:

; 111  : 			for (typename std::vector<T*>::iterator i = entry.begin(); i != entry.end(); i++)

	mov	ebp, DWORD PTR [esi+24]
	cmp	ebp, DWORD PTR [esi+28]
	jbe	SHORT $LN116@Queue
	call	__invalid_parameter_noinfo
$LN116@Queue:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, ebp
	npad	7
$LL133@Queue:
	mov	ebp, DWORD PTR [esi+28]
	cmp	DWORD PTR [esi+24], ebp
	jbe	SHORT $LN148@Queue
	call	__invalid_parameter_noinfo
$LN148@Queue:
	mov	eax, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN161@Queue
	cmp	edi, eax
	je	SHORT $LN162@Queue
$LN161@Queue:
	call	__invalid_parameter_noinfo
$LN162@Queue:
	cmp	ebx, ebp
	je	SHORT $LN1@Queue
	test	edi, edi
	jne	SHORT $LN186@Queue
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN140@Queue:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN131@Queue
	call	__invalid_parameter_noinfo
$LN131@Queue:
	add	ebx, 4
	jmp	SHORT $LL133@Queue
$LN186@Queue:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN140@Queue
$LN1@Queue:

; 112  : 				assert(*i == NULL);
; 113  : 		}	

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN174@Queue
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN174@Queue:
	mov	edx, DWORD PTR [esi+12]
	xor	eax, eax
	push	edx
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
__ehhandler$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ENDP	; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
_TEXT	SEGMENT
tv843 = -36						; size = 4
_tRFCGap$139900 = -36					; size = 4
_t_ras_gap$139923 = -32					; size = 4
_tRRDGap$139888 = -32					; size = 4
$T390473 = -28						; size = 4
$T390472 = -28						; size = 4
_t_cas_gap$139925 = -28					; size = 4
_t_cas_gap$139910 = -28					; size = 4
_tRPGap$139885 = -28					; size = 4
tv982 = -24						; size = 4
$T390712 = -24						; size = 8
$T390476 = -24						; size = 4
_t_ras_gap$139908 = -24					; size = 4
_tFAWGap$139895 = -24					; size = 4
$T390475 = -12						; size = 4
$T390474 = -12						; size = 4
$T390471 = -12						; size = 4
$T390470 = -12						; size = 4
$T390468 = -12						; size = 4
_tRCGap$139893 = -12					; size = 4
_min_gap$ = -8						; size = 8
_this_c$ = 8						; size = 4
?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::fbdChannel::minProtocolGap
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H
	push	ebx

; 35   : 	// TODO: also consider commands issued one cycle ago which are not yet executed
; 36   : 	tick min_gap = 0;
; 37   : 
; 38   : 	const unsigned this_rank = this_c->getAddress().getRank();

	mov	ebx, DWORD PTR _this_c$[ebp]
	xor	eax, eax
	push	esi
	mov	esi, ecx

; 39   : 	const Rank &currentRank = rank[this_rank];

	mov	ecx, DWORD PTR [esi+384]
	sub	ecx, DWORD PTR [esi+380]
	mov	DWORD PTR _min_gap$[esp+44], eax
	mov	DWORD PTR _min_gap$[esp+48], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	edi
	mov	edi, DWORD PTR [ebx+60]
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN21@minProtoco
	call	__invalid_parameter_noinfo
$LN21@minProtoco:
	imul	edi, 200				; 000000c8H
	add	edi, DWORD PTR [esi+380]

; 40   : 	const Bank &currentBank = currentRank.bank[this_c->getAddress().getBank()];

	mov	ebx, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebx, ecx
	jb	SHORT $LN30@minProtoco
	call	__invalid_parameter_noinfo
$LN30@minProtoco:

; 41   : 
; 42   : 	int t_al = timingSpecification.tAL();
; 43   : 
; 44   : 	switch(this_c->getCommandType())

	mov	eax, DWORD PTR _this_c$[ebp]
	imul	ebx, 152				; 00000098H
	mov	eax, DWORD PTR [eax+80]
	add	ebx, DWORD PTR [edi+184]
	mov	edx, DWORD PTR [esi+28]
	cmp	eax, 12					; 0000000cH
	ja	$LN1@minProtoco
	movzx	ecx, BYTE PTR $LN173@minProtoco[eax]
	jmp	DWORD PTR $LN181@minProtoco[ecx*4]
$LN12@minProtoco:

; 45   : 	{
; 46   : 	case Command::ACTIVATE:
; 47   : 		{
; 48   : 			// respect t_rp of same bank
; 49   : 			int tRPGap = (int)(currentBank.getLastPrechargeTime() - time) + timingSpecification.tRP();

	mov	eax, DWORD PTR [ebx+72]
	add	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+8]

; 50   : 
; 51   : 			int ras_q_count = currentRank.lastActivateTimes.size();

	mov	ecx, DWORD PTR [edi+164]
	sub	eax, edx
	mov	DWORD PTR tv843[esp+48], edx
	mov	DWORD PTR _tRPGap$139885[esp+48], eax

; 52   : 
; 53   : 			// respect tRRD and tRC of all other banks of same rank
; 54   : 			int tRRDGap;
; 55   : 
; 56   : 			if (ras_q_count == 0)

	test	ecx, ecx
	jne	SHORT $LN11@minProtoco

; 57   : 			{
; 58   : 				tRRDGap = 0;

	mov	DWORD PTR _tRRDGap$139888[esp+48], ecx

; 59   : 			}
; 60   : 			else

	jmp	SHORT $LN10@minProtoco
$LN11@minProtoco:

; 61   : 			{
; 62   : 				// read tail end of ras history
; 63   : 				//tick *last_ras_time = currentRank.lastCommand::ACTIVATETimes.read(ras_q_count - 1);
; 64   : 				const tick lastRASTime = currentRank.lastActivateTimes.back();

	lea	eax, DWORD PTR [edi+148]
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back

; 65   : 				// respect the row-to-row activation delay
; 66   : 				tRRDGap = (int)(lastRASTime - time) + timingSpecification.tRRD();				

	mov	ecx, DWORD PTR [esi+76]
	sub	ecx, DWORD PTR tv843[esp+48]
	mov	edx, DWORD PTR tv843[esp+48]
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _tRPGap$139885[esp+48]
	mov	DWORD PTR _tRRDGap$139888[esp+48], ecx
$LN10@minProtoco:

; 67   : 			}
; 68   : 
; 69   : 			// respect the row cycle time limitation
; 70   : 			int tRCGap = (int)(currentBank.getLastRASTime() - time) + timingSpecification.tRC();

	mov	ebx, DWORD PTR [ebx+48]
	add	ebx, DWORD PTR [esi+60]
	sub	ebx, edx

; 71   : 
; 72   : 			// respect the t_faw value for DDR2 and beyond
; 73   : 			int tFAWGap;
; 74   : 
; 75   : 			if (ras_q_count < 4)

	cmp	DWORD PTR [edi+164], 4
	mov	DWORD PTR _tRCGap$139893[esp+48], ebx
	jge	SHORT $LN9@minProtoco

; 76   : 			{
; 77   : 				tFAWGap = 0;

	xor	ecx, ecx

; 78   : 			}
; 79   : 			else

	jmp	SHORT $LN176@minProtoco
$LN9@minProtoco:

; 80   : 			{
; 81   : 				// read head of ras history
; 82   : 				const tick fourth_ras_time = currentRank.lastActivateTimes.back();

	lea	eax, DWORD PTR [edi+148]
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back

; 83   : 				tFAWGap = (int)(fourth_ras_time - time) + timingSpecification.tFAW();

	mov	ecx, DWORD PTR [esi+52]
	sub	ecx, DWORD PTR tv843[esp+48]
	mov	edx, DWORD PTR tv843[esp+48]
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _tRPGap$139885[esp+48]
$LN176@minProtoco:

; 84   : 			}
; 85   : 
; 86   : 			// respect tRFC
; 87   : 			int tRFCGap = (int)(currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC();

	mov	edi, DWORD PTR [edi+8]
	add	edi, DWORD PTR [esi+68]
	mov	DWORD PTR _tFAWGap$139895[esp+48], ecx
	sub	edi, edx

; 88   : 
; 89   : 			min_gap = max(max(max(tRFCGap,tRCGap) , tRPGap) , max(tRRDGap , tFAWGap));

	cmp	DWORD PTR _tRRDGap$139888[esp+48], ecx
	mov	DWORD PTR _tRFCGap$139900[esp+48], edi
	lea	edx, DWORD PTR _tFAWGap$139895[esp+48]
	jl	SHORT $LN60@minProtoco
	lea	edx, DWORD PTR _tRRDGap$139888[esp+48]
$LN60@minProtoco:
	cmp	edi, ebx
	lea	ecx, DWORD PTR _tRCGap$139893[esp+48]
	jl	SHORT $LN64@minProtoco
	lea	ecx, DWORD PTR _tRFCGap$139900[esp+48]
$LN64@minProtoco:
	cmp	DWORD PTR [ecx], eax
	lea	eax, DWORD PTR _tRPGap$139885[esp+48]
	jl	SHORT $LN68@minProtoco
	mov	eax, ecx
$LN68@minProtoco:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx]
	jge	$LN172@minProtoco
	mov	eax, edx

; 90   : 		}
; 91   : 		break;

	jmp	$LN172@minProtoco
$LN7@minProtoco:

; 92   : 
; 93   : 	case Command::READ_AND_PRECHARGE:
; 94   : 		// Auto precharge will be issued as part of command,
; 95   : 		// but DRAM devices are intelligent enough to delay the prec command
; 96   : 		// until tRAS timing is met, so no need to check tRAS timing requirement here.
; 97   : 
; 98   : 	case Command::READ:
; 99   : 		{
; 100  : 			//respect last ras of same rank
; 101  : 			int t_ras_gap = (int)((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - t_al);
; 102  : 
; 103  : 			// ensure that if no other rank has issued a CAS command that it will treat
; 104  : 			// this as if a CAS command was issued long ago
; 105  : 			//tick other_r_last_cas_time = time - 1000;
; 106  : 			//int other_r_last_cas_length = timingSpecification.tBurst();
; 107  : 			//tick other_r_last_casw_time = time - 1000;
; 108  : 			//int other_r_last_casw_length = timingSpecification.tBurst();
; 109  : 
; 110  : 			// find the most recent cas(w) time and length
; 111  : 			//for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)
; 112  : 			//{
; 113  : 			//	if (rank_id != this_rank)
; 114  : 			//	{
; 115  : 			//		if (rank[rank_id].lastCASTime > other_r_last_cas_time)
; 116  : 			//		{
; 117  : 			//			other_r_last_cas_time = rank[rank_id].lastCASTime;
; 118  : 			//			other_r_last_cas_length = rank[rank_id].lastCASLength;
; 119  : 			//		}
; 120  : 			//		if (rank[rank_id].lastCASWTime > other_r_last_casw_time)
; 121  : 			//		{
; 122  : 			//			other_r_last_casw_time = rank[rank_id].lastCASWTime;
; 123  : 			//			other_r_last_casw_length = rank[rank_id].lastCASWLength;
; 124  : 			//		}
; 125  : 			//	}
; 126  : 			//}
; 127  : 
; 128  : 			//respect last cas of same rank
; 129  : 			// DW 3/9/2006 add these two lines
; 130  : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 131  : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 132  : 			// DW 3/9/2006 replace the line after next with the next line
; 133  : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 134  : 			int t_cas_gap = (int)((currentRank.getLastCASTime() - time) + timingSpecification.tBurst());

	mov	eax, DWORD PTR [edi+24]

; 135  : 
; 136  : 			//respect last cas write of same rank
; 137  : 			// DW 3/9/2006 replace the line after next with the next line
; 138  : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 139  : 			t_cas_gap = max(t_cas_gap,(int)((currentRank.getLastCASWTime() - time) + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR()));

	mov	edi, DWORD PTR [edi+32]
	add	edi, DWORD PTR [esi+92]
	add	edi, DWORD PTR [esi+48]
$LN180@minProtoco:
	mov	ebx, DWORD PTR [ebx+48]
	add	ebx, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+8]
	sub	ebx, ecx
	sub	ebx, edx
	mov	edx, DWORD PTR [esi+32]
	sub	eax, ecx
	sub	edi, ecx
	add	eax, edx
	add	edi, edx
	mov	DWORD PTR _t_cas_gap$139910[esp+48], eax
	cmp	eax, edi
	lea	eax, DWORD PTR $T390468[esp+48]
	mov	DWORD PTR $T390468[esp+48], edi
	mov	DWORD PTR _t_ras_gap$139908[esp+48], ebx
	jl	SHORT $LN92@minProtoco
	lea	eax, DWORD PTR _t_cas_gap$139910[esp+48]
$LN92@minProtoco:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$139910[esp+48], eax

; 140  : 
; 141  : 			//if (rank.size() > 1)
; 142  : 			//{
; 143  : 			//respect most recent cas of different rank
; 144  : 			//	t_cas_gap = max(t_cas_gap,(int)(other_r_last_cas_time + other_r_last_cas_length + timingSpecification.tRTRS() - time));
; 145  : 			//respect timing of READ follow WRITE, different ranks.*/
; 146  : 			//	t_cas_gap = max(t_cas_gap,(int)(other_r_last_casw_time + timingSpecification.tCWD() + other_r_last_casw_length + timingSpecification.tRTRS() - timingSpecification.tCAS() - time));
; 147  : 			//}
; 148  : 			min_gap = max(t_ras_gap,t_cas_gap);

	cmp	ebx, eax
	lea	eax, DWORD PTR _t_cas_gap$139910[esp+48]

; 149  : 
; 150  : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 151  : 		}
; 152  : 		break;

	jmp	$LN178@minProtoco
$LN6@minProtoco:

; 153  : 
; 154  : 	case Command::WRITE_AND_PRECHARGE:
; 155  : 		// Auto precharge will be issued as part of command, so
; 156  : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 157  : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 158  : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 159  : 
; 160  : 	case Command::WRITE:
; 161  : 		{
; 162  : 			//respect last ras of same rank
; 163  : 			int t_ras_gap = (int)((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - t_al);
; 164  : 
; 165  : 			/*tick other_r_last_cas_time = time - 1000;
; 166  : 			int other_r_last_cas_length = timingSpecification.tBurst();
; 167  : 			tick other_r_last_casw_time = time - 1000;
; 168  : 			int other_r_last_casw_length = timingSpecification.tBurst();*/
; 169  : 
; 170  : 			// find the most recent CAS/CASW time and length
; 171  : 			// FIXME: change to use iterators
; 172  : 			/*for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)
; 173  : 			{
; 174  : 			if (rank_id != this_rank)
; 175  : 			{
; 176  : 			if (rank[rank_id].lastCASTime > other_r_last_cas_time)
; 177  : 			{
; 178  : 			other_r_last_cas_time = rank[rank_id].lastCASTime;
; 179  : 			other_r_last_cas_length = rank[rank_id].lastCASLength;
; 180  : 			}
; 181  : 			if (rank[rank_id].lastCASWTime > other_r_last_casw_time)
; 182  : 			{
; 183  : 			other_r_last_casw_time = rank[rank_id].lastCASWTime;
; 184  : 			other_r_last_casw_length = rank[rank_id].lastCASWLength;
; 185  : 			}
; 186  : 			}
; 187  : 			}*/
; 188  : 
; 189  : 			// respect last cas to same rank
; 190  : 			int t_cas_gap = (int)(currentRank.getLastCASTime() - time) + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	eax, DWORD PTR [edi+24]
	sub	eax, DWORD PTR [esi+48]

; 191  : 
; 192  : 			// respect last cas to different ranks
; 193  : 			// not in FBD, each rank is on its own channel
; 194  : 			//t_cas_gap = max(t_cas_gap,(int)(other_r_last_cas_time + timingSpecification.tCAS() + other_r_last_cas_length + timingSpecification.tRTRS() - timingSpecification.tCWD() - time));
; 195  : 
; 196  : 			// respect last cas write to same rank
; 197  : 			t_cas_gap = max(t_cas_gap,(int)(currentRank.getLastCASWTime() - time) + timingSpecification.tBurst());

	mov	edi, DWORD PTR [edi+32]
	add	eax, DWORD PTR [esi+84]
	add	eax, DWORD PTR [esi+36]

; 198  : 
; 199  : 			// respect last cas write to different ranks
; 200  : 			// not in FBD
; 201  : 			//t_cas_gap = max(t_cas_gap,(int)(other_r_last_casw_time + other_r_last_casw_length - time));
; 202  : 
; 203  : 			min_gap = max(t_ras_gap,t_cas_gap);
; 204  : 		}
; 205  : 		break;

	jmp	SHORT $LN180@minProtoco
$LN4@minProtoco:

; 206  : 
; 207  : 	case Command::RETIRE_COMMAND:
; 208  : 		break;
; 209  : 
; 210  : 	case Command::PRECHARGE:
; 211  : 		{
; 212  : 			// respect t_ras of same bank
; 213  : 			int t_ras_gap = (int)(currentBank.getLastRASTime() - time) + timingSpecification.tRAS();

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi+56]

; 214  : 
; 215  : 			// respect t_cas of same bank
; 216  : 			int t_cas_gap = max(0,(int)((currentBank.getLastCASTime() - time) + t_al + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD())));

	mov	edi, DWORD PTR [ebx+60]
	sub	ecx, eax
	mov	DWORD PTR tv843[esp+48], eax
	mov	eax, DWORD PTR [esi+80]
	sub	eax, DWORD PTR [esi+44]
	mov	DWORD PTR $T390712[esp+52], edi
	mov	edi, DWORD PTR [esi+32]
	mov	DWORD PTR $T390471[esp+48], eax
	test	eax, eax
	mov	DWORD PTR _t_ras_gap$139923[esp+48], ecx
	mov	DWORD PTR $T390472[esp+48], 0
	mov	DWORD PTR tv982[esp+48], edi
	lea	eax, DWORD PTR $T390471[esp+48]
	jg	SHORT $LN140@minProtoco
	lea	eax, DWORD PTR $T390472[esp+48]
$LN140@minProtoco:
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR tv843[esp+48]
	mov	DWORD PTR $T390473[esp+48], 0
	add	eax, DWORD PTR [ebx+56]
	add	eax, edi
	add	eax, DWORD PTR [esi+36]
	add	eax, edx
	mov	DWORD PTR $T390470[esp+48], eax
	test	eax, eax
	lea	eax, DWORD PTR $T390470[esp+48]
	jg	SHORT $LN144@minProtoco
	lea	eax, DWORD PTR $T390473[esp+48]
$LN144@minProtoco:
	mov	edi, DWORD PTR [eax]

; 217  : 
; 218  : 			// respect t_casw of same bank
; 219  : 			t_cas_gap = max(t_cas_gap,(int)((currentBank.getLastCASWTime() - time) + t_al + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR()));

	mov	eax, DWORD PTR [ebx+64]
	add	eax, DWORD PTR [esi+88]
	mov	DWORD PTR _t_cas_gap$139925[esp+48], edi
	add	eax, DWORD PTR [esi+48]
	sub	eax, DWORD PTR tv843[esp+48]
	add	eax, DWORD PTR tv982[esp+48]
	add	eax, edx
	mov	DWORD PTR $T390474[esp+48], eax
	cmp	edi, eax
	lea	eax, DWORD PTR $T390474[esp+48]
	jl	SHORT $LN156@minProtoco
	lea	eax, DWORD PTR _t_cas_gap$139925[esp+48]
$LN156@minProtoco:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$139925[esp+48], eax

; 220  : 
; 221  : 			min_gap = max(t_ras_gap,t_cas_gap);

	cmp	ecx, eax
	lea	eax, DWORD PTR _t_cas_gap$139925[esp+48]
	jl	SHORT $LN172@minProtoco
	lea	eax, DWORD PTR _t_ras_gap$139923[esp+48]

; 222  : 		}
; 223  : 		break;

	jmp	SHORT $LN172@minProtoco
$LN2@minProtoco:

; 224  : 
; 225  : 	case Command::PRECHARGE_ALL:
; 226  : 	case Command::ACTIVATE_ALL:
; 227  : 	case Command::DRIVE_COMMAND:
; 228  : 	case Command::DATA_COMMAND:
; 229  : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 230  : 		break;
; 231  : 
; 232  : 	case Command::REFRESH_ALL:
; 233  : 		// respect tRFC and tRP
; 234  : 		min_gap = max((int)((currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC()),(int)((currentRank.getLastPrechargeTime() - time) + timingSpecification.tRP()));

	mov	eax, DWORD PTR [edi+16]
	mov	edi, DWORD PTR [edi+8]
	add	eax, DWORD PTR [esi+72]
	add	edi, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+8]
	sub	eax, ecx
	sub	edi, ecx
	mov	DWORD PTR $T390475[esp+48], eax
	cmp	edi, eax
	mov	DWORD PTR $T390476[esp+48], edi
	lea	eax, DWORD PTR $T390475[esp+48]
$LN178@minProtoco:
	jl	SHORT $LN172@minProtoco
	lea	eax, DWORD PTR $T390476[esp+48]
$LN172@minProtoco:
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[esp+48], eax
	mov	DWORD PTR _min_gap$[esp+52], edx
$LN13@minProtoco:

; 239  : 		break;
; 240  : 	}
; 241  : 
; 242  : #ifdef DEBUG_MIN_PROTOCOL_GAP
; 243  : 	outStream << this_c->commandType;
; 244  : 	outStream << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]" << endl;
; 245  : #endif
; 246  : 
; 247  : 	//return max(min_gap,timingSpecification.tCMD());
; 248  : 	return min_gap;

	mov	eax, DWORD PTR _min_gap$[esp+48]
	mov	edx, DWORD PTR _min_gap$[esp+52]

; 249  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN1@minProtoco:

; 235  : 		break;
; 236  : 
; 237  : 	default:
; 238  : 		exit(-20);

	push	-20					; ffffffecH
	call	_exit
$LN182@minProtoco:
$LN175@minProtoco:
	npad	2
$LN181@minProtoco:

; 249  : }

	DD	$LN12@minProtoco
	DD	$LN7@minProtoco
	DD	$LN6@minProtoco
	DD	$LN13@minProtoco
	DD	$LN4@minProtoco
	DD	$LN2@minProtoco
$LN173@minProtoco:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::fbdChannel::minProtocolGap
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T533935 = -84						; size = 28
$T533934 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T533935[esp+100]
	mov	DWORD PTR $T533935[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T533935[esp+120], 0
	mov	BYTE PTR $T533935[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T533935[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T533934[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T533934[esp+96]
	push	ecx
	mov	DWORD PTR $T533934[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@9:
$LN44@Xlen@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T533935[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T534234 = -4						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 8
	push	ebx
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@3

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
$LN97@reserve@3:
$LN5@reserve@3:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@3
	xor	eax, eax
	jmp	SHORT $LN21@reserve@3
$LN20@reserve@3:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@3:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@3

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@3
	call	__invalid_parameter_noinfo
$LN27@reserve@3:
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T534234[esp+16], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T534234[esp+16]
$LN43@reserve@3:
	sub	edi, ecx
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@3
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@3:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@3

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@3:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@3:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN96@reserve@3:
?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@14

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	ret	0
$LN4@Buy@14:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@14

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
$LN2@Buy@14:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@4
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@4
	call	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
$LN50@Construct_@4:
$LN10@Construct_@4:
	mov	ecx, edi
	call	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@4
	npad	3
$LL42@Construct_@4:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@4
$LN40@Construct_@4:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@4:
	pop	ebp
	pop	ebx

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	ret	4
$LN49@Construct_@4:
?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T563784 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@42
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@42
$LN13@vector@42:
	xor	eax, eax
$LN14@vector@42:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T563784[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T563784[esp+28], ecx
	call	?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1fbdChannel@DRAMsimII@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1fbdChannel@DRAMsimII@@UAE@XZ$0
__ehfuncinfo$??1fbdChannel@DRAMsimII@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1fbdChannel@DRAMsimII@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1fbdChannel@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1fbdChannel@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::fbdChannel::~fbdChannel, COMDAT
	push	-1
	push	__ehhandler$??1fbdChannel@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	lea	eax, DWORD PTR [esi+424]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1fbdChannel@DRAMsimII@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
__ehhandler$??1fbdChannel@DRAMsimII@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1fbdChannel@DRAMsimII@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1fbdChannel@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::fbdChannel::~fbdChannel
; Function compile flags: /Ogtpy
;	COMDAT ??_GfbdChannel@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GfbdChannel@DRAMsimII@@UAEPAXI@Z PROC		; DRAMsimII::fbdChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	esi
	call	??1fbdChannel@DRAMsimII@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@96
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@96:
	mov	eax, esi
	pop	esi
	ret	4
??_GfbdChannel@DRAMsimII@@UAEPAXI@Z ENDP		; DRAMsimII::fbdChannel::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push, COMDAT
; _this$ = eax

; 147  : 		{

	push	ebx
	mov	ebx, DWORD PTR _item$[esp]
	push	esi
	mov	esi, eax

; 148  : 			assert(item != NULL);
; 149  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	cmp	eax, ecx

; 150  : 				return false;

	je	SHORT $LN20@push

; 151  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push

; 152  : 			{
; 153  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN20@push:
	pop	esi

; 154  : 				return false;

	xor	al, al
	pop	ebx

; 162  : 			}
; 163  : 		}

	ret	4
$LN2@push:

; 155  : 			}
; 156  : 			else
; 157  : 			{
; 158  : 				count++;

	inc	eax
	mov	DWORD PTR [esi], eax

; 159  : 				entry[tail] = item;

	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN13@push
	call	__invalid_parameter_noinfo
$LN13@push:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 160  : 				tail = (tail + 1) % entry.size(); 	//advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	pop	edi

; 161  : 				return true;

	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebx

; 162  : 			}
; 163  : 		}

	ret	4
?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.cpp
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0
__ehfuncinfo$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_preallocate$ = 12					; size = 1
??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>, COMDAT
; _size$ = ecx

; 88   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _this$[esp+28]
	xor	ebx, ebx
	lea	esi, DWORD PTR [ebp+12]
	push	esi
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	call	??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	mov	al, BYTE PTR _preallocate$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], ebx

; 89   : 			entry.reserve(size);

	push	edi
	mov	BYTE PTR [ebp+36], al
	call	?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve

; 90   : 
; 91   : 			if (preallocate)

	cmp	BYTE PTR _preallocate$[esp+28], bl
	je	SHORT $LN19@Queue@4

; 92   : 			{
; 93   : 				while (!isFull())

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp]
	je	SHORT $LN19@Queue@4
	lea	edi, DWORD PTR [ebx+16]
$LL2@Queue@4:

; 94   : 				{
; 95   : 					push(::new T());

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN6@Queue@4
	mov	DWORD PTR [eax+40], ebx
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+24], edi
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+16], edi
	jmp	SHORT $LN7@Queue@4
$LN6@Queue@4:
	xor	eax, eax
$LN7@Queue@4:
	push	eax
	mov	eax, ebp
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sar	edx, 2
	cmp	edx, DWORD PTR [ebp]
	jne	SHORT $LL2@Queue@4
$LN19@Queue@4:

; 96   : 				}
; 97   : 			}
; 98   : 		}

	mov	eax, ebp
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
__ehhandler$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>
PUBLIC	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
_TEXT	SEGMENT
_notAllRefresh$140568 = -89				; size = 1
_noPendingRefreshes$140509 = -89			; size = 1
_noPendingRefreshes$140439 = -89			; size = 1
_notAllRefresh$140352 = -89				; size = 1
_candidateCommand$140555 = -88				; size = 4
_oldestCommandTime$140213 = -88				; size = 8
_lastBankID$ = -88					; size = 4
_challengerCommand$140580 = -76				; size = 4
_oldestExecutableBank$140228 = -76			; size = 8
_lastRankID$ = -76					; size = 4
tv5709 = -68						; size = 4
tv5532 = -68						; size = 4
tv5339 = -68						; size = 4
_currentRank$140343 = -68				; size = 8
tv5613 = -60						; size = 4
_transactionType$140485 = -60				; size = 4
tv185 = -60						; size = 4
_transactionType$140414 = -60				; size = 4
_candidateGap$140556 = -56				; size = 4
_originalTransactionType$140508 = -56			; size = 4
tv175 = -56						; size = 4
_originalLastBankID$140437 = -56			; size = 4
$T601923 = -52						; size = 4
$T601568 = -52						; size = 4
_challengerGap$140582 = -52				; size = 4
_originalLastRankID$140506 = -52			; size = 4
_originalLastRankID$140436 = -52			; size = 4
_originalLastBankID$140507 = -48			; size = 4
_originalTransactionType$140438 = -48			; size = 4
_oldestExecutableCommandTime$140216 = -48		; size = 8
_currentRank$140561 = -40				; size = 8
_currentRank$140519 = -40				; size = 8
_currentRank$140449 = -40				; size = 8
_bank_id$140357 = -40					; size = 8
_oldestBank$140223 = -32				; size = 8
_currentBank$140573 = -24				; size = 8
_currentBank$140373 = -24				; size = 8
tv5712 = -16						; size = 8
$T601333 = -8						; size = 8
_this$ = 8						; size = 4
_slotACommand$ = 12					; size = 4
_slotBCommand$ = 16					; size = 4
?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z PROC ; DRAMsimII::fbdChannel::readNextCommand

; 474  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 92					; 0000005cH
	push	ebx
	mov	ebx, DWORD PTR _slotACommand$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[ebp]

; 475  : 	// look at the most recently retired command in this channel's history
; 476  : 
; 477  : 	//const Command *lastCommand = historyQueue.back();
; 478  : 
; 479  : 	unsigned lastBankID = lastCommand ? lastCommand->getAddress().getBank() : systemConfig.getBankCount() - 1;

	mov	eax, DWORD PTR [edi+24]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN123@readNextCo
	mov	ecx, DWORD PTR [eax+64]
	jmp	SHORT $LN124@readNextCo
$LN123@readNextCo:
	mov	ecx, DWORD PTR [edi+176]
	mov	ecx, DWORD PTR [ecx+364]
	dec	ecx
$LN124@readNextCo:
	mov	DWORD PTR _lastBankID$[esp+104], ecx

; 480  : 	unsigned lastRankID = lastCommand ? lastCommand->getAddress().getRank() : systemConfig.getRankCount() - 1;

	cmp	eax, esi
	je	SHORT $LN125@readNextCo
	mov	ecx, DWORD PTR [eax+60]
	jmp	SHORT $LN126@readNextCo
$LN125@readNextCo:
	mov	edx, DWORD PTR [edi+176]
	mov	ecx, DWORD PTR [edx+360]
	dec	ecx
$LN126@readNextCo:
	mov	DWORD PTR _lastRankID$[esp+104], ecx

; 481  : 	const Command::CommandType lastCommandType = lastCommand ? lastCommand->getCommandType() : Command::WRITE_AND_PRECHARGE;

	cmp	eax, esi
	je	SHORT $LN127@readNextCo
	mov	eax, DWORD PTR [eax+80]
	jmp	SHORT $LN128@readNextCo
$LN127@readNextCo:
	mov	eax, 4
$LN128@readNextCo:

; 482  : 
; 483  : 	const int slotARank = slotACommand ? slotACommand->getAddress().getRank() : -1;

	or	edx, -1
	cmp	ebx, esi
	je	SHORT $LN129@readNextCo
	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR tv175[esp+104], ecx
	jmp	SHORT $LN130@readNextCo
$LN129@readNextCo:
	mov	DWORD PTR tv175[esp+104], edx
$LN130@readNextCo:

; 484  : 	const int slotBRank = slotBCommand ? slotBCommand->getAddress().getRank() : -1;

	mov	ecx, DWORD PTR _slotBCommand$[ebp]
	cmp	ecx, esi
	je	SHORT $LN131@readNextCo
	mov	ecx, DWORD PTR [ecx+60]
	mov	DWORD PTR tv185[esp+104], ecx
	jmp	SHORT $LN132@readNextCo
$LN131@readNextCo:
	mov	DWORD PTR tv185[esp+104], edx
$LN132@readNextCo:

; 485  : 
; 486  : 	switch (systemConfig.getCommandOrderingAlgorithm())

	mov	ecx, DWORD PTR [edi+176]
	mov	ecx, DWORD PTR [ecx+288]
	cmp	ecx, 3
	ja	$LN1@readNextCo
	jmp	DWORD PTR $LN1372@readNextCo[ecx*4]
$LN118@readNextCo:

; 487  : 	{
; 488  : 		// this strategy attempts to find the oldest command and returns that to be executed
; 489  : 		// however, if the oldest command cannot be issued, the oldest command that can be executed immediately
; 490  : 		// will be returned instead
; 491  : 	case STRICT_ORDER:
; 492  : 		{
; 493  : 			tick oldestCommandTime = TICK_MAX;
; 494  : 			tick oldestExecutableCommandTime = TICK_MAX;
; 495  : 			vector<Bank>::const_iterator oldestBank;

	mov	DWORD PTR _oldestBank$140223[esp+104], esi
	mov	DWORD PTR _oldestBank$140223[esp+108], esi

; 496  : 			vector<Bank>::const_iterator oldestExecutableBank;

	mov	DWORD PTR _oldestExecutableBank$140228[esp+104], esi

; 497  : 
; 498  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	esi, DWORD PTR [edi+380]
	mov	eax, 2147483647				; 7fffffffH
	xor	ebx, ebx
	mov	DWORD PTR _oldestCommandTime$140213[esp+104], edx
	mov	DWORD PTR _oldestCommandTime$140213[esp+108], eax
	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+104], edx
	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+108], eax
	mov	DWORD PTR _oldestExecutableBank$140228[esp+108], ebx
	cmp	esi, DWORD PTR [edi+384]
	jbe	SHORT $LN176@readNextCo
	call	__invalid_parameter_noinfo
$LN176@readNextCo:
	mov	eax, edi
	mov	edi, DWORD PTR [eax+368]
	mov	DWORD PTR _currentRank$140343[esp+104], edi
$LN1362@readNextCo:
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _currentRank$140343[esp+108], esi
	mov	DWORD PTR $T601568[esp+104], ecx
	cmp	DWORD PTR [eax+380], ecx
	jbe	SHORT $LN204@readNextCo
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _this$[ebp]
$LN204@readNextCo:
	mov	eax, DWORD PTR [eax+368]
	test	edi, edi
	je	SHORT $LN217@readNextCo
	cmp	edi, eax
	je	SHORT $LN218@readNextCo
$LN217@readNextCo:
	call	__invalid_parameter_noinfo
$LN218@readNextCo:
	cmp	esi, DWORD PTR $T601568[esp+104]
	je	$LN115@readNextCo

; 499  : 			{
; 500  : 				// do not consider ranks which have already had a command chosen from them
; 501  : 				if (currentRank->getRankID() == slotARank || currentRank->getRankID() == slotBRank)

	test	edi, edi
	jne	$LN1329@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN236@readNextCo:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN227@readNextCo
	call	__invalid_parameter_noinfo
$LN227@readNextCo:
	mov	edx, DWORD PTR [esi+136]
	cmp	edx, DWORD PTR tv175[esp+104]
	je	$LN116@readNextCo
	test	edi, edi
	jne	$LN1328@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN252@readNextCo:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN243@readNextCo
	call	__invalid_parameter_noinfo
$LN243@readNextCo:
	mov	eax, DWORD PTR [esi+136]
	cmp	eax, DWORD PTR tv185[esp+104]
	je	$LN116@readNextCo

; 502  : 					continue;
; 503  : 
; 504  : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$140352[esp+104], 0

; 505  : 
; 506  : 				for (vector<Bank>::const_iterator bank_id = currentRank->bank.begin(); bank_id != currentRank->bank.end(); bank_id++)

	test	edi, edi
	jne	$LN1327@readNextCo
	call	__invalid_parameter_noinfo
$LN268@readNextCo:
	cmp	esi, DWORD PTR [edi+16]
	jb	SHORT $LN259@readNextCo
	call	__invalid_parameter_noinfo
$LN259@readNextCo:
	mov	edi, DWORD PTR [esi+184]
	cmp	edi, DWORD PTR [esi+188]
	jbe	SHORT $LN274@readNextCo
	call	__invalid_parameter_noinfo
$LN274@readNextCo:
	mov	ebx, DWORD PTR [esi+172]
	mov	DWORD PTR _bank_id$140357[esp+104], ebx
$LN1361@readNextCo:
	mov	eax, DWORD PTR _currentRank$140343[esp+104]
	mov	DWORD PTR _bank_id$140357[esp+108], edi
	test	eax, eax
	jne	$LN1326@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN310@readNextCo:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN301@readNextCo
	call	__invalid_parameter_noinfo
$LN301@readNextCo:
	mov	eax, DWORD PTR [esi+188]
	mov	DWORD PTR $T601923[esp+104], eax
	cmp	DWORD PTR [esi+184], eax
	jbe	SHORT $LN316@readNextCo
	call	__invalid_parameter_noinfo
$LN316@readNextCo:
	mov	eax, DWORD PTR [esi+172]
	test	ebx, ebx
	je	SHORT $LN329@readNextCo
	cmp	ebx, eax
	je	SHORT $LN330@readNextCo
$LN329@readNextCo:
	call	__invalid_parameter_noinfo
$LN330@readNextCo:
	cmp	edi, DWORD PTR $T601923[esp+104]
	je	$LN116@readNextCo

; 507  : 				{
; 508  : 					if (const Command *temp_c = bank_id->front())

	test	ebx, ebx
	jne	$LN1325@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN348@readNextCo:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN339@readNextCo
	call	__invalid_parameter_noinfo
$LN339@readNextCo:
	mov	ecx, DWORD PTR [edi+36]
	sub	ecx, DWORD PTR [edi+32]
	mov	esi, DWORD PTR [edi+12]
	sar	ecx, 2
	cmp	esi, ecx
	jb	SHORT $LN355@readNextCo
	call	__invalid_parameter_noinfo
$LN355@readNextCo:
	mov	edx, DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [edx+esi*4]
	test	ebx, ebx
	je	$LN111@readNextCo

; 509  : 					{
; 510  : 						if ((temp_c->getEnqueueTime() < oldestExecutableCommandTime) && (minProtocolGap(temp_c) <= timingSpecification.tCMD()))

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR _oldestExecutableCommandTime$140216[esp+108]
	jg	$LN111@readNextCo
	jl	SHORT $LN1337@readNextCo
	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, DWORD PTR _oldestExecutableCommandTime$140216[esp+104]
	jae	$LN111@readNextCo
$LN1337@readNextCo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+44]
	push	ebx
	call	eax
	mov	DWORD PTR tv5712[esp+104], eax
	mov	ecx, edx
	mov	eax, esi
	cdq
	cmp	ecx, edx
	jg	$LN111@readNextCo
	jl	SHORT $LN1338@readNextCo
	cmp	DWORD PTR tv5712[esp+104], eax
	ja	$LN111@readNextCo
$LN1338@readNextCo:

; 511  : 						{
; 512  : 							// if it's a Command::REFRESH_ALL command and
; 513  : 							// we haven't proved that all the queues aren't Command::REFRESH_ALL commands, search
; 514  : 							if (temp_c->getCommandType() == Command::REFRESH_ALL)

	cmp	DWORD PTR [ebx+80], 12			; 0000000cH
	jne	$LN107@readNextCo

; 515  : 							{
; 516  : 								if (!notAllRefresh)

	cmp	BYTE PTR _notAllRefresh$140352[esp+104], 0
	jne	$LN111@readNextCo

; 517  : 								{
; 518  : 									// try to show that at the head of each queue isn't a refresh command
; 519  : 									for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	esi, DWORD PTR _currentRank$140343[esp+104]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR _currentBank$140373[esp+104]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
$LL105@readNextCo:
	lea	esi, DWORD PTR _currentRank$140343[esp+104]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	edi, DWORD PTR [esi+188]
	add	esi, 172				; 000000acH
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN369@readNextCo
	call	__invalid_parameter_noinfo
$LN369@readNextCo:
	mov	eax, DWORD PTR _currentBank$140373[esp+104]
	mov	esi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN382@readNextCo
	cmp	eax, esi
	je	SHORT $LN383@readNextCo
$LN382@readNextCo:
	call	__invalid_parameter_noinfo
$LN383@readNextCo:
	cmp	DWORD PTR _currentBank$140373[esp+108], edi
	je	SHORT $LN1330@readNextCo

; 520  : 									{
; 521  : 										// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 522  : 										if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	lea	esi, DWORD PTR _currentBank$140373[esp+104]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1283@readNextCo
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	test	eax, eax
	je	SHORT $LN104@readNextCo
	lea	esi, DWORD PTR _currentBank$140373[esp+104]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	jne	SHORT $LN1283@readNextCo
$LN104@readNextCo:

; 517  : 								{
; 518  : 									// try to show that at the head of each queue isn't a refresh command
; 519  : 									for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	edi, DWORD PTR $T601333[esp+104]
	lea	esi, DWORD PTR _currentBank$140373[esp+104]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	jmp	SHORT $LL105@readNextCo
$LN1329@readNextCo:

; 499  : 			{
; 500  : 				// do not consider ranks which have already had a command chosen from them
; 501  : 				if (currentRank->getRankID() == slotARank || currentRank->getRankID() == slotBRank)

	mov	eax, DWORD PTR [edi]
	jmp	$LN236@readNextCo
$LN1328@readNextCo:
	mov	eax, DWORD PTR [edi]
	jmp	$LN252@readNextCo
$LN1327@readNextCo:

; 505  : 
; 506  : 				for (vector<Bank>::const_iterator bank_id = currentRank->bank.begin(); bank_id != currentRank->bank.end(); bank_id++)

	mov	edi, DWORD PTR [edi]
	jmp	$LN268@readNextCo
$LN1326@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	$LN310@readNextCo
$LN1325@readNextCo:

; 507  : 				{
; 508  : 					if (const Command *temp_c = bank_id->front())

	mov	eax, DWORD PTR [ebx]
	jmp	$LN348@readNextCo
$LN1283@readNextCo:

; 523  : 										{
; 524  : 											notAllRefresh = true;
; 525  : 											break;
; 526  : 										}
; 527  : 
; 528  : 									}
; 529  : 									// if all are known now to be refresh commands
; 530  : 									if (!notAllRefresh)

	mov	edi, DWORD PTR _bank_id$140357[esp+108]
	mov	BYTE PTR _notAllRefresh$140352[esp+104], 1
	jmp	SHORT $LN111@readNextCo
$LN1330@readNextCo:

; 531  : 									{
; 532  : 										oldestExecutableCommandTime = temp_c->getEnqueueTime();

	mov	ecx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+20]
	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+104], ecx

; 533  : 										oldestExecutableBank = bank_id;

	mov	ecx, DWORD PTR _bank_id$140357[esp+108]
	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+108], edx
	mov	DWORD PTR _oldestExecutableBank$140228[esp+108], ecx

; 534  : 									}
; 535  : 								}
; 536  : 							}

	mov	edi, ecx
	jmp	SHORT $LN1360@readNextCo
$LN107@readNextCo:

; 537  : 							else if (temp_c->getEnqueueTime() < oldestCommandTime)

	mov	eax, DWORD PTR [ebx+16]
	mov	ebx, DWORD PTR [ebx+20]
	cmp	ebx, DWORD PTR _oldestCommandTime$140213[esp+108]
	jg	SHORT $LN98@readNextCo
	jl	SHORT $LN1339@readNextCo
	cmp	eax, DWORD PTR _oldestCommandTime$140213[esp+104]
	jae	SHORT $LN98@readNextCo
$LN1339@readNextCo:

; 538  : 							{
; 539  : 								// if it's a Command::REFRESH_ALL command and
; 540  : 								// we haven't proved that all the queues aren't Command::REFRESH_ALL commands, search
; 541  : 								if (temp_c->getCommandType() == Command::REFRESH_ALL)
; 542  : 								{
; 543  : 									if (!notAllRefresh)
; 544  : 									{
; 545  : 										// try to show that at the head of each queue isn't a refresh command
; 546  : 										for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)
; 547  : 										{
; 548  : 											// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 549  : 											if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))
; 550  : 											{
; 551  : 												notAllRefresh = true;
; 552  : 												break;
; 553  : 											}
; 554  : 
; 555  : 										}
; 556  : 										// if all are known now to be refresh commands
; 557  : 										if (!notAllRefresh)
; 558  : 										{
; 559  : 											oldestCommandTime = temp_c->getEnqueueTime();
; 560  : 											oldestBank = bank_id;
; 561  : 										}
; 562  : 									}
; 563  : 								}
; 564  : 								else
; 565  : 								{
; 566  : 									oldestCommandTime = temp_c->getEnqueueTime();
; 567  : 									oldestBank = bank_id;

	mov	edx, DWORD PTR _bank_id$140357[esp+104]
	mov	DWORD PTR _oldestCommandTime$140213[esp+104], eax
	mov	DWORD PTR _oldestCommandTime$140213[esp+108], ebx
	mov	DWORD PTR _oldestBank$140223[esp+104], edx
	mov	DWORD PTR _oldestBank$140223[esp+108], edi

; 568  : 								}
; 569  : 
; 570  : 							}
; 571  : 
; 572  : 							else

	jmp	SHORT $LN111@readNextCo
$LN98@readNextCo:

; 573  : 							{
; 574  : 								oldestExecutableCommandTime = temp_c->getEnqueueTime();

	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+104], eax
	mov	DWORD PTR _oldestExecutableCommandTime$140216[esp+108], ebx

; 575  : 								oldestExecutableBank = bank_id;

	mov	DWORD PTR _oldestExecutableBank$140228[esp+108], edi
$LN1360@readNextCo:
	mov	eax, DWORD PTR _bank_id$140357[esp+104]
	mov	DWORD PTR _oldestExecutableBank$140228[esp+104], eax
$LN111@readNextCo:
	mov	eax, DWORD PTR _bank_id$140357[esp+104]
	test	eax, eax
	jne	SHORT $LN1324@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN296@readNextCo:

; 505  : 
; 506  : 				for (vector<Bank>::const_iterator bank_id = currentRank->bank.begin(); bank_id != currentRank->bank.end(); bank_id++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN287@readNextCo
	call	__invalid_parameter_noinfo
$LN287@readNextCo:
	mov	ebx, DWORD PTR _bank_id$140357[esp+104]
	mov	esi, DWORD PTR _currentRank$140343[esp+108]
	add	edi, 152				; 00000098H
	jmp	$LN1361@readNextCo
$LN1324@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN296@readNextCo
$LN116@readNextCo:

; 497  : 
; 498  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	edi, DWORD PTR _currentRank$140343[esp+104]
	test	edi, edi
	jne	SHORT $LN1323@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN198@readNextCo:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN189@readNextCo
	call	__invalid_parameter_noinfo
$LN189@readNextCo:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR _oldestExecutableBank$140228[esp+108]
	add	esi, 200				; 000000c8H
	jmp	$LN1362@readNextCo
$LN1323@readNextCo:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN198@readNextCo
$LN115@readNextCo:

; 576  : 							}
; 577  : 						}
; 578  : 					}
; 579  : 				}
; 580  : 			}
; 581  : 
; 582  : 			// if any executable command was found, prioritize it over those which must wait
; 583  : 			if (oldestExecutableCommandTime < TICK_MAX)

	mov	eax, 2147483647				; 7fffffffH
	cmp	DWORD PTR _oldestExecutableCommandTime$140216[esp+108], eax
	jg	SHORT $LN87@readNextCo
	jl	SHORT $LN1340@readNextCo
	cmp	DWORD PTR _oldestExecutableCommandTime$140216[esp+104], -1
	jae	SHORT $LN87@readNextCo
$LN1340@readNextCo:

; 584  : 			{
; 585  : 				assert(oldestExecutableBank->nextCommandType() == Command::REFRESH_ALL || rank[oldestExecutableBank->front()->getAddress().getRank()].bank[oldestExecutableBank->front()->getAddress().getBank()].front() == oldestExecutableBank->front());
; 586  : 
; 587  : 				return oldestExecutableBank->front();

	mov	eax, DWORD PTR _oldestExecutableBank$140228[esp+104]
	test	eax, eax
	jne	SHORT $LN1322@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN425@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN416@readNextCo
	call	__invalid_parameter_noinfo
$LN416@readNextCo:
	mov	ecx, DWORD PTR [ebx+36]
	sub	ecx, DWORD PTR [ebx+32]
	mov	esi, DWORD PTR [ebx+12]
	sar	ecx, 2
	cmp	esi, ecx
	jb	SHORT $LN432@readNextCo
	call	__invalid_parameter_noinfo
$LN432@readNextCo:
	mov	edx, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR [edx+esi*4]
$LN121@readNextCo:

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN1322@readNextCo:

; 584  : 			{
; 585  : 				assert(oldestExecutableBank->nextCommandType() == Command::REFRESH_ALL || rank[oldestExecutableBank->front()->getAddress().getRank()].bank[oldestExecutableBank->front()->getAddress().getBank()].front() == oldestExecutableBank->front());
; 586  : 
; 587  : 				return oldestExecutableBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN425@readNextCo
$LN87@readNextCo:

; 588  : 			}
; 589  : 			// if there was a command found
; 590  : 			else if (oldestCommandTime < TICK_MAX)

	cmp	DWORD PTR _oldestCommandTime$140213[esp+108], eax
	jg	SHORT $LN85@readNextCo
	jl	SHORT $LN1341@readNextCo
	cmp	DWORD PTR _oldestCommandTime$140213[esp+104], -1
	jae	SHORT $LN85@readNextCo
$LN1341@readNextCo:

; 591  : 			{
; 592  : 				assert(oldestBank->front()->getCommandType() == Command::REFRESH_ALL || rank[oldestBank->front()->getAddress().getRank()].bank[oldestBank->front()->getAddress().getBank()].front() == oldestBank->front());
; 593  : 
; 594  : 				return oldestBank->front();

	mov	eax, DWORD PTR _oldestBank$140223[esp+104]
	test	eax, eax
	jne	SHORT $LN1321@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN448@readNextCo:
	mov	ecx, DWORD PTR _oldestBank$140223[esp+108]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN439@readNextCo
	call	__invalid_parameter_noinfo
$LN439@readNextCo:
	mov	eax, DWORD PTR _oldestBank$140223[esp+108]
	mov	edx, DWORD PTR [eax+36]
	sub	edx, DWORD PTR [eax+32]
	mov	esi, DWORD PTR [eax+12]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN455@readNextCo
	call	__invalid_parameter_noinfo
$LN455@readNextCo:
	mov	eax, DWORD PTR _oldestBank$140223[esp+108]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx+esi*4]

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN1321@readNextCo:

; 591  : 			{
; 592  : 				assert(oldestBank->front()->getCommandType() == Command::REFRESH_ALL || rank[oldestBank->front()->getAddress().getRank()].bank[oldestBank->front()->getAddress().getBank()].front() == oldestBank->front());
; 593  : 
; 594  : 				return oldestBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN448@readNextCo
$LN85@readNextCo:

; 595  : 			}
; 596  : 			else
; 597  : 				return NULL;

	xor	eax, eax

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN83@readNextCo:

; 598  : 		}
; 599  : 		break;
; 600  : 
; 601  : 		// alternate ranks as we go down banks
; 602  : 	case RANK_ROUND_ROBIN:
; 603  : 		{
; 604  : 			Transaction::TransactionType transactionType;
; 605  : 
; 606  : 			switch (lastCommandType)

	cmp	eax, 12					; 0000000cH
	ja	$LN75@readNextCo
	movzx	edx, BYTE PTR $LN1342@readNextCo[eax]
	jmp	DWORD PTR $LN1373@readNextCo[edx*4]
$LN80@readNextCo:

; 607  : 			{
; 608  : 				// if it was RAS before and you want to finish doing the read/write
; 609  : 			case Command::ACTIVATE:
; 610  : 				{
; 611  : 					const Command *temp_c =  rank[lastRankID].bank[lastBankID].front();

	mov	ebx, edi
	mov	edi, DWORD PTR _lastRankID$[esp+104]
	add	ebx, 368				; 00000170H
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR _lastBankID$[esp+104]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front

; 612  : 
; 613  : 					if (temp_c && temp_c->isReadOrWrite())

	test	eax, eax
	je	SHORT $LN79@readNextCo
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	je	SHORT $LN79@readNextCo
$LN1366@readNextCo:

; 614  : 					{
; 615  : 						return rank[lastRankID].bank[lastBankID].front();

	mov	edi, DWORD PTR _lastRankID$[esp+104]
	mov	esi, ebx
$LN1365@readNextCo:
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR _lastBankID$[esp+104]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN79@readNextCo:

; 616  : 					}
; 617  : 					else
; 618  : 					{
; 619  : 						cerr << "Serious problems. RAS not followed by CAS" << endl;

	push	OFFSET ??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 620  : 						exit(2);

	push	2
	call	_exit
$LN1375@readNextCo:
$LN77@readNextCo:

; 621  : 					}
; 622  : 				}
; 623  : 				break;
; 624  : 
; 625  : 			case Command::READ_AND_PRECHARGE:
; 626  : 			case Command::READ:
; 627  : 			case Command::PRECHARGE:
; 628  : 				transactionType = Transaction::READ_TRANSACTION;

	mov	esi, 2
	mov	DWORD PTR _transactionType$140414[esp+104], esi

; 629  : 				break;

	jmp	SHORT $LN81@readNextCo
$LN76@readNextCo:

; 630  : 
; 631  : 			case Command::REFRESH_ALL:
; 632  : 			case Command::WRITE:
; 633  : 			case Command::WRITE_AND_PRECHARGE:
; 634  : 				transactionType = Transaction::WRITE_TRANSACTION;

	mov	esi, 1
	mov	DWORD PTR _transactionType$140414[esp+104], esi

; 635  : 				break;	

	jmp	SHORT $LN81@readNextCo
$LN75@readNextCo:

; 636  : 
; 637  : 			default:
; 638  : 				transactionType = Transaction::READ_TRANSACTION;
; 639  : 				cerr << "Did not find a CAS or RAS command when it was expected" << endl;

	push	OFFSET ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
	mov	esi, 2
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	DWORD PTR _transactionType$140414[esp+112], esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	edi, eax
	push	10					; 0000000aH
	mov	ecx, edi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, edi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN81@readNextCo:

; 640  : 				break;
; 641  : 			}
; 642  : 
; 643  : 			unsigned originalLastRankID = lastRankID;

	mov	eax, DWORD PTR _lastRankID$[esp+104]

; 644  : 			unsigned originalLastBankID = lastBankID;

	mov	ecx, DWORD PTR _lastBankID$[esp+104]
	mov	DWORD PTR _originalLastRankID$140436[esp+104], eax
	mov	DWORD PTR _originalLastBankID$140437[esp+104], ecx

; 645  : 			Transaction::TransactionType originalTransactionType = transactionType;

	mov	DWORD PTR _originalTransactionType$140438[esp+104], esi

; 646  : 			bool noPendingRefreshes = false;

	mov	BYTE PTR _noPendingRefreshes$140439[esp+104], 0
$LN74@readNextCo:

; 647  : 
; 648  : 			while (true)
; 649  : 			{
; 650  : 				// select the next rank
; 651  : 				lastRankID = (lastRankID + 1) % systemConfig.getRankCount();

	mov	eax, DWORD PTR _lastRankID$[esp+104]
	mov	edi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edi+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+360]
	mov	ebx, edx
	mov	DWORD PTR _lastRankID$[esp+104], ebx

; 652  : 
; 653  : 				// select the next bank when all ranks at this bank have been checked
; 654  : 				if (lastRankID == originalLastRankID)

	cmp	ebx, DWORD PTR _originalLastRankID$140436[esp+104]
	jne	$LN60@readNextCo

; 655  : 				{
; 656  : 					if (!noPendingRefreshes)

	cmp	BYTE PTR _noPendingRefreshes$140439[esp+104], 0
	jne	$LN71@readNextCo

; 657  : 					{
; 658  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 659  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	esi, DWORD PTR [edi+380]
	cmp	esi, DWORD PTR [edi+384]
	jbe	SHORT $LN469@readNextCo
	call	__invalid_parameter_noinfo
$LN469@readNextCo:
	mov	ebx, DWORD PTR [edi+368]
	mov	DWORD PTR _currentRank$140449[esp+108], esi
	add	esi, 184				; 000000b8H
	mov	DWORD PTR _currentRank$140449[esp+104], ebx
	mov	DWORD PTR tv5339[esp+104], esi
$LL484@readNextCo:
	mov	esi, DWORD PTR [edi+384]
	cmp	DWORD PTR [edi+380], esi
	jbe	SHORT $LN497@readNextCo
	call	__invalid_parameter_noinfo
$LN497@readNextCo:
	mov	eax, DWORD PTR [edi+368]
	test	ebx, ebx
	je	SHORT $LN510@readNextCo
	cmp	ebx, eax
	je	SHORT $LN511@readNextCo
$LN510@readNextCo:
	call	__invalid_parameter_noinfo
$LN511@readNextCo:
	cmp	DWORD PTR _currentRank$140449[esp+108], esi
	je	$LN68@readNextCo

; 660  : 						{
; 661  : 							bool notAllRefresh = false;
; 662  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	test	ebx, ebx
	jne	$LN1320@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN529@readNextCo:
	mov	edx, DWORD PTR _currentRank$140449[esp+108]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN520@readNextCo
	call	__invalid_parameter_noinfo
$LN520@readNextCo:
	mov	eax, DWORD PTR tv5339[esp+104]
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [eax+4]
	jbe	SHORT $LN535@readNextCo
	call	__invalid_parameter_noinfo
$LN535@readNextCo:
	mov	eax, DWORD PTR tv5339[esp+104]
	mov	ebx, DWORD PTR [eax-12]
	lea	edi, DWORD PTR [esi+32]
	npad	7
$LL550@readNextCo:
	mov	eax, DWORD PTR _currentRank$140449[esp+104]
	test	eax, eax
	jne	$LN1319@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN571@readNextCo:
	mov	ecx, DWORD PTR _currentRank$140449[esp+108]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN562@readNextCo
	call	__invalid_parameter_noinfo
$LN562@readNextCo:
	mov	eax, DWORD PTR tv5339[esp+104]
	mov	esi, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax], esi
	ja	SHORT $LN576@readNextCo
	cmp	esi, esi
	jbe	SHORT $LN577@readNextCo
$LN576@readNextCo:
	call	__invalid_parameter_noinfo
$LN577@readNextCo:
	mov	edx, DWORD PTR tv5339[esp+104]
	mov	eax, DWORD PTR [edx-12]
	test	ebx, ebx
	je	SHORT $LN590@readNextCo
	cmp	ebx, eax
	je	SHORT $LN591@readNextCo
$LN590@readNextCo:
	call	__invalid_parameter_noinfo
$LN591@readNextCo:
	lea	eax, DWORD PTR [edi-32]
	cmp	eax, esi
	je	$LN1286@readNextCo

; 663  : 							{
; 664  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 665  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	test	ebx, ebx
	jne	$LN1318@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN609@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN600@readNextCo
	call	__invalid_parameter_noinfo
$LN600@readNextCo:
	cmp	DWORD PTR [edi-24], 0
	je	$LN1285@readNextCo
	test	ebx, ebx
	jne	$LN1317@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN627@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN618@readNextCo
	call	__invalid_parameter_noinfo
$LN618@readNextCo:
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN634@readNextCo
	call	__invalid_parameter_noinfo
$LN634@readNextCo:
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx+esi*4], 0
	je	SHORT $LN66@readNextCo
	test	ebx, ebx
	jne	SHORT $LN1316@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN650@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN641@readNextCo
	call	__invalid_parameter_noinfo
$LN641@readNextCo:
	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN657@readNextCo
	call	__invalid_parameter_noinfo
$LN657@readNextCo:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+esi*4]
	cmp	DWORD PTR [ecx+80], 12			; 0000000cH
	jne	SHORT $LN1285@readNextCo
$LN66@readNextCo:

; 660  : 						{
; 661  : 							bool notAllRefresh = false;
; 662  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	test	ebx, ebx
	jne	SHORT $LN1315@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN557@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN548@readNextCo
	call	__invalid_parameter_noinfo
$LN548@readNextCo:
	add	edi, 152				; 00000098H
	jmp	$LL550@readNextCo
$LN1320@readNextCo:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN529@readNextCo
$LN1319@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	$LN571@readNextCo
$LN1318@readNextCo:

; 663  : 							{
; 664  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 665  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	mov	eax, DWORD PTR [ebx]
	jmp	$LN609@readNextCo
$LN1317@readNextCo:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN627@readNextCo
$LN1316@readNextCo:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN650@readNextCo
$LN1315@readNextCo:

; 660  : 						{
; 661  : 							bool notAllRefresh = false;
; 662  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN557@readNextCo
$LN1285@readNextCo:

; 657  : 					{
; 658  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 659  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	eax, DWORD PTR _currentRank$140449[esp+104]
	test	eax, eax
	jne	SHORT $LN1314@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN491@readNextCo:
	mov	edx, DWORD PTR _currentRank$140449[esp+108]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN482@readNextCo
	call	__invalid_parameter_noinfo
$LN482@readNextCo:
	mov	ebx, DWORD PTR _currentRank$140449[esp+104]
	mov	edi, DWORD PTR _this$[ebp]
	mov	eax, 200				; 000000c8H
	add	DWORD PTR _currentRank$140449[esp+108], eax
	add	DWORD PTR tv5339[esp+104], eax
	jmp	$LL484@readNextCo
$LN1314@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN491@readNextCo
$LN68@readNextCo:

; 674  : 						}
; 675  : 						noPendingRefreshes = true;

	mov	ebx, DWORD PTR _lastRankID$[esp+104]
	mov	BYTE PTR _noPendingRefreshes$140439[esp+104], 1
$LN71@readNextCo:

; 676  : 					}
; 677  : 
; 678  : 					lastBankID = (lastBankID + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _lastBankID$[esp+104]
	mov	ecx, DWORD PTR [edi+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]
	mov	DWORD PTR _lastBankID$[esp+104], edx

; 679  : 
; 680  : 					// when all ranks and all banks have been checked for a read/write, look for a write/read
; 681  : 					if (lastBankID == originalLastBankID)

	cmp	edx, DWORD PTR _originalLastBankID$140437[esp+104]
	jne	SHORT $LN60@readNextCo

; 682  : 					{
; 683  : 
; 684  : 						transactionType = (transactionType == Transaction::WRITE_TRANSACTION) ? Transaction::READ_TRANSACTION : Transaction::WRITE_TRANSACTION;

	mov	eax, DWORD PTR _transactionType$140414[esp+104]
	dec	eax
	neg	eax
	sbb	eax, eax
	add	eax, 2
	mov	DWORD PTR _transactionType$140414[esp+104], eax

; 685  : 						// however, if this type has already been searched for, then there are no commands, so quit
; 686  : 						if (transactionType == originalTransactionType)

	cmp	eax, DWORD PTR _originalTransactionType$140438[esp+104]
	je	$LN85@readNextCo
$LN60@readNextCo:

; 687  : 							break;
; 688  : 					}
; 689  : 				}
; 690  : 
; 691  : 				const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	ecx, DWORD PTR [edi+384]
	sub	ecx, DWORD PTR [edi+380]
	lea	esi, DWORD PTR [edi+368]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN694@readNextCo
	call	__invalid_parameter_noinfo
$LN694@readNextCo:
	mov	ecx, DWORD PTR [esi+12]
	imul	ebx, 200				; 000000c8H
	lea	edi, DWORD PTR [ebx+ecx+172]
	mov	ecx, DWORD PTR [edi+16]
	sub	ecx, DWORD PTR [edi+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _lastBankID$[esp+104], eax
	jb	SHORT $LN699@readNextCo
	call	__invalid_parameter_noinfo
$LN699@readNextCo:
	mov	ecx, DWORD PTR _lastBankID$[esp+104]
	mov	edx, DWORD PTR [edi+12]
	imul	ecx, 152				; 00000098H
	mov	eax, DWORD PTR [ecx+edx+36]
	sub	eax, DWORD PTR [ecx+edx+32]
	mov	ebx, DWORD PTR [ecx+edx+12]
	lea	edi, DWORD PTR [ecx+edx+8]
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LN708@readNextCo
	call	__invalid_parameter_noinfo
$LN708@readNextCo:
	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+ebx*4]

; 692  : 
; 693  : 				if (temp_c && !temp_c->isRefresh())

	test	eax, eax
	je	$LN74@readNextCo
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	je	$LN74@readNextCo

; 694  : 				{
; 695  : 					if (!systemConfig.isReadWriteGrouping())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+176]
	cmp	BYTE PTR [ecx+345], 0
	je	$LN121@readNextCo

; 696  : 					{
; 697  : 						return temp_c;
; 698  : 					}
; 699  : 					else // have to follow read_write grouping considerations
; 700  : 					{
; 701  : 						// look at the second command
; 702  : 						const Command *next_c = rank[lastRankID].bank[lastBankID].read(1);	

	mov	ebx, DWORD PTR _lastRankID$[esp+104]
	mov	edi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR _lastBankID$[esp+104]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read

; 703  : 
; 704  : 						if (next_c)

	test	eax, eax
	je	$LN74@readNextCo

; 705  : 							if ((next_c->isRead() && (transactionType == Transaction::READ_TRANSACTION)) ||
; 706  : 								(next_c->isWrite() && (transactionType == Transaction::WRITE_TRANSACTION)))

	mov	ecx, DWORD PTR [eax+80]
	cmp	ecx, 1
	je	SHORT $LN719@readNextCo
	cmp	ecx, 2
	jne	SHORT $LN53@readNextCo
$LN719@readNextCo:
	cmp	DWORD PTR _transactionType$140414[esp+104], 2
	je	SHORT $LN54@readNextCo
$LN53@readNextCo:
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	je	$LN74@readNextCo
	cmp	DWORD PTR _transactionType$140414[esp+104], 1
	jne	$LN74@readNextCo
$LN54@readNextCo:

; 707  : 							{
; 708  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getBank() == lastBankID);
; 709  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getRank() == lastRankID);
; 710  : 								return rank[lastRankID].bank[lastBankID].front();

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 368				; 00000170H
	mov	edi, ebx
	jmp	$LN1365@readNextCo
$LN1286@readNextCo:

; 666  : 								{
; 667  : 									notAllRefresh = true;
; 668  : 									break;
; 669  : 								}
; 670  : 							}
; 671  : 							// are all the commands refreshes? if so then return this
; 672  : 							if (!notAllRefresh)
; 673  : 								return currentRank->bank[lastBankID].front(); // which bank doesn't really matter

	mov	eax, DWORD PTR _currentRank$140449[esp+104]
	test	eax, eax
	je	SHORT $LN1371@readNextCo
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN675@readNextCo
$LN1371@readNextCo:

; 793  : 								{
; 794  : 									notAllRefresh = true;
; 795  : 									break;
; 796  : 								}
; 797  : 							}
; 798  : 							// are all the commands refreshes? if so then return this
; 799  : 							if (!notAllRefresh)
; 800  : 								return currentRank->bank[lastBankID].front(); // which bank doesn't really matter

	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN675@readNextCo:
	mov	edx, DWORD PTR _currentRank$140449[esp+108]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN666@readNextCo

; 666  : 								{
; 667  : 									notAllRefresh = true;
; 668  : 									break;
; 669  : 								}
; 670  : 							}
; 671  : 							// are all the commands refreshes? if so then return this
; 672  : 							if (!notAllRefresh)
; 673  : 								return currentRank->bank[lastBankID].front(); // which bank doesn't really matter

	call	__invalid_parameter_noinfo
$LN666@readNextCo:
	mov	edi, DWORD PTR _currentRank$140449[esp+108]
	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	esi, DWORD PTR _lastBankID$[esp+104]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN678@readNextCo
	call	__invalid_parameter_noinfo
$LN678@readNextCo:
	mov	ecx, DWORD PTR [edi+184]
	imul	esi, 152				; 00000098H
	mov	edx, DWORD PTR [esi+ecx+36]
	sub	edx, DWORD PTR [esi+ecx+32]
	mov	edi, DWORD PTR [esi+ecx+12]
	lea	esi, DWORD PTR [esi+ecx+8]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN687@readNextCo
	call	__invalid_parameter_noinfo
$LN687@readNextCo:
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+edi*4]

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN52@readNextCo:

; 711  : 							}
; 712  : 					}
; 713  : 
; 714  : #ifdef DEBUG_FLAG_2
; 715  : 					cerr << "Looked in ["<< temp_c->getAddress().rank << "] [" << temp_c->getAddress().bank << "] but wrong type, We want [" << transactionType << "]. Candidate command type ";
; 716  : 					cerr << temp_c->getCommandType();
; 717  : 					cerr << " followed by ";
; 718  : 					cerr << rank[lastRankID].bank[lastBankID].getPerBankQueue().read(1)->getCommandType();
; 719  : 					cerr << "count [" << rank[lastRankID].bank[lastBankID].getPerBankQueue().get_count() << "]" << endl;
; 720  : #endif
; 721  : 
; 722  : 				}
; 723  : 
; 724  : #ifdef DEBUG_FLAG_2
; 725  : 				cerr << "Looked in [" << lastRankID << "] [" << lastBankID << "] but Q empty" << endl;
; 726  : #endif
; 727  : 
; 728  : 			}
; 729  : 		}
; 730  : 		break;
; 731  : 
; 732  : 		// keep rank id as long as possible, go round robin down a given rank
; 733  : 	case BANK_ROUND_ROBIN:
; 734  : 		{			
; 735  : 			Transaction::TransactionType transactionType;
; 736  : 
; 737  : 			switch (lastCommandType)

	cmp	eax, 12					; 0000000cH
	ja	$LN44@readNextCo
	movzx	ecx, BYTE PTR $LN1343@readNextCo[eax]
	jmp	DWORD PTR $LN1374@readNextCo[ecx*4]
$LN49@readNextCo:

; 738  : 			{
; 739  : 			case Command::ACTIVATE:
; 740  : 				{
; 741  : 					const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	ebx, edi
	mov	edi, DWORD PTR _lastRankID$[esp+104]
	add	ebx, 368				; 00000170H
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR _lastBankID$[esp+104]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front

; 742  : 
; 743  : 					if ((temp_c) && temp_c->isReadOrWrite())

	test	eax, eax
	je	SHORT $LN48@readNextCo
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al

; 744  : 					{
; 745  : 						return rank[lastRankID].bank[lastBankID].front();

	jne	$LN1366@readNextCo
$LN48@readNextCo:

; 746  : 					}
; 747  : 					else
; 748  : 					{
; 749  : 						cerr << "Serious problems. RAS not followed by CAS." << endl;

	push	OFFSET ??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 750  : 						exit(2);

	push	2
	call	_exit
$LN1376@readNextCo:
$LN46@readNextCo:

; 751  : 					}
; 752  : 				}
; 753  : 				break;
; 754  : 			case Command::READ_AND_PRECHARGE:
; 755  : 			case Command::READ:
; 756  : 			case Command::PRECHARGE:
; 757  : 				transactionType = Transaction::READ_TRANSACTION;

	mov	esi, 2
	mov	DWORD PTR _transactionType$140485[esp+104], esi

; 758  : 				break;

	jmp	SHORT $LN50@readNextCo
$LN45@readNextCo:

; 759  : 
; 760  : 			case Command::REFRESH_ALL:
; 761  : 			case Command::WRITE:
; 762  : 			case Command::WRITE_AND_PRECHARGE:
; 763  : 				transactionType = Transaction::WRITE_TRANSACTION;

	mov	esi, 1
	mov	DWORD PTR _transactionType$140485[esp+104], esi

; 764  : 				break;

	jmp	SHORT $LN50@readNextCo
$LN44@readNextCo:

; 765  : 			default:
; 766  : 				transactionType = Transaction::WRITE_TRANSACTION; // FIXME: added this to ensure no uninit vars
; 767  : 				cerr << "Did not find a CAS or RAS command when it was expected" << endl;

	push	OFFSET ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
	mov	esi, 1
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	DWORD PTR _transactionType$140485[esp+112], esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	edi, eax
	push	10					; 0000000aH
	mov	ecx, edi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, edi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN50@readNextCo:

; 768  : 				break;
; 769  : 			}
; 770  : 
; 771  : 			unsigned originalLastRankID = lastRankID;

	mov	edx, DWORD PTR _lastRankID$[esp+104]

; 772  : 			unsigned originalLastBankID = lastBankID;

	mov	eax, DWORD PTR _lastBankID$[esp+104]
	mov	DWORD PTR _originalLastRankID$140506[esp+104], edx
	mov	DWORD PTR _originalLastBankID$140507[esp+104], eax

; 773  : 			Transaction::TransactionType originalTransactionType = transactionType;

	mov	DWORD PTR _originalTransactionType$140508[esp+104], esi

; 774  : 			bool noPendingRefreshes = false;

	mov	BYTE PTR _noPendingRefreshes$140509[esp+104], 0
$LN43@readNextCo:

; 775  : 
; 776  : 			while (true)
; 777  : 			{
; 778  : 				// select the next bank
; 779  : 				lastBankID = (lastBankID + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _lastBankID$[esp+104]
	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ebx+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]
	mov	DWORD PTR _lastBankID$[esp+104], edx

; 780  : 
; 781  : 				if (lastBankID == originalLastBankID)

	cmp	edx, DWORD PTR _originalLastBankID$140507[esp+104]
	jne	$LN1348@readNextCo

; 782  : 				{
; 783  : 					if (!noPendingRefreshes)

	cmp	BYTE PTR _noPendingRefreshes$140509[esp+104], 0
	jne	$LN40@readNextCo

; 784  : 					{
; 785  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 786  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	esi, DWORD PTR [ebx+380]
	cmp	esi, DWORD PTR [ebx+384]
	jbe	SHORT $LN730@readNextCo
	call	__invalid_parameter_noinfo
$LN730@readNextCo:
	mov	edi, DWORD PTR [ebx+368]
	mov	DWORD PTR _currentRank$140519[esp+108], esi
	add	esi, 184				; 000000b8H
	mov	DWORD PTR _currentRank$140519[esp+104], edi
	mov	DWORD PTR tv5532[esp+104], esi
	npad	11
$LL745@readNextCo:
	mov	esi, DWORD PTR [ebx+384]
	cmp	DWORD PTR [ebx+380], esi
	jbe	SHORT $LN758@readNextCo
	call	__invalid_parameter_noinfo
$LN758@readNextCo:
	mov	eax, DWORD PTR [ebx+368]
	test	edi, edi
	je	SHORT $LN771@readNextCo
	cmp	edi, eax
	je	SHORT $LN772@readNextCo
$LN771@readNextCo:
	call	__invalid_parameter_noinfo
$LN772@readNextCo:
	cmp	DWORD PTR _currentRank$140519[esp+108], esi
	je	$LN37@readNextCo

; 787  : 						{
; 788  : 							bool notAllRefresh = false;
; 789  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	test	edi, edi
	jne	$LN1312@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN790@readNextCo:
	mov	edx, DWORD PTR _currentRank$140519[esp+108]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN781@readNextCo
	call	__invalid_parameter_noinfo
$LN781@readNextCo:
	mov	eax, DWORD PTR tv5532[esp+104]
	mov	esi, DWORD PTR [eax]
	mov	ecx, eax
	cmp	esi, DWORD PTR [ecx+4]
	jbe	SHORT $LN796@readNextCo
	call	__invalid_parameter_noinfo
$LN796@readNextCo:
	mov	edx, DWORD PTR tv5532[esp+104]
	mov	ebx, DWORD PTR [edx-12]
	lea	edi, DWORD PTR [esi+32]
	npad	7
$LL811@readNextCo:
	mov	eax, DWORD PTR _currentRank$140519[esp+104]
	test	eax, eax
	jne	$LN1311@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN832@readNextCo:
	mov	ecx, DWORD PTR _currentRank$140519[esp+108]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN823@readNextCo
	call	__invalid_parameter_noinfo
$LN823@readNextCo:
	mov	eax, DWORD PTR tv5532[esp+104]
	mov	esi, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax], esi
	ja	SHORT $LN837@readNextCo
	cmp	esi, esi
	jbe	SHORT $LN838@readNextCo
$LN837@readNextCo:
	call	__invalid_parameter_noinfo
$LN838@readNextCo:
	mov	edx, DWORD PTR tv5532[esp+104]
	mov	eax, DWORD PTR [edx-12]
	test	ebx, ebx
	je	SHORT $LN851@readNextCo
	cmp	ebx, eax
	je	SHORT $LN852@readNextCo
$LN851@readNextCo:
	call	__invalid_parameter_noinfo
$LN852@readNextCo:
	lea	eax, DWORD PTR [edi-32]
	cmp	eax, esi
	je	$LN1286@readNextCo

; 790  : 							{
; 791  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 792  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	test	ebx, ebx
	jne	$LN1310@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN870@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN861@readNextCo
	call	__invalid_parameter_noinfo
$LN861@readNextCo:
	cmp	DWORD PTR [edi-24], 0
	je	$LN1289@readNextCo
	test	ebx, ebx
	jne	$LN1309@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN888@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN879@readNextCo
	call	__invalid_parameter_noinfo
$LN879@readNextCo:
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN895@readNextCo
	call	__invalid_parameter_noinfo
$LN895@readNextCo:
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx+esi*4], 0
	je	SHORT $LN35@readNextCo
	test	ebx, ebx
	jne	SHORT $LN1308@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN911@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN902@readNextCo
	call	__invalid_parameter_noinfo
$LN902@readNextCo:
	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN918@readNextCo
	call	__invalid_parameter_noinfo
$LN918@readNextCo:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+esi*4]
	cmp	DWORD PTR [ecx+80], 12			; 0000000cH
	jne	SHORT $LN1289@readNextCo
$LN35@readNextCo:

; 787  : 						{
; 788  : 							bool notAllRefresh = false;
; 789  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	test	ebx, ebx
	jne	SHORT $LN1307@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN818@readNextCo:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN809@readNextCo
	call	__invalid_parameter_noinfo
$LN809@readNextCo:
	add	edi, 152				; 00000098H
	jmp	$LL811@readNextCo
$LN1312@readNextCo:
	mov	eax, DWORD PTR [edi]
	jmp	$LN790@readNextCo
$LN1311@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	$LN832@readNextCo
$LN1310@readNextCo:

; 790  : 							{
; 791  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 792  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	mov	eax, DWORD PTR [ebx]
	jmp	$LN870@readNextCo
$LN1309@readNextCo:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN888@readNextCo
$LN1308@readNextCo:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN911@readNextCo
$LN1307@readNextCo:

; 787  : 						{
; 788  : 							bool notAllRefresh = false;
; 789  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN818@readNextCo
$LN1289@readNextCo:

; 784  : 					{
; 785  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 786  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	eax, DWORD PTR _currentRank$140519[esp+104]
	test	eax, eax
	jne	SHORT $LN1306@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN752@readNextCo:
	mov	edx, DWORD PTR _currentRank$140519[esp+108]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN743@readNextCo
	call	__invalid_parameter_noinfo
$LN743@readNextCo:
	mov	edi, DWORD PTR _currentRank$140519[esp+104]
	mov	ebx, DWORD PTR _this$[ebp]
	mov	eax, 200				; 000000c8H
	add	DWORD PTR _currentRank$140519[esp+108], eax
	add	DWORD PTR tv5532[esp+104], eax
	jmp	$LL745@readNextCo
$LN1306@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN752@readNextCo
$LN37@readNextCo:

; 801  : 						}
; 802  : 						noPendingRefreshes = true;

	mov	BYTE PTR _noPendingRefreshes$140509[esp+104], 1
$LN40@readNextCo:

; 803  : 					}
; 804  : 
; 805  : 					lastRankID = (lastRankID + 1) % systemConfig.getRankCount();

	mov	eax, DWORD PTR _lastRankID$[esp+104]
	mov	ecx, DWORD PTR [ebx+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+360]
	mov	edi, edx
	mov	DWORD PTR _lastRankID$[esp+104], edi

; 806  : 
; 807  : 					if (lastRankID == originalLastRankID)

	cmp	edi, DWORD PTR _originalLastRankID$140506[esp+104]
	jne	SHORT $LN29@readNextCo

; 808  : 					{
; 809  : 						transactionType = (transactionType == Transaction::WRITE_TRANSACTION) ? Transaction::READ_TRANSACTION : Transaction::WRITE_TRANSACTION;

	mov	eax, DWORD PTR _transactionType$140485[esp+104]
	dec	eax
	neg	eax
	sbb	eax, eax
	add	eax, 2
	mov	DWORD PTR _transactionType$140485[esp+104], eax

; 810  : 						// however, if this type has already been searched for, then there are no commands, so quit
; 811  : 						if (transactionType == originalTransactionType)

	cmp	eax, DWORD PTR _originalTransactionType$140508[esp+104]
	je	$LN85@readNextCo
	jmp	SHORT $LN29@readNextCo
$LN1348@readNextCo:
	mov	edi, DWORD PTR _lastRankID$[esp+104]
$LN29@readNextCo:

; 812  : 							break;
; 813  : 					}
; 814  : 				}
; 815  : 
; 816  : 				const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	lea	esi, DWORD PTR [ebx+368]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN955@readNextCo
	call	__invalid_parameter_noinfo
$LN955@readNextCo:
	mov	ecx, DWORD PTR [esi+12]
	imul	edi, 200				; 000000c8H
	lea	edi, DWORD PTR [edi+ecx+172]
	mov	ecx, DWORD PTR [edi+16]
	sub	ecx, DWORD PTR [edi+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _lastBankID$[esp+104], eax
	jb	SHORT $LN960@readNextCo
	call	__invalid_parameter_noinfo
$LN960@readNextCo:
	mov	ecx, DWORD PTR _lastBankID$[esp+104]
	mov	edx, DWORD PTR [edi+12]
	imul	ecx, 152				; 00000098H
	mov	eax, DWORD PTR [ecx+edx+36]
	sub	eax, DWORD PTR [ecx+edx+32]
	mov	ebx, DWORD PTR [ecx+edx+12]
	lea	edi, DWORD PTR [ecx+edx+8]
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LN969@readNextCo
	call	__invalid_parameter_noinfo
$LN969@readNextCo:
	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+ebx*4]

; 817  : 
; 818  : 				if (temp_c && temp_c->getCommandType() != Command::REFRESH_ALL)

	test	eax, eax
	je	$LN43@readNextCo
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	je	$LN43@readNextCo

; 819  : 				{	
; 820  : 					if(systemConfig.isReadWriteGrouping() == false)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+176]
	cmp	BYTE PTR [ecx+345], 0
	je	$LN121@readNextCo

; 821  : 					{
; 822  : 						return temp_c;
; 823  : 					}
; 824  : 					else // have to follow read_write grouping considerations
; 825  : 					{
; 826  : 						// look at the second command
; 827  : 						const Command *next_c =  rank[lastRankID].bank[lastBankID].read(1);

	mov	ebx, DWORD PTR _lastRankID$[esp+104]
	mov	edi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR _lastBankID$[esp+104]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read

; 828  : 
; 829  : 						if (next_c)

	test	eax, eax
	je	$LN43@readNextCo

; 830  : 							if ((next_c->isRead() && (transactionType == Transaction::READ_TRANSACTION)) ||
; 831  : 								(next_c->isWrite() && (transactionType == Transaction::WRITE_TRANSACTION)))

	mov	ecx, DWORD PTR [eax+80]
	cmp	ecx, 1
	je	SHORT $LN980@readNextCo
	cmp	ecx, 2
	jne	SHORT $LN22@readNextCo
$LN980@readNextCo:
	cmp	DWORD PTR _transactionType$140485[esp+104], 2
	je	$LN54@readNextCo
$LN22@readNextCo:
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	je	$LN43@readNextCo
	cmp	DWORD PTR _transactionType$140485[esp+104], 1
	jne	$LN43@readNextCo
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 368				; 00000170H
	mov	edi, ebx
	jmp	$LN1365@readNextCo
$LN21@readNextCo:

; 832  : 							{
; 833  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getBank() == lastBankID);
; 834  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getRank() == lastRankID);
; 835  : 								return rank[lastRankID].bank[lastBankID].front();
; 836  : 							}
; 837  : 					}
; 838  : 
; 839  : #ifdef DEBUG_FLAG_2
; 840  : 					cerr << "Looked in ["<< temp_c->getAddress().rank << "] [" << temp_c->getAddress().bank << "] but wrong type, We want [" << transactionType << "]. Candidate command type ";
; 841  : 					cerr << temp_c->getCommandType();
; 842  : 					cerr << " followed by ";
; 843  : 					cerr << rank[lastRankID].bank[lastBankID].getPerBankQueue().read(1)->getCommandType();
; 844  : 					cerr << "count [" << rank[lastRankID].bank[lastBankID].getPerBankQueue().get_count() << "]" << endl;
; 845  : #endif
; 846  : 
; 847  : 				}
; 848  : 
; 849  : #ifdef DEBUG_FLAG_2
; 850  : 				cerr << "Looked in rank=[" << lastRankID << "] bank=[" << lastBankID << "] but Q empty" << endl;
; 851  : #endif
; 852  : 
; 853  : 			}
; 854  : 		}
; 855  : 		break;
; 856  : 
; 857  : 	case FIRST_AVAILABLE_AGE:
; 858  : 		{
; 859  : 			const Command *candidateCommand = NULL;

	mov	DWORD PTR _candidateCommand$140555[esp+104], esi

; 860  : 
; 861  : 			int candidateGap = INT_MAX;
; 862  : 
; 863  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	esi, DWORD PTR [edi+380]
	mov	DWORD PTR _candidateGap$140556[esp+104], 2147483647 ; 7fffffffH
	cmp	esi, DWORD PTR [edi+384]
	jbe	SHORT $LN985@readNextCo
	call	__invalid_parameter_noinfo
$LN985@readNextCo:
	mov	ecx, DWORD PTR [edi+368]
	mov	DWORD PTR _currentRank$140561[esp+104], ecx
	mov	ebx, esi
$LN1364@readNextCo:
	mov	esi, DWORD PTR [edi+384]
	mov	DWORD PTR _currentRank$140561[esp+108], ebx
	cmp	DWORD PTR [edi+380], esi
	jbe	SHORT $LN1013@readNextCo
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _currentRank$140561[esp+104]
$LN1013@readNextCo:
	mov	eax, DWORD PTR [edi+368]
	test	ecx, ecx
	je	SHORT $LN1026@readNextCo
	cmp	ecx, eax
	je	SHORT $LN1027@readNextCo
$LN1026@readNextCo:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _currentRank$140561[esp+104]
$LN1027@readNextCo:
	cmp	ebx, esi
	je	$LN18@readNextCo

; 864  : 			{
; 865  : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$140568[esp+104], 0

; 866  : 
; 867  : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	test	ecx, ecx
	jne	$LN1304@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1045@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1036@readNextCo
	call	__invalid_parameter_noinfo
$LN1036@readNextCo:
	mov	esi, DWORD PTR [ebx+184]
	cmp	esi, DWORD PTR [ebx+188]
	jbe	SHORT $LN1051@readNextCo
	call	__invalid_parameter_noinfo
$LN1051@readNextCo:
	mov	edi, DWORD PTR [ebx+172]
	add	esi, 32					; 00000020H
	mov	DWORD PTR _currentBank$140573[esp+104], edi
	mov	DWORD PTR tv5709[esp+104], esi
	npad	11
$LL1066@readNextCo:
	mov	eax, DWORD PTR _currentRank$140561[esp+104]
	test	eax, eax
	jne	$LN1303@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1087@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1078@readNextCo
	call	__invalid_parameter_noinfo
$LN1078@readNextCo:
	mov	esi, DWORD PTR [ebx+188]
	cmp	DWORD PTR [ebx+184], esi
	jbe	SHORT $LN1093@readNextCo
	call	__invalid_parameter_noinfo
$LN1093@readNextCo:
	mov	eax, DWORD PTR [ebx+172]
	test	edi, edi
	je	SHORT $LN1106@readNextCo
	cmp	edi, eax
	je	SHORT $LN1107@readNextCo
$LN1106@readNextCo:
	call	__invalid_parameter_noinfo
$LN1107@readNextCo:
	mov	eax, DWORD PTR tv5709[esp+104]
	add	eax, -32				; ffffffe0H
	cmp	eax, esi
	je	$LN19@readNextCo

; 868  : 				{
; 869  : 					const Command *challengerCommand = currentBank->front();

	test	edi, edi
	jne	$LN1302@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1125@readNextCo:
	mov	ecx, DWORD PTR tv5709[esp+104]
	add	ecx, -32				; ffffffe0H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1116@readNextCo
	call	__invalid_parameter_noinfo
$LN1116@readNextCo:
	mov	eax, DWORD PTR tv5709[esp+104]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax-20]
	sar	ecx, 2
	cmp	esi, ecx
	jb	SHORT $LN1132@readNextCo
	call	__invalid_parameter_noinfo
$LN1132@readNextCo:
	mov	edx, DWORD PTR tv5709[esp+104]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _challengerCommand$140580[esp+104], esi

; 870  : 
; 871  : 					if (challengerCommand)

	test	esi, esi
	je	$LN16@readNextCo

; 872  : 					{
; 873  : 						int challengerGap = minProtocolGap(challengerCommand);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 874  : 
; 875  : 						if (challengerGap < candidateGap || (candidateGap == challengerGap && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	mov	ecx, DWORD PTR _candidateGap$140556[esp+104]
	cmp	ecx, eax
	mov	DWORD PTR _challengerGap$140582[esp+104], eax
	jg	SHORT $LN1344@readNextCo
	jne	$LN16@readNextCo
	mov	eax, DWORD PTR _candidateCommand$140555[esp+104]
	mov	ecx, esi
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jg	$LN16@readNextCo
	jl	SHORT $LN1355@readNextCo
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN16@readNextCo
$LN1355@readNextCo:
	mov	eax, DWORD PTR _challengerGap$140582[esp+104]
	mov	esi, DWORD PTR _challengerCommand$140580[esp+104]
$LN1344@readNextCo:

; 876  : 						{
; 877  : 							if (challengerCommand->getCommandType() == Command::REFRESH_ALL)

	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	jne	$LN11@readNextCo

; 878  : 							{					
; 879  : 								// if it hasn't been proven to be all refreshes or not yet
; 880  : 								if (!notAllRefresh)

	cmp	BYTE PTR _notAllRefresh$140568[esp+104], 0
	jne	$LN16@readNextCo

; 881  : 								{
; 882  : 									for (vector<Bank>::const_iterator thisBank = currentRank->bank.begin(); thisBank != currentRank->bank.end(); thisBank++)

	mov	eax, DWORD PTR _currentRank$140561[esp+104]
	test	eax, eax
	jne	$LN1301@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1154@readNextCo:
	mov	ebx, DWORD PTR _currentRank$140561[esp+108]
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1145@readNextCo
	call	__invalid_parameter_noinfo
$LN1145@readNextCo:
	mov	esi, DWORD PTR [ebx+184]
	cmp	esi, DWORD PTR [ebx+188]
	jbe	SHORT $LN1160@readNextCo
	call	__invalid_parameter_noinfo
$LN1160@readNextCo:
	mov	edi, DWORD PTR [ebx+172]
	add	esi, 32					; 00000020H
	mov	DWORD PTR tv5613[esp+104], esi
	npad	6
$LL1175@readNextCo:
	mov	eax, DWORD PTR _currentRank$140561[esp+104]
	test	eax, eax
	jne	$LN1300@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1196@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1187@readNextCo
	call	__invalid_parameter_noinfo
$LN1187@readNextCo:
	mov	esi, DWORD PTR [ebx+188]
	cmp	DWORD PTR [ebx+184], esi
	jbe	SHORT $LN1202@readNextCo
	call	__invalid_parameter_noinfo
$LN1202@readNextCo:
	mov	eax, DWORD PTR [ebx+172]
	test	edi, edi
	je	SHORT $LN1215@readNextCo
	cmp	edi, eax
	je	SHORT $LN1216@readNextCo
$LN1215@readNextCo:
	call	__invalid_parameter_noinfo
$LN1216@readNextCo:
	mov	ebx, DWORD PTR tv5613[esp+104]
	add	ebx, -32				; ffffffe0H
	cmp	ebx, esi
	je	$LN1336@readNextCo

; 883  : 									{
; 884  : 										// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 885  : 										if ((thisBank->size() == 0) || (thisBank->front()->getCommandType() != Command::REFRESH_ALL))

	test	edi, edi
	jne	$LN1299@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1234@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1225@readNextCo
	call	__invalid_parameter_noinfo
$LN1225@readNextCo:
	mov	ecx, DWORD PTR tv5613[esp+104]
	cmp	DWORD PTR [ecx-24], 0
	je	$LN1293@readNextCo
	test	edi, edi
	jne	$LN1298@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1252@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1243@readNextCo
	call	__invalid_parameter_noinfo
$LN1243@readNextCo:
	mov	eax, DWORD PTR tv5613[esp+104]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1259@readNextCo
	call	__invalid_parameter_noinfo
$LN1259@readNextCo:
	mov	eax, DWORD PTR tv5613[esp+104]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+esi*4]
	cmp	DWORD PTR [edx+80], 12			; 0000000cH
	jne	SHORT $LN1293@readNextCo

; 881  : 								{
; 882  : 									for (vector<Bank>::const_iterator thisBank = currentRank->bank.begin(); thisBank != currentRank->bank.end(); thisBank++)

	test	edi, edi
	jne	SHORT $LN1297@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1182@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1173@readNextCo
	call	__invalid_parameter_noinfo
$LN1173@readNextCo:
	add	DWORD PTR tv5613[esp+104], 152		; 00000098H
	mov	ebx, DWORD PTR _currentRank$140561[esp+108]
	jmp	$LL1175@readNextCo
$LN1304@readNextCo:

; 866  : 
; 867  : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR [ecx]
	jmp	$LN1045@readNextCo
$LN1303@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	$LN1087@readNextCo
$LN1302@readNextCo:

; 868  : 				{
; 869  : 					const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [edi]
	jmp	$LN1125@readNextCo
$LN1301@readNextCo:

; 881  : 								{
; 882  : 									for (vector<Bank>::const_iterator thisBank = currentRank->bank.begin(); thisBank != currentRank->bank.end(); thisBank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN1154@readNextCo
$LN1300@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	$LN1196@readNextCo
$LN1299@readNextCo:

; 883  : 									{
; 884  : 										// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 885  : 										if ((thisBank->size() == 0) || (thisBank->front()->getCommandType() != Command::REFRESH_ALL))

	mov	eax, DWORD PTR [edi]
	jmp	$LN1234@readNextCo
$LN1298@readNextCo:
	mov	eax, DWORD PTR [edi]
	jmp	$LN1252@readNextCo
$LN1297@readNextCo:

; 881  : 								{
; 882  : 									for (vector<Bank>::const_iterator thisBank = currentRank->bank.begin(); thisBank != currentRank->bank.end(); thisBank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN1182@readNextCo
$LN1293@readNextCo:

; 886  : 										{
; 887  : 											notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$140568[esp+104], 1

; 888  : 											break;
; 889  : 										}
; 890  : 									}
; 891  : 									// are all the commands refreshes? if so then choose this
; 892  : 									if (!notAllRefresh)

	jmp	SHORT $LN16@readNextCo
$LN1336@readNextCo:

; 893  : 									{
; 894  : 										candidateGap = challengerGap;
; 895  : 										candidateCommand = challengerCommand;

	mov	ecx, DWORD PTR _challengerCommand$140580[esp+104]
	mov	eax, DWORD PTR _challengerGap$140582[esp+104]
	mov	DWORD PTR _candidateCommand$140555[esp+104], ecx

; 896  : 									}
; 897  : 								}
; 898  : 							}
; 899  : 							else

	jmp	SHORT $LN1363@readNextCo
$LN11@readNextCo:

; 902  : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$140555[esp+104], esi
$LN1363@readNextCo:

; 900  : 							{
; 901  : 								candidateGap = challengerGap;

	mov	DWORD PTR _candidateGap$140556[esp+104], eax
$LN16@readNextCo:

; 866  : 
; 867  : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR _currentBank$140573[esp+104]
	test	eax, eax
	jne	SHORT $LN1296@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1073@readNextCo:
	mov	ecx, DWORD PTR tv5709[esp+104]
	add	ecx, -32				; ffffffe0H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1064@readNextCo
	call	__invalid_parameter_noinfo
$LN1064@readNextCo:
	add	DWORD PTR tv5709[esp+104], 152		; 00000098H
	mov	ebx, DWORD PTR _currentRank$140561[esp+108]
	mov	edi, DWORD PTR _currentBank$140573[esp+104]
	jmp	$LL1066@readNextCo
$LN1296@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1073@readNextCo
$LN19@readNextCo:

; 860  : 
; 861  : 			int candidateGap = INT_MAX;
; 862  : 
; 863  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	mov	eax, DWORD PTR _currentRank$140561[esp+104]
	test	eax, eax
	jne	SHORT $LN1295@readNextCo
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1007@readNextCo:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN998@readNextCo
	call	__invalid_parameter_noinfo
$LN998@readNextCo:
	mov	ecx, DWORD PTR _currentRank$140561[esp+104]
	mov	edi, DWORD PTR _this$[ebp]
	add	ebx, 200				; 000000c8H
	jmp	$LN1364@readNextCo
$LN1295@readNextCo:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1007@readNextCo
$LN18@readNextCo:

; 903  : 							}							
; 904  : 						}
; 905  : 					}
; 906  : 				}
; 907  : 			}
; 908  : 
; 909  : 			if (candidateCommand)
; 910  : 			{
; 911  : 				assert(candidateCommand->getCommandType() == Command::REFRESH_ALL || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 912  : 
; 913  : 				DEBUG_TIMING_LOG("R[" << candidateCommand->getAddress().getRank() << "] B[" << candidateCommand->getAddress().getBank() << "]\tWinner: " << candidateCommand << "gap[" << candidateGap << "] now[" << time << "]")
; 914  : 			}
; 915  : 
; 916  : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$140555[esp+104]

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN1@readNextCo:

; 917  : 		}
; 918  : 		break;
; 919  : 
; 920  : 	default:
; 921  : 		{
; 922  : 			cerr << "This configuration and algorithm combination is not supported" << endl;

	push	OFFSET ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 923  : 			exit(0);

	push	0
	call	_exit
$LN1377@readNextCo:
$LN1359@readNextCo:
	npad	3
$LN1372@readNextCo:

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;
; 928  : }

	DD	$LN118@readNextCo
	DD	$LN83@readNextCo
	DD	$LN52@readNextCo
	DD	$LN21@readNextCo
$LN1373@readNextCo:
	DD	$LN80@readNextCo
	DD	$LN77@readNextCo
	DD	$LN76@readNextCo
	DD	$LN75@readNextCo
$LN1342@readNextCo:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	npad	3
$LN1374@readNextCo:
	DD	$LN49@readNextCo
	DD	$LN46@readNextCo
	DD	$LN45@readNextCo
	DD	$LN44@readNextCo
$LN1343@readNextCo:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ENDP ; DRAMsimII::fbdChannel::readNextCommand
_TEXT	ENDS
PUBLIC	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tempCommand$140020 = 8					; size = 4
_this$ = 8						; size = 4
?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z PROC ; DRAMsimII::fbdChannel::getNextCommand
; _slotACommand$ = ecx
; _slotBCommand$ = eax

; 421  : {

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	push	edi

; 422  : 	const Command *nextCommand = readNextCommand(slotACommand, slotBCommand);

	push	eax
	push	ecx
	push	ebx
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	mov	edi, eax

; 423  : 
; 424  : 	if (nextCommand)

	test	edi, edi
	je	$LN7@getNextCom@2

; 425  : 	{
; 426  : 		Rank &currentRank = rank[nextCommand->getAddress().getRank()];

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR [edi+60]
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN14@getNextCom@2
	call	__invalid_parameter_noinfo
$LN14@getNextCom@2:
	imul	esi, 200				; 000000c8H
	add	esi, DWORD PTR [ebx+380]

; 427  : 
; 428  : 		// if it was a refresh all command, then dequeue all n banks worth of commands
; 429  : 		if (nextCommand->getCommandType() == Command::REFRESH_ALL)

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	mov	ebx, esi
	jne	$LN6@getNextCom@2

; 430  : 		{
; 431  : 			Command *tempCommand = NULL;
; 432  : 
; 433  : 			for (vector<Bank>::iterator cur_bank = currentRank.bank.begin(); cur_bank != currentRank.bank.end(); cur_bank++)

	mov	esi, DWORD PTR [ebx+184]
	mov	DWORD PTR _tempCommand$140020[esp+8], 0
	cmp	esi, DWORD PTR [ebx+188]
	jbe	SHORT $LN26@getNextCom@2
	call	__invalid_parameter_noinfo
$LN26@getNextCom@2:
	mov	edi, DWORD PTR [ebx+172]
	push	ebp
	mov	ebp, esi
	npad	2
$LL43@getNextCom@2:
	mov	esi, DWORD PTR [ebx+188]
	cmp	DWORD PTR [ebx+184], esi
	jbe	SHORT $LN58@getNextCom@2
	call	__invalid_parameter_noinfo
$LN58@getNextCom@2:
	mov	eax, DWORD PTR [ebx+172]
	test	edi, edi
	je	SHORT $LN71@getNextCom@2
	cmp	edi, eax
	je	SHORT $LN72@getNextCom@2
$LN71@getNextCom@2:
	call	__invalid_parameter_noinfo
$LN72@getNextCom@2:
	cmp	ebp, esi
	je	SHORT $LN3@getNextCom@2

; 434  : 			{
; 435  : 				//if (tempCommand)
; 436  : 				//delete tempCommand;
; 437  : 				tempCommand = cur_bank->pop();

	test	edi, edi
	jne	SHORT $LN110@getNextCom@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN92@getNextCom@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN83@getNextCom@2
	call	__invalid_parameter_noinfo
$LN83@getNextCom@2:
	lea	esi, DWORD PTR [ebp+8]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	mov	DWORD PTR _tempCommand$140020[esp+12], eax
	test	edi, edi
	jne	SHORT $LN109@getNextCom@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN50@getNextCom@2:

; 430  : 		{
; 431  : 			Command *tempCommand = NULL;
; 432  : 
; 433  : 			for (vector<Bank>::iterator cur_bank = currentRank.bank.begin(); cur_bank != currentRank.bank.end(); cur_bank++)

	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN41@getNextCom@2
	call	__invalid_parameter_noinfo
$LN41@getNextCom@2:
	add	ebp, 152				; 00000098H
	jmp	SHORT $LL43@getNextCom@2
$LN110@getNextCom@2:

; 434  : 			{
; 435  : 				//if (tempCommand)
; 436  : 				//delete tempCommand;
; 437  : 				tempCommand = cur_bank->pop();

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN92@getNextCom@2
$LN109@getNextCom@2:

; 430  : 		{
; 431  : 			Command *tempCommand = NULL;
; 432  : 
; 433  : 			for (vector<Bank>::iterator cur_bank = currentRank.bank.begin(); cur_bank != currentRank.bank.end(); cur_bank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN50@getNextCom@2
$LN3@getNextCom@2:

; 438  : 				assert(tempCommand->getCommandType() == Command::REFRESH_ALL);
; 439  : 			}
; 440  : 
; 441  : 			return tempCommand;

	mov	eax, DWORD PTR _tempCommand$140020[esp+12]
	pop	ebp
	pop	esi
	pop	edi
	pop	ebx

; 454  : 	}
; 455  : }

	ret	4
$LN6@getNextCom@2:

; 442  : 
; 443  : 		}
; 444  : 		else
; 445  : 		{
; 446  : 			//bank_c &currentBank = currentRank.bank[nextCommand->getAddress().bank_id];
; 447  : 			assert(currentRank.bank[nextCommand->getAddress().getBank()].front() == nextCommand);
; 448  : 			return currentRank.bank[nextCommand->getAddress().getBank()].pop();

	mov	ecx, DWORD PTR [ebx+188]
	sub	ecx, DWORD PTR [ebx+184]
	mov	esi, DWORD PTR [edi+64]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN101@getNextCom@2
	call	__invalid_parameter_noinfo
$LN101@getNextCom@2:
	imul	esi, 152				; 00000098H
	add	esi, DWORD PTR [ebx+184]
	add	esi, 8
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	pop	esi
	pop	edi
	pop	ebx

; 454  : 	}
; 455  : }

	ret	4
$LN7@getNextCom@2:
	pop	edi

; 449  : 		}
; 450  : 	}
; 451  : 	else
; 452  : 	{
; 453  : 		return NULL;

	xor	eax, eax
	pop	ebx

; 454  : 	}
; 455  : }

	ret	4
?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ENDP ; DRAMsimII::fbdChannel::getNextCommand
PUBLIC	?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z	; DRAMsimII::fbdChannel::makeFrame
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T624567 = -4						; size = 4
_currentTime$ = 8					; size = 8
?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z PROC		; DRAMsimII::fbdChannel::makeFrame
; _this$ = edi

; 345  : {

	push	ecx

; 346  : 	assert(frameQueue.back()->getExecuteTime() != currentTime);
; 347  : 
; 348  : 	// decide if a new frame should be made or if commands can be added to an existing CMD+D frame
; 349  : 	fbdFrame *newFrame;
; 350  : 
; 351  : 	// then there is already a frame here that contains data so try to find a command to fill the A slot
; 352  : 	if (frameQueue.front()->getExecuteTime() == currentTime)

	mov	eax, DWORD PTR [edi+452]
	sub	eax, DWORD PTR [edi+448]
	push	ebx
	lea	ebx, DWORD PTR [edi+424]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN22@makeFrame
	call	__invalid_parameter_noinfo
$LN22@makeFrame:
	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, DWORD PTR _currentTime$[esp+12]
	jne	$LN140@makeFrame
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, DWORD PTR _currentTime$[esp+16]
	jne	$LN140@makeFrame

; 353  : 	{
; 354  : 		newFrame = frameQueue.read(0);

	cmp	DWORD PTR [ebx], 0
	jle	SHORT $LN30@makeFrame
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+4]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	esi, edx
	mov	edx, DWORD PTR [ebx+28]
	sub	edx, DWORD PTR [ebx+24]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN36@makeFrame
	call	__invalid_parameter_noinfo
$LN36@makeFrame:
	mov	eax, DWORD PTR [ebx+24]
	mov	ebp, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN29@makeFrame
$LN30@makeFrame:
	xor	ebp, ebp
$LN29@makeFrame:

; 355  : 		// search for an A command, something that can be executed in < 2 ticks
; 356  : 		// this command should also not conflict with the others in the queue
; 357  : 		// or others
; 358  : 		const Command *newCommand = readNextCommand(NULL, NULL);

	push	0
	push	0
	push	edi
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand

; 359  : 		// if the command can be issued on the next tick
; 360  : 		if (newCommand && (minProtocolGap(newCommand) - timingSpecification.tCMD() < 1))

	test	eax, eax
	je	$LN126@makeFrame
	mov	edx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+44]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, edi
	call	eax
	mov	esi, eax
	mov	ecx, edx
	mov	eax, ebx
	cdq
	sub	esi, eax
	sbb	ecx, edx
	test	ecx, ecx
	jg	$LN126@makeFrame
	jl	SHORT $LN137@makeFrame
	cmp	esi, 1
	jae	$LN126@makeFrame
$LN137@makeFrame:

; 361  : 		{
; 362  : 			newFrame->setCommandA(getNextCommand(NULL, NULL));

	push	edi
	xor	eax, eax
	xor	ecx, ecx
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	mov	DWORD PTR [ebp+4], eax
	test	eax, eax
	jne	SHORT $LN44@makeFrame
	pop	esi
	mov	DWORD PTR [ebp+16], 16			; 00000010H
	pop	ebp

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1
	pop	ebx

; 411  : }

	pop	ecx
	ret	8

; 361  : 		{
; 362  : 			newFrame->setCommandA(getNextCommand(NULL, NULL));

$LN44@makeFrame:
	mov	ecx, DWORD PTR [eax+80]
	pop	esi
	mov	DWORD PTR [ebp+16], ecx
	pop	ebp

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1
	pop	ebx

; 411  : }

	pop	ecx
	ret	8
$LN140@makeFrame:

; 363  : 		}
; 364  : 	}
; 365  : 	else
; 366  : 	{
; 367  : 		newFrame = new fbdFrame(currentTime);

	xor	esi, esi
	mov	ebp, 16					; 00000010H
	cmp	DWORD PTR ?freeFramePool@fbdFrame@DRAMsimII@@0V?$Queue@VfbdFrame@DRAMsimII@@@2@A, esi
	jne	SHORT $LN52@makeFrame
	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN55@makeFrame
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+24], ebp
	mov	DWORD PTR [eax+20], ebp
	mov	DWORD PTR [eax+16], ebp
	jmp	SHORT $LN51@makeFrame
$LN55@makeFrame:
	xor	eax, eax
	jmp	SHORT $LN51@makeFrame
$LN52@makeFrame:
	mov	esi, OFFSET ?freeFramePool@fbdFrame@DRAMsimII@@0V?$Queue@VfbdFrame@DRAMsimII@@@2@A ; DRAMsimII::fbdFrame::freeFramePool
	call	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
$LN51@makeFrame:
	test	eax, eax
	je	SHORT $LN14@makeFrame
	mov	edx, DWORD PTR _currentTime$[esp+12]
	mov	ecx, DWORD PTR _currentTime$[esp+16]
	mov	DWORD PTR [eax+40], edx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+24], ebp
	mov	DWORD PTR [eax+20], ebp
	mov	DWORD PTR [eax+16], ebp
	mov	esi, eax
	jmp	SHORT $LN15@makeFrame
$LN14@makeFrame:
	xor	esi, esi
$LN15@makeFrame:

; 368  : 		frameQueue.push(newFrame);

	push	esi
	mov	eax, ebx
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push

; 369  : 
; 370  : 		// search for an A command, something that can be executed in < 2 ticks
; 371  : 		// this command should also not conflict with the others in the queue
; 372  : 		// or others
; 373  : 		const Command *newCommand = readNextCommand(NULL, NULL);

	push	0
	push	0
	push	edi
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	mov	ebx, eax

; 374  : 		// if the command can be issued on the next tick
; 375  : 		if (newCommand && (minProtocolGap(newCommand) - timingSpecification.tCMD() < 1))

	test	ebx, ebx
	je	$LN126@makeFrame
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR $T624567[esp+16], edx
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	mov	ecx, edi
	call	edx
	mov	ebp, eax
	mov	eax, DWORD PTR $T624567[esp+16]
	mov	ecx, edx
	cdq
	sub	ebp, eax
	sbb	ecx, edx
	test	ecx, ecx
	jg	$LN126@makeFrame
	jl	SHORT $LN138@makeFrame
	cmp	ebp, 1
	jae	$LN126@makeFrame
$LN138@makeFrame:

; 376  : 		{
; 377  : 			newFrame->setCommandA(getNextCommand(NULL, NULL));

	push	edi
	xor	eax, eax
	xor	ecx, ecx
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	xor	ecx, ecx
	mov	DWORD PTR [esi+4], eax
	lea	ebp, DWORD PTR [ecx+16]
	cmp	eax, ecx
	jne	SHORT $LN65@makeFrame
	mov	DWORD PTR [esi+16], ebp
	jmp	SHORT $LN64@makeFrame
$LN65@makeFrame:
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR [esi+16], eax
$LN64@makeFrame:

; 378  : 
; 379  : 			// if this was a CAS+W then the frame type will be CMD+D
; 380  : 			if (newCommand->isReadOrWrite())

	mov	eax, DWORD PTR [ebx+80]
	cmp	eax, 1
	je	SHORT $LN72@makeFrame
	cmp	eax, 2
	je	SHORT $LN72@makeFrame
	cmp	eax, 3
	je	SHORT $LN72@makeFrame
	cmp	eax, 4
	jne	$LN7@makeFrame
$LN72@makeFrame:

; 381  : 			{
; 382  : 				newFrame->setCommandB(NULL);

	mov	ebx, 10					; 0000000aH
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+20], ebx

; 383  : 				newFrame->setCommandC(NULL);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+24], ebx

; 384  : 				// create some new frames for the remainder of the data
; 385  : 				for (int i = 1; i < timingSpecification.tBurst(); ++i)

	mov	esi, 1
	cmp	DWORD PTR [edi+32], esi
	jle	$LN126@makeFrame
	npad	6
$LL6@makeFrame:

; 386  : 				{
; 387  : 					fbdFrame *extraFrame = new fbdFrame(currentTime + i);

	call	??2fbdFrame@DRAMsimII@@SAPAXI@Z		; DRAMsimII::fbdFrame::operator new
	mov	ecx, eax
	xor	edx, edx
	cmp	ecx, edx
	je	SHORT $LN16@makeFrame
	mov	eax, esi
	cdq
	add	eax, DWORD PTR _currentTime$[esp+12]
	mov	DWORD PTR [ecx+24], ebp
	adc	edx, DWORD PTR _currentTime$[esp+16]
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+20], ebp
	mov	DWORD PTR [ecx+16], ebp
	mov	eax, ecx
	mov	ebx, 10					; 0000000aH
	xor	edx, edx
	jmp	SHORT $LN17@makeFrame
$LN16@makeFrame:
	xor	eax, eax
$LN17@makeFrame:

; 388  : 					extraFrame->setCommandA(NULL);

	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+16], ebp

; 389  : 					extraFrame->setCommandB(NULL);

	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+20], ebx

; 390  : 					extraFrame->setCommandC(NULL);

	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+24], ebx

; 391  : 					frameQueue.push(extraFrame);

	push	eax
	lea	eax, DWORD PTR [edi+424]
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
	inc	esi
	cmp	esi, DWORD PTR [edi+32]
	jl	SHORT $LL6@makeFrame
	pop	esi
	pop	ebp

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1
	pop	ebx

; 411  : }

	pop	ecx
	ret	8
$LN7@makeFrame:

; 392  : 				}
; 393  : 			}
; 394  : 			// otherwise try to find two more commands to fill the B and C slots
; 395  : 			else
; 396  : 			{
; 397  : 				// overloaded readNextCommand() will only return commands which do not interfere with the commands passed in
; 398  : 				if (readNextCommand(newCommand, NULL))

	push	ecx
	push	ebx
	push	edi
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	test	eax, eax
	je	SHORT $LN139@makeFrame

; 399  : 				{
; 400  : 					newFrame->setCommandB(getNextCommand(newCommand, NULL));

	push	edi
	xor	eax, eax
	mov	ecx, ebx
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	jne	SHORT $LN117@makeFrame
	mov	DWORD PTR [esi+20], 10			; 0000000aH
	jmp	SHORT $LN139@makeFrame
$LN117@makeFrame:
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [esi+20], ecx
$LN139@makeFrame:

; 401  : 				}
; 402  : 				if (readNextCommand(newCommand, newFrame->getCommandB()))

	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ebx
	push	edi
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	test	eax, eax
	je	SHORT $LN126@makeFrame

; 403  : 				{
; 404  : 					newFrame->setCommandC(getNextCommand(newCommand, newFrame->getCommandB()));

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ecx, ebx
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	mov	DWORD PTR [esi+12], eax
	test	eax, eax
	jne	SHORT $LN127@makeFrame
	mov	DWORD PTR [esi+24], 10			; 0000000aH
	pop	esi
	pop	ebp

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1
	pop	ebx

; 411  : }

	pop	ecx
	ret	8

; 403  : 				{
; 404  : 					newFrame->setCommandC(getNextCommand(newCommand, newFrame->getCommandB()));

$LN127@makeFrame:
	mov	edx, DWORD PTR [eax+80]
	mov	DWORD PTR [esi+24], edx
$LN126@makeFrame:
	pop	esi
	pop	ebp

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1
	pop	ebx

; 411  : }

	pop	ecx
	ret	8
?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ENDP		; DRAMsimII::fbdChannel::makeFrame
PUBLIC	?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z	; DRAMsimII::fbdChannel::moveToTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_nextFrameTime$139962 = -16				; size = 8
_nextDecodeTime$139960 = -8				; size = 8
_endTime$ = 8						; size = 8
?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z PROC	; DRAMsimII::fbdChannel::moveToTime
; _this$ = esi

; 256  : 	while (time < endTime)

	mov	eax, DWORD PTR [esi+12]
	sub	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _endTime$[esp+16]
	jg	$LN101@moveToTime@3
	jl	SHORT $LN105@moveToTime@3
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _endTime$[esp+12]
	jae	$LN101@moveToTime@3
$LN105@moveToTime@3:
	push	ebx
	push	ebp
	push	edi
$LL8@moveToTime@3:

; 257  : 	{
; 258  : 		// try to convert any transactions into commands first
; 259  : 		if (checkForAvailableCommandSlots(readTransaction(true)))

	push	1
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	push	esi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	SHORT $LN6@moveToTime@3

; 260  : 		{
; 261  : 			// actually remove it from the queue now
; 262  : 			Transaction *decodedTransaction = getTransaction();

	mov	eax, esi
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction

; 263  : 
; 264  : 			// then break into commands and insert into per bank command queues
; 265  : 			bool t2cResult = transaction2commands(decodedTransaction);

	push	eax
	push	esi
	call	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands

; 266  : 
; 267  : 			assert(t2cResult == true);
; 268  : 
; 269  : 			DEBUG_TRANSACTION_LOG("T->C [" << time << "] Q[" << getTransactionQueueCount() << "]" << decodedTransaction);
; 270  : 		}
; 271  : 		// if all available transactions are converted to commands, then execute the frame corresponding to this time
; 272  : 		else

	jmp	$LN5@moveToTime@3
$LN6@moveToTime@3:

; 273  : 		{
; 274  : 			// move time up by executing frames
; 275  : 			fbdFrame *nextFrame = getNextFrame();

	mov	eax, DWORD PTR [esi+424]
	test	eax, eax
	je	$LN11@moveToTime@3
	mov	edi, DWORD PTR [esi+428]
	dec	eax
	mov	DWORD PTR [esi+424], eax
	mov	edx, DWORD PTR [esi+452]
	sub	edx, DWORD PTR [esi+448]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN19@moveToTime@3
	call	__invalid_parameter_noinfo
$LN19@moveToTime@3:
	mov	eax, DWORD PTR [esi+448]
	mov	ecx, DWORD PTR [esi+452]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [esi+428]
	sub	ecx, eax
	sar	ecx, 2
	cmp	edi, ecx
	jb	SHORT $LN24@moveToTime@3
	call	__invalid_parameter_noinfo
$LN24@moveToTime@3:
	mov	edx, DWORD PTR [esi+448]
	mov	DWORD PTR [edx+edi*4], 0
	mov	ecx, DWORD PTR [esi+452]
	sub	ecx, DWORD PTR [esi+448]
	mov	eax, DWORD PTR [esi+428]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	DWORD PTR [esi+428], edx

; 276  : 
; 277  : 			// if there's a frame at this time
; 278  : 			if (nextFrame)

	test	ebx, ebx
	je	SHORT $LN11@moveToTime@3

; 279  : 			{
; 280  : 				// execute any commands in this frame
; 281  : 				if (nextFrame->getCommandAType() != Command::INVALID_COMMAND)

	cmp	DWORD PTR [ebx+16], 16			; 00000010H
	je	SHORT $LN3@moveToTime@3

; 282  : 				{
; 283  : 					statistics.collectCommandStats(nextFrame->getCommandA());

	mov	edx, DWORD PTR [esi+180]
	mov	edi, DWORD PTR [ebx+4]
	push	edx
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 284  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandA());
; 285  : 					executeCommand(nextFrame->getCommandA());

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	push	esi
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN3@moveToTime@3:

; 286  : 				}
; 287  : 				if (nextFrame->getCommandBType() != Command::INVALID_COMMAND && nextFrame->getCommandBType() != Command::DATA_COMMAND)

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 16					; 00000010H
	je	SHORT $LN104@moveToTime@3
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN104@moveToTime@3

; 288  : 				{
; 289  : 					statistics.collectCommandStats(nextFrame->getCommandB());

	mov	ecx, DWORD PTR [esi+180]
	mov	edi, DWORD PTR [ebx+8]
	push	ecx
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 290  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandB());
; 291  : 					executeCommand(nextFrame->getCommandB());

	mov	edx, DWORD PTR [ebx+8]
	push	edx
	push	esi
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN104@moveToTime@3:

; 292  : 				}
; 293  : 				if (nextFrame->getCommandCType() != Command::INVALID_COMMAND && nextFrame->getCommandCType() != Command::DATA_COMMAND)

	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, 16					; 00000010H
	je	SHORT $LN1@moveToTime@3
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN1@moveToTime@3

; 294  : 				{
; 295  : 					statistics.collectCommandStats(nextFrame->getCommandC());

	mov	eax, DWORD PTR [esi+180]
	mov	edi, DWORD PTR [ebx+12]
	push	eax
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 296  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandC());
; 297  : 					executeCommand(nextFrame->getCommandC());

	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	push	esi
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN1@moveToTime@3:

; 298  : 				}
; 299  : 			}
; 300  : 
; 301  : 			delete nextFrame;

	push	ebx
	mov	ecx, OFFSET ?freeFramePool@fbdFrame@DRAMsimII@@0V?$Queue@VfbdFrame@DRAMsimII@@@2@A ; DRAMsimII::fbdFrame::freeFramePool
	call	?releaseItem@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEXPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::releaseItem
$LN11@moveToTime@3:

; 302  : 
; 303  : 			// then build a frame for t+1, if possible
; 304  : 			makeFrame(time);

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+8]
	push	edx
	push	eax
	mov	edi, esi
	call	?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ; DRAMsimII::fbdChannel::makeFrame

; 305  : 
; 306  : 			// last, move time forward to either the next transaction decode or frame create time
; 307  : 			tick nextDecodeTime = nextTransactionDecodeTime();

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN60@moveToTime@3
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN61@moveToTime@3
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN64@moveToTime@3
$LN61@moveToTime@3:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN64@moveToTime@3
$LN60@moveToTime@3:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN64@moveToTime@3:

; 308  : 			assert(nextDecodeTime > time);
; 309  : 			tick nextFrameTime = nextFrameExecuteTime();

	mov	ecx, DWORD PTR [esi+452]
	sub	ecx, DWORD PTR [esi+448]
	mov	ebp, DWORD PTR [esi+428]
	sar	ecx, 2
	mov	DWORD PTR _nextDecodeTime$139960[esp+28], ebx
	mov	DWORD PTR _nextDecodeTime$139960[esp+32], edi
	cmp	ebp, ecx
	jb	SHORT $LN78@moveToTime@3
	call	__invalid_parameter_noinfo
$LN78@moveToTime@3:
	mov	edx, DWORD PTR [esi+448]
	mov	eax, DWORD PTR [edx+ebp*4]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [eax+44]

; 310  : 			assert(nextFrameTime > time);
; 311  : 
; 312  : 
; 313  : 			time = min(endTime, min(nextDecodeTime, nextFrameTime));

	cmp	eax, edi
	mov	DWORD PTR _nextFrameTime$139962[esp+28], ecx
	mov	DWORD PTR _nextFrameTime$139962[esp+32], eax
	jg	SHORT $LN87@moveToTime@3
	jl	SHORT $LN96@moveToTime@3
	cmp	ecx, ebx
	jae	SHORT $LN87@moveToTime@3
$LN96@moveToTime@3:
	lea	eax, DWORD PTR _nextFrameTime$139962[esp+28]
	jmp	SHORT $LN88@moveToTime@3
$LN87@moveToTime@3:
	lea	eax, DWORD PTR _nextDecodeTime$139960[esp+28]
$LN88@moveToTime@3:
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _endTime$[esp+28]
	jg	SHORT $LN91@moveToTime@3
	jl	SHORT $LN92@moveToTime@3
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _endTime$[esp+24]
	jb	SHORT $LN92@moveToTime@3
$LN91@moveToTime@3:
	lea	eax, DWORD PTR _endTime$[esp+24]
$LN92@moveToTime@3:
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx
$LN5@moveToTime@3:
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _endTime$[esp+28]
	jl	$LL8@moveToTime@3

; 256  : 	while (time < endTime)

	jg	SHORT $LN100@moveToTime@3
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _endTime$[esp+24]
	jb	$LL8@moveToTime@3
$LN100@moveToTime@3:
	pop	edi
	pop	ebp

; 314  : 		}		
; 315  : 	}
; 316  : 
; 317  : 
; 318  : 	assert(time <= endTime + timingSpecification.tCMD());
; 319  : 
; 320  : 	//*transFinishTime = endTime;
; 321  : 
; 322  : 	M5_TIMING_LOG("ch[" << channelID << "] @ " << std::dec << time);
; 323  : 
; 324  : 	return UINT_MAX;

	or	eax, -1
	pop	ebx

; 325  : 
; 326  : }

	add	esp, 16					; 00000010H
	ret	8
$LN101@moveToTime@3:

; 314  : 		}		
; 315  : 	}
; 316  : 
; 317  : 
; 318  : 	assert(time <= endTime + timingSpecification.tCMD());
; 319  : 
; 320  : 	//*transFinishTime = endTime;
; 321  : 
; 322  : 	M5_TIMING_LOG("ch[" << channelID << "] @ " << std::dec << time);
; 323  : 
; 324  : 	return UINT_MAX;

	or	eax, -1

; 325  : 
; 326  : }

	add	esp, 16					; 00000010H
	ret	8
?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z ENDP	; DRAMsimII::fbdChannel::moveToTime
PUBLIC	??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::fbdChannel::fbdChannel
__unwindtable$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
__ehfuncinfo$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_stats$ = 12						; size = 4
??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::fbdChannel::fbdChannel
; _settings$ = edx
; _sysConfig$ = ecx

; 25   : {

	push	-1
	push	__ehhandler$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	mov	eax, DWORD PTR _stats$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
	push	0
	lea	eax, DWORD PTR [esi+424]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	push	eax
	mov	ecx, 3
	mov	DWORD PTR [esi], OFFSET ??_7fbdChannel@DRAMsimII@@6B@
	call	??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>

; 26   : 
; 27   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
__unwindfunclet$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
__ehhandler$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::fbdChannel::fbdChannel
END
