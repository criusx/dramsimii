; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\reporting\stdsoap2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07JJJGGCEE@x?9token?$AA@			; `string'
PUBLIC	??_C@_0L@EPBKNKII@ietf?9token?$AA@		; `string'
PUBLIC	??_C@_06JEFEFGEJ@base64?$AA@			; `string'
PUBLIC	??_C@_0BB@CAHAECFA@quoted?9printable?$AA@	; `string'
PUBLIC	??_C@_06FNFBAEBE@binary?$AA@			; `string'
PUBLIC	??_C@_04DFPGIIHA@8bit?$AA@			; `string'
PUBLIC	??_C@_04LHKGBPKB@7bit?$AA@			; `string'
PUBLIC	??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@ ; `string'
PUBLIC	??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@	; `string'
PUBLIC	??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@	; `string'
PUBLIC	??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@		; `string'
PUBLIC	??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@	; `string'
PUBLIC	??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@	; `string'
PUBLIC	??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@	; `string'
PUBLIC	??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@ ; `string'
PUBLIC	??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@ ; `string'
PUBLIC	??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@	; `string'
PUBLIC	??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@ ; `string'
PUBLIC	??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@	; `string'
PUBLIC	??_C@_0BA@JCKHPIPI@Length?5Required?$AA@	; `string'
PUBLIC	??_C@_04OKIIBCCG@Gone?$AA@			; `string'
PUBLIC	??_C@_08OJCIFGDF@Conflict?$AA@			; `string'
PUBLIC	??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@	; `string'
PUBLIC	??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@ ; `string'
PUBLIC	??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@		; `string'
PUBLIC	??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@	; `string'
PUBLIC	??_C@_09CFCBFJND@Not?5Found?$AA@		; `string'
PUBLIC	??_C@_09LMDIMFJD@Forbidden?$AA@			; `string'
PUBLIC	??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@	; `string'
PUBLIC	??_C@_0N@OOAPMOJA@Unauthorized?$AA@		; `string'
PUBLIC	??_C@_0M@LNAIDEEG@Bad?5Request?$AA@		; `string'
PUBLIC	??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@	; `string'
PUBLIC	??_C@_09JFBGBFIM@Use?5Proxy?$AA@		; `string'
PUBLIC	??_C@_0N@IFEFAIJB@Not?5Modified?$AA@		; `string'
PUBLIC	??_C@_09FAMPMKIP@See?5Other?$AA@		; `string'
PUBLIC	??_C@_05JDGHEPJG@Found?$AA@			; `string'
PUBLIC	??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@	; `string'
PUBLIC	??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@	; `string'
PUBLIC	??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@	; `string'
PUBLIC	??_C@_0O@BFFLKCLE@Reset?5Content?$AA@		; `string'
PUBLIC	??_C@_0L@FDPJCNGK@No?5Content?$AA@		; `string'
PUBLIC	??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@ ; `string'
PUBLIC	??_C@_08DOBOODLA@Accepted?$AA@			; `string'
PUBLIC	??_C@_07BBIDHECN@Created?$AA@			; `string'
PUBLIC	??_C@_02GIPFHKNO@OK?$AA@			; `string'
PUBLIC	??_C@_0L@GGLPAOMP@No?5Address?$AA@		; `string'
PUBLIC	??_C@_07NNGPDNPG@No?5Data?$AA@			; `string'
PUBLIC	??_C@_0M@IFLIHMFH@No?5Recovery?$AA@		; `string'
PUBLIC	??_C@_09NOIJLNLL@Try?5Again?$AA@		; `string'
PUBLIC	??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@		; `string'
PUBLIC	??_C@_04BILJKGCK@yuml?$AA@			; `string'
PUBLIC	??_C@_05LIICDAEF@thorn?$AA@			; `string'
PUBLIC	??_C@_06BBMKGLNL@yacute?$AA@			; `string'
PUBLIC	??_C@_04NNEJELCL@uuml?$AA@			; `string'
PUBLIC	??_C@_05JEMLPDGA@ucirc?$AA@			; `string'
PUBLIC	??_C@_06NGGKABKP@uacute?$AA@			; `string'
PUBLIC	??_C@_06IBEMEICG@ugrave?$AA@			; `string'
PUBLIC	??_C@_06LGBAFOGO@oslash?$AA@			; `string'
PUBLIC	??_C@_06FFHJEHBN@divide?$AA@			; `string'
PUBLIC	??_C@_04PHBJMEAI@ouml?$AA@			; `string'
PUBLIC	??_C@_06DNFIPCMD@otilde?$AA@			; `string'
PUBLIC	??_C@_05DGIGNCJN@ocirc?$AA@			; `string'
PUBLIC	??_C@_06BFMEMCCP@oacute?$AA@			; `string'
PUBLIC	??_C@_06ECOCILKG@ograve?$AA@			; `string'
PUBLIC	??_C@_06JLCPPJHH@ntilde?$AA@			; `string'
PUBLIC	??_C@_03CMJPAGPB@eth?$AA@			; `string'
PUBLIC	??_C@_04HIFJDBKI@iuml?$AA@			; `string'
PUBLIC	??_C@_05OANPDBIA@icirc?$AA@			; `string'
PUBLIC	??_C@_06HGBEPHBF@iacute?$AA@			; `string'
PUBLIC	??_C@_06CBDCLOJM@igrave?$AA@			; `string'
PUBLIC	??_C@_04LNKJNMKJ@euml?$AA@			; `string'
PUBLIC	??_C@_05JHBNPBPL@ecirc?$AA@			; `string'
PUBLIC	??_C@_06LBLEJNGB@eacute?$AA@			; `string'
PUBLIC	??_C@_06OGJCNEOI@egrave?$AA@			; `string'
PUBLIC	??_C@_06DNHFEHGA@ccedil?$AA@			; `string'
PUBLIC	??_C@_05MAANDPOK@aelig?$AA@			; `string'
PUBLIC	??_C@_05CAFMJCMP@aring?$AA@			; `string'
PUBLIC	??_C@_04EICJHKGJ@auml?$AA@			; `string'
PUBLIC	??_C@_06GNGHIJJO@atilde?$AA@			; `string'
PUBLIC	??_C@_05MIMLDON@acirc?$AA@			; `string'
PUBLIC	??_C@_06EFPLLJHC@aacute?$AA@			; `string'
PUBLIC	??_C@_06BCNNPAPL@agrave?$AA@			; `string'
PUBLIC	??_C@_05GMKDJMCJ@szlig?$AA@			; `string'
PUBLIC	??_C@_05HDBENHAL@THORN?$AA@			; `string'
PUBLIC	??_C@_06NOHHFCEH@Yacute?$AA@			; `string'
PUBLIC	??_C@_04BMIIGECP@Uuml?$AA@			; `string'
PUBLIC	??_C@_05JDGHPGFG@Ucirc?$AA@			; `string'
PUBLIC	??_C@_06BJNHDIDD@Uacute?$AA@			; `string'
PUBLIC	??_C@_06EOPBHBLK@Ugrave?$AA@			; `string'
PUBLIC	??_C@_06HJKNGHPC@Oslash?$AA@			; `string'
PUBLIC	??_C@_05MJOOAIJH@times?$AA@			; `string'
PUBLIC	??_C@_04DGNIOLAM@Ouml?$AA@			; `string'
PUBLIC	??_C@_06PCOFMLFP@Otilde?$AA@			; `string'
PUBLIC	??_C@_05DBCKNHKL@Ocirc?$AA@			; `string'
PUBLIC	??_C@_06NKHJPLLD@Oacute?$AA@			; `string'
PUBLIC	??_C@_06INFPLCDK@Ograve?$AA@			; `string'
PUBLIC	??_C@_06FEJCMAOL@Ntilde?$AA@			; `string'
PUBLIC	??_C@_03CBGEMLIN@ETH?$AA@			; `string'
PUBLIC	??_C@_04LJJIBOKM@Iuml?$AA@			; `string'
PUBLIC	??_C@_05OHHDDELG@Icirc?$AA@			; `string'
PUBLIC	??_C@_06LJKJMOIJ@Iacute?$AA@			; `string'
PUBLIC	??_C@_06OOIPIHAA@Igrave?$AA@			; `string'
PUBLIC	??_C@_04HMGIPDKN@Euml?$AA@			; `string'
PUBLIC	??_C@_05JALBPEMN@Ecirc?$AA@			; `string'
PUBLIC	??_C@_06HOAJKEPN@Eacute?$AA@			; `string'
PUBLIC	??_C@_06CJCPONHE@Egrave?$AA@			; `string'
PUBLIC	??_C@_06PCMIHOPM@Ccedil?$AA@			; `string'
PUBLIC	??_C@_05GGABFNI@AElig?$AA@			; `string'
PUBLIC	??_C@_05CHPAJHPJ@Aring?$AA@			; `string'
PUBLIC	??_C@_04IJOIFFGN@Auml?$AA@			; `string'
PUBLIC	??_C@_06KCNKLAAC@Atilde?$AA@			; `string'
PUBLIC	??_C@_05LCALGNL@Acirc?$AA@			; `string'
PUBLIC	??_C@_06IKEGIAOO@Aacute?$AA@			; `string'
PUBLIC	??_C@_06NNGAMJGH@Agrave?$AA@			; `string'
PUBLIC	??_C@_06JMONPFKG@iquest?$AA@			; `string'
PUBLIC	??_C@_06NMNJFLLK@frac34?$AA@			; `string'
PUBLIC	??_C@_06IJAHCIFC@frac12?$AA@			; `string'
PUBLIC	??_C@_06NPFNIPNE@frac14?$AA@			; `string'
PUBLIC	??_C@_05MPFJLGEB@raquo?$AA@			; `string'
PUBLIC	??_C@_04HMAEPGHP@ordm?$AA@			; `string'
PUBLIC	??_C@_04EJOCKNLB@sup1?$AA@			; `string'
PUBLIC	??_C@_05KLIFGPMF@cedil?$AA@			; `string'
PUBLIC	??_C@_06HHCHNCAA@middot?$AA@			; `string'
PUBLIC	??_C@_04GIAGJOJD@para?$AA@			; `string'
PUBLIC	??_C@_05PCPGMEFP@micro?$AA@			; `string'
PUBLIC	??_C@_05EEJEIAPO@acute?$AA@			; `string'
PUBLIC	??_C@_04HLNEMPDD@sup3?$AA@			; `string'
PUBLIC	??_C@_04GCMPPOHC@sup2?$AA@			; `string'
PUBLIC	??_C@_06CAEEBBM@plusmn?$AA@			; `string'
PUBLIC	??_C@_03OFPLEBM@deg?$AA@			; `string'
PUBLIC	??_C@_04IMHNEFHF@macr?$AA@			; `string'
PUBLIC	??_C@_03HLCNLMFP@reg?$AA@			; `string'
PUBLIC	??_C@_03BPAIHHLG@shy?$AA@			; `string'
PUBLIC	??_C@_03NJKJADM@not?$AA@			; `string'
PUBLIC	??_C@_05PGIFNFKK@laquo?$AA@			; `string'
PUBLIC	??_C@_04JPPACPLE@ordf?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_03LBNAMJF@uml?$AA@			; `string'
PUBLIC	??_C@_04IKJFFMEH@sect?$AA@			; `string'
PUBLIC	??_C@_06ILPBEBAD@brvbar?$AA@			; `string'
PUBLIC	??_C@_03HNOOIABH@yen?$AA@			; `string'
PUBLIC	??_C@_06HEGEHONB@curren?$AA@			; `string'
PUBLIC	??_C@_05EBEEKLCG@pound?$AA@			; `string'
PUBLIC	??_C@_04OCKNFIJG@cent?$AA@			; `string'
PUBLIC	??_C@_05BNEGCBFC@iexcl?$AA@			; `string'
PUBLIC	??_C@_04PHHIFBLJ@nbsp?$AA@			; `string'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	_soap_double_nan
_BSS	SEGMENT
_tcp_done DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07JJJGGCEE@x?9token?$AA@
CONST	SEGMENT
??_C@_07JJJGGCEE@x?9token?$AA@ DB 'x-token', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPBKNKII@ietf?9token?$AA@
CONST	SEGMENT
??_C@_0L@EPBKNKII@ietf?9token?$AA@ DB 'ietf-token', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JEFEFGEJ@base64?$AA@
CONST	SEGMENT
??_C@_06JEFEFGEJ@base64?$AA@ DB 'base64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAHAECFA@quoted?9printable?$AA@
CONST	SEGMENT
??_C@_0BB@CAHAECFA@quoted?9printable?$AA@ DB 'quoted-printable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNFBAEBE@binary?$AA@
CONST	SEGMENT
??_C@_06FNFBAEBE@binary?$AA@ DB 'binary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFPGIIHA@8bit?$AA@
CONST	SEGMENT
??_C@_04DFPGIIHA@8bit?$AA@ DB '8bit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LHKGBPKB@7bit?$AA@
CONST	SEGMENT
??_C@_04LHKGBPKB@7bit?$AA@ DB '7bit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@
CONST	SEGMENT
??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@ DB 'HTTP Version no'
	DB	't supported', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@
CONST	SEGMENT
??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@ DB 'Gateway Time-out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@
CONST	SEGMENT
??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@ DB 'Service Unavailable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@
CONST	SEGMENT
??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@ DB 'Bad Gateway', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@
CONST	SEGMENT
??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@ DB 'Not Implemented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@
CONST	SEGMENT
??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@ DB 'Internal Server Error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@
CONST	SEGMENT
??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@ DB 'Expectation Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@
CONST	SEGMENT
??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@ DB 'Requested '
	DB	'range not satisfiable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@
CONST	SEGMENT
??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@ DB 'Unsupported Media Ty'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@
CONST	SEGMENT
??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@ DB 'Request-URI Too Large'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@
CONST	SEGMENT
??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@ DB 'Request Entity To'
	DB	'o Large', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@
CONST	SEGMENT
??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@ DB 'Precondition Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCKHPIPI@Length?5Required?$AA@
CONST	SEGMENT
??_C@_0BA@JCKHPIPI@Length?5Required?$AA@ DB 'Length Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKIIBCCG@Gone?$AA@
CONST	SEGMENT
??_C@_04OKIIBCCG@Gone?$AA@ DB 'Gone', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJCIFGDF@Conflict?$AA@
CONST	SEGMENT
??_C@_08OJCIFGDF@Conflict?$AA@ DB 'Conflict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@
CONST	SEGMENT
??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@ DB 'Request Time-out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@
CONST	SEGMENT
??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@ DB 'Proxy Authent'
	DB	'ication Required', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@
CONST	SEGMENT
??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@ DB 'Not Acceptable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@
CONST	SEGMENT
??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@ DB 'Method Not Allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFCBFJND@Not?5Found?$AA@
CONST	SEGMENT
??_C@_09CFCBFJND@Not?5Found?$AA@ DB 'Not Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMDIMFJD@Forbidden?$AA@
CONST	SEGMENT
??_C@_09LMDIMFJD@Forbidden?$AA@ DB 'Forbidden', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@
CONST	SEGMENT
??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@ DB 'Payment Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOAPMOJA@Unauthorized?$AA@
CONST	SEGMENT
??_C@_0N@OOAPMOJA@Unauthorized?$AA@ DB 'Unauthorized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNAIDEEG@Bad?5Request?$AA@
CONST	SEGMENT
??_C@_0M@LNAIDEEG@Bad?5Request?$AA@ DB 'Bad Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@
CONST	SEGMENT
??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@ DB 'Temporary Redirect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFBGBFIM@Use?5Proxy?$AA@
CONST	SEGMENT
??_C@_09JFBGBFIM@Use?5Proxy?$AA@ DB 'Use Proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFEFAIJB@Not?5Modified?$AA@
CONST	SEGMENT
??_C@_0N@IFEFAIJB@Not?5Modified?$AA@ DB 'Not Modified', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAMPMKIP@See?5Other?$AA@
CONST	SEGMENT
??_C@_09FAMPMKIP@See?5Other?$AA@ DB 'See Other', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JDGHEPJG@Found?$AA@
CONST	SEGMENT
??_C@_05JDGHEPJG@Found?$AA@ DB 'Found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@
CONST	SEGMENT
??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@ DB 'Moved Permanently', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@
CONST	SEGMENT
??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@ DB 'Multiple Choices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@
CONST	SEGMENT
??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@ DB 'Partial Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFFLKCLE@Reset?5Content?$AA@
CONST	SEGMENT
??_C@_0O@BFFLKCLE@Reset?5Content?$AA@ DB 'Reset Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FDPJCNGK@No?5Content?$AA@
CONST	SEGMENT
??_C@_0L@FDPJCNGK@No?5Content?$AA@ DB 'No Content', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@
CONST	SEGMENT
??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@ DB 'Non-Authorita'
	DB	'tive Information', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOBOODLA@Accepted?$AA@
CONST	SEGMENT
??_C@_08DOBOODLA@Accepted?$AA@ DB 'Accepted', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBIDHECN@Created?$AA@
CONST	SEGMENT
??_C@_07BBIDHECN@Created?$AA@ DB 'Created', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIPFHKNO@OK?$AA@
CONST	SEGMENT
??_C@_02GIPFHKNO@OK?$AA@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GGLPAOMP@No?5Address?$AA@
CONST	SEGMENT
??_C@_0L@GGLPAOMP@No?5Address?$AA@ DB 'No Address', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNGPDNPG@No?5Data?$AA@
CONST	SEGMENT
??_C@_07NNGPDNPG@No?5Data?$AA@ DB 'No Data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFLIHMFH@No?5Recovery?$AA@
CONST	SEGMENT
??_C@_0M@IFLIHMFH@No?5Recovery?$AA@ DB 'No Recovery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NOIJLNLL@Try?5Again?$AA@
CONST	SEGMENT
??_C@_09NOIJLNLL@Try?5Again?$AA@ DB 'Try Again', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@ DB 'Host not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BILJKGCK@yuml?$AA@
CONST	SEGMENT
??_C@_04BILJKGCK@yuml?$AA@ DB 'yuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LIICDAEF@thorn?$AA@
CONST	SEGMENT
??_C@_05LIICDAEF@thorn?$AA@ DB 'thorn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBMKGLNL@yacute?$AA@
CONST	SEGMENT
??_C@_06BBMKGLNL@yacute?$AA@ DB 'yacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNEJELCL@uuml?$AA@
CONST	SEGMENT
??_C@_04NNEJELCL@uuml?$AA@ DB 'uuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JEMLPDGA@ucirc?$AA@
CONST	SEGMENT
??_C@_05JEMLPDGA@ucirc?$AA@ DB 'ucirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGGKABKP@uacute?$AA@
CONST	SEGMENT
??_C@_06NGGKABKP@uacute?$AA@ DB 'uacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBEMEICG@ugrave?$AA@
CONST	SEGMENT
??_C@_06IBEMEICG@ugrave?$AA@ DB 'ugrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGBAFOGO@oslash?$AA@
CONST	SEGMENT
??_C@_06LGBAFOGO@oslash?$AA@ DB 'oslash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFHJEHBN@divide?$AA@
CONST	SEGMENT
??_C@_06FFHJEHBN@divide?$AA@ DB 'divide', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHBJMEAI@ouml?$AA@
CONST	SEGMENT
??_C@_04PHBJMEAI@ouml?$AA@ DB 'ouml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNFIPCMD@otilde?$AA@
CONST	SEGMENT
??_C@_06DNFIPCMD@otilde?$AA@ DB 'otilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGIGNCJN@ocirc?$AA@
CONST	SEGMENT
??_C@_05DGIGNCJN@ocirc?$AA@ DB 'ocirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFMEMCCP@oacute?$AA@
CONST	SEGMENT
??_C@_06BFMEMCCP@oacute?$AA@ DB 'oacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ECOCILKG@ograve?$AA@
CONST	SEGMENT
??_C@_06ECOCILKG@ograve?$AA@ DB 'ograve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLCPPJHH@ntilde?$AA@
CONST	SEGMENT
??_C@_06JLCPPJHH@ntilde?$AA@ DB 'ntilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CMJPAGPB@eth?$AA@
CONST	SEGMENT
??_C@_03CMJPAGPB@eth?$AA@ DB 'eth', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIFJDBKI@iuml?$AA@
CONST	SEGMENT
??_C@_04HIFJDBKI@iuml?$AA@ DB 'iuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OANPDBIA@icirc?$AA@
CONST	SEGMENT
??_C@_05OANPDBIA@icirc?$AA@ DB 'icirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGBEPHBF@iacute?$AA@
CONST	SEGMENT
??_C@_06HGBEPHBF@iacute?$AA@ DB 'iacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBDCLOJM@igrave?$AA@
CONST	SEGMENT
??_C@_06CBDCLOJM@igrave?$AA@ DB 'igrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNKJNMKJ@euml?$AA@
CONST	SEGMENT
??_C@_04LNKJNMKJ@euml?$AA@ DB 'euml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JHBNPBPL@ecirc?$AA@
CONST	SEGMENT
??_C@_05JHBNPBPL@ecirc?$AA@ DB 'ecirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LBLEJNGB@eacute?$AA@
CONST	SEGMENT
??_C@_06LBLEJNGB@eacute?$AA@ DB 'eacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGJCNEOI@egrave?$AA@
CONST	SEGMENT
??_C@_06OGJCNEOI@egrave?$AA@ DB 'egrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNHFEHGA@ccedil?$AA@
CONST	SEGMENT
??_C@_06DNHFEHGA@ccedil?$AA@ DB 'ccedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAANDPOK@aelig?$AA@
CONST	SEGMENT
??_C@_05MAANDPOK@aelig?$AA@ DB 'aelig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAFMJCMP@aring?$AA@
CONST	SEGMENT
??_C@_05CAFMJCMP@aring?$AA@ DB 'aring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJHKGJ@auml?$AA@
CONST	SEGMENT
??_C@_04EICJHKGJ@auml?$AA@ DB 'auml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNGHIJJO@atilde?$AA@
CONST	SEGMENT
??_C@_06GNGHIJJO@atilde?$AA@ DB 'atilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIMLDON@acirc?$AA@
CONST	SEGMENT
??_C@_05MIMLDON@acirc?$AA@ DB 'acirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFPLLJHC@aacute?$AA@
CONST	SEGMENT
??_C@_06EFPLLJHC@aacute?$AA@ DB 'aacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCNNPAPL@agrave?$AA@
CONST	SEGMENT
??_C@_06BCNNPAPL@agrave?$AA@ DB 'agrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GMKDJMCJ@szlig?$AA@
CONST	SEGMENT
??_C@_05GMKDJMCJ@szlig?$AA@ DB 'szlig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDBENHAL@THORN?$AA@
CONST	SEGMENT
??_C@_05HDBENHAL@THORN?$AA@ DB 'THORN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOHHFCEH@Yacute?$AA@
CONST	SEGMENT
??_C@_06NOHHFCEH@Yacute?$AA@ DB 'Yacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMIIGECP@Uuml?$AA@
CONST	SEGMENT
??_C@_04BMIIGECP@Uuml?$AA@ DB 'Uuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JDGHPGFG@Ucirc?$AA@
CONST	SEGMENT
??_C@_05JDGHPGFG@Ucirc?$AA@ DB 'Ucirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJNHDIDD@Uacute?$AA@
CONST	SEGMENT
??_C@_06BJNHDIDD@Uacute?$AA@ DB 'Uacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOPBHBLK@Ugrave?$AA@
CONST	SEGMENT
??_C@_06EOPBHBLK@Ugrave?$AA@ DB 'Ugrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJKNGHPC@Oslash?$AA@
CONST	SEGMENT
??_C@_06HJKNGHPC@Oslash?$AA@ DB 'Oslash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJOOAIJH@times?$AA@
CONST	SEGMENT
??_C@_05MJOOAIJH@times?$AA@ DB 'times', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGNIOLAM@Ouml?$AA@
CONST	SEGMENT
??_C@_04DGNIOLAM@Ouml?$AA@ DB 'Ouml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCOFMLFP@Otilde?$AA@
CONST	SEGMENT
??_C@_06PCOFMLFP@Otilde?$AA@ DB 'Otilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DBCKNHKL@Ocirc?$AA@
CONST	SEGMENT
??_C@_05DBCKNHKL@Ocirc?$AA@ DB 'Ocirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NKHJPLLD@Oacute?$AA@
CONST	SEGMENT
??_C@_06NKHJPLLD@Oacute?$AA@ DB 'Oacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INFPLCDK@Ograve?$AA@
CONST	SEGMENT
??_C@_06INFPLCDK@Ograve?$AA@ DB 'Ograve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEJCMAOL@Ntilde?$AA@
CONST	SEGMENT
??_C@_06FEJCMAOL@Ntilde?$AA@ DB 'Ntilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBGEMLIN@ETH?$AA@
CONST	SEGMENT
??_C@_03CBGEMLIN@ETH?$AA@ DB 'ETH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJJIBOKM@Iuml?$AA@
CONST	SEGMENT
??_C@_04LJJIBOKM@Iuml?$AA@ DB 'Iuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHHDDELG@Icirc?$AA@
CONST	SEGMENT
??_C@_05OHHDDELG@Icirc?$AA@ DB 'Icirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJKJMOIJ@Iacute?$AA@
CONST	SEGMENT
??_C@_06LJKJMOIJ@Iacute?$AA@ DB 'Iacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOIPIHAA@Igrave?$AA@
CONST	SEGMENT
??_C@_06OOIPIHAA@Igrave?$AA@ DB 'Igrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMGIPDKN@Euml?$AA@
CONST	SEGMENT
??_C@_04HMGIPDKN@Euml?$AA@ DB 'Euml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JALBPEMN@Ecirc?$AA@
CONST	SEGMENT
??_C@_05JALBPEMN@Ecirc?$AA@ DB 'Ecirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOAJKEPN@Eacute?$AA@
CONST	SEGMENT
??_C@_06HOAJKEPN@Eacute?$AA@ DB 'Eacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJCPONHE@Egrave?$AA@
CONST	SEGMENT
??_C@_06CJCPONHE@Egrave?$AA@ DB 'Egrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCMIHOPM@Ccedil?$AA@
CONST	SEGMENT
??_C@_06PCMIHOPM@Ccedil?$AA@ DB 'Ccedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGABFNI@AElig?$AA@
CONST	SEGMENT
??_C@_05GGABFNI@AElig?$AA@ DB 'AElig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHPAJHPJ@Aring?$AA@
CONST	SEGMENT
??_C@_05CHPAJHPJ@Aring?$AA@ DB 'Aring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJOIFFGN@Auml?$AA@
CONST	SEGMENT
??_C@_04IJOIFFGN@Auml?$AA@ DB 'Auml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCNKLAAC@Atilde?$AA@
CONST	SEGMENT
??_C@_06KCNKLAAC@Atilde?$AA@ DB 'Atilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCALGNL@Acirc?$AA@
CONST	SEGMENT
??_C@_05LCALGNL@Acirc?$AA@ DB 'Acirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKEGIAOO@Aacute?$AA@
CONST	SEGMENT
??_C@_06IKEGIAOO@Aacute?$AA@ DB 'Aacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNGAMJGH@Agrave?$AA@
CONST	SEGMENT
??_C@_06NNGAMJGH@Agrave?$AA@ DB 'Agrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMONPFKG@iquest?$AA@
CONST	SEGMENT
??_C@_06JMONPFKG@iquest?$AA@ DB 'iquest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMNJFLLK@frac34?$AA@
CONST	SEGMENT
??_C@_06NMNJFLLK@frac34?$AA@ DB 'frac34', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJAHCIFC@frac12?$AA@
CONST	SEGMENT
??_C@_06IJAHCIFC@frac12?$AA@ DB 'frac12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPFNIPNE@frac14?$AA@
CONST	SEGMENT
??_C@_06NPFNIPNE@frac14?$AA@ DB 'frac14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPFJLGEB@raquo?$AA@
CONST	SEGMENT
??_C@_05MPFJLGEB@raquo?$AA@ DB 'raquo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMAEPGHP@ordm?$AA@
CONST	SEGMENT
??_C@_04HMAEPGHP@ordm?$AA@ DB 'ordm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EJOCKNLB@sup1?$AA@
CONST	SEGMENT
??_C@_04EJOCKNLB@sup1?$AA@ DB 'sup1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KLIFGPMF@cedil?$AA@
CONST	SEGMENT
??_C@_05KLIFGPMF@cedil?$AA@ DB 'cedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHCHNCAA@middot?$AA@
CONST	SEGMENT
??_C@_06HHCHNCAA@middot?$AA@ DB 'middot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIAGJOJD@para?$AA@
CONST	SEGMENT
??_C@_04GIAGJOJD@para?$AA@ DB 'para', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PCPGMEFP@micro?$AA@
CONST	SEGMENT
??_C@_05PCPGMEFP@micro?$AA@ DB 'micro', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EEJEIAPO@acute?$AA@
CONST	SEGMENT
??_C@_05EEJEIAPO@acute?$AA@ DB 'acute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLNEMPDD@sup3?$AA@
CONST	SEGMENT
??_C@_04HLNEMPDD@sup3?$AA@ DB 'sup3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GCMPPOHC@sup2?$AA@
CONST	SEGMENT
??_C@_04GCMPPOHC@sup2?$AA@ DB 'sup2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAEEBBM@plusmn?$AA@
CONST	SEGMENT
??_C@_06CAEEBBM@plusmn?$AA@ DB 'plusmn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFPLEBM@deg?$AA@
CONST	SEGMENT
??_C@_03OFPLEBM@deg?$AA@ DB 'deg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IMHNEFHF@macr?$AA@
CONST	SEGMENT
??_C@_04IMHNEFHF@macr?$AA@ DB 'macr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLCNLMFP@reg?$AA@
CONST	SEGMENT
??_C@_03HLCNLMFP@reg?$AA@ DB 'reg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPAIHHLG@shy?$AA@
CONST	SEGMENT
??_C@_03BPAIHHLG@shy?$AA@ DB 'shy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJKJADM@not?$AA@
CONST	SEGMENT
??_C@_03NJKJADM@not?$AA@ DB 'not', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGIFNFKK@laquo?$AA@
CONST	SEGMENT
??_C@_05PGIFNFKK@laquo?$AA@ DB 'laquo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPPACPLE@ordf?$AA@
CONST	SEGMENT
??_C@_04JPPACPLE@ordf?$AA@ DB 'ordf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBNAMJF@uml?$AA@
CONST	SEGMENT
??_C@_03LBNAMJF@uml?$AA@ DB 'uml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IKJFFMEH@sect?$AA@
CONST	SEGMENT
??_C@_04IKJFFMEH@sect?$AA@ DB 'sect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILPBEBAD@brvbar?$AA@
CONST	SEGMENT
??_C@_06ILPBEBAD@brvbar?$AA@ DB 'brvbar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HNOOIABH@yen?$AA@
CONST	SEGMENT
??_C@_03HNOOIABH@yen?$AA@ DB 'yen', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEGEHONB@curren?$AA@
CONST	SEGMENT
??_C@_06HEGEHONB@curren?$AA@ DB 'curren', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBEEKLCG@pound?$AA@
CONST	SEGMENT
??_C@_05EBEEKLCG@pound?$AA@ DB 'pound', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OCKNFIJG@cent?$AA@
CONST	SEGMENT
??_C@_04OCKNFIJG@cent?$AA@ DB 'cent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNEGCBFC@iexcl?$AA@
CONST	SEGMENT
??_C@_05BNEGCBFC@iexcl?$AA@ DB 'iexcl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHIFBLJ@nbsp?$AA@
CONST	SEGMENT
??_C@_04PHHIFBLJ@nbsp?$AA@ DB 'nbsp', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
_soap_env1 DB	'http://schemas.xmlsoap.org/soap/envelope/', 00H
	ORG $+2
_soap_enc1 DB	'http://schemas.xmlsoap.org/soap/encoding/', 00H
	ORG $+2
_soap_env2 DB	'http://www.w3.org/2003/05/soap-envelope', 00H
_soap_enc2 DB	'http://www.w3.org/2003/05/soap-encoding', 00H
_soap_rpc DB	'http://www.w3.org/2003/05/soap-rpc', 00H
	ORG $+1
_soap_double_nan DD 0ffffffffH
	DD	0ffffffffH
_soap_indent DB	0aH, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 00H
	ORG $+1
_soap_base64o DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012'
	DB	'3456789+/', 00H
	ORG $+7
_soap_base64i DB '>XXX?456789:;<=XXXXXXX', 00H, 01H, 02H, 03H, 04H, 05H, 06H
	DB	07H, 08H, 09H, 0aH, 0bH, 0cH, 0dH, 0eH, 0fH, 010H, 011H, 012H, 013H
	DB	014H, 015H, 016H, 017H, 018H, 019H, 'XXXXXX', 01aH, 01bH, 01cH
	DB	01dH, 01eH, 01fH, ' !"#$%&''()*+,-./0123', 00H
	ORG $+3
_soap_padding DB 00H, 00H, 00H, 00H
_html_entity_codes DD 0a0H
	DD	FLAT:??_C@_04PHHIFBLJ@nbsp?$AA@
	DD	0a1H
	DD	FLAT:??_C@_05BNEGCBFC@iexcl?$AA@
	DD	0a2H
	DD	FLAT:??_C@_04OCKNFIJG@cent?$AA@
	DD	0a3H
	DD	FLAT:??_C@_05EBEEKLCG@pound?$AA@
	DD	0a4H
	DD	FLAT:??_C@_06HEGEHONB@curren?$AA@
	DD	0a5H
	DD	FLAT:??_C@_03HNOOIABH@yen?$AA@
	DD	0a6H
	DD	FLAT:??_C@_06ILPBEBAD@brvbar?$AA@
	DD	0a7H
	DD	FLAT:??_C@_04IKJFFMEH@sect?$AA@
	DD	0a8H
	DD	FLAT:??_C@_03LBNAMJF@uml?$AA@
	DD	0a9H
	DD	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DD	0aaH
	DD	FLAT:??_C@_04JPPACPLE@ordf?$AA@
	DD	0abH
	DD	FLAT:??_C@_05PGIFNFKK@laquo?$AA@
	DD	0acH
	DD	FLAT:??_C@_03NJKJADM@not?$AA@
	DD	0adH
	DD	FLAT:??_C@_03BPAIHHLG@shy?$AA@
	DD	0aeH
	DD	FLAT:??_C@_03HLCNLMFP@reg?$AA@
	DD	0afH
	DD	FLAT:??_C@_04IMHNEFHF@macr?$AA@
	DD	0b0H
	DD	FLAT:??_C@_03OFPLEBM@deg?$AA@
	DD	0b1H
	DD	FLAT:??_C@_06CAEEBBM@plusmn?$AA@
	DD	0b2H
	DD	FLAT:??_C@_04GCMPPOHC@sup2?$AA@
	DD	0b3H
	DD	FLAT:??_C@_04HLNEMPDD@sup3?$AA@
	DD	0b4H
	DD	FLAT:??_C@_05EEJEIAPO@acute?$AA@
	DD	0b5H
	DD	FLAT:??_C@_05PCPGMEFP@micro?$AA@
	DD	0b6H
	DD	FLAT:??_C@_04GIAGJOJD@para?$AA@
	DD	0b7H
	DD	FLAT:??_C@_06HHCHNCAA@middot?$AA@
	DD	0b8H
	DD	FLAT:??_C@_05KLIFGPMF@cedil?$AA@
	DD	0b9H
	DD	FLAT:??_C@_04EJOCKNLB@sup1?$AA@
	DD	0baH
	DD	FLAT:??_C@_04HMAEPGHP@ordm?$AA@
	DD	0bbH
	DD	FLAT:??_C@_05MPFJLGEB@raquo?$AA@
	DD	0bcH
	DD	FLAT:??_C@_06NPFNIPNE@frac14?$AA@
	DD	0bdH
	DD	FLAT:??_C@_06IJAHCIFC@frac12?$AA@
	DD	0beH
	DD	FLAT:??_C@_06NMNJFLLK@frac34?$AA@
	DD	0bfH
	DD	FLAT:??_C@_06JMONPFKG@iquest?$AA@
	DD	0c0H
	DD	FLAT:??_C@_06NNGAMJGH@Agrave?$AA@
	DD	0c1H
	DD	FLAT:??_C@_06IKEGIAOO@Aacute?$AA@
	DD	0c2H
	DD	FLAT:??_C@_05LCALGNL@Acirc?$AA@
	DD	0c3H
	DD	FLAT:??_C@_06KCNKLAAC@Atilde?$AA@
	DD	0c4H
	DD	FLAT:??_C@_04IJOIFFGN@Auml?$AA@
	DD	0c5H
	DD	FLAT:??_C@_05CHPAJHPJ@Aring?$AA@
	DD	0c6H
	DD	FLAT:??_C@_05GGABFNI@AElig?$AA@
	DD	0c7H
	DD	FLAT:??_C@_06PCMIHOPM@Ccedil?$AA@
	DD	0c8H
	DD	FLAT:??_C@_06CJCPONHE@Egrave?$AA@
	DD	0c9H
	DD	FLAT:??_C@_06HOAJKEPN@Eacute?$AA@
	DD	0caH
	DD	FLAT:??_C@_05JALBPEMN@Ecirc?$AA@
	DD	0cbH
	DD	FLAT:??_C@_04HMGIPDKN@Euml?$AA@
	DD	0ccH
	DD	FLAT:??_C@_06OOIPIHAA@Igrave?$AA@
	DD	0cdH
	DD	FLAT:??_C@_06LJKJMOIJ@Iacute?$AA@
	DD	0ceH
	DD	FLAT:??_C@_05OHHDDELG@Icirc?$AA@
	DD	0cfH
	DD	FLAT:??_C@_04LJJIBOKM@Iuml?$AA@
	DD	0d0H
	DD	FLAT:??_C@_03CBGEMLIN@ETH?$AA@
	DD	0d1H
	DD	FLAT:??_C@_06FEJCMAOL@Ntilde?$AA@
	DD	0d2H
	DD	FLAT:??_C@_06INFPLCDK@Ograve?$AA@
	DD	0d3H
	DD	FLAT:??_C@_06NKHJPLLD@Oacute?$AA@
	DD	0d4H
	DD	FLAT:??_C@_05DBCKNHKL@Ocirc?$AA@
	DD	0d5H
	DD	FLAT:??_C@_06PCOFMLFP@Otilde?$AA@
	DD	0d6H
	DD	FLAT:??_C@_04DGNIOLAM@Ouml?$AA@
	DD	0d7H
	DD	FLAT:??_C@_05MJOOAIJH@times?$AA@
	DD	0d8H
	DD	FLAT:??_C@_06HJKNGHPC@Oslash?$AA@
	DD	0d9H
	DD	FLAT:??_C@_06EOPBHBLK@Ugrave?$AA@
	DD	0daH
	DD	FLAT:??_C@_06BJNHDIDD@Uacute?$AA@
	DD	0dbH
	DD	FLAT:??_C@_05JDGHPGFG@Ucirc?$AA@
	DD	0dcH
	DD	FLAT:??_C@_04BMIIGECP@Uuml?$AA@
	DD	0ddH
	DD	FLAT:??_C@_06NOHHFCEH@Yacute?$AA@
	DD	0deH
	DD	FLAT:??_C@_05HDBENHAL@THORN?$AA@
	DD	0dfH
	DD	FLAT:??_C@_05GMKDJMCJ@szlig?$AA@
	DD	0e0H
	DD	FLAT:??_C@_06BCNNPAPL@agrave?$AA@
	DD	0e1H
	DD	FLAT:??_C@_06EFPLLJHC@aacute?$AA@
	DD	0e2H
	DD	FLAT:??_C@_05MIMLDON@acirc?$AA@
	DD	0e3H
	DD	FLAT:??_C@_06GNGHIJJO@atilde?$AA@
	DD	0e4H
	DD	FLAT:??_C@_04EICJHKGJ@auml?$AA@
	DD	0e5H
	DD	FLAT:??_C@_05CAFMJCMP@aring?$AA@
	DD	0e6H
	DD	FLAT:??_C@_05MAANDPOK@aelig?$AA@
	DD	0e7H
	DD	FLAT:??_C@_06DNHFEHGA@ccedil?$AA@
	DD	0e8H
	DD	FLAT:??_C@_06OGJCNEOI@egrave?$AA@
	DD	0e9H
	DD	FLAT:??_C@_06LBLEJNGB@eacute?$AA@
	DD	0eaH
	DD	FLAT:??_C@_05JHBNPBPL@ecirc?$AA@
	DD	0ebH
	DD	FLAT:??_C@_04LNKJNMKJ@euml?$AA@
	DD	0ecH
	DD	FLAT:??_C@_06CBDCLOJM@igrave?$AA@
	DD	0edH
	DD	FLAT:??_C@_06HGBEPHBF@iacute?$AA@
	DD	0eeH
	DD	FLAT:??_C@_05OANPDBIA@icirc?$AA@
	DD	0efH
	DD	FLAT:??_C@_04HIFJDBKI@iuml?$AA@
	DD	0f0H
	DD	FLAT:??_C@_03CMJPAGPB@eth?$AA@
	DD	0f1H
	DD	FLAT:??_C@_06JLCPPJHH@ntilde?$AA@
	DD	0f2H
	DD	FLAT:??_C@_06ECOCILKG@ograve?$AA@
	DD	0f3H
	DD	FLAT:??_C@_06BFMEMCCP@oacute?$AA@
	DD	0f4H
	DD	FLAT:??_C@_05DGIGNCJN@ocirc?$AA@
	DD	0f5H
	DD	FLAT:??_C@_06DNFIPCMD@otilde?$AA@
	DD	0f6H
	DD	FLAT:??_C@_04PHBJMEAI@ouml?$AA@
	DD	0f7H
	DD	FLAT:??_C@_06FFHJEHBN@divide?$AA@
	DD	0f8H
	DD	FLAT:??_C@_06LGBAFOGO@oslash?$AA@
	DD	0f9H
	DD	FLAT:??_C@_06IBEMEICG@ugrave?$AA@
	DD	0faH
	DD	FLAT:??_C@_06NGGKABKP@uacute?$AA@
	DD	0fbH
	DD	FLAT:??_C@_05JEMLPDGA@ucirc?$AA@
	DD	0fcH
	DD	FLAT:??_C@_04NNEJELCL@uuml?$AA@
	DD	0fdH
	DD	FLAT:??_C@_06BBMKGLNL@yacute?$AA@
	DD	0feH
	DD	FLAT:??_C@_05LIICDAEF@thorn?$AA@
	DD	0ffH
	DD	FLAT:??_C@_04BILJKGCK@yuml?$AA@
	DD	00H
	DD	00H
_h_error_codes DD 02af9H
	DD	FLAT:??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@
	DD	02afaH
	DD	FLAT:??_C@_09NOIJLNLL@Try?5Again?$AA@
	DD	02afbH
	DD	FLAT:??_C@_0M@IFLIHMFH@No?5Recovery?$AA@
	DD	02afcH
	DD	FLAT:??_C@_07NNGPDNPG@No?5Data?$AA@
	DD	02afcH
	DD	FLAT:??_C@_0L@GGLPAOMP@No?5Address?$AA@
	DD	00H
	DD	00H
_h_http_error_codes DD 0c8H
	DD	FLAT:??_C@_02GIPFHKNO@OK?$AA@
	DD	0c9H
	DD	FLAT:??_C@_07BBIDHECN@Created?$AA@
	DD	0caH
	DD	FLAT:??_C@_08DOBOODLA@Accepted?$AA@
	DD	0cbH
	DD	FLAT:??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@
	DD	0ccH
	DD	FLAT:??_C@_0L@FDPJCNGK@No?5Content?$AA@
	DD	0cdH
	DD	FLAT:??_C@_0O@BFFLKCLE@Reset?5Content?$AA@
	DD	0ceH
	DD	FLAT:??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@
	DD	012cH
	DD	FLAT:??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@
	DD	012dH
	DD	FLAT:??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@
	DD	012eH
	DD	FLAT:??_C@_05JDGHEPJG@Found?$AA@
	DD	012fH
	DD	FLAT:??_C@_09FAMPMKIP@See?5Other?$AA@
	DD	0130H
	DD	FLAT:??_C@_0N@IFEFAIJB@Not?5Modified?$AA@
	DD	0131H
	DD	FLAT:??_C@_09JFBGBFIM@Use?5Proxy?$AA@
	DD	0133H
	DD	FLAT:??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@
	DD	0190H
	DD	FLAT:??_C@_0M@LNAIDEEG@Bad?5Request?$AA@
	DD	0191H
	DD	FLAT:??_C@_0N@OOAPMOJA@Unauthorized?$AA@
	DD	0192H
	DD	FLAT:??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@
	DD	0193H
	DD	FLAT:??_C@_09LMDIMFJD@Forbidden?$AA@
	DD	0194H
	DD	FLAT:??_C@_09CFCBFJND@Not?5Found?$AA@
	DD	0195H
	DD	FLAT:??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@
	DD	0196H
	DD	FLAT:??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@
	DD	0197H
	DD	FLAT:??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@
	DD	0198H
	DD	FLAT:??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@
	DD	0199H
	DD	FLAT:??_C@_08OJCIFGDF@Conflict?$AA@
	DD	019aH
	DD	FLAT:??_C@_04OKIIBCCG@Gone?$AA@
	DD	019bH
	DD	FLAT:??_C@_0BA@JCKHPIPI@Length?5Required?$AA@
	DD	019cH
	DD	FLAT:??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@
	DD	019dH
	DD	FLAT:??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@
	DD	019eH
	DD	FLAT:??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@
	DD	019fH
	DD	FLAT:??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@
	DD	01a0H
	DD	FLAT:??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@
	DD	01a1H
	DD	FLAT:??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@
	DD	01f4H
	DD	FLAT:??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@
	DD	01f5H
	DD	FLAT:??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@
	DD	01f6H
	DD	FLAT:??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@
	DD	01f8H
	DD	FLAT:??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@
	DD	01f9H
	DD	FLAT:??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@
	DD	00H
	DD	00H
_mime_codes DD	01H
	DD	FLAT:??_C@_04LHKGBPKB@7bit?$AA@
	DD	02H
	DD	FLAT:??_C@_04DFPGIIHA@8bit?$AA@
	DD	03H
	DD	FLAT:??_C@_06FNFBAEBE@binary?$AA@
	DD	04H
	DD	FLAT:??_C@_0BB@CAHAECFA@quoted?9printable?$AA@
	DD	05H
	DD	FLAT:??_C@_06JEFEFGEJ@base64?$AA@
	DD	06H
	DD	FLAT:??_C@_0L@EPBKNKII@ietf?9token?$AA@
	DD	07H
	DD	FLAT:??_C@_07JJJGGCEE@x?9token?$AA@
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	_soap_flush_raw
PUBLIC	_soap_flush
PUBLIC	_soap_send_raw
EXTRN	_memcpy:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCcsu /ZI
rtc$IMZ	ENDS
;	COMDAT _soap_send_raw
_TEXT	SEGMENT
_i$82426 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_send_raw PROC					; COMDAT

; 711  : { if (!n)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN7@soap_send_

; 712  :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN8@soap_send_
$LN7@soap_send_:

; 713  :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN6@soap_send_

; 714  :   { soap->count += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12448], ecx

; 715  : #ifndef WITH_LEANER
; 716  :     if (soap->fpreparesend && (soap->mode & SOAP_IO) != SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12344], 0
	je	SHORT $LN5@soap_send_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	je	SHORT $LN5@soap_send_

; 717  :       return soap->error = soap->fpreparesend(soap, s, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12344]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN8@soap_send_
$LN5@soap_send_:

; 718  : #endif
; 719  :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN8@soap_send_
$LN6@soap_send_:

; 720  :   }
; 721  :   if (soap->mode & SOAP_IO)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	je	$LN4@soap_send_

; 722  :   { register size_t i = SOAP_BUFLEN - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, 65536				; 00010000H
	sub	ecx, DWORD PTR [eax+12428]
	mov	DWORD PTR _i$82426[ebp], ecx
$LN3@soap_send_:

; 723  :     while (n >= i)

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _i$82426[ebp]
	jb	SHORT $LN2@soap_send_

; 724  :     { memcpy(soap->buf + soap->bufidx, s, i);

	mov	eax, DWORD PTR _i$82426[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12468]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 725  :       soap->bufidx = SOAP_BUFLEN;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 65536		; 00010000H

; 726  :       if (soap_flush(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_flush
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_send_

; 727  :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN8@soap_send_
$LN1@soap_send_:

; 728  :       s += i;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$82426[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 729  :       n -= i;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _i$82426[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 730  :       i = SOAP_BUFLEN;

	mov	DWORD PTR _i$82426[ebp], 65536		; 00010000H

; 731  :     }

	jmp	SHORT $LN3@soap_send_
$LN2@soap_send_:

; 732  :     memcpy(soap->buf + soap->bufidx, s, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12468]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 733  :     soap->bufidx += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 734  :     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN8@soap_send_
$LN4@soap_send_:

; 735  :   }
; 736  :   return soap_flush_raw(soap, s, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_flush_raw
	add	esp, 12					; 0000000cH
$LN8@soap_send_:

; 737  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_send_raw ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_flush
_TEXT	SEGMENT
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_flush PROC					; COMDAT

; 746  : { register size_t n = soap->bufidx;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	DWORD PTR _n$[ebp], ecx

; 747  :   if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN1@soap_flush

; 748  :   { soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 749  : #ifdef WITH_ZLIB
; 750  :     if (soap->mode & SOAP_ENC_ZLIB)
; 751  :     { soap->d_stream->next_in = (Byte*)soap->buf;
; 752  :       soap->d_stream->avail_in = (unsigned int)n;
; 753  : #ifdef WITH_GZIP
; 754  :       soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)n);
; 755  : #endif
; 756  :       do
; 757  :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflating %u bytes\n", soap->d_stream->avail_in));
; 758  :         if (deflate(soap->d_stream, Z_NO_FLUSH) != Z_OK)
; 759  :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to deflate: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 760  :           return soap->error = SOAP_ZLIB_ERROR;
; 761  :         }
; 762  :         if (!soap->d_stream->avail_out)
; 763  :         { if (soap_flush_raw(soap, soap->z_buf, SOAP_BUFLEN))
; 764  :             return soap->error;
; 765  :           soap->d_stream->next_out = (Byte*)soap->z_buf;
; 766  :           soap->d_stream->avail_out = SOAP_BUFLEN;
; 767  :         }
; 768  :       } while (soap->d_stream->avail_in);
; 769  :     }
; 770  :     else
; 771  : #endif
; 772  :       return soap_flush_raw(soap, soap->buf, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_flush_raw
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@soap_flush
$LN1@soap_flush:

; 773  :   }
; 774  :   return SOAP_OK;

	xor	eax, eax
$LN2@soap_flush:

; 775  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_flush ENDP
_TEXT	ENDS
PUBLIC	_soap_open_logfile
PUBLIC	??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@	; `string'
PUBLIC	_soap_push_block
PUBLIC	__$ArrayPad$
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT ??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@
CONST	SEGMENT
??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@ DB 0dH, 0aH, '%lX', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_flush_raw
_TEXT	SEGMENT
_rc$82461 = -60						; size = 4
_rc$82454 = -48						; size = 4
_t$82447 = -36						; size = 16
_t$82442 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_flush_raw PROC					; COMDAT

; 784  : { if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	$LN13@soap_flush@2

; 785  :   { register char *t;
; 786  :     if (!(t = (char*)soap_push_block(soap, n)))

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_push_block
	add	esp, 8
	mov	DWORD PTR _t$82442[ebp], eax
	cmp	DWORD PTR _t$82442[ebp], 0
	jne	SHORT $LN12@soap_flush@2

; 787  :       return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN14@soap_flush@2
$LN12@soap_flush@2:

; 788  :     memcpy(t, s, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$82442[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 789  : #ifndef WITH_LEANER
; 790  :     if (soap->fpreparesend)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12344], 0
	je	SHORT $LN11@soap_flush@2

; 791  :       return soap->error = soap->fpreparesend(soap, s, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12344]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN14@soap_flush@2
$LN11@soap_flush@2:

; 792  : #endif
; 793  :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN14@soap_flush@2
$LN13@soap_flush@2:

; 794  :   }
; 795  : #ifndef WITH_LEANER
; 796  :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	jne	$LN10@soap_flush@2

; 797  :   { char t[16];
; 798  :     sprintf(t, "\r\n%lX\r\n" + (soap->chunksize ? 0 : 2), (unsigned long)n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87312]
	neg	edx
	sbb	edx, edx
	and	edx, -2					; fffffffeH
	add	edx, 2
	add	edx, OFFSET ??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@
	push	edx
	lea	eax, DWORD PTR _t$82447[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 799  :     DBGMSG(SENT, t, strlen(t));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN9@soap_flush@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	jne	SHORT $LN8@soap_flush@2
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_flush@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	je	SHORT $LN9@soap_flush@2
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	lea	edx, DWORD PTR _t$82447[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	push	1
	lea	eax, DWORD PTR _t$82447[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82454[ebp], eax
	cmp	DWORD PTR _rc$82454[ebp], 0
	jae	SHORT $LN6@soap_flush@2
	mov	eax, DWORD PTR _rc$82454[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82454[ebp], eax
$LN6@soap_flush@2:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_flush@2:

; 800  :     if ((soap->error = soap->fsend(soap, t, strlen(t))))

	lea	eax, DWORD PTR _t$82447[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _t$82447[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12308]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN5@soap_flush@2

; 801  :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN14@soap_flush@2
$LN5@soap_flush@2:

; 802  :     soap->chunksize += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87312]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+87312], ecx
$LN10@soap_flush@2:

; 803  :   }
; 804  :   DBGMSG(SENT, s, n);

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_flush@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	jne	SHORT $LN3@soap_flush@2
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_flush@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	je	SHORT $LN4@soap_flush@2
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82461[ebp], eax
	cmp	DWORD PTR _rc$82461[ebp], 0
	jae	SHORT $LN1@soap_flush@2
	mov	eax, DWORD PTR _rc$82461[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82461[ebp], eax
$LN1@soap_flush@2:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_flush@2:

; 805  : #endif
; 806  :   return soap->error = soap->fsend(soap, s, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12308]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN14@soap_flush@2:

; 807  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@soap_flush@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN18@soap_flush@2:
	DD	1
	DD	$LN17@soap_flush@2
$LN17@soap_flush@2:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN16@soap_flush@2
$LN16@soap_flush@2:
	DB	116					; 00000074H
	DB	0
_soap_flush_raw ENDP
_TEXT	ENDS
PUBLIC	_soap_send
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_send
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_send PROC						; COMDAT

; 816  : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_send

; 817  :     return soap_send_raw(soap, s, strlen(s));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@soap_send
$LN1@soap_send:

; 818  :   return SOAP_OK;

	xor	eax, eax
$LN2@soap_send:

; 819  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_send ENDP
_TEXT	ENDS
PUBLIC	_soap_send2
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_send2
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s1$ = 12						; size = 4
_s2$ = 16						; size = 4
_soap_send2 PROC					; COMDAT

; 829  : { if (soap_send(soap, s1))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_send2

; 830  :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN2@soap_send2
$LN1@soap_send2:

; 831  :   return soap_send(soap, s2);

	mov	eax, DWORD PTR _s2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
$LN2@soap_send2:

; 832  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_send2 ENDP
_TEXT	ENDS
PUBLIC	_soap_send3
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_send3
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s1$ = 12						; size = 4
_s2$ = 16						; size = 4
_s3$ = 20						; size = 4
_soap_send3 PROC					; COMDAT

; 843  : { if (soap_send(soap, s1)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 844  :    || soap_send(soap, s2))

	mov	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_send3
	mov	eax, DWORD PTR _s2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_send3
$LN1@soap_send3:

; 845  :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_send3
$LN2@soap_send3:

; 846  :   return soap_send(soap, s3);

	mov	eax, DWORD PTR _s3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
$LN3@soap_send3:

; 847  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_send3 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@BPPEEPFK@Read?5?$CFu?5bytes?5from?5socket?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@OPILDOG@Passed?5end?5of?5buffer?5for?5chunked@ ; `string'
PUBLIC	??_C@_0CG@KPDEBNJE@Moving?5buf?5len?5to?5idx?$DN?$CFu?5len?$DN?$CFu?5@ ; `string'
PUBLIC	??_C@_0BI@DEMCILKJ@End?5of?5chunked?5message?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@LMGDHKCF@Chunk?5size?5?$DN?5?$CFs?5?$CIhex?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@EDBJBBKG@Getting?5chunk?5size?5?$CIidx?$DN?$CFu?5len?$DN?$CF@ ; `string'
PUBLIC	??_C@_0CI@OGFPOEIN@Read?5?$CFu?5bytes?5?$CIchunked?$CJ?5from?5soc@ ; `string'
PUBLIC	??_C@_0BO@HBPHHPDN@Getting?5chunk?3?5read?5?$CFu?5bytes?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_recv_raw
EXTRN	__imp__strtoul:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	@_RTC_Check_4_to_1@4:PROC
;	COMDAT ??_C@_0BO@BPPEEPFK@Read?5?$CFu?5bytes?5from?5socket?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@BPPEEPFK@Read?5?$CFu?5bytes?5from?5socket?5?$CFd?6?$AA@ DB 'Rea'
	DB	'd %u bytes from socket %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OPILDOG@Passed?5end?5of?5buffer?5for?5chunked@
CONST	SEGMENT
??_C@_0DH@OPILDOG@Passed?5end?5of?5buffer?5for?5chunked@ DB 'Passed end o'
	DB	'f buffer for chunked HTTP (%u bytes left)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KPDEBNJE@Moving?5buf?5len?5to?5idx?$DN?$CFu?5len?$DN?$CFu?5@
CONST	SEGMENT
??_C@_0CG@KPDEBNJE@Moving?5buf?5len?5to?5idx?$DN?$CFu?5len?$DN?$CFu?5@ DB 'M'
	DB	'oving buf len to idx=%u len=%u (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DEMCILKJ@End?5of?5chunked?5message?6?$AA@
CONST	SEGMENT
??_C@_0BI@DEMCILKJ@End?5of?5chunked?5message?6?$AA@ DB 'End of chunked me'
	DB	'ssage', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LMGDHKCF@Chunk?5size?5?$DN?5?$CFs?5?$CIhex?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BH@LMGDHKCF@Chunk?5size?5?$DN?5?$CFs?5?$CIhex?$CJ?6?$AA@ DB 'Chunk'
	DB	' size = %s (hex)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EDBJBBKG@Getting?5chunk?5size?5?$CIidx?$DN?$CFu?5len?$DN?$CF@
CONST	SEGMENT
??_C@_0CE@EDBJBBKG@Getting?5chunk?5size?5?$CIidx?$DN?$CFu?5len?$DN?$CF@ DB 'G'
	DB	'etting chunk size (idx=%u len=%u)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OGFPOEIN@Read?5?$CFu?5bytes?5?$CIchunked?$CJ?5from?5soc@
CONST	SEGMENT
??_C@_0CI@OGFPOEIN@Read?5?$CFu?5bytes?5?$CIchunked?$CJ?5from?5soc@ DB 'Re'
	DB	'ad %u bytes (chunked) from socket %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HBPHHPDN@Getting?5chunk?3?5read?5?$CFu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BO@HBPHHPDN@Getting?5chunk?3?5read?5?$CFu?5bytes?6?$AA@ DB 'Gettin'
	DB	'g chunk: read %u bytes', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_recv_raw
_TEXT	SEGMENT
tv75 = -384						; size = 4
_rc$82691 = -184					; size = 4
_fdebug$82685 = -172					; size = 4
_fdebug$82674 = -160					; size = 4
_fdebug$82665 = -148					; size = 4
_fdebug$82655 = -136					; size = 4
_fdebug$82648 = -124					; size = 4
_fdebug$82622 = -112					; size = 4
_rc$82614 = -100					; size = 4
_fdebug$82607 = -88					; size = 4
_rc$82600 = -76						; size = 4
_fdebug$82593 = -64					; size = 4
_tmp$82587 = -52					; size = 8
_t$82586 = -36						; size = 4
_c$82585 = -24						; size = 4
_ret$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_recv_raw PROC					; COMDAT

; 1080 : { register size_t ret;

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-384]
	mov	ecx, 96					; 00000060H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1081 : #ifdef WITH_ZLIB
; 1082 :   if (soap->mode & SOAP_ENC_ZLIB)
; 1083 :   { if (soap->d_stream->next_out == Z_NULL)
; 1084 :       return EOF;
; 1085 :     if (soap->d_stream->avail_in || !soap->d_stream->avail_out)
; 1086 :     { register int r;
; 1087 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflating\n"));
; 1088 :       soap->d_stream->next_out = (Byte*)soap->buf;
; 1089 :       soap->d_stream->avail_out = SOAP_BUFLEN;
; 1090 :       r = inflate(soap->d_stream, Z_NO_FLUSH);
; 1091 :       if (r == Z_OK || r == Z_STREAM_END)
; 1092 :       { soap->bufidx = 0;
; 1093 :         ret = soap->buflen = SOAP_BUFLEN - soap->d_stream->avail_out;
; 1094 :         if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 1095 :           soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)ret);
; 1096 :         if (r == Z_STREAM_END)
; 1097 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 1098 :           soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
; 1099 :           soap->d_stream->next_out = Z_NULL;
; 1100 :         }
; 1101 :         if (ret)
; 1102 :         { soap->count += ret;
; 1103 :           DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- decompressed ----\n"));
; 1104 :           DBGMSG(RECV, soap->buf, ret);
; 1105 :           DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n----\n"));
; 1106 :           return SOAP_OK;
; 1107 :         }
; 1108 :       }
; 1109 :       else if (r != Z_BUF_ERROR)
; 1110 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflate error: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 1111 :         soap->d_stream->next_out = Z_NULL;
; 1112 :         soap->error = SOAP_ZLIB_ERROR;
; 1113 :         return EOF;
; 1114 :       }
; 1115 :     }
; 1116 : zlib_again:
; 1117 :     if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK && !soap->chunksize)
; 1118 :     { memcpy(soap->buf, soap->z_buf, SOAP_BUFLEN);
; 1119 :       soap->buflen = soap->z_buflen;
; 1120 :     }
; 1121 :     DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- compressed ----\n"));
; 1122 :   }
; 1123 : #endif
; 1124 : #ifndef WITH_NOHTTP
; 1125 :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) /* read HTTP chunked transfer */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	jne	$LN62@soap_recv_
$LN61@soap_recv_:

; 1126 :   { for (;;)
; 1127 :     { register soap_wchar c;
; 1128 :       char *t, tmp[8];
; 1129 :       if (soap->chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87312], 0
	je	$LN59@soap_recv_

; 1130 :       { soap->buflen = ret = soap->frecv(soap, soap->buf, soap->chunksize > SOAP_BUFLEN ? SOAP_BUFLEN : soap->chunksize);

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87312], 65536		; 00010000H
	jbe	SHORT $LN65@soap_recv_
	mov	DWORD PTR tv75[ebp], 65536		; 00010000H
	jmp	SHORT $LN66@soap_recv_
$LN65@soap_recv_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87312]
	mov	DWORD PTR tv75[ebp], edx
$LN66@soap_recv_:
	mov	esi, esp
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12312]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+12432], eax

; 1131 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Getting chunk: read %u bytes\n", (unsigned int)ret));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN58@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN57@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN57@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN58@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82593[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HBPHHPDN@Getting?5chunk?3?5read?5?$CFu?5bytes?6?$AA@
	mov	ecx, DWORD PTR _fdebug$82593[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82593[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN58@soap_recv_:

; 1132 :         DBGMSG(RECV, soap->buf, ret);

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN55@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	jne	SHORT $LN54@soap_recv_
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN54@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	je	SHORT $LN55@soap_recv_
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82600[ebp], eax
	cmp	DWORD PTR _rc$82600[ebp], 0
	jae	SHORT $LN52@soap_recv_
	mov	eax, DWORD PTR _rc$82600[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82600[ebp], eax
$LN52@soap_recv_:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@soap_recv_:

; 1133 :         soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 1134 :         soap->chunksize -= ret;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87312]
	sub	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+87312], ecx

; 1135 :         break;

	jmp	$LN60@soap_recv_
$LN59@soap_recv_:

; 1136 :       }
; 1137 :       t = tmp;

	lea	eax, DWORD PTR _tmp$82587[ebp]
	mov	DWORD PTR _t$82586[ebp], eax

; 1138 :       if (!soap->chunkbuflen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87316], 0
	jne	$LN51@soap_recv_

; 1139 :       { soap->chunkbuflen = ret = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	esi, esp
	push	65536					; 00010000H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12312]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+87316], edx

; 1140 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes (chunked) from socket %d\n", (unsigned int)ret, soap->socket));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN50@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN49@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN49@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN50@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82607[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@OGFPOEIN@Read?5?$CFu?5bytes?5?$CIchunked?$CJ?5from?5soc@
	mov	eax, DWORD PTR _fdebug$82607[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82607[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@soap_recv_:

; 1141 :         DBGMSG(RECV, soap->buf, ret);

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN47@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	jne	SHORT $LN46@soap_recv_
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN46@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	je	SHORT $LN47@soap_recv_
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82614[ebp], eax
	cmp	DWORD PTR _rc$82614[ebp], 0
	jae	SHORT $LN44@soap_recv_
	mov	eax, DWORD PTR _rc$82614[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82614[ebp], eax
$LN44@soap_recv_:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@soap_recv_:

; 1142 :         soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 1143 :         if (!ret)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN43@soap_recv_

; 1144 :           return soap->ahead = EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], -1
	or	eax, -1
	jmp	$LN63@soap_recv_
$LN43@soap_recv_:

; 1145 :       }
; 1146 :       else

	jmp	SHORT $LN42@soap_recv_
$LN51@soap_recv_:

; 1147 :         soap->bufidx = soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+12428], edx
$LN42@soap_recv_:

; 1148 :       soap->buflen = soap->chunkbuflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87316]
	mov	DWORD PTR [eax+12432], edx

; 1149 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Getting chunk size (idx=%u len=%u)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN38@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN40@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN40@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN38@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82622[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12432]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	push	eax
	push	OFFSET ??_C@_0CE@EDBJBBKG@Getting?5chunk?5size?5?$CIidx?$DN?$CFu?5len?$DN?$CF@
	mov	ecx, DWORD PTR _fdebug$82622[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82622[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN38@soap_recv_:

; 1150 :       while (!soap_isxdigit((int)(c = soap_getchunkchar(soap))))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchunkchar
	add	esp, 4
	mov	DWORD PTR _c$82585[ebp], eax
	mov	ecx, DWORD PTR _c$82585[ebp]
	push	ecx
	call	_soap_isxdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN35@soap_recv_

; 1151 :       { if ((int)c == EOF)

	cmp	DWORD PTR _c$82585[ebp], -1
	jne	SHORT $LN36@soap_recv_

; 1152 :           return soap->ahead = EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], -1
	or	eax, -1
	jmp	$LN63@soap_recv_
$LN36@soap_recv_:

; 1153 :       }

	jmp	SHORT $LN38@soap_recv_
$LN35@soap_recv_:

; 1154 :       do
; 1155 :         *t++ = (char)c;

	mov	ecx, DWORD PTR _c$82585[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$82586[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$82586[ebp]
	add	edx, 1
	mov	DWORD PTR _t$82586[ebp], edx

; 1156 :       while (soap_isxdigit((int)(c = soap_getchunkchar(soap))) && t - tmp < 7);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchunkchar
	add	esp, 4
	mov	DWORD PTR _c$82585[ebp], eax
	mov	ecx, DWORD PTR _c$82585[ebp]
	push	ecx
	call	_soap_isxdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@soap_recv_
	mov	eax, DWORD PTR _t$82586[ebp]
	lea	ecx, DWORD PTR _tmp$82587[ebp]
	sub	eax, ecx
	cmp	eax, 7
	jl	SHORT $LN35@soap_recv_
$LN31@soap_recv_:

; 1157 :       while ((int)c != EOF && c != '\n')

	cmp	DWORD PTR _c$82585[ebp], -1
	je	SHORT $LN30@soap_recv_
	cmp	DWORD PTR _c$82585[ebp], 10		; 0000000aH
	je	SHORT $LN30@soap_recv_

; 1158 :         c = soap_getchunkchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchunkchar
	add	esp, 4
	mov	DWORD PTR _c$82585[ebp], eax
	jmp	SHORT $LN31@soap_recv_
$LN30@soap_recv_:

; 1159 :       if ((int)c == EOF)

	cmp	DWORD PTR _c$82585[ebp], -1
	jne	SHORT $LN29@soap_recv_

; 1160 :         return soap->ahead = EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], -1
	or	eax, -1
	jmp	$LN63@soap_recv_
$LN29@soap_recv_:

; 1161 :       *t = '\0';

	mov	eax, DWORD PTR _t$82586[ebp]
	mov	BYTE PTR [eax], 0

; 1162 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunk size = %s (hex)\n", tmp));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN28@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN27@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN27@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN28@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82648[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR _tmp$82587[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@LMGDHKCF@Chunk?5size?5?$DN?5?$CFs?5?$CIhex?$CJ?6?$AA@
	mov	ecx, DWORD PTR _fdebug$82648[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82648[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@soap_recv_:

; 1163 :       soap->chunksize = soap_strtoul(tmp, &t, 16);

	mov	esi, esp
	push	16					; 00000010H
	lea	eax, DWORD PTR _t$82586[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$82587[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+87312], eax

; 1164 :       if (!soap->chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87312], 0
	jne	$LN25@soap_recv_

; 1165 :       { soap->chunkbuflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87316], 0

; 1166 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of chunked message\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN23@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN23@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82655[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@DEMCILKJ@End?5of?5chunked?5message?6?$AA@
	mov	eax, DWORD PTR _fdebug$82655[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82655[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_recv_:

; 1167 :         while ((int)c != EOF && c != '\n')

	cmp	DWORD PTR _c$82585[ebp], -1
	je	SHORT $LN20@soap_recv_
	cmp	DWORD PTR _c$82585[ebp], 10		; 0000000aH
	je	SHORT $LN20@soap_recv_

; 1168 :           c = soap_getchunkchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchunkchar
	add	esp, 4
	mov	DWORD PTR _c$82585[ebp], eax
	jmp	SHORT $LN21@soap_recv_
$LN20@soap_recv_:

; 1169 :         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1170 :         soap->ahead = EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], -1

; 1171 : 	break;

	jmp	$LN60@soap_recv_
$LN25@soap_recv_:

; 1172 :       }
; 1173 :       soap->buflen = soap->bufidx + soap->chunksize;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+87312]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], ecx

; 1174 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Moving buf len to idx=%u len=%u (%s)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen, tmp));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN19@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN18@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN18@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82665[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR _tmp$82587[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	push	ecx
	push	OFFSET ??_C@_0CG@KPDEBNJE@Moving?5buf?5len?5to?5idx?$DN?$CFu?5len?$DN?$CFu?5@
	mov	edx, DWORD PTR _fdebug$82665[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82665[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_recv_:

; 1175 :       if (soap->buflen > soap->chunkbuflen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	cmp	edx, DWORD PTR [ecx+87316]
	jbe	$LN16@soap_recv_

; 1176 :       { soap->buflen = soap->chunkbuflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87316]
	mov	DWORD PTR [eax+12432], edx

; 1177 :         soap->chunksize -= soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87312]
	sub	ecx, edx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+87312], ecx

; 1178 :         soap->chunkbuflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87316], 0

; 1179 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Passed end of buffer for chunked HTTP (%u bytes left)\n", (unsigned int)(soap->buflen - soap->bufidx)));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN15@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN14@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN14@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN15@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82674[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_0DH@OPILDOG@Passed?5end?5of?5buffer?5for?5chunked@
	mov	eax, DWORD PTR _fdebug$82674[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82674[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_recv_:
	jmp	SHORT $LN12@soap_recv_
$LN16@soap_recv_:

; 1180 :       }
; 1181 :       else if (soap->chunkbuflen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87316], 0
	je	SHORT $LN12@soap_recv_

; 1182 :         soap->chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87312], 0
$LN12@soap_recv_:

; 1183 :       ret = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	DWORD PTR _ret$[ebp], edx

; 1184 :       if (ret)

	je	SHORT $LN10@soap_recv_

; 1185 :         break;

	jmp	SHORT $LN60@soap_recv_
$LN10@soap_recv_:

; 1186 :     }

	jmp	$LN61@soap_recv_
$LN60@soap_recv_:

; 1187 :   }
; 1188 :   else

	jmp	$LN9@soap_recv_
$LN62@soap_recv_:

; 1189 : #endif
; 1190 :   { soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 1191 :     soap->buflen = ret = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	esi, esp
	push	65536					; 00010000H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12312]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+12432], edx

; 1192 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket %d\n", (unsigned int)ret, soap->socket));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_recv_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82685[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@BPPEEPFK@Read?5?$CFu?5bytes?5from?5socket?5?$CFd?6?$AA@
	mov	eax, DWORD PTR _fdebug$82685[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82685[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_recv_:

; 1193 :     DBGMSG(RECV, soap->buf, ret);

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN9@soap_recv_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	jne	SHORT $LN4@soap_recv_
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_recv_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	je	SHORT $LN9@soap_recv_
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82691[ebp], eax
	cmp	DWORD PTR _rc$82691[ebp], 0
	jae	SHORT $LN2@soap_recv_
	mov	eax, DWORD PTR _rc$82691[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82691[ebp], eax
$LN2@soap_recv_:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_recv_:

; 1194 :   }
; 1195 : #ifndef WITH_LEANER
; 1196 :   if (soap->fpreparerecv && (soap->error = soap->fpreparerecv(soap, soap->buf, ret)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12348], 0
	je	SHORT $LN1@soap_recv_
	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12348]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN1@soap_recv_

; 1197 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN63@soap_recv_
$LN1@soap_recv_:

; 1198 : #endif
; 1199 : #ifdef WITH_ZLIB
; 1200 :   if (soap->mode & SOAP_ENC_ZLIB)
; 1201 :   { register int r;
; 1202 :     memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 1203 :     soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 1204 :     soap->d_stream->avail_in = (unsigned int)ret;
; 1205 :     soap->d_stream->next_out = (Byte*)soap->buf;
; 1206 :     soap->d_stream->avail_out = SOAP_BUFLEN;
; 1207 :     r = inflate(soap->d_stream, Z_NO_FLUSH);
; 1208 :     if (r == Z_OK || r == Z_STREAM_END)
; 1209 :     { soap->bufidx = 0;
; 1210 :       soap->z_buflen = soap->buflen;
; 1211 :       soap->buflen = SOAP_BUFLEN - soap->d_stream->avail_out;
; 1212 :       if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 1213 :         soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)soap->buflen);
; 1214 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %u bytes\n", (unsigned int)soap->buflen));
; 1215 :       if (ret && !soap->buflen)
; 1216 :         goto zlib_again;
; 1217 :       ret = soap->buflen;
; 1218 :       if (r == Z_STREAM_END)
; 1219 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 1220 :         soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
; 1221 :         soap->d_stream->next_out = Z_NULL;
; 1222 :       }
; 1223 :       DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- decompressed ----\n"));
; 1224 :       DBGMSG(RECV, soap->buf, ret);
; 1225 :     }
; 1226 :     else
; 1227 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to inflate: (%d) %s\n", r, soap->d_stream->msg?soap->d_stream->msg:""));
; 1228 :       soap->d_stream->next_out = Z_NULL;
; 1229 :       soap->error = SOAP_ZLIB_ERROR;
; 1230 :       return EOF;
; 1231 :     }
; 1232 :   }
; 1233 : #endif
; 1234 :   soap->count += ret;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	add	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12448], ecx

; 1235 :   return !ret;

	xor	eax, eax
	cmp	DWORD PTR _ret$[ebp], 0
	sete	al
$LN63@soap_recv_:

; 1236 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN70@soap_recv_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 384				; 00000180H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN70@soap_recv_:
	DD	2
	DD	$LN69@soap_recv_
$LN69@soap_recv_:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN67@soap_recv_
	DD	-52					; ffffffccH
	DD	8
	DD	$LN68@soap_recv_
$LN68@soap_recv_:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN67@soap_recv_:
	DB	116					; 00000074H
	DB	0
_soap_recv_raw ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_getchunkchar
_TEXT	SEGMENT
tv167 = -220						; size = 4
tv74 = -220						; size = 4
_rc$82571 = -20						; size = 4
_fdebug$82564 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_getchunkchar PROC					; COMDAT

; 1053 : { if (soap->bufidx < soap->buflen)

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jae	SHORT $LN9@soap_getch

; 1054 :     return soap->buf[soap->bufidx++];

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+12468]
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	add	edx, 1
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], edx
	mov	eax, DWORD PTR tv74[ebp]
	jmp	$LN10@soap_getch
$LN9@soap_getch:

; 1055 :   soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 1056 :   soap->buflen = soap->chunkbuflen = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	esi, esp
	push	65536					; 00010000H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12312]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+87316], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87316]
	mov	DWORD PTR [edx+12432], ecx

; 1057 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket %d\n", (unsigned int)soap->buflen, soap->socket));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_getch
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_getch
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_getch:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_getch
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82564[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12432]
	push	eax
	push	OFFSET ??_C@_0BO@BPPEEPFK@Read?5?$CFu?5bytes?5from?5socket?5?$CFd?6?$AA@
	mov	ecx, DWORD PTR _fdebug$82564[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82564[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_getch:

; 1058 :   DBGMSG(RECV, soap->buf, soap->buflen);

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN5@soap_getch
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	jne	SHORT $LN4@soap_getch
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_getch:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90560], 0
	je	SHORT $LN5@soap_getch
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12432]
	push	eax
	push	1
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$82571[ebp], eax
	cmp	DWORD PTR _rc$82571[ebp], 0
	jae	SHORT $LN2@soap_getch
	mov	eax, DWORD PTR _rc$82571[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$82571[ebp], eax
$LN2@soap_getch:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90560]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_getch:

; 1059 :   if (soap->buflen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12432], 0
	je	SHORT $LN1@soap_getch

; 1060 :     return soap->buf[soap->bufidx++];

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+12468]
	mov	DWORD PTR tv167[ebp], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	add	edx, 1
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], edx
	mov	eax, DWORD PTR tv167[ebp]
	jmp	SHORT $LN10@soap_getch
$LN1@soap_getch:

; 1061 :   return EOF;

	or	eax, -1
$LN10@soap_getch:

; 1062 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getchunkchar ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_isxdigit
_TEXT	SEGMENT
tv70 = -196						; size = 4
_c$ = 8							; size = 4
_soap_isxdigit PROC					; COMDAT

; 1070 : { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN3@soap_isxdi
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	SHORT $LN5@soap_isxdi
$LN3@soap_isxdi:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN4@soap_isxdi
	cmp	DWORD PTR _c$[ebp], 70			; 00000046H
	jle	SHORT $LN5@soap_isxdi
$LN4@soap_isxdi:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN6@soap_isxdi
	cmp	DWORD PTR _c$[ebp], 102			; 00000066H
	jle	SHORT $LN5@soap_isxdi
$LN6@soap_isxdi:
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN7@soap_isxdi
$LN5@soap_isxdi:
	mov	DWORD PTR tv70[ebp], 1
$LN7@soap_isxdi:
	mov	eax, DWORD PTR tv70[ebp]

; 1071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_isxdigit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@DMDBKBBH@?$CFlu?5bytes?5remaining?0?5count?$DN?$CFu?6?$AA@ ; `string'
PUBLIC	??_C@_0DF@HCKKPCCH@Get?5next?5DIME?5hdr?5for?5chunked?5DI@ ; `string'
PUBLIC	??_C@_0BE@BAFKLKAC@?$CFu?5bytes?5remaining?6?$AA@ ; `string'
PUBLIC	??_C@_0M@GDABLMIG@Last?5chunk?6?$AA@		; `string'
PUBLIC	??_C@_0P@FAJIPIIP@More?5chunking?6?$AA@		; `string'
PUBLIC	??_C@_0BL@EHOPGBHA@Get?5DIME?5chunk?5?$CI?$CFu?5bytes?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@HCGGJFMA@Get?5DIME?5hdr?5for?5next?5chunk?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@DPFBJGHD@Skip?5padding?5?$CI?$CFld?5bytes?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNMGENOD@DIME?5hdr?5for?5chunked?5DIME?5is?5in?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_recv
;	COMDAT ??_C@_0BP@DMDBKBBH@?$CFlu?5bytes?5remaining?0?5count?$DN?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0BP@DMDBKBBH@?$CFlu?5bytes?5remaining?0?5count?$DN?$CFu?6?$AA@ DB '%'
	DB	'lu bytes remaining, count=%u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HCKKPCCH@Get?5next?5DIME?5hdr?5for?5chunked?5DI@
CONST	SEGMENT
??_C@_0DF@HCKKPCCH@Get?5next?5DIME?5hdr?5for?5chunked?5DI@ DB 'Get next D'
	DB	'IME hdr for chunked DIME (%u bytes chunk)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAFKLKAC@?$CFu?5bytes?5remaining?6?$AA@
CONST	SEGMENT
??_C@_0BE@BAFKLKAC@?$CFu?5bytes?5remaining?6?$AA@ DB '%u bytes remaining', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GDABLMIG@Last?5chunk?6?$AA@
CONST	SEGMENT
??_C@_0M@GDABLMIG@Last?5chunk?6?$AA@ DB 'Last chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FAJIPIIP@More?5chunking?6?$AA@
CONST	SEGMENT
??_C@_0P@FAJIPIIP@More?5chunking?6?$AA@ DB 'More chunking', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EHOPGBHA@Get?5DIME?5chunk?5?$CI?$CFu?5bytes?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BL@EHOPGBHA@Get?5DIME?5chunk?5?$CI?$CFu?5bytes?$CJ?6?$AA@ DB 'Get '
	DB	'DIME chunk (%u bytes)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HCGGJFMA@Get?5DIME?5hdr?5for?5next?5chunk?6?$AA@
CONST	SEGMENT
??_C@_0BN@HCGGJFMA@Get?5DIME?5hdr?5for?5next?5chunk?6?$AA@ DB 'Get DIME h'
	DB	'dr for next chunk', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DPFBJGHD@Skip?5padding?5?$CI?$CFld?5bytes?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BK@DPFBJGHD@Skip?5padding?5?$CI?$CFld?5bytes?$CJ?6?$AA@ DB 'Skip p'
	DB	'adding (%ld bytes)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNMGENOD@DIME?5hdr?5for?5chunked?5DIME?5is?5in?5@
CONST	SEGMENT
??_C@_0CI@HNMGENOD@DIME?5hdr?5for?5chunked?5DIME?5is?5in?5@ DB 'DIME hdr '
	DB	'for chunked DIME is in buffer', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_recv
_TEXT	SEGMENT
_fdebug$82782 = -152					; size = 4
_fdebug$82772 = -140					; size = 4
_fdebug$82764 = -128					; size = 4
_fdebug$82758 = -116					; size = 4
_fdebug$82749 = -104					; size = 4
_fdebug$82741 = -92					; size = 4
_fdebug$82725 = -80					; size = 4
_fdebug$82712 = -68					; size = 4
_fdebug$82706 = -56					; size = 4
_tmp$82701 = -44					; size = 12
_i$82700 = -24						; size = 4
_s$82699 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_recv PROC						; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1246 : #ifndef WITH_LEANER
; 1247 :   if (soap->mode & SOAP_ENC_DIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	$LN47@soap_recv

; 1248 :   { if (soap->dime.buflen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90488], 0
	je	$LN46@soap_recv

; 1249 :     { char *s;
; 1250 :       int i;
; 1251 :       unsigned char tmp[12];
; 1252 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME hdr for chunked DIME is in buffer\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN45@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN44@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN44@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN45@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82706[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CI@HNMGENOD@DIME?5hdr?5for?5chunked?5DIME?5is?5in?5@
	mov	eax, DWORD PTR _fdebug$82706[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82706[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN45@soap_recv:

; 1253 :       soap->count += soap->dime.buflen - soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+90488]
	sub	edx, DWORD PTR [ecx+12432]
	mov	eax, DWORD PTR _soap$[ebp]
	add	edx, DWORD PTR [eax+12448]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12448], edx

; 1254 :       soap->buflen = soap->dime.buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90488]
	mov	DWORD PTR [eax+12432], edx

; 1255 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Skip padding (%ld bytes)\n", -(long)soap->dime.size&3));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN42@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN41@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN41@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN42@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82712[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_0BK@DPFBJGHD@Skip?5padding?5?$CI?$CFld?5bytes?$CJ?6?$AA@
	mov	edx, DWORD PTR _fdebug$82712[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82712[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN42@soap_recv:

; 1256 :       for (i = -(long)soap->dime.size&3; i > 0; i--)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	mov	DWORD PTR _i$82700[ebp], ecx
	jmp	SHORT $LN39@soap_recv
$LN38@soap_recv:
	mov	eax, DWORD PTR _i$82700[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$82700[ebp], eax
$LN39@soap_recv:
	cmp	DWORD PTR _i$82700[ebp], 0
	jle	SHORT $LN37@soap_recv

; 1257 :       { soap->bufidx++;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 1258 :         if (soap->bufidx >= soap->buflen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN36@soap_recv

; 1259 :           if (soap_recv_raw(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv_raw
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@soap_recv

; 1260 :             return EOF;

	or	eax, -1
	jmp	$LN48@soap_recv
$LN36@soap_recv:

; 1261 :       }

	jmp	SHORT $LN38@soap_recv
$LN37@soap_recv:

; 1262 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME hdr for next chunk\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN34@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN33@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN33@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN34@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82725[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BN@HCGGJFMA@Get?5DIME?5hdr?5for?5next?5chunk?6?$AA@
	mov	eax, DWORD PTR _fdebug$82725[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82725[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@soap_recv:

; 1263 :       s = (char*)tmp;

	lea	eax, DWORD PTR _tmp$82701[ebp]
	mov	DWORD PTR _s$82699[ebp], eax

; 1264 :       for (i = 12; i > 0; i--)

	mov	DWORD PTR _i$82700[ebp], 12		; 0000000cH
	jmp	SHORT $LN31@soap_recv
$LN30@soap_recv:
	mov	eax, DWORD PTR _i$82700[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$82700[ebp], eax
$LN31@soap_recv:
	cmp	DWORD PTR _i$82700[ebp], 0
	jle	SHORT $LN29@soap_recv

; 1265 :       { *s++ = soap->buf[soap->bufidx++];

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _s$82699[ebp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	cl, BYTE PTR [eax+ecx+12468]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _s$82699[ebp]
	add	edx, 1
	mov	DWORD PTR _s$82699[ebp], edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 1266 :         if (soap->bufidx >= soap->buflen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN28@soap_recv

; 1267 :           if (soap_recv_raw(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv_raw
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@soap_recv

; 1268 :             return EOF;

	or	eax, -1
	jmp	$LN48@soap_recv
$LN28@soap_recv:

; 1269 :       }

	jmp	SHORT $LN30@soap_recv
$LN29@soap_recv:

; 1270 :       soap->dime.flags = tmp[0] & 0x7;

	movzx	ecx, BYTE PTR _tmp$82701[ebp]
	and	ecx, 7
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al

; 1271 :       soap->dime.size = ((size_t)tmp[8] << 24) | ((size_t)tmp[9] << 16) | ((size_t)tmp[10] << 8) | ((size_t)tmp[11]);

	movzx	eax, BYTE PTR _tmp$82701[ebp+8]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _tmp$82701[ebp+9]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _tmp$82701[ebp+10]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _tmp$82701[ebp+11]
	or	eax, ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90480], eax

; 1272 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME chunk (%u bytes)\n", (unsigned int)soap->dime.size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN26@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN25@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN25@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN26@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82741[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	push	ecx
	push	OFFSET ??_C@_0BL@EHOPGBHA@Get?5DIME?5chunk?5?$CI?$CFu?5bytes?$CJ?6?$AA@
	mov	edx, DWORD PTR _fdebug$82741[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82741[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@soap_recv:

; 1273 :       if (soap->dime.flags & SOAP_DIME_CF)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	je	$LN23@soap_recv

; 1274 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "More chunking\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN22@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN21@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN21@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN22@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82749[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0P@FAJIPIIP@More?5chunking?6?$AA@
	mov	eax, DWORD PTR _fdebug$82749[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82749[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@soap_recv:

; 1275 :         soap->dime.chunksize = soap->dime.size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90480]
	mov	DWORD PTR [eax+90484], edx

; 1276 :         if (soap->buflen - soap->bufidx >= soap->dime.size)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	edx, DWORD PTR [eax+90480]
	jb	SHORT $LN19@soap_recv

; 1277 :         { soap->dime.buflen = soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+90488], edx

; 1278 :           soap->buflen = soap->bufidx + soap->dime.chunksize;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+90484]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], ecx

; 1279 :         }
; 1280 :         else

	jmp	SHORT $LN18@soap_recv
$LN19@soap_recv:

; 1281 :           soap->dime.chunksize -= soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90484]
	sub	ecx, edx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90484], ecx
$LN18@soap_recv:

; 1282 :       }
; 1283 :       else

	jmp	$LN17@soap_recv
$LN23@soap_recv:

; 1284 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Last chunk\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN16@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN15@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN15@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN16@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82758[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0M@GDABLMIG@Last?5chunk?6?$AA@
	mov	eax, DWORD PTR _fdebug$82758[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82758[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@soap_recv:

; 1285 :         soap->dime.buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90488], 0

; 1286 :         soap->dime.chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90484], 0
$LN17@soap_recv:

; 1287 :       }
; 1288 :       soap->count = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], edx

; 1289 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%u bytes remaining\n", (unsigned int)soap->count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN13@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN12@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN12@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN13@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82764[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	push	ecx
	push	OFFSET ??_C@_0BE@BAFKLKAC@?$CFu?5bytes?5remaining?6?$AA@
	mov	edx, DWORD PTR _fdebug$82764[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82764[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@soap_recv:

; 1290 :       return SOAP_OK;

	xor	eax, eax
	jmp	$LN48@soap_recv
$LN46@soap_recv:

; 1291 :     }
; 1292 :     if (soap->dime.chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90484], 0
	je	$LN47@soap_recv

; 1293 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get next DIME hdr for chunked DIME (%u bytes chunk)\n", (unsigned int)soap->dime.chunksize));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82772[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90484]
	push	ecx
	push	OFFSET ??_C@_0DF@HCKKPCCH@Get?5next?5DIME?5hdr?5for?5chunked?5DI@
	mov	edx, DWORD PTR _fdebug$82772[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82772[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_recv:

; 1294 :       if (soap_recv_raw(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv_raw
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_recv

; 1295 :         return EOF;

	or	eax, -1
	jmp	$LN48@soap_recv
$LN6@soap_recv:

; 1296 :       if (soap->buflen - soap->bufidx >= soap->dime.chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	edx, DWORD PTR [eax+90484]
	jb	SHORT $LN5@soap_recv

; 1297 :       { soap->dime.buflen = soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+90488], edx

; 1298 :         soap->count -= soap->buflen - soap->bufidx - soap->dime.chunksize;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	sub	edx, DWORD PTR [eax+90484]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+12448]
	sub	eax, edx
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12448], eax

; 1299 :         soap->buflen = soap->bufidx + soap->dime.chunksize;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+90484]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], ecx

; 1300 :       }
; 1301 :       else

	jmp	SHORT $LN4@soap_recv
$LN5@soap_recv:

; 1302 :         soap->dime.chunksize -= soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90484]
	sub	ecx, edx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90484], ecx
$LN4@soap_recv:

; 1303 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%lu bytes remaining, count=%u\n", (unsigned long)(soap->buflen-soap->bufidx), (unsigned int)soap->count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN3@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_recv
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_recv:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_recv
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82782[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+12432]
	sub	ecx, DWORD PTR [eax+12428]
	push	ecx
	push	OFFSET ??_C@_0BP@DMDBKBBH@?$CFlu?5bytes?5remaining?0?5count?$DN?$CFu?6?$AA@
	mov	edx, DWORD PTR _fdebug$82782[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82782[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_recv:

; 1304 :       return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN48@soap_recv
$LN47@soap_recv:

; 1305 :     }
; 1306 :   }
; 1307 : #endif
; 1308 :   return soap_recv_raw(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv_raw
	add	esp, 4
$LN48@soap_recv:

; 1309 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN52@soap_recv
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN52@soap_recv:
	DD	1
	DD	$LN51@soap_recv
$LN51@soap_recv:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN50@soap_recv
$LN50@soap_recv:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_soap_recv ENDP
_TEXT	ENDS
PUBLIC	_soap_getchar
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getchar
_TEXT	SEGMENT
tv81 = -208						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_getchar PROC					; COMDAT

; 1318 : { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1319 :   c = soap->ahead;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12436]
	mov	DWORD PTR _c$[ebp], ecx

; 1320 :   if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN2@soap_getch@2

; 1321 :   { if (c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN1@soap_getch@2

; 1322 :       soap->ahead = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 0
$LN1@soap_getch@2:

; 1323 :     return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	SHORT $LN3@soap_getch@2
$LN2@soap_getch@2:

; 1324 :   }
; 1325 :   return soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN5@soap_getch@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@soap_getch@2
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN6@soap_getch@2
$LN5@soap_getch@2:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN6@soap_getch@2:
	mov	eax, DWORD PTR tv81[ebp]
$LN3@soap_getch@2:

; 1326 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getchar ENDP
_TEXT	ENDS
PUBLIC	_soap_code
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_code
_TEXT	SEGMENT
_code_map$ = 8						; size = 4
_str$ = 12						; size = 4
_soap_code PROC						; COMDAT

; 1335 : { if (code_map && str)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _code_map$[ebp], 0
	je	SHORT $LN4@soap_code
	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN4@soap_code
$LN3@soap_code:

; 1336 :   { while (code_map->string)

	mov	eax, DWORD PTR _code_map$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@soap_code

; 1337 :     { if (!strcmp(str, code_map->string)) /* case sensitive */

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_code

; 1338 :         return code_map;

	mov	eax, DWORD PTR _code_map$[ebp]
	jmp	SHORT $LN5@soap_code
$LN1@soap_code:

; 1339 :       code_map++;

	mov	eax, DWORD PTR _code_map$[ebp]
	add	eax, 8
	mov	DWORD PTR _code_map$[ebp], eax

; 1340 :     }

	jmp	SHORT $LN3@soap_code
$LN4@soap_code:

; 1341 :   }
; 1342 :   return NULL;

	xor	eax, eax
$LN5@soap_code:

; 1343 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_code ENDP
_TEXT	ENDS
PUBLIC	_soap_tag_cmp
PUBLIC	_soap_code_int
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_code_int
_TEXT	SEGMENT
_code_map$ = 8						; size = 4
_str$ = 12						; size = 4
_other$ = 16						; size = 4
_soap_code_int PROC					; COMDAT

; 1352 : { if (code_map)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _code_map$[ebp], 0
	je	SHORT $LN4@soap_code_
$LN3@soap_code_:

; 1353 :   { while (code_map->string)

	mov	eax, DWORD PTR _code_map$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@soap_code_

; 1354 :     { if (!soap_tag_cmp(str, code_map->string)) /* case insensitive */

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_code_

; 1355 :         return code_map->code;

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@soap_code_
$LN1@soap_code_:

; 1356 :       code_map++;

	mov	eax, DWORD PTR _code_map$[ebp]
	add	eax, 8
	mov	DWORD PTR _code_map$[ebp], eax

; 1357 :     }

	jmp	SHORT $LN3@soap_code_
$LN4@soap_code_:

; 1358 :   }
; 1359 :   return other;

	mov	eax, DWORD PTR _other$[ebp]
$LN5@soap_code_:

; 1360 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_code_int ENDP
_TEXT	ENDS
PUBLIC	_soap_code_str
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_code_str
_TEXT	SEGMENT
_code_map$ = 8						; size = 4
_code$ = 12						; size = 4
_soap_code_str PROC					; COMDAT

; 1369 : { if (!code_map)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _code_map$[ebp], 0
	jne	SHORT $LN2@soap_code_@2

; 1370 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@soap_code_@2
$LN2@soap_code_@2:

; 1371 :   while (code_map->code != code && code_map->string)

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _code$[ebp]
	je	SHORT $LN1@soap_code_@2
	mov	eax, DWORD PTR _code_map$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@soap_code_@2

; 1372 :     code_map++;

	mov	eax, DWORD PTR _code_map$[ebp]
	add	eax, 8
	mov	DWORD PTR _code_map$[ebp], eax
	jmp	SHORT $LN2@soap_code_@2
$LN1@soap_code_@2:

; 1373 :   return code_map->string;

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN4@soap_code_@2:

; 1374 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_code_str ENDP
_TEXT	ENDS
PUBLIC	_soap_code_bits
EXTRN	__imp__strncmp:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_code_bits
_TEXT	SEGMENT
_n$82833 = -32						; size = 4
_p$82829 = -20						; size = 4
_bits$ = -8						; size = 4
_code_map$ = 8						; size = 4
_str$ = 12						; size = 4
_soap_code_bits PROC					; COMDAT

; 1383 : { register long bits = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _bits$[ebp], 0

; 1384 :   if (code_map)

	cmp	DWORD PTR _code_map$[ebp], 0
	je	$LN10@soap_code_@3
$LN9@soap_code_@3:

; 1385 :   { while (str && *str)

	cmp	DWORD PTR _str$[ebp], 0
	je	$LN10@soap_code_@3
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN10@soap_code_@3

; 1386 :     { const struct soap_code_map *p;
; 1387 :       for (p = code_map; p->string; p++)

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	DWORD PTR _p$82829[ebp], eax
	jmp	SHORT $LN7@soap_code_@3
$LN6@soap_code_@3:
	mov	eax, DWORD PTR _p$82829[ebp]
	add	eax, 8
	mov	DWORD PTR _p$82829[ebp], eax
$LN7@soap_code_@3:
	mov	eax, DWORD PTR _p$82829[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN5@soap_code_@3

; 1388 :       { register size_t n = strlen(p->string);

	mov	eax, DWORD PTR _p$82829[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$82833[ebp], eax

; 1389 :         if (!strncmp(p->string, str, n) && soap_blank(str[n]))

	mov	esi, esp
	mov	eax, DWORD PTR _n$82833[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$82829[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN4@soap_code_@3
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _n$82833[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN4@soap_code_@3
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _n$82833[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN4@soap_code_@3

; 1390 :         { bits |= p->code;

	mov	eax, DWORD PTR _p$82829[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	or	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bits$[ebp], ecx

; 1391 :           str += n;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _n$82833[ebp]
	mov	DWORD PTR _str$[ebp], eax
$LN3@soap_code_@3:

; 1392 :           while (*str > 0 && *str <= 32)

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN2@soap_code_@3
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN2@soap_code_@3

; 1393 :             str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	jmp	SHORT $LN3@soap_code_@3
$LN2@soap_code_@3:

; 1394 :           break;

	jmp	SHORT $LN5@soap_code_@3
$LN4@soap_code_@3:

; 1395 :         }
; 1396 :       }

	jmp	$LN6@soap_code_@3
$LN5@soap_code_@3:

; 1397 :       if (!p->string)

	mov	eax, DWORD PTR _p$82829[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@soap_code_@3

; 1398 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN11@soap_code_@3
$LN1@soap_code_@3:

; 1399 :     }

	jmp	$LN9@soap_code_@3
$LN10@soap_code_@3:

; 1400 :   }
; 1401 :   return bits;

	mov	eax, DWORD PTR _bits$[ebp]
$LN11@soap_code_@3:

; 1402 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_code_bits ENDP
_TEXT	ENDS
PUBLIC	_soap_code_list
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_code_list
_TEXT	SEGMENT
_s$82850 = -20						; size = 4
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_code_map$ = 12						; size = 4
_code$ = 16						; size = 4
_soap_code_list PROC					; COMDAT

; 1411 : { register char *t = soap->tmpbuf;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _t$[ebp], eax

; 1412 :   if (code_map)

	cmp	DWORD PTR _code_map$[ebp], 0
	je	$LN8@soap_code_@4
$LN7@soap_code_@4:

; 1413 :   { while (code_map->string)

	mov	eax, DWORD PTR _code_map$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN8@soap_code_@4

; 1414 :     { if (code_map->code & code)

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, DWORD PTR _code$[ebp]
	je	SHORT $LN5@soap_code_@4

; 1415 :       { register const char *s = code_map->string;

	mov	eax, DWORD PTR _code_map$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _s$82850[ebp], ecx

; 1416 :         if (t != soap->tmpbuf)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	cmp	DWORD PTR _t$[ebp], eax
	je	SHORT $LN3@soap_code_@4

; 1417 :           *t++ = ' ';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx
$LN3@soap_code_@4:

; 1418 :         while (*s && t < soap->tmpbuf + sizeof(soap->tmpbuf) - 1)

	mov	eax, DWORD PTR _s$82850[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@soap_code_@4
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80051				; 000138b3H
	cmp	DWORD PTR _t$[ebp], eax
	jae	SHORT $LN2@soap_code_@4

; 1419 :           *t++ = *s++;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _s$82850[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _s$82850[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$82850[ebp], ecx
	jmp	SHORT $LN3@soap_code_@4
$LN2@soap_code_@4:

; 1420 :         if (t == soap->tmpbuf + sizeof(soap->tmpbuf) - 1)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80051				; 000138b3H
	cmp	DWORD PTR _t$[ebp], eax
	jne	SHORT $LN5@soap_code_@4

; 1421 :           break;

	jmp	SHORT $LN8@soap_code_@4
$LN5@soap_code_@4:

; 1422 :       }
; 1423 :       code_map++;

	mov	eax, DWORD PTR _code_map$[ebp]
	add	eax, 8
	mov	DWORD PTR _code_map$[ebp], eax

; 1424 :     }

	jmp	$LN7@soap_code_@4
$LN8@soap_code_@4:

; 1425 :   }
; 1426 :   *t = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 1427 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_code_list ENDP
_TEXT	ENDS
PUBLIC	_soap_get
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_get
_TEXT	SEGMENT
tv332 = -220						; size = 4
tv317 = -220						; size = 4
tv292 = -220						; size = 4
tv277 = -220						; size = 4
tv262 = -220						; size = 4
tv247 = -220						; size = 4
tv229 = -220						; size = 4
tv214 = -220						; size = 4
tv194 = -220						; size = 4
tv180 = -220						; size = 4
tv174 = -220						; size = 4
tv160 = -220						; size = 4
tv144 = -220						; size = 4
tv132 = -220						; size = 4
tv81 = -220						; size = 4
_k$82921 = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_get PROC						; COMDAT

; 1499 : { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1500 :   c = soap->ahead;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12436]
	mov	DWORD PTR _c$[ebp], ecx

; 1501 :   if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN47@soap_get

; 1502 :   { if ((int)c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN46@soap_get

; 1503 :       soap->ahead = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 0
$LN46@soap_get:

; 1504 :   }
; 1505 :   else

	jmp	SHORT $LN44@soap_get
$LN47@soap_get:

; 1506 :     c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN50@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN50@soap_get
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN51@soap_get
$LN50@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN51@soap_get:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _c$[ebp], edx
$LN44@soap_get:

; 1507 :   while ((int)c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	$LN43@soap_get

; 1508 :   { if (soap->cdata)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12440]
	test	ecx, ecx
	je	$LN42@soap_get

; 1509 :     { if (c == ']')

	cmp	DWORD PTR _c$[ebp], 93			; 0000005dH
	jne	$LN41@soap_get

; 1510 :       { c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN52@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN52@soap_get
	mov	DWORD PTR tv132[ebp], -1
	jmp	SHORT $LN53@soap_get
$LN52@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN53@soap_get:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1511 :         if (c == ']')

	cmp	DWORD PTR _c$[ebp], 93			; 0000005dH
	jne	$LN40@soap_get

; 1512 :         { c = soap_get0(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN54@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN54@soap_get
	mov	DWORD PTR tv144[ebp], -1
	jmp	SHORT $LN55@soap_get
$LN54@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv144[ebp], ecx
$LN55@soap_get:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1513 :           if (c == '>')

	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	jne	$LN39@soap_get

; 1514 :           { soap->cdata = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12440], ax

; 1515 :             soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN56@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN56@soap_get
	mov	DWORD PTR tv160[ebp], -1
	jmp	SHORT $LN57@soap_get
$LN56@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN57@soap_get:

; 1516 :             c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN58@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN58@soap_get
	mov	DWORD PTR tv174[ebp], -1
	jmp	SHORT $LN59@soap_get
$LN58@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv174[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN59@soap_get:
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1517 :           }
; 1518 :           else

	jmp	SHORT $LN38@soap_get
$LN39@soap_get:

; 1519 :           { soap_unget(soap, ']');

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 93		; 0000005dH

; 1520 :             return ']';

	mov	eax, 93					; 0000005dH
	jmp	$LN48@soap_get
$LN38@soap_get:

; 1521 :           }
; 1522 :         }
; 1523 :         else

	jmp	SHORT $LN37@soap_get
$LN40@soap_get:

; 1524 :         { soap_revget1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 1525 :           return ']';

	mov	eax, 93					; 0000005dH
	jmp	$LN48@soap_get
$LN37@soap_get:

; 1526 :         }
; 1527 :       }
; 1528 :       else

	jmp	SHORT $LN42@soap_get
$LN41@soap_get:

; 1529 :         return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$LN48@soap_get
$LN42@soap_get:

; 1530 :     }
; 1531 :     switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv180[ebp], eax
	mov	ecx, DWORD PTR tv180[ebp]
	sub	ecx, 34					; 00000022H
	mov	DWORD PTR tv180[ebp], ecx
	cmp	DWORD PTR tv180[ebp], 28		; 0000001cH
	ja	$LN34@soap_get
	mov	edx, DWORD PTR tv180[ebp]
	movzx	eax, BYTE PTR $LN79@soap_get[edx]
	jmp	DWORD PTR $LN80@soap_get[eax*4]
$LN32@soap_get:

; 1532 :     { case '<':
; 1533 :         do c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN60@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN60@soap_get
	mov	DWORD PTR tv194[ebp], -1
	jmp	SHORT $LN61@soap_get
$LN60@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv194[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN61@soap_get:
	mov	edx, DWORD PTR tv194[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1534 :         while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN30@soap_get
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN32@soap_get
$LN30@soap_get:

; 1535 :         if (c == '!' || c == '?' || c == '%')

	cmp	DWORD PTR _c$[ebp], 33			; 00000021H
	je	SHORT $LN27@soap_get
	cmp	DWORD PTR _c$[ebp], 63			; 0000003fH
	je	SHORT $LN27@soap_get
	cmp	DWORD PTR _c$[ebp], 37			; 00000025H
	jne	$LN28@soap_get
$LN27@soap_get:

; 1536 :         { register int k = 1;

	mov	DWORD PTR _k$82921[ebp], 1

; 1537 :           if (c == '!')

	cmp	DWORD PTR _c$[ebp], 33			; 00000021H
	jne	$LN26@soap_get

; 1538 :           { c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN62@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@soap_get
	mov	DWORD PTR tv214[ebp], -1
	jmp	SHORT $LN63@soap_get
$LN62@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv214[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN63@soap_get:
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1539 :             if (c == '[')

	cmp	DWORD PTR _c$[ebp], 91			; 0000005bH
	jne	$LN25@soap_get
$LN24@soap_get:

; 1540 :             { do c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN64@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN64@soap_get
	mov	DWORD PTR tv229[ebp], -1
	jmp	SHORT $LN65@soap_get
$LN64@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv229[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN65@soap_get:
	mov	edx, DWORD PTR tv229[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1541 :               while ((int)c != EOF && c != '[');

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN22@soap_get
	cmp	DWORD PTR _c$[ebp], 91			; 0000005bH
	jne	SHORT $LN24@soap_get
$LN22@soap_get:

; 1542 :               if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN20@soap_get

; 1543 :                 break;

	jmp	$LN34@soap_get
$LN20@soap_get:

; 1544 :               soap->cdata = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12440], ax

; 1545 :               c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN66@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@soap_get
	mov	DWORD PTR tv247[ebp], -1
	jmp	SHORT $LN67@soap_get
$LN66@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv247[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN67@soap_get:
	mov	edx, DWORD PTR tv247[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1546 :               continue;

	jmp	$LN44@soap_get
$LN25@soap_get:

; 1547 :             }
; 1548 :             if (c == '-' && (c = soap_get1(soap)) == '-')

	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	$LN19@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN68@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN68@soap_get
	mov	DWORD PTR tv262[ebp], -1
	jmp	SHORT $LN69@soap_get
$LN68@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv262[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN69@soap_get:
	mov	edx, DWORD PTR tv262[ebp]
	mov	DWORD PTR _c$[ebp], edx
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	$LN19@soap_get
$LN18@soap_get:

; 1549 :             { do
; 1550 :               { c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN70@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@soap_get
	mov	DWORD PTR tv277[ebp], -1
	jmp	SHORT $LN71@soap_get
$LN70@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv277[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN71@soap_get:
	mov	edx, DWORD PTR tv277[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1551 :                 if (c == '-' && (c = soap_get1(soap)) == '-')

	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	SHORT $LN17@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN72@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN72@soap_get
	mov	DWORD PTR tv292[ebp], -1
	jmp	SHORT $LN73@soap_get
$LN72@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv292[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN73@soap_get:
	mov	edx, DWORD PTR tv292[ebp]
	mov	DWORD PTR _c$[ebp], edx
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	SHORT $LN17@soap_get

; 1552 :                   break;

	jmp	SHORT $LN19@soap_get
$LN17@soap_get:

; 1553 :               } while ((int)c != EOF);

	cmp	DWORD PTR _c$[ebp], -1
	jne	$LN18@soap_get
$LN19@soap_get:

; 1554 :             }
; 1555 :           }

	jmp	SHORT $LN12@soap_get
$LN26@soap_get:

; 1556 :           else if (c == '?')

	cmp	DWORD PTR _c$[ebp], 63			; 0000003fH
	jne	SHORT $LN12@soap_get

; 1557 :             c = soap_get_pi(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get_pi
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN12@soap_get:

; 1558 :           while ((int)c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	$LN11@soap_get

; 1559 :           { if (c == '<')

	cmp	DWORD PTR _c$[ebp], 60			; 0000003cH
	jne	SHORT $LN10@soap_get

; 1560 :               k++;

	mov	eax, DWORD PTR _k$82921[ebp]
	add	eax, 1
	mov	DWORD PTR _k$82921[ebp], eax
	jmp	SHORT $LN9@soap_get
$LN10@soap_get:

; 1561 :             else if (c == '>')

	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	jne	SHORT $LN9@soap_get

; 1562 :             { if (--k <= 0)

	mov	eax, DWORD PTR _k$82921[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$82921[ebp], eax
	cmp	DWORD PTR _k$82921[ebp], 0
	jg	SHORT $LN9@soap_get

; 1563 :                 break;

	jmp	SHORT $LN11@soap_get
$LN9@soap_get:

; 1564 :             }
; 1565 :             c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN74@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN74@soap_get
	mov	DWORD PTR tv317[ebp], -1
	jmp	SHORT $LN75@soap_get
$LN74@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv317[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN75@soap_get:
	mov	edx, DWORD PTR tv317[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1566 :           }

	jmp	$LN12@soap_get
$LN11@soap_get:

; 1567 :           if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN6@soap_get

; 1568 :             break;

	jmp	$LN34@soap_get
$LN6@soap_get:

; 1569 :           c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN76@soap_get
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN76@soap_get
	mov	DWORD PTR tv332[ebp], -1
	jmp	SHORT $LN77@soap_get
$LN76@soap_get:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv332[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN77@soap_get:
	mov	edx, DWORD PTR tv332[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1570 :           continue;

	jmp	$LN44@soap_get
$LN28@soap_get:

; 1571 :         }
; 1572 :         if (c == '/')

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN5@soap_get

; 1573 :           return SOAP_TT;

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN48@soap_get
$LN5@soap_get:

; 1574 :         soap_revget1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 1575 :         return SOAP_LT;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN48@soap_get
$LN4@soap_get:

; 1576 :       case '>':
; 1577 :         return SOAP_GT;

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN48@soap_get
$LN3@soap_get:

; 1578 :       case '"':
; 1579 :         return SOAP_QT;

	mov	eax, -5					; fffffffbH
	jmp	SHORT $LN48@soap_get
$LN2@soap_get:

; 1580 :       case '\'':
; 1581 :         return SOAP_AP;

	mov	eax, -6					; fffffffaH
	jmp	SHORT $LN48@soap_get
$LN1@soap_get:

; 1582 :       case '&':
; 1583 :         return soap_char(soap) | 0x80000000;

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_char
	add	esp, 4
	or	eax, -2147483648			; 80000000H
	jmp	SHORT $LN48@soap_get
$LN34@soap_get:

; 1584 :     }
; 1585 :     break;

	jmp	SHORT $LN43@soap_get

; 1586 :   }

	jmp	$LN44@soap_get
$LN43@soap_get:

; 1587 :   return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN48@soap_get:

; 1588 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN80@soap_get:
	DD	$LN3@soap_get
	DD	$LN1@soap_get
	DD	$LN2@soap_get
	DD	$LN32@soap_get
	DD	$LN4@soap_get
	DD	$LN34@soap_get
$LN79@soap_get:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	4
_soap_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LBCJFAKL@apos?$AA@			; `string'
PUBLIC	??_C@_04KJFGKBNM@quot?$AA@			; `string'
PUBLIC	??_C@_03DCBBJBAA@amp?$AA@			; `string'
PUBLIC	??_C@_02GHFEHLK@gt?$AA@				; `string'
PUBLIC	??_C@_02KCAKIFL@lt?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__atol:PROC
EXTRN	__imp__strtol:PROC
;	COMDAT ??_C@_04LBCJFAKL@apos?$AA@
CONST	SEGMENT
??_C@_04LBCJFAKL@apos?$AA@ DB 'apos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJFGKBNM@quot?$AA@
CONST	SEGMENT
??_C@_04KJFGKBNM@quot?$AA@ DB 'quot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCBBJBAA@amp?$AA@
CONST	SEGMENT
??_C@_03DCBBJBAA@amp?$AA@ DB 'amp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GHFEHLK@gt?$AA@
CONST	SEGMENT
??_C@_02GHFEHLK@gt?$AA@ DB 'gt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCAKIFL@lt?$AA@
CONST	SEGMENT
??_C@_02KCAKIFL@lt?$AA@ DB 'lt', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_char
_TEXT	SEGMENT
tv79 = -252						; size = 4
_s$ = -52						; size = 4
_c$ = -40						; size = 4
_i$ = -28						; size = 4
_tmp$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_char PROC						; COMDAT

; 1435 : { char tmp[8];

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1436 :   register int i;
; 1437 :   register soap_wchar c;
; 1438 :   register char *s = tmp;

	lea	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 1439 :   for (i = 0; i < 7; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@soap_char
$LN12@soap_char:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@soap_char:
	cmp	DWORD PTR _i$[ebp], 7
	jge	$LN11@soap_char

; 1440 :   { c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN16@soap_char
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@soap_char
	mov	DWORD PTR tv79[ebp], -1
	jmp	SHORT $LN17@soap_char
$LN16@soap_char:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv79[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN17@soap_char:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 1441 :     if (c == ';' || (int)c == EOF)

	cmp	DWORD PTR _c$[ebp], 59			; 0000003bH
	je	SHORT $LN9@soap_char
	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN10@soap_char
$LN9@soap_char:

; 1442 :       break;

	jmp	SHORT $LN11@soap_char
$LN10@soap_char:

; 1443 :     *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 1444 :   }

	jmp	$LN12@soap_char
$LN11@soap_char:

; 1445 :   *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 1446 :   if (*tmp == '#')

	movsx	eax, BYTE PTR _tmp$[ebp]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN8@soap_char

; 1447 :   { if (tmp[1] == 'x' || tmp[1] == 'X')

	movsx	eax, BYTE PTR _tmp$[ebp+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN6@soap_char
	movsx	eax, BYTE PTR _tmp$[ebp+1]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN7@soap_char
$LN6@soap_char:

; 1448 :       return soap_strtol(tmp + 2, NULL, 16);

	mov	esi, esp
	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _tmp$[ebp+2]
	push	eax
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN14@soap_char
$LN7@soap_char:

; 1449 :     return atol(tmp + 1);

	lea	eax, DWORD PTR _tmp$[ebp+1]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN14@soap_char
$LN8@soap_char:

; 1450 :   }
; 1451 :   if (!strcmp(tmp, "lt"))

	push	OFFSET ??_C@_02KCAKIFL@lt?$AA@
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@soap_char

; 1452 :     return '<';

	mov	eax, 60					; 0000003cH
	jmp	$LN14@soap_char
$LN5@soap_char:

; 1453 :   if (!strcmp(tmp, "gt"))

	push	OFFSET ??_C@_02GHFEHLK@gt?$AA@
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_char

; 1454 :     return '>';

	mov	eax, 62					; 0000003eH
	jmp	SHORT $LN14@soap_char
$LN4@soap_char:

; 1455 :   if (!strcmp(tmp, "amp"))

	push	OFFSET ??_C@_03DCBBJBAA@amp?$AA@
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@soap_char

; 1456 :     return '&';

	mov	eax, 38					; 00000026H
	jmp	SHORT $LN14@soap_char
$LN3@soap_char:

; 1457 :   if (!strcmp(tmp, "quot"))

	push	OFFSET ??_C@_04KJFGKBNM@quot?$AA@
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_char

; 1458 :     return '"';

	mov	eax, 34					; 00000022H
	jmp	SHORT $LN14@soap_char
$LN2@soap_char:

; 1459 :   if (!strcmp(tmp, "apos"))

	push	OFFSET ??_C@_04LBCJFAKL@apos?$AA@
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_char

; 1460 :     return '\'';

	mov	eax, 39					; 00000027H
	jmp	SHORT $LN14@soap_char
$LN1@soap_char:

; 1461 : #ifndef WITH_LEAN
; 1462 :   return (soap_wchar)soap_code_int(html_entity_codes, tmp, SOAP_UNKNOWN_CHAR);

	push	127					; 0000007fH
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	OFFSET _html_entity_codes
	call	_soap_code_int
	add	esp, 12					; 0000000cH
$LN14@soap_char:

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@soap_char
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@soap_char:
	DD	1
	DD	$LN19@soap_char
$LN19@soap_char:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN18@soap_char
$LN18@soap_char:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_soap_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@NFPKHKDB@Switching?5to?5utf?98?5encoding?6?$AA@ ; `string'
PUBLIC	??_C@_06ENEJBNNE@utf?98?$CK?$AA@		; `string'
PUBLIC	??_C@_0BO@DPPMDGG@Switching?5to?5latin1?5encoding?6?$AA@ ; `string'
PUBLIC	??_C@_07KFPCELGH@latin1?$CK?$AA@		; `string'
PUBLIC	??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@		; `string'
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@		; `string'
PUBLIC	??_C@_04ONHKJKNE@xml?5?$AA@			; `string'
PUBLIC	??_C@_0P@CBJBIGLG@XML?5PI?5?$DM?$DP?$CFs?$DP?$DO?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BN@NFPKHKDB@Switching?5to?5utf?98?5encoding?6?$AA@
CONST	SEGMENT
??_C@_0BN@NFPKHKDB@Switching?5to?5utf?98?5encoding?6?$AA@ DB 'Switching t'
	DB	'o utf-8 encoding', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENEJBNNE@utf?98?$CK?$AA@
CONST	SEGMENT
??_C@_06ENEJBNNE@utf?98?$CK?$AA@ DB 'utf-8*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DPPMDGG@Switching?5to?5latin1?5encoding?6?$AA@
CONST	SEGMENT
??_C@_0BO@DPPMDGG@Switching?5to?5latin1?5encoding?6?$AA@ DB 'Switching to'
	DB	' latin1 encoding', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFPCELGH@latin1?$CK?$AA@
CONST	SEGMENT
??_C@_07KFPCELGH@latin1?$CK?$AA@ DB 'latin1*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@
CONST	SEGMENT
??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@ DB 'iso-8859-1*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@
CONST	SEGMENT
??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@ DB ' encoding=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONHKJKNE@xml?5?$AA@
CONST	SEGMENT
??_C@_04ONHKJKNE@xml?5?$AA@ DB 'xml ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBJBIGLG@XML?5PI?5?$DM?$DP?$CFs?$DP?$DO?6?$AA@
CONST	SEGMENT
??_C@_0P@CBJBIGLG@XML?5PI?5?$DM?$DP?$CFs?$DP?$DO?6?$AA@ DB 'XML PI <?%s?>'
	DB	0aH, 00H					; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_get_pi
_TEXT	SEGMENT
_fdebug$83008 = -144					; size = 4
_fdebug$82999 = -132					; size = 4
_fdebug$82985 = -120					; size = 4
_c$ = -108						; size = 4
_i$ = -96						; size = 4
_s$ = -84						; size = 4
_buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_get_pi PROC					; COMDAT

; 1595 : { char buf[64];

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1596 :   register char *s = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 1597 :   register int i = sizeof(buf);

	mov	DWORD PTR _i$[ebp], 64			; 00000040H

; 1598 :   register soap_wchar c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN20@soap_get_p:

; 1599 :   /* This is a quick way to parse XML PI and we could use a callback instead to
; 1600 :    * enable applications to intercept processing instructions */
; 1601 :   while ((int)c != EOF && c != '?')

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN19@soap_get_p
	cmp	DWORD PTR _c$[ebp], 63			; 0000003fH
	je	SHORT $LN19@soap_get_p

; 1602 :   { if (--i > 0)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN18@soap_get_p

; 1603 :     { if (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN17@soap_get_p
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN17@soap_get_p

; 1604 :         c = ' ';

	mov	DWORD PTR _c$[ebp], 32			; 00000020H
$LN17@soap_get_p:

; 1605 :       *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN18@soap_get_p:

; 1606 :     }
; 1607 :     c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 1608 :   }

	jmp	SHORT $LN20@soap_get_p
$LN19@soap_get_p:

; 1609 :   *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 1610 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "XML PI <?%s?>\n", buf));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN16@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN15@soap_get_p
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN15@soap_get_p:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN16@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82985[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@CBJBIGLG@XML?5PI?5?$DM?$DP?$CFs?$DP?$DO?6?$AA@
	mov	ecx, DWORD PTR _fdebug$82985[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82985[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@soap_get_p:

; 1611 :   if (!strncmp(buf, "xml ", 4))

	mov	esi, esp
	push	4
	push	OFFSET ??_C@_04ONHKJKNE@xml?5?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN13@soap_get_p

; 1612 :   { s = strstr(buf, " encoding=");

	push	OFFSET ??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 1613 :     if (s && s[10])

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN13@soap_get_p
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	test	ecx, ecx
	je	$LN13@soap_get_p

; 1614 :     { if (!soap_tag_cmp(s + 11, "iso-8859-1*")
; 1615 :        || !soap_tag_cmp(s + 11, "latin1*"))

	push	OFFSET ??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_get_p
	push	OFFSET ??_C@_07KFPCELGH@latin1?$CK?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN11@soap_get_p
$LN10@soap_get_p:

; 1616 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Switching to latin1 encoding\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_get_p
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_get_p:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$82999[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BO@DPPMDGG@Switching?5to?5latin1?5encoding?6?$AA@
	mov	eax, DWORD PTR _fdebug$82999[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$82999[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_get_p:

; 1617 :         soap->mode |= SOAP_ENC_LATIN;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN13@soap_get_p
$LN11@soap_get_p:

; 1618 :       }
; 1619 :       else if (!soap_tag_cmp(s + 11, "utf-8*"))

	push	OFFSET ??_C@_06ENEJBNNE@utf?98?$CK?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN13@soap_get_p

; 1620 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Switching to utf-8 encoding\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_get_p
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_get_p:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_get_p
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83008[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BN@NFPKHKDB@Switching?5to?5utf?98?5encoding?6?$AA@
	mov	eax, DWORD PTR _fdebug$83008[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83008[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_get_p:

; 1621 :         soap->mode &= ~SOAP_ENC_LATIN;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN13@soap_get_p:

; 1622 :       }
; 1623 :     }
; 1624 :   }
; 1625 :   if ((int)c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN1@soap_get_p

; 1626 :     c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN1@soap_get_p:

; 1627 :   return c;

	mov	eax, DWORD PTR _c$[ebp]

; 1628 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@soap_get_p
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@soap_get_p:
	DD	1
	DD	$LN24@soap_get_p
$LN24@soap_get_p:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN23@soap_get_p
$LN23@soap_get_p:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_soap_get_pi ENDP
_TEXT	ENDS
EXTRN	__imp__strstr:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\string.h
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR __SubStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
PUBLIC	??_C@_0BK@NEKAKPOO@Moving?5?$CFld?5bytes?5forward?6?$AA@ ; `string'
PUBLIC	_soap_move
;	COMDAT ??_C@_0BK@NEKAKPOO@Moving?5?$CFld?5bytes?5forward?6?$AA@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
CONST	SEGMENT
??_C@_0BK@NEKAKPOO@Moving?5?$CFld?5bytes?5forward?6?$AA@ DB 'Moving %ld b'
	DB	'ytes forward', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_move
_TEXT	SEGMENT
_fdebug$83020 = -8					; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_move PROC						; COMDAT

; 1638 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Moving %ld bytes forward\n", (long)n));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_move
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_move
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_move:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_move
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83020[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@NEKAKPOO@Moving?5?$CFld?5bytes?5forward?6?$AA@
	mov	ecx, DWORD PTR _fdebug$83020[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83020[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_move:
	jmp	SHORT $LN4@soap_move
$LN3@soap_move:

; 1639 :   for (; n > 0; n--)

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN4@soap_move:
	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN2@soap_move

; 1640 :     if ((int)soap_getchar(soap) == EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN1@soap_move

; 1641 :       return SOAP_EOF;

	or	eax, -1
	jmp	SHORT $LN8@soap_move
$LN1@soap_move:

; 1642 :   return SOAP_OK;

	jmp	SHORT $LN3@soap_move
$LN2@soap_move:
	xor	eax, eax
$LN8@soap_move:

; 1643 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_move ENDP
_TEXT	ENDS
PUBLIC	_soap_tell
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_tell
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_tell PROC						; COMDAT

; 1654 : { return soap->count - soap->buflen + soap->bufidx - (soap->ahead != 0);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+12448]
	sub	eax, DWORD PTR [ecx+12432]
	mov	edx, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR [edx+12428]
	mov	ecx, DWORD PTR _soap$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12436], 0
	setne	dl
	sub	eax, edx

; 1655 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_tell ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_pututf8
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_pututf8
_TEXT	SEGMENT
_t$83039 = -36						; size = 4
_tmp$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_c$ = 12						; size = 4
_soap_pututf8 PROC					; COMDAT

; 1665 : { char tmp[16];

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1666 :   if (c < 0x80 && c > 0)

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $LN10@soap_putut
	cmp	DWORD PTR _c$[ebp], 0
	jbe	SHORT $LN10@soap_putut

; 1667 :   { *tmp = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp], al

; 1668 :     return soap_send_raw(soap, tmp, 1);

	push	1
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	jmp	$LN11@soap_putut
$LN10@soap_putut:

; 1669 :   }
; 1670 : #ifndef WITH_LEAN
; 1671 :   if (c >= 0x80)

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jb	$LN9@soap_putut

; 1672 :   { register char *t = tmp;

	lea	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _t$83039[ebp], eax

; 1673 :     if (c < 0x0800)

	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $LN8@soap_putut

; 1674 :       *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1675 :     else

	jmp	$LN7@soap_putut
$LN8@soap_putut:

; 1676 :     { if (c < 0x010000)

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $LN6@soap_putut

; 1677 :         *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1678 :       else

	jmp	$LN5@soap_putut
$LN6@soap_putut:

; 1679 :       { if (c < 0x200000)

	cmp	DWORD PTR _c$[ebp], 2097152		; 00200000H
	jae	SHORT $LN4@soap_putut

; 1680 :           *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1681 :         else

	jmp	$LN3@soap_putut
$LN4@soap_putut:

; 1682 :         { if (c < 0x04000000)

	cmp	DWORD PTR _c$[ebp], 67108864		; 04000000H
	jae	SHORT $LN2@soap_putut

; 1683 :             *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 3
	or	ecx, 248				; 000000f8H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1684 :           else

	jmp	SHORT $LN1@soap_putut
$LN2@soap_putut:

; 1685 :           { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 30					; 0000001eH
	and	ecx, 1
	or	ecx, 252				; 000000fcH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1686 :             *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx
$LN1@soap_putut:

; 1687 :           }
; 1688 :           *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 18					; 00000012H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx
$LN3@soap_putut:

; 1689 :         }
; 1690 :         *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 12					; 0000000cH
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx
$LN5@soap_putut:

; 1691 :       }
; 1692 :       *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 6
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx
$LN7@soap_putut:

; 1693 :     }
; 1694 :     *t++ = (char)(0x80 | (c & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$83039[ebp]
	add	edx, 1
	mov	DWORD PTR _t$83039[ebp], edx

; 1695 :     *t = '\0';

	mov	eax, DWORD PTR _t$83039[ebp]
	mov	BYTE PTR [eax], 0
$LN9@soap_putut:

; 1696 :   }
; 1697 : #else
; 1698 :   sprintf(tmp, "&#%lu;", c);
; 1699 : #endif
; 1700 :   return soap_send(soap, tmp);

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
$LN11@soap_putut:

; 1701 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@soap_putut
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@soap_putut:
	DD	1
	DD	$LN14@soap_putut
$LN14@soap_putut:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN13@soap_putut
$LN13@soap_putut:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_soap_pututf8 ENDP
_TEXT	ENDS
PUBLIC	_soap_getutf8
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getutf8
_TEXT	SEGMENT
tv224 = -256						; size = 4
tv189 = -256						; size = 4
tv166 = -256						; size = 4
tv142 = -256						; size = 4
tv86 = -256						; size = 4
_c4$ = -56						; size = 4
_c3$ = -44						; size = 4
_c2$ = -32						; size = 4
_c1$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_getutf8 PROC					; COMDAT

; 1710 : { register soap_wchar c, c1, c2, c3, c4;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1711 :   c = soap->ahead;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12436]
	mov	DWORD PTR _c$[ebp], ecx

; 1712 :   if (c > 0xFF)

	cmp	DWORD PTR _c$[ebp], 255			; 000000ffH
	jle	SHORT $again$83067

; 1713 :   { soap->ahead = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 0

; 1714 :     return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$LN10@soap_getut
$again$83067:

; 1715 :   }
; 1716 : again:
; 1717 :   c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 1718 :   if (c < 0x80 || (soap->mode & SOAP_ENC_LATIN))

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jl	SHORT $LN7@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN8@soap_getut
$LN7@soap_getut:

; 1719 :     return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$LN10@soap_getut
$LN8@soap_getut:

; 1720 :   c1 = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN12@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@soap_getut
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $LN13@soap_getut
$LN12@soap_getut:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN13@soap_getut:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _c1$[ebp], edx

; 1721 :   if (c1 < 0x80)

	cmp	DWORD PTR _c1$[ebp], 128		; 00000080H
	jge	SHORT $LN6@soap_getut

; 1722 :   { soap_revget1(soap); /* doesn't look like this is UTF8 */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 1723 :     return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$LN10@soap_getut
$LN6@soap_getut:

; 1724 :   }
; 1725 :   c1 &= 0x3F;

	mov	eax, DWORD PTR _c1$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _c1$[ebp], eax

; 1726 :   if (c < 0xE0)

	cmp	DWORD PTR _c$[ebp], 224			; 000000e0H
	jge	SHORT $LN5@soap_getut

; 1727 :     return ((soap_wchar)(c & 0x1F) << 6) | c1;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 6
	or	eax, DWORD PTR _c1$[ebp]
	jmp	$LN10@soap_getut
$LN5@soap_getut:

; 1728 :   c2 = (soap_wchar)soap_get1(soap) & 0x3F;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN14@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@soap_getut
	mov	DWORD PTR tv142[ebp], -1
	jmp	SHORT $LN15@soap_getut
$LN14@soap_getut:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN15@soap_getut:
	mov	edx, DWORD PTR tv142[ebp]
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _c2$[ebp], edx

; 1729 :   if (c == 0xEF && c1 == 0x3B && c2 == 0x3F)	/* ignore UTF-8 BOM */

	cmp	DWORD PTR _c$[ebp], 239			; 000000efH
	jne	SHORT $LN4@soap_getut
	cmp	DWORD PTR _c1$[ebp], 59			; 0000003bH
	jne	SHORT $LN4@soap_getut
	cmp	DWORD PTR _c2$[ebp], 63			; 0000003fH
	jne	SHORT $LN4@soap_getut

; 1730 :     goto again;

	jmp	$again$83067
$LN4@soap_getut:

; 1731 :   if (c < 0xF0)

	cmp	DWORD PTR _c$[ebp], 240			; 000000f0H
	jge	SHORT $LN3@soap_getut

; 1732 :     return ((soap_wchar)(c & 0x0F) << 12) | (c1 << 6) | c2;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 15					; 0000000fH
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _c1$[ebp]
	shl	ecx, 6
	or	eax, ecx
	or	eax, DWORD PTR _c2$[ebp]
	jmp	$LN10@soap_getut
$LN3@soap_getut:

; 1733 :   c3 = (soap_wchar)soap_get1(soap) & 0x3F;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN16@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@soap_getut
	mov	DWORD PTR tv166[ebp], -1
	jmp	SHORT $LN17@soap_getut
$LN16@soap_getut:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv166[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN17@soap_getut:
	mov	edx, DWORD PTR tv166[ebp]
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _c3$[ebp], edx

; 1734 :   if (c < 0xF8)

	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN2@soap_getut

; 1735 :     return ((soap_wchar)(c & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 7
	shl	eax, 18					; 00000012H
	mov	ecx, DWORD PTR _c1$[ebp]
	shl	ecx, 12					; 0000000cH
	or	eax, ecx
	mov	edx, DWORD PTR _c2$[ebp]
	shl	edx, 6
	or	eax, edx
	or	eax, DWORD PTR _c3$[ebp]
	jmp	$LN10@soap_getut
$LN2@soap_getut:

; 1736 :   c4 = (soap_wchar)soap_get1(soap) & 0x3F;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN18@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@soap_getut
	mov	DWORD PTR tv189[ebp], -1
	jmp	SHORT $LN19@soap_getut
$LN18@soap_getut:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv189[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN19@soap_getut:
	mov	edx, DWORD PTR tv189[ebp]
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _c4$[ebp], edx

; 1737 :   if (c < 0xFC)

	cmp	DWORD PTR _c$[ebp], 252			; 000000fcH
	jge	SHORT $LN1@soap_getut

; 1738 :     return ((soap_wchar)(c & 0x03) << 24) | (c1 << 18) | (c2 << 12) | (c3 << 6) | c4;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 3
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _c1$[ebp]
	shl	ecx, 18					; 00000012H
	or	eax, ecx
	mov	edx, DWORD PTR _c2$[ebp]
	shl	edx, 12					; 0000000cH
	or	eax, edx
	mov	ecx, DWORD PTR _c3$[ebp]
	shl	ecx, 6
	or	eax, ecx
	or	eax, DWORD PTR _c4$[ebp]
	jmp	$LN10@soap_getut
$LN1@soap_getut:

; 1739 :   return ((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(soap_get1(soap) & 0x3F);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN20@soap_getut
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@soap_getut
	mov	DWORD PTR tv224[ebp], -1
	jmp	SHORT $LN21@soap_getut
$LN20@soap_getut:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv224[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN21@soap_getut:
	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 1
	shl	eax, 30					; 0000001eH
	mov	edx, DWORD PTR _c1$[ebp]
	shl	edx, 24					; 00000018H
	or	eax, edx
	mov	ecx, DWORD PTR _c2$[ebp]
	shl	ecx, 18					; 00000012H
	or	eax, ecx
	mov	edx, DWORD PTR _c3$[ebp]
	shl	edx, 12					; 0000000cH
	or	eax, edx
	mov	ecx, DWORD PTR _c4$[ebp]
	shl	ecx, 6
	or	eax, ecx
	mov	edx, DWORD PTR tv224[ebp]
	and	edx, 63					; 0000003fH
	or	eax, edx
$LN10@soap_getut:

; 1740 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getutf8 ENDP
_TEXT	ENDS
PUBLIC	_soap_puthex
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_puthex
_TEXT	SEGMENT
_m$83100 = -32						; size = 4
_i$ = -20						; size = 4
_d$ = -8						; size = 2
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_puthex PROC					; COMDAT

; 1749 : { char d[2];

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1750 :   register int i;
; 1751 : #ifdef WITH_DOM
; 1752 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1753 :   { if (!(soap->dom->data = soap_s2hex(soap, s, NULL, n)))
; 1754 :       return soap->error;
; 1755 :     return SOAP_OK;
; 1756 :   }
; 1757 : #endif
; 1758 :   for (i = 0; i < n; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@soap_puthe
$LN3@soap_puthe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@soap_puthe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@soap_puthe

; 1759 :   { register int m = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _m$83100[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 1760 :     d[0] = (char)((m >> 4) + (m > 159 ? '7' : '0'));

	mov	ecx, DWORD PTR _m$83100[ebp]
	sar	ecx, 4
	cmp	DWORD PTR _m$83100[ebp], 159		; 0000009fH
	setle	al
	sub	al, 1
	and	al, 7
	add	al, 48					; 00000030H
	movsx	edx, al
	add	ecx, edx
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _d$[ebp], al

; 1761 :     m &= 0x0F;

	mov	eax, DWORD PTR _m$83100[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _m$83100[ebp], eax

; 1762 :     d[1] = (char)(m + (m > 9 ? '7' : '0'));

	cmp	DWORD PTR _m$83100[ebp], 9
	setle	al
	sub	al, 1
	and	al, 7
	add	al, 48					; 00000030H
	movsx	ecx, al
	add	ecx, DWORD PTR _m$83100[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _d$[ebp+1], al

; 1763 :     if (soap_send_raw(soap, d, 2))

	push	2
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_puthe

; 1764 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@soap_puthe
$LN1@soap_puthe:

; 1765 :   }

	jmp	$LN3@soap_puthe
$LN2@soap_puthe:

; 1766 :   return SOAP_OK;

	xor	eax, eax
$LN5@soap_puthe:

; 1767 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_puthe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@soap_puthe:
	DD	1
	DD	$LN8@soap_puthe
$LN8@soap_puthe:
	DD	-8					; fffffff8H
	DD	2
	DD	$LN7@soap_puthe
$LN7@soap_puthe:
	DB	100					; 00000064H
	DB	0
_soap_puthex ENDP
_TEXT	ENDS
PUBLIC	_soap_malloc
PUBLIC	_soap_append_lab
PUBLIC	_soap_gethex
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_gethex
_TEXT	SEGMENT
tv161 = -284						; size = 4
tv152 = -280						; size = 4
_p$83127 = -80						; size = 4
_c$83120 = -68						; size = 4
_d2$83119 = -53						; size = 1
_d1$83118 = -41						; size = 1
_k$83113 = -32						; size = 4
_i$83112 = -20						; size = 4
_s$83111 = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_gethex PROC					; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1777 : #ifdef WITH_DOM
; 1778 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1779 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1780 :     return (unsigned char*)soap_hex2s(soap, soap->dom->data, NULL, 0, n);
; 1781 :   }
; 1782 : #endif
; 1783 : #ifdef WITH_FAST
; 1784 :   soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0
$LN12@soap_gethe:

; 1785 :   for (;;)
; 1786 :   { register char *s;
; 1787 :     register size_t i, k;
; 1788 :     if (soap_append_lab(soap, NULL, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@soap_gethe

; 1789 :       return NULL;

	xor	eax, eax
	jmp	$LN13@soap_gethe
$LN10@soap_gethe:

; 1790 :     s = soap->labbuf + soap->labidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+12464]
	mov	DWORD PTR _s$83111[ebp], ecx

; 1791 :     k = soap->lablen - soap->labidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12460]
	sub	edx, DWORD PTR [ecx+12464]
	mov	DWORD PTR _k$83113[ebp], edx

; 1792 :     soap->labidx = soap->lablen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12460]
	mov	DWORD PTR [eax+12464], edx

; 1793 :     for (i = 0; i < k; i++)

	mov	DWORD PTR _i$83112[ebp], 0
	jmp	SHORT $LN9@soap_gethe
$LN8@soap_gethe:
	mov	eax, DWORD PTR _i$83112[ebp]
	add	eax, 1
	mov	DWORD PTR _i$83112[ebp], eax
$LN9@soap_gethe:
	mov	eax, DWORD PTR _i$83112[ebp]
	cmp	eax, DWORD PTR _k$83113[ebp]
	jae	$LN7@soap_gethe

; 1794 :     { register char d1, d2;
; 1795 :       register soap_wchar c;
; 1796 :       c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$83120[ebp], eax

; 1797 :       if (soap_isxdigit(c))

	mov	eax, DWORD PTR _c$83120[ebp]
	push	eax
	call	_soap_isxdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_gethe

; 1798 :       { d1 = (char)c;

	mov	ecx, DWORD PTR _c$83120[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _d1$83118[ebp], al

; 1799 :         c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$83120[ebp], eax

; 1800 :         if (soap_isxdigit(c))

	mov	eax, DWORD PTR _c$83120[ebp]
	push	eax
	call	_soap_isxdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@soap_gethe

; 1801 :           d2 = (char)c;

	mov	ecx, DWORD PTR _c$83120[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _d2$83119[ebp], al

; 1802 :         else

	jmp	SHORT $LN4@soap_gethe
$LN5@soap_gethe:

; 1803 :         { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 1804 :           return NULL;

	xor	eax, eax
	jmp	$LN13@soap_gethe
$LN4@soap_gethe:

; 1805 :         }
; 1806 :       }
; 1807 :       else

	jmp	SHORT $LN3@soap_gethe
$LN6@soap_gethe:

; 1808 :       { unsigned char *p;
; 1809 :         soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$83120[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 1810 :         if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN2@soap_gethe

; 1811 :           *n = (int)(soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83112[ebp]
	sub	ecx, DWORD PTR _k$83113[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@soap_gethe:

; 1812 :         p = (unsigned char*)soap_malloc(soap, soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83112[ebp]
	sub	ecx, DWORD PTR _k$83113[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$83127[ebp], eax

; 1813 :         if (p)

	cmp	DWORD PTR _p$83127[ebp], 0
	je	SHORT $LN1@soap_gethe

; 1814 :           memcpy(p, soap->labbuf, soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83112[ebp]
	sub	ecx, DWORD PTR _k$83113[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12456]
	push	eax
	mov	ecx, DWORD PTR _p$83127[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@soap_gethe:

; 1815 :         return p;

	mov	eax, DWORD PTR _p$83127[ebp]
	jmp	SHORT $LN13@soap_gethe
$LN3@soap_gethe:

; 1816 :       }
; 1817 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');

	movsx	eax, BYTE PTR _d1$83118[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN15@soap_gethe
	movsx	ecx, BYTE PTR _d1$83118[ebp]
	and	ecx, 7
	add	ecx, 9
	mov	DWORD PTR tv152[ebp], ecx
	jmp	SHORT $LN16@soap_gethe
$LN15@soap_gethe:
	movsx	edx, BYTE PTR _d1$83118[ebp]
	sub	edx, 48					; 00000030H
	mov	DWORD PTR tv152[ebp], edx
$LN16@soap_gethe:
	movsx	eax, BYTE PTR _d2$83119[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN17@soap_gethe
	movsx	ecx, BYTE PTR _d2$83119[ebp]
	and	ecx, 7
	add	ecx, 9
	mov	DWORD PTR tv161[ebp], ecx
	jmp	SHORT $LN18@soap_gethe
$LN17@soap_gethe:
	movsx	edx, BYTE PTR _d2$83119[ebp]
	sub	edx, 48					; 00000030H
	mov	DWORD PTR tv161[ebp], edx
$LN18@soap_gethe:
	mov	ecx, DWORD PTR tv152[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR tv161[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83111[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83111[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83111[ebp], edx

; 1818 :     }

	jmp	$LN8@soap_gethe
$LN7@soap_gethe:

; 1819 :   }

	jmp	$LN12@soap_gethe
$LN13@soap_gethe:

; 1820 : #else
; 1821 :   if (soap_new_block(soap))
; 1822 :     return NULL;
; 1823 :   for (;;)
; 1824 :   { register int i;
; 1825 :     register char *s = (char*)soap_push_block(soap, SOAP_BLKLEN);
; 1826 :     if (!s)
; 1827 :     { soap_end_block(soap);
; 1828 :       return NULL;
; 1829 :     }
; 1830 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1831 :     { register char d1, d2;
; 1832 :       register soap_wchar c = soap_get(soap);
; 1833 :       if (soap_isxdigit(c))
; 1834 :       { d1 = (char)c;
; 1835 :         c = soap_get(soap);
; 1836 :         if (soap_isxdigit(c))
; 1837 :           d2 = (char)c;
; 1838 :         else
; 1839 :         { soap_end_block(soap);
; 1840 :           soap->error = SOAP_TYPE;
; 1841 :           return NULL;
; 1842 :         }
; 1843 :       }
; 1844 :       else
; 1845 :       { unsigned char *p;
; 1846 :         soap_unget(soap, c);
; 1847 :         if (n)
; 1848 :           *n = (int)soap_size_block(soap, i);
; 1849 :         p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 1850 :         return p;
; 1851 :       }
; 1852 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');
; 1853 :     }
; 1854 :   }
; 1855 : #endif
; 1856 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_gethex ENDP
_TEXT	ENDS
PUBLIC	_soap_putbase64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_putbase64
_TEXT	SEGMENT
_d$ = -32						; size = 4
_m$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_putbase64 PROC					; COMDAT

; 1865 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1866 :   register unsigned long m;
; 1867 :   char d[4];
; 1868 :   if (!s)

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN22@soap_putba

; 1869 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN23@soap_putba
$LN22@soap_putba:

; 1870 : #ifdef WITH_DOM
; 1871 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1872 :   { if (!(soap->dom->data = soap_s2base64(soap, s, NULL, n)))
; 1873 :       return soap->error;
; 1874 :     return SOAP_OK;
; 1875 :   }
; 1876 : #endif
; 1877 :   for (; n > 2; n -= 3, s += 3)

	jmp	SHORT $LN21@soap_putba
$LN20@soap_putba:
	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 3
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 3
	mov	DWORD PTR _s$[ebp], ecx
$LN21@soap_putba:
	cmp	DWORD PTR _n$[ebp], 2
	jle	$LN19@soap_putba

; 1878 :   { m = s[0];

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _m$[ebp], ecx

; 1879 :     m = (m << 8) | s[1];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax

; 1880 :     m = (m << 8) | s[2];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax

; 1881 :     for (i = 4; i > 0; m >>= 6)

	mov	DWORD PTR _i$[ebp], 4
	jmp	SHORT $LN18@soap_putba
$LN17@soap_putba:
	mov	eax, DWORD PTR _m$[ebp]
	shr	eax, 6
	mov	DWORD PTR _m$[ebp], eax
$LN18@soap_putba:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN16@soap_putba

; 1882 :       d[--i] = soap_base64o[m & 0x3F];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _soap_base64o[ecx]
	mov	BYTE PTR _d$[ebp+edx], al
	jmp	SHORT $LN17@soap_putba
$LN16@soap_putba:

; 1883 :     if (soap_send_raw(soap, d, 4))

	push	4
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@soap_putba

; 1884 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN23@soap_putba
$LN15@soap_putba:

; 1885 :   }

	jmp	$LN20@soap_putba
$LN19@soap_putba:

; 1886 :   if (n > 0)

	cmp	DWORD PTR _n$[ebp], 0
	jle	$LN14@soap_putba

; 1887 :   { m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 1888 :     for (i = 0; i < n; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@soap_putba
$LN12@soap_putba:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@soap_putba:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN11@soap_putba

; 1889 :       m = (m << 8) | *s++;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN12@soap_putba
$LN11@soap_putba:

; 1890 :     for (; i < 3; i++)

	jmp	SHORT $LN10@soap_putba
$LN9@soap_putba:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@soap_putba:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN8@soap_putba

; 1891 :       m <<= 8;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN9@soap_putba
$LN8@soap_putba:

; 1892 :     for (i++; i > 0; m >>= 6)

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@soap_putba
$LN6@soap_putba:
	mov	eax, DWORD PTR _m$[ebp]
	shr	eax, 6
	mov	DWORD PTR _m$[ebp], eax
$LN7@soap_putba:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN5@soap_putba

; 1893 :       d[--i] = soap_base64o[m & 0x3F];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _soap_base64o[ecx]
	mov	BYTE PTR _d$[ebp+edx], al
	jmp	SHORT $LN6@soap_putba
$LN5@soap_putba:

; 1894 :     for (i = 3; i > n; i--)

	mov	DWORD PTR _i$[ebp], 3
	jmp	SHORT $LN4@soap_putba
$LN3@soap_putba:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@soap_putba:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jle	SHORT $LN2@soap_putba

; 1895 :       d[i] = '=';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _d$[ebp+eax], 61		; 0000003dH
	jmp	SHORT $LN3@soap_putba
$LN2@soap_putba:

; 1896 :     if (soap_send_raw(soap, d, 4))

	push	4
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@soap_putba

; 1897 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN23@soap_putba
$LN14@soap_putba:

; 1898 :   }
; 1899 :   return SOAP_OK;

	xor	eax, eax
$LN23@soap_putba:

; 1900 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@soap_putba
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@soap_putba:
	DD	1
	DD	$LN26@soap_putba
$LN26@soap_putba:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN25@soap_putba
$LN25@soap_putba:
	DB	100					; 00000064H
	DB	0
_soap_putbase64 ENDP
_TEXT	ENDS
PUBLIC	_soap_getbase64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getbase64
_TEXT	SEGMENT
tv89 = -292						; size = 4
_b$83209 = -92						; size = 4
_p$83187 = -80						; size = 4
_c$83184 = -68						; size = 4
_j$83180 = -56						; size = 4
_m$83179 = -44						; size = 4
_s$83172 = -32						; size = 4
_k$83171 = -20						; size = 4
_i$83170 = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_malloc_flag$ = 16					; size = 4
_soap_getbase64 PROC					; COMDAT

; 1909 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1910 : #ifdef WITH_DOM
; 1911 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1912 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1913 :     return (unsigned char*)soap_base642s(soap, soap->dom->data, NULL, 0, n);
; 1914 :   }
; 1915 : #endif
; 1916 : #ifdef WITH_FAST
; 1917 :   soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0
$LN27@soap_getba:

; 1918 :   for (;;)
; 1919 :   { register size_t i, k;
; 1920 :     register char *s;
; 1921 :     if (soap_append_lab(soap, NULL, 2))

	push	2
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@soap_getba

; 1922 :       return NULL;

	xor	eax, eax
	jmp	$LN28@soap_getba
$LN25@soap_getba:

; 1923 :     s = soap->labbuf + soap->labidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+12464]
	mov	DWORD PTR _s$83172[ebp], ecx

; 1924 :     k = soap->lablen - soap->labidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12460]
	sub	edx, DWORD PTR [ecx+12464]
	mov	DWORD PTR _k$83171[ebp], edx

; 1925 :     soap->labidx = 3 * (soap->lablen / 3);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+12460]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	imul	eax, 3
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12464], eax

; 1926 :     if (!s)

	cmp	DWORD PTR _s$83172[ebp], 0
	jne	SHORT $LN24@soap_getba

; 1927 :       return NULL;

	xor	eax, eax
	jmp	$LN28@soap_getba
$LN24@soap_getba:

; 1928 :     if (k > 2)

	cmp	DWORD PTR _k$83171[ebp], 2
	jbe	$LN23@soap_getba

; 1929 :     { for (i = 0; i < k - 2; i += 3)

	mov	DWORD PTR _i$83170[ebp], 0
	jmp	SHORT $LN22@soap_getba
$LN21@soap_getba:
	mov	eax, DWORD PTR _i$83170[ebp]
	add	eax, 3
	mov	DWORD PTR _i$83170[ebp], eax
$LN22@soap_getba:
	mov	eax, DWORD PTR _k$83171[ebp]
	sub	eax, 2
	cmp	DWORD PTR _i$83170[ebp], eax
	jae	$LN23@soap_getba

; 1930 :       { register unsigned long m = 0;

	mov	DWORD PTR _m$83179[ebp], 0

; 1931 :         register int j = 0;

	mov	DWORD PTR _j$83180[ebp], 0
$LN19@soap_getba:

; 1932 :         do
; 1933 :         { register soap_wchar c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$83184[ebp], eax

; 1934 :           if (c == '=' || c < 0)

	cmp	DWORD PTR _c$83184[ebp], 61		; 0000003dH
	je	SHORT $LN15@soap_getba
	cmp	DWORD PTR _c$83184[ebp], 0
	jge	$LN16@soap_getba
$LN15@soap_getba:

; 1935 :           { unsigned char *p;
; 1936 :             switch (j)

	mov	eax, DWORD PTR _j$83180[ebp]
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 2
	je	SHORT $LN12@soap_getba
	cmp	DWORD PTR tv89[ebp], 3
	je	SHORT $LN11@soap_getba
	jmp	SHORT $LN13@soap_getba
$LN12@soap_getba:

; 1937 :             { case 2:
; 1938 :                 *s++ = (char)((m >> 4) & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	shr	ecx, 4
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1939 :                 i++;

	mov	eax, DWORD PTR _i$83170[ebp]
	add	eax, 1
	mov	DWORD PTR _i$83170[ebp], eax

; 1940 :                 break;

	jmp	SHORT $LN13@soap_getba
$LN11@soap_getba:

; 1941 :               case 3:
; 1942 :                 *s++ = (char)((m >> 10) & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1943 :                 *s++ = (char)((m >> 2) & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	shr	ecx, 2
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1944 :                 i += 2;

	mov	eax, DWORD PTR _i$83170[ebp]
	add	eax, 2
	mov	DWORD PTR _i$83170[ebp], eax
$LN13@soap_getba:

; 1945 :             }
; 1946 :             if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN10@soap_getba

; 1947 :               *n = (int)(soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83170[ebp]
	sub	ecx, DWORD PTR _k$83171[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx
$LN10@soap_getba:

; 1948 :             p = (unsigned char*)soap_malloc(soap, soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83170[ebp]
	sub	ecx, DWORD PTR _k$83171[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$83187[ebp], eax

; 1949 :             if (p)

	cmp	DWORD PTR _p$83187[ebp], 0
	je	SHORT $LN9@soap_getba

; 1950 :               memcpy(p, soap->labbuf, soap->lablen + i - k);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	add	ecx, DWORD PTR _i$83170[ebp]
	sub	ecx, DWORD PTR _k$83171[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12456]
	push	eax
	mov	ecx, DWORD PTR _p$83187[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@soap_getba:

; 1951 :             if (c >= 0)

	cmp	DWORD PTR _c$83184[ebp], 0
	jl	SHORT $LN8@soap_getba
$LN7@soap_getba:

; 1952 :             { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$83184[ebp], eax
	xor	ecx, ecx
	cmp	DWORD PTR _c$83184[ebp], -1
	setne	cl
	test	ecx, ecx
	je	SHORT $LN8@soap_getba
	cmp	DWORD PTR _c$83184[ebp], -2		; fffffffeH
	je	SHORT $LN8@soap_getba
	cmp	DWORD PTR _c$83184[ebp], -3		; fffffffdH
	je	SHORT $LN8@soap_getba

; 1953 :                 ;

	jmp	SHORT $LN7@soap_getba
$LN8@soap_getba:

; 1954 :             }
; 1955 :             soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$83184[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 1956 :             return p;

	mov	eax, DWORD PTR _p$83187[ebp]
	jmp	$LN28@soap_getba
$LN16@soap_getba:

; 1957 :           }
; 1958 :           c -= '+';

	mov	eax, DWORD PTR _c$83184[ebp]
	sub	eax, 43					; 0000002bH
	mov	DWORD PTR _c$83184[ebp], eax

; 1959 :           if (c >= 0 && c <= 79)

	js	SHORT $LN5@soap_getba
	cmp	DWORD PTR _c$83184[ebp], 79		; 0000004fH
	jg	SHORT $LN5@soap_getba

; 1960 :           { register int b = soap_base64i[c];

	mov	eax, DWORD PTR _c$83184[ebp]
	movsx	ecx, BYTE PTR _soap_base64i[eax]
	mov	DWORD PTR _b$83209[ebp], ecx

; 1961 :             if (b >= 64)

	cmp	DWORD PTR _b$83209[ebp], 64		; 00000040H
	jl	SHORT $LN4@soap_getba

; 1962 :             { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 1963 :               return NULL;

	xor	eax, eax
	jmp	$LN28@soap_getba
$LN4@soap_getba:

; 1964 :             }
; 1965 :             m = (m << 6) + b;

	mov	eax, DWORD PTR _m$83179[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _b$83209[ebp]
	mov	DWORD PTR _m$83179[ebp], eax

; 1966 :             j++;

	mov	eax, DWORD PTR _j$83180[ebp]
	add	eax, 1
	mov	DWORD PTR _j$83180[ebp], eax
	jmp	SHORT $LN18@soap_getba
$LN5@soap_getba:

; 1967 :           }
; 1968 :           else if (!soap_blank(c + '+'))

	mov	eax, DWORD PTR _c$83184[ebp]
	add	eax, 43					; 0000002bH
	js	SHORT $LN1@soap_getba
	mov	eax, DWORD PTR _c$83184[ebp]
	add	eax, 43					; 0000002bH
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN18@soap_getba
$LN1@soap_getba:

; 1969 :           { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 1970 :             return NULL;

	xor	eax, eax
	jmp	SHORT $LN28@soap_getba
$LN18@soap_getba:

; 1971 :           }
; 1972 :         } while (j < 4);

	cmp	DWORD PTR _j$83180[ebp], 4
	jl	$LN19@soap_getba

; 1973 :         *s++ = (char)((m >> 16) & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1974 :         *s++ = (char)((m >> 8) & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1975 :         *s++ = (char)(m & 0xFF);

	mov	ecx, DWORD PTR _m$83179[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$83172[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$83172[ebp]
	add	edx, 1
	mov	DWORD PTR _s$83172[ebp], edx

; 1976 :       }

	jmp	$LN21@soap_getba
$LN23@soap_getba:

; 1977 :     }
; 1978 :   }

	jmp	$LN27@soap_getba
$LN28@soap_getba:

; 1979 : #else
; 1980 :   if (soap_new_block(soap))
; 1981 :     return NULL;
; 1982 :   for (;;)
; 1983 :   { register int i;
; 1984 :     register char *s = (char*)soap_push_block(soap, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
; 1985 :     if (!s)
; 1986 :     { soap_end_block(soap);
; 1987 :       return NULL;
; 1988 :     }
; 1989 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1990 :     { register unsigned long m = 0;
; 1991 :       register int j = 0;
; 1992 :       do
; 1993 :       { register soap_wchar c = soap_get(soap);
; 1994 :         if (c == '=' || c < 0)
; 1995 :         { unsigned char *p;
; 1996 :           i *= 3;
; 1997 :           switch (j)
; 1998 :           { case 2:
; 1999 :               *s++ = (char)((m >> 4) & 0xFF);
; 2000 :               i++;
; 2001 :               break;
; 2002 :             case 3:
; 2003 :               *s++ = (char)((m >> 10) & 0xFF);
; 2004 :               *s++ = (char)((m >> 2) & 0xFF);
; 2005 :               i += 2;
; 2006 :           }
; 2007 :           if (n)
; 2008 :             *n = (int)soap_size_block(soap, i);
; 2009 :           p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 2010 :           if (c >= 0)
; 2011 :           { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)
; 2012 :               ;
; 2013 :           }
; 2014 :           soap_unget(soap, c);
; 2015 :           return p;
; 2016 :         }
; 2017 :         c -= '+';
; 2018 :         if (c >= 0 && c <= 79)
; 2019 :         { int b = soap_base64i[c];
; 2020 :           if (b >= 64)
; 2021 :           { soap->error = SOAP_TYPE;
; 2022 :             return NULL;
; 2023 :           }
; 2024 :           m = (m << 6) + b;
; 2025 :           j++;
; 2026 :         }
; 2027 :         else if (!soap_blank(c))
; 2028 :         { soap->error = SOAP_TYPE;
; 2029 :           return NULL;
; 2030 :         }
; 2031 :       } while (j < 4);
; 2032 :       *s++ = (char)((m >> 16) & 0xFF);
; 2033 :       *s++ = (char)((m >> 8) & 0xFF);
; 2034 :       *s++ = (char)(m & 0xFF);
; 2035 :     }
; 2036 :   }
; 2037 : #endif
; 2038 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getbase64 ENDP
_TEXT	ENDS
PUBLIC	_soap_element_end_in
PUBLIC	_soap_dime_forward
PUBLIC	_soap_element_begin_in
PUBLIC	??_C@_0M@BMFKMGMG@xop?3Include?$AA@		; `string'
PUBLIC	_soap_peek_element
PUBLIC	_soap_xop_forward
EXTRN	@_RTC_Check_4_to_2@4:PROC
;	COMDAT ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
CONST	SEGMENT
??_C@_0M@BMFKMGMG@xop?3Include?$AA@ DB 'xop:Include', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_xop_forward
_TEXT	SEGMENT
_body$ = -8						; size = 4
_soap$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_id$ = 20						; size = 4
_type$ = 24						; size = 4
_options$ = 28						; size = 4
_soap_xop_forward PROC					; COMDAT

; 2048 : { /* Check MTOM xop:Include element (within hex/base64Binary) */

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2049 :   /* TODO: this code to be obsoleted with new import/xop.h conventions */
; 2050 :   int body = soap->body; /* should save type too? */

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	mov	DWORD PTR _body$[ebp], ecx

; 2051 :   if (!soap_peek_element(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_peek_element
	add	esp, 4
	test	eax, eax
	jne	$LN4@soap_xop_f

; 2052 :   { if (!soap_element_begin_in(soap, "xop:Include", 0, NULL) && *soap->href)

	push	0
	push	0
	push	OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@soap_xop_f
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN3@soap_xop_f

; 2053 :     { if (soap_dime_forward(soap, ptr, size, id, type, options))

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_dime_forward
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN3@soap_xop_f

; 2054 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@soap_xop_f
$LN3@soap_xop_f:

; 2055 :     }
; 2056 :     if (soap->body && soap_element_end_in(soap, NULL))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN4@soap_xop_f
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_xop_f

; 2057 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@soap_xop_f
$LN4@soap_xop_f:

; 2058 :   }
; 2059 :   soap->body = body;

	mov	ecx, DWORD PTR _body$[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12442], ax

; 2060 :   return SOAP_OK;

	xor	eax, eax
$LN5@soap_xop_f:

; 2061 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_xop_forward ENDP
_TEXT	ENDS
PUBLIC	_soap_track_malloc
PUBLIC	??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_dime_forward@@9@4JA	; `soap_dime_forward'::`2'::__LINE__Var
PUBLIC	_soap_strdup
;	COMDAT ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
CONST	SEGMENT
??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@ DB 'c:\users\c'
	DB	'rius\documents\visual studio 2008\projects\dramsimiihg\src\re'
	DB	'porting\stdsoap2.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_dime_forward@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_dime_forward@@9@4JA DD 0818H	; `soap_dime_forward'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_dime_forward
_TEXT	SEGMENT
_xp$ = -8						; size = 4
_soap$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_id$ = 20						; size = 4
_type$ = 24						; size = 4
_options$ = 28						; size = 4
_soap_dime_forward PROC					; COMDAT

; 2072 : { struct soap_xlist *xp;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2073 :   *ptr = NULL;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], 0

; 2074 :   *size = 0;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], 0

; 2075 :   *id = NULL;

	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax], 0

; 2076 :   *type = NULL;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax], 0

; 2077 :   *options = NULL;

	mov	eax, DWORD PTR _options$[ebp]
	mov	DWORD PTR [eax], 0

; 2078 :   if (!*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	jne	SHORT $LN2@soap_dime_

; 2079 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN3@soap_dime_
$LN2@soap_dime_:

; 2080 :   *id = soap_strdup(soap, soap->href);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 82100				; 000140b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [edx], eax

; 2081 :   xp = (struct soap_xlist*)SOAP_MALLOC(soap, sizeof(struct soap_xlist));

	push	24					; 00000018H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_dime_forward@@9@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _xp$[ebp], eax

; 2082 :   if (!xp)

	cmp	DWORD PTR _xp$[ebp], 0
	jne	SHORT $LN1@soap_dime_

; 2083 :     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	SHORT $LN3@soap_dime_
$LN1@soap_dime_:

; 2084 :   xp->next = soap->xlist;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90544]
	mov	DWORD PTR [eax], edx

; 2085 :   xp->ptr = ptr;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2086 :   xp->size = size;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2087 :   xp->id = *id;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx

; 2088 :   xp->type = type;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 2089 :   xp->options = options;

	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _options$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2090 :   soap->xlist = xp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	mov	DWORD PTR [eax+90544], ecx

; 2091 :   return SOAP_OK;

	xor	eax, eax
$LN3@soap_dime_:

; 2092 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_dime_forward ENDP
_TEXT	ENDS
EXTRN	_strcpy:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_strdup
_TEXT	SEGMENT
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_strdup PROC					; COMDAT

; 2102 : { char *t = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _t$[ebp], 0

; 2103 :   if (s && (t = (char*)soap_malloc(soap, strlen(s) + 1)))

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_strdu
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN1@soap_strdu

; 2104 :     strcpy(t, s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@soap_strdu:

; 2105 :   return t;

	mov	eax, DWORD PTR _t$[ebp]

; 2106 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_strdup ENDP
_TEXT	ENDS
PUBLIC	_soap_wstrdup
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_wstrdup
_TEXT	SEGMENT
_n$83259 = -20						; size = 4
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_wstrdup PROC					; COMDAT

; 2115 : { wchar_t *t = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _t$[ebp], 0

; 2116 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_wstrd

; 2117 :   { size_t n = 0;

	mov	DWORD PTR _n$83259[ebp], 0
$LN3@soap_wstrd:

; 2118 :     while (s[n])

	mov	eax, DWORD PTR _n$83259[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN2@soap_wstrd

; 2119 :       n++;

	mov	eax, DWORD PTR _n$83259[ebp]
	add	eax, 1
	mov	DWORD PTR _n$83259[ebp], eax
	jmp	SHORT $LN3@soap_wstrd
$LN2@soap_wstrd:

; 2120 :     if ((t = (wchar_t*)soap_malloc(soap, sizeof(wchar_t)*(n+1))))

	mov	eax, DWORD PTR _n$83259[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN4@soap_wstrd

; 2121 :       memcpy(t, s, sizeof(wchar_t)*(n+1));

	mov	eax, DWORD PTR _n$83259[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@soap_wstrd:

; 2122 :   }
; 2123 :   return t;

	mov	eax, DWORD PTR _t$[ebp]

; 2124 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_wstrdup ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_new_block@@9@4JA		; `soap_new_block'::`2'::__LINE__Var
PUBLIC	??_C@_0BO@CHHOBIIC@New?5block?5sequence?5?$CIprev?$DN?$CFp?$CJ?6?$AA@ ; `string'
PUBLIC	_soap_new_block
;	COMDAT ?__LINE__Var@?1??soap_new_block@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_new_block@@9@4JA DD 0855H		; `soap_new_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@CHHOBIIC@New?5block?5sequence?5?$CIprev?$DN?$CFp?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BO@CHHOBIIC@New?5block?5sequence?5?$CIprev?$DN?$CFp?$CJ?6?$AA@ DB 'N'
	DB	'ew block sequence (prev=%p)', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_new_block
_TEXT	SEGMENT
_fdebug$83275 = -20					; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_new_block PROC					; COMDAT

; 2133 : { struct soap_blist *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2134 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New block sequence (prev=%p)\n", soap->blist));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_new_b
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_new_b
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_new_b:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_new_b
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83275[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	push	OFFSET ??_C@_0BO@CHHOBIIC@New?5block?5sequence?5?$CIprev?$DN?$CFp?$CJ?6?$AA@
	mov	edx, DWORD PTR _fdebug$83275[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83275[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_new_b:

; 2135 :   if (!(p = (struct soap_blist*)SOAP_MALLOC(soap, sizeof(struct soap_blist))))

	push	12					; 0000000cH
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_new_block@@9@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN1@soap_new_b

; 2136 :     return SOAP_EOM;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN5@soap_new_b
$LN1@soap_new_b:

; 2137 :   p->next = soap->blist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax], edx

; 2138 :   p->ptr = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], 0

; 2139 :   p->size = 0;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2140 :   soap->blist = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+92], ecx

; 2141 :   return SOAP_OK;

	xor	eax, eax
$LN5@soap_new_b:

; 2142 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_new_block ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_push_block@@9@4JA		; `soap_push_block'::`2'::__LINE__Var
PUBLIC	??_C@_0CJ@FPDHAHMG@Push?5block?5of?5?$CFu?5bytes?5?$CI?$CFu?5bytes@ ; `string'
;	COMDAT ?__LINE__Var@?1??soap_push_block@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_push_block@@9@4JA DD 0867H	; `soap_push_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CJ@FPDHAHMG@Push?5block?5of?5?$CFu?5bytes?5?$CI?$CFu?5bytes@
CONST	SEGMENT
??_C@_0CJ@FPDHAHMG@Push?5block?5of?5?$CFu?5bytes?5?$CI?$CFu?5bytes@ DB 'P'
	DB	'ush block of %u bytes (%u bytes total)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_push_block
_TEXT	SEGMENT
_fdebug$83290 = -20					; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_push_block PROC					; COMDAT

; 2151 : { char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2152 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push block of %u bytes (%u bytes total)\n", (unsigned int)n, (unsigned int)soap->blist->size + (unsigned int)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_push_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_push_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_push_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_push_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83290[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _n$[ebp]
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@FPDHAHMG@Push?5block?5of?5?$CFu?5bytes?5?$CI?$CFu?5bytes@
	mov	ecx, DWORD PTR _fdebug$83290[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83290[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_push_:

; 2153 :   if (!(p = (char*)SOAP_MALLOC(soap, n + sizeof(char*) + sizeof(size_t))))

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_push_block@@9@4JA
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN1@soap_push_

; 2154 :   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 2155 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN5@soap_push_
$LN1@soap_push_:

; 2156 :   }
; 2157 :   *(char**)p = soap->blist->ptr;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 2158 :   *(size_t*)(p + sizeof(char*)) = n;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2159 :   soap->blist->ptr = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2160 :   soap->blist->size += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [ecx+8], edx

; 2161 :   return p + sizeof(char*) + sizeof(size_t);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
$LN5@soap_push_:

; 2162 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_push_block ENDP
_TEXT	ENDS
PUBLIC	_soap_track_free
PUBLIC	?__LINE__Var@?1??soap_pop_block@@9@4JA		; `soap_pop_block'::`2'::__LINE__Var
PUBLIC	??_C@_0L@CKHMILJO@Pop?5block?6?$AA@		; `string'
PUBLIC	_soap_pop_block
;	COMDAT ?__LINE__Var@?1??soap_pop_block@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_pop_block@@9@4JA DD 087bH		; `soap_pop_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@CKHMILJO@Pop?5block?6?$AA@
CONST	SEGMENT
??_C@_0L@CKHMILJO@Pop?5block?6?$AA@ DB 'Pop block', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_pop_block
_TEXT	SEGMENT
_fdebug$83314 = -20					; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_pop_block PROC					; COMDAT

; 2171 : { char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2172 :   if (!soap->blist->ptr)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN4@soap_pop_b@2

; 2173 :     return;

	jmp	$LN5@soap_pop_b@2
$LN4@soap_pop_b@2:

; 2174 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop block\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_pop_b@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_pop_b@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_pop_b@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_pop_b@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83314[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0L@CKHMILJO@Pop?5block?6?$AA@
	mov	eax, DWORD PTR _fdebug$83314[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83314[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_pop_b@2:

; 2175 :   p = soap->blist->ptr;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx

; 2176 :   soap->blist->size -= *(size_t*)(p + sizeof(char*));

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [edx+8], eax

; 2177 :   soap->blist->ptr = *(char**)p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 2178 :   SOAP_FREE(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_pop_block@@9@4JA
	add	ecx, 7
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN5@soap_pop_b@2:

; 2179 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_pop_block ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@DOJCLNM@Resolution?5done?6?$AA@	; `string'
PUBLIC	??_C@_0HE@LGGIOOAK@Resolution?5error?3?5forwarded?5data@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_resolve@@9@4JA		; `soap_resolve'::`2'::__LINE__Var
PUBLIC	_soap_fcopy
PUBLIC	??_C@_0DD@NKJBOFEE@Descending?5one?5level?0?5new?5locati@ ; `string'
PUBLIC	??_C@_0EC@KDOGKLNK@Resolving?5forwarded?5data?5type?$DN?$CFd@ ; `string'
PUBLIC	??_C@_0BO@BDFNFBLI@?4?4?4?5copy?5?$CFp?5?9?$DO?5?$CFp?5?$CI?$CFu?5bytes?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@PJODKEFC@Traversing?5copy?5chain?5to?5resolve@ ; `string'
PUBLIC	??_C@_0BC@EPLEAELE@Resolution?5phase?6?$AA@	; `string'
PUBLIC	??_C@_0BK@ENJKNJEG@Missing?5data?5for?5id?$DN?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@GNFMOHKP@?4?4?4?5link?5?$CFp?5?9?$DO?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@IOGIIBAJ@Traversing?5link?5chain?5to?5resolve@ ; `string'
PUBLIC	??_C@_0BK@BJFFABPO@Resolving?5forwarded?5data?6?$AA@ ; `string'
PUBLIC	_soap_resolve
;	COMDAT ??_C@_0BB@DOJCLNM@Resolution?5done?6?$AA@
CONST	SEGMENT
??_C@_0BB@DOJCLNM@Resolution?5done?6?$AA@ DB 'Resolution done', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@LGGIOOAK@Resolution?5error?3?5forwarded?5data@
CONST	SEGMENT
??_C@_0HE@LGGIOOAK@Resolution?5error?3?5forwarded?5data@ DB 'Resolution e'
	DB	'rror: forwarded data for id=''%s'' could not be propagated, p'
	DB	'lease report this problem to the developers', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_resolve@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_resolve@@9@4JA DD 08dcH		; `soap_resolve'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@NKJBOFEE@Descending?5one?5level?0?5new?5locati@
CONST	SEGMENT
??_C@_0DD@NKJBOFEE@Descending?5one?5level?0?5new?5locati@ DB 'Descending '
	DB	'one level, new location=%p holds=%p...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KDOGKLNK@Resolving?5forwarded?5data?5type?$DN?$CFd@
CONST	SEGMENT
??_C@_0EC@KDOGKLNK@Resolving?5forwarded?5data?5type?$DN?$CFd@ DB 'Resolvi'
	DB	'ng forwarded data type=%d location=%p level=%u,%u id=''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BDFNFBLI@?4?4?4?5copy?5?$CFp?5?9?$DO?5?$CFp?5?$CI?$CFu?5bytes?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BO@BDFNFBLI@?4?4?4?5copy?5?$CFp?5?9?$DO?5?$CFp?5?$CI?$CFu?5bytes?$CJ?6?$AA@ DB '.'
	DB	'.. copy %p -> %p (%u bytes)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PJODKEFC@Traversing?5copy?5chain?5to?5resolve@
CONST	SEGMENT
??_C@_0CK@PJODKEFC@Traversing?5copy?5chain?5to?5resolve@ DB 'Traversing c'
	DB	'opy chain to resolve id=''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPLEAELE@Resolution?5phase?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPLEAELE@Resolution?5phase?6?$AA@ DB 'Resolution phase', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ENJKNJEG@Missing?5data?5for?5id?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BK@ENJKNJEG@Missing?5data?5for?5id?$DN?8?$CFs?8?6?$AA@ DB 'Missing'
	DB	' data for id=''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNFMOHKP@?4?4?4?5link?5?$CFp?5?9?$DO?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BD@GNFMOHKP@?4?4?4?5link?5?$CFp?5?9?$DO?5?$CFp?6?$AA@ DB '... link'
	DB	' %p -> %p', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IOGIIBAJ@Traversing?5link?5chain?5to?5resolve@
CONST	SEGMENT
??_C@_0CK@IOGIIBAJ@Traversing?5link?5chain?5to?5resolve@ DB 'Traversing l'
	DB	'ink chain to resolve id=''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BJFFABPO@Resolving?5forwarded?5data?6?$AA@
CONST	SEGMENT
??_C@_0BK@BJFFABPO@Resolving?5forwarded?5data?6?$AA@ DB 'Resolving forwar'
	DB	'ded data', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_resolve
_TEXT	SEGMENT
_fdebug$83574 = -272					; size = 4
_fdebug$83568 = -260					; size = 4
_fdebug$83550 = -248					; size = 4
_q$83542 = -236						; size = 4
_fdebug$83537 = -224					; size = 4
_p$83532 = -212						; size = 4
_k$83531 = -200						; size = 4
_fdebug$83524 = -188					; size = 4
_fdebug$83514 = -176					; size = 4
_q$83508 = -164						; size = 4
_p$83507 = -152						; size = 4
_fdebug$83495 = -140					; size = 4
_fdebug$83486 = -128					; size = 4
_fdebug$83477 = -116					; size = 4
_fdebug$83467 = -104					; size = 4
_r$83461 = -92						; size = 4
_q$83460 = -80						; size = 4
_p$83459 = -68						; size = 4
_fdebug$83450 = -56					; size = 4
_flag$ = -44						; size = 2
_fp$ = -32						; size = 4
_ip$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_resolve PROC					; COMDAT

; 2268 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2269 :   register struct soap_ilist *ip = NULL;

	mov	DWORD PTR _ip$[ebp], 0

; 2270 :   register struct soap_flist *fp = NULL;

	mov	DWORD PTR _fp$[ebp], 0

; 2271 :   short flag;
; 2272 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN76@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN75@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN75@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN76@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83450[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BK@BJFFABPO@Resolving?5forwarded?5data?6?$AA@
	mov	eax, DWORD PTR _fdebug$83450[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83450[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN76@soap_resol:

; 2273 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN73@soap_resol
$LN72@soap_resol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN73@soap_resol:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN52@soap_resol

; 2274 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN70@soap_resol
$LN69@soap_resol:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN70@soap_resol:
	cmp	DWORD PTR _ip$[ebp], 0
	je	$LN68@soap_resol

; 2275 :     { if (ip->ptr)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN67@soap_resol

; 2276 :       { register void *p, **q, *r;
; 2277 :         q = (void**)ip->link;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _q$83460[ebp], ecx

; 2278 :         ip->link = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+12], 0

; 2279 :         r = ip->ptr;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _r$83461[ebp], ecx

; 2280 :         DBGLOG(TEST, if (q) SOAP_MESSAGE(fdebug, "Traversing link chain to resolve id='%s'\n", ip->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN62@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN65@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN65@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN62@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83467[ebp], ecx
	cmp	DWORD PTR _q$83460[ebp], 0
	je	SHORT $LN63@soap_resol
	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0CK@IOGIIBAJ@Traversing?5link?5chain?5to?5resolve@
	mov	ecx, DWORD PTR _fdebug$83467[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN63@soap_resol:
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83467[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN62@soap_resol:

; 2281 :         while (q)

	cmp	DWORD PTR _q$83460[ebp], 0
	je	$LN61@soap_resol

; 2282 :         { p = *q;

	mov	eax, DWORD PTR _q$83460[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$83459[ebp], ecx

; 2283 :           *q = r;

	mov	eax, DWORD PTR _q$83460[ebp]
	mov	ecx, DWORD PTR _r$83461[ebp]
	mov	DWORD PTR [eax], ecx

; 2284 :           DBGLOG(TEST,SOAP_MESSAGE(fdebug, "... link %p -> %p\n", q, r));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN60@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN59@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN59@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN60@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83477[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _r$83461[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$83460[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@GNFMOHKP@?4?4?4?5link?5?$CFp?5?9?$DO?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83477[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83477[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN60@soap_resol:

; 2285 :           q = (void**)p;

	mov	eax, DWORD PTR _p$83459[ebp]
	mov	DWORD PTR _q$83460[ebp], eax

; 2286 :         }

	jmp	$LN62@soap_resol
$LN61@soap_resol:

; 2287 :       }
; 2288 :       else if (*ip->id == '#')

	jmp	$LN57@soap_resol
$LN67@soap_resol:
	mov	eax, DWORD PTR _ip$[ebp]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 35					; 00000023H
	jne	$LN57@soap_resol

; 2289 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Missing data for id='%s'\n", ip->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN55@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN54@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN54@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN55@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83486[ebp], ecx
	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BK@ENJKNJEG@Missing?5data?5for?5id?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$83486[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83486[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@soap_resol:

; 2290 :         strcpy(soap->id, ip->id + 1);

	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 33					; 00000021H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 2291 :         return soap->error = SOAP_MISSING_ID;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 25		; 00000019H
	mov	eax, 25					; 00000019H
	jmp	$LN77@soap_resol
$LN57@soap_resol:

; 2292 :       }
; 2293 :     }

	jmp	$LN69@soap_resol
$LN68@soap_resol:

; 2294 :   }

	jmp	$LN72@soap_resol
$LN52@soap_resol:

; 2295 :   do
; 2296 :   { flag = 0;

	xor	eax, eax
	mov	WORD PTR _flag$[ebp], ax

; 2297 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution phase\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN49@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN48@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN48@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN49@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83495[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BC@EPLEAELE@Resolution?5phase?6?$AA@
	mov	eax, DWORD PTR _fdebug$83495[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83495[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN49@soap_resol:

; 2298 :     for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN46@soap_resol
$LN45@soap_resol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN46@soap_resol:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN51@soap_resol

; 2299 :     { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN43@soap_resol
$LN42@soap_resol:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN43@soap_resol:
	cmp	DWORD PTR _ip$[ebp], 0
	je	$LN41@soap_resol

; 2300 :       { if (ip->ptr && !soap_has_copies(soap, (const char*)ip->ptr, (const char*)ip->ptr + ip->size))

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN40@soap_resol
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _ip$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_has_copies
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN40@soap_resol

; 2301 :         { if (ip->copy)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN39@soap_resol

; 2302 :           { register void *p, **q = (void**)ip->copy;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _q$83508[ebp], ecx

; 2303 :             DBGLOG(TEST, if (q) SOAP_MESSAGE(fdebug, "Traversing copy chain to resolve id='%s'\n", ip->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN38@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN37@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN37@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN38@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83514[ebp], ecx
	cmp	DWORD PTR _q$83508[ebp], 0
	je	SHORT $LN35@soap_resol
	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0CK@PJODKEFC@Traversing?5copy?5chain?5to?5resolve@
	mov	ecx, DWORD PTR _fdebug$83514[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@soap_resol:
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83514[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN38@soap_resol:

; 2304 :             ip->copy = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN34@soap_resol:

; 2305 :             do
; 2306 :             { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "... copy %p -> %p (%u bytes)\n", ip->ptr, q, (unsigned int)ip->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN31@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN30@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN30@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN31@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83524[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _q$83508[ebp]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0BO@BDFNFBLI@?4?4?4?5copy?5?$CFp?5?9?$DO?5?$CFp?5?$CI?$CFu?5bytes?$CJ?6?$AA@
	mov	edx, DWORD PTR _fdebug$83524[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83524[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN31@soap_resol:

; 2307 :               p = *q;

	mov	eax, DWORD PTR _q$83508[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$83507[ebp], ecx

; 2308 :               memcpy(q, ip->ptr, ip->size);

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _q$83508[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2309 :               q = (void**)p;

	mov	eax, DWORD PTR _p$83507[ebp]
	mov	DWORD PTR _q$83508[ebp], eax

; 2310 :             } while (q);

	cmp	DWORD PTR _q$83508[ebp], 0
	jne	$LN34@soap_resol

; 2311 :             flag = 1;

	mov	eax, 1
	mov	WORD PTR _flag$[ebp], ax
$LN39@soap_resol:

; 2312 :           }
; 2313 :           for (fp = ip->flist; fp; fp = ip->flist)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
	jmp	SHORT $LN28@soap_resol
$LN27@soap_resol:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
$LN28@soap_resol:
	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN40@soap_resol

; 2314 :           { register unsigned int k = fp->level;

	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _k$83531[ebp], ecx

; 2315 :             register void *p = ip->ptr;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _p$83532[ebp], ecx

; 2316 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data type=%d location=%p level=%u,%u id='%s'\n", ip->type, p, ip->level, fp->level, ip->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN22@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN24@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN24@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN22@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83537[ebp], ecx
	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _p$83532[ebp]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0EC@KDOGKLNK@Resolving?5forwarded?5data?5type?$DN?$CFd@
	mov	edx, DWORD PTR _fdebug$83537[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83537[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@soap_resol:

; 2317 :             while (ip->level < k)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$83531[ebp]
	jae	$LN21@soap_resol

; 2318 :             { register void **q = (void**)soap_malloc(soap, sizeof(void*));

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _q$83542[ebp], eax

; 2319 :               if (!q)

	cmp	DWORD PTR _q$83542[ebp], 0
	jne	SHORT $LN20@soap_resol

; 2320 :                 return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN77@soap_resol
$LN20@soap_resol:

; 2321 :               *q = p;

	mov	eax, DWORD PTR _q$83542[ebp]
	mov	ecx, DWORD PTR _p$83532[ebp]
	mov	DWORD PTR [eax], ecx

; 2322 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level, new location=%p holds=%p...\n", q, *q));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN18@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN18@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83550[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _q$83542[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _q$83542[ebp]
	push	edx
	push	OFFSET ??_C@_0DD@NKJBOFEE@Descending?5one?5level?0?5new?5locati@
	mov	eax, DWORD PTR _fdebug$83550[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83550[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_resol:

; 2323 :               p = (void*)q;

	mov	eax, DWORD PTR _q$83542[ebp]
	mov	DWORD PTR _p$83532[ebp], eax

; 2324 :               k--;

	mov	eax, DWORD PTR _k$83531[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$83531[ebp], eax

; 2325 :             }

	jmp	$LN22@soap_resol
$LN21@soap_resol:

; 2326 :             if (fp->fcopy)

	mov	eax, DWORD PTR _fp$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN16@soap_resol

; 2327 :               fp->fcopy(soap, ip->type, fp->type, fp->ptr, fp->len, p, ip->size);

	mov	esi, esp
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _p$83532[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	ecx
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2328 :             else

	jmp	SHORT $LN15@soap_resol
$LN16@soap_resol:

; 2329 :               soap_fcopy(soap, ip->type, fp->type, fp->ptr, fp->len, p, ip->size);

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _p$83532[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_fcopy
	add	esp, 28					; 0000001cH
$LN15@soap_resol:

; 2330 :             ip->flist = fp->next;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], edx

; 2331 :             SOAP_FREE(soap, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_resolve@@9@4JA
	add	ecx, 63					; 0000003fH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 2332 :             flag = 1;

	mov	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 2333 :           }

	jmp	$LN27@soap_resol
$LN40@soap_resol:

; 2334 :         }
; 2335 :       }

	jmp	$LN42@soap_resol
$LN41@soap_resol:

; 2336 :     }

	jmp	$LN45@soap_resol
$LN51@soap_resol:

; 2337 :   } while (flag);

	movsx	eax, WORD PTR _flag$[ebp]
	test	eax, eax
	jne	$LN52@soap_resol

; 2338 : #ifdef SOAP_DEBUG
; 2339 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@soap_resol
$LN13@soap_resol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@soap_resol:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN12@soap_resol

; 2340 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN11@soap_resol
$LN10@soap_resol:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN11@soap_resol:
	cmp	DWORD PTR _ip$[ebp], 0
	je	$LN9@soap_resol

; 2341 :     { if (ip->copy || ip->flist)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN7@soap_resol
	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN8@soap_resol
$LN7@soap_resol:

; 2342 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution error: forwarded data for id='%s' could not be propagated, please report this problem to the developers\n", ip->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83568[ebp], ecx
	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 32					; 00000020H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0HE@LGGIOOAK@Resolution?5error?3?5forwarded?5data@
	mov	ecx, DWORD PTR _fdebug$83568[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83568[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_resol:

; 2343 :       }
; 2344 :     }

	jmp	$LN10@soap_resol
$LN9@soap_resol:

; 2345 :   }

	jmp	$LN13@soap_resol
$LN12@soap_resol:

; 2346 : #endif
; 2347 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution done\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_resol
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_resol:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_resol
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83574[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BB@DOJCLNM@Resolution?5done?6?$AA@
	mov	eax, DWORD PTR _fdebug$83574[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83574[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_resol:

; 2348 :   return SOAP_OK;

	xor	eax, eax
$LN77@soap_resol:

; 2349 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_resolve ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_has_copies
_TEXT	SEGMENT
_p$ = -44						; size = 4
_fp$ = -32						; size = 4
_ip$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_soap_has_copies PROC					; COMDAT

; 2242 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2243 :   register struct soap_ilist *ip = NULL;

	mov	DWORD PTR _ip$[ebp], 0

; 2244 :   register struct soap_flist *fp = NULL;

	mov	DWORD PTR _fp$[ebp], 0

; 2245 :   register const char *p;
; 2246 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@soap_has_c
$LN13@soap_has_c:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@soap_has_c:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN12@soap_has_c

; 2247 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN11@soap_has_c
$LN10@soap_has_c:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN11@soap_has_c:
	cmp	DWORD PTR _ip$[ebp], 0
	je	SHORT $LN9@soap_has_c

; 2248 :     { for (p = (const char*)ip->copy; p; p = *(const char**)p)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN8@soap_has_c
$LN7@soap_has_c:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN8@soap_has_c:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@soap_has_c

; 2249 :         if (p >= start && p < end)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jb	SHORT $LN5@soap_has_c
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	SHORT $LN5@soap_has_c

; 2250 :           return SOAP_ERR;

	or	eax, -1
	jmp	SHORT $LN15@soap_has_c
$LN5@soap_has_c:

; 2251 :       for (fp = ip->flist; fp; fp = fp->next)

	jmp	SHORT $LN7@soap_has_c
$LN6@soap_has_c:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
	jmp	SHORT $LN4@soap_has_c
$LN3@soap_has_c:
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fp$[ebp], ecx
$LN4@soap_has_c:
	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN2@soap_has_c

; 2252 :         if ((const char*)fp->ptr >= start && (const char*)fp->ptr < end)

	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _start$[ebp]
	jb	SHORT $LN1@soap_has_c
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	SHORT $LN1@soap_has_c

; 2253 :           return SOAP_ERR;

	or	eax, -1
	jmp	SHORT $LN15@soap_has_c
$LN1@soap_has_c:

; 2254 :     }

	jmp	SHORT $LN3@soap_has_c
$LN2@soap_has_c:
	jmp	SHORT $LN10@soap_has_c
$LN9@soap_has_c:

; 2255 :   }

	jmp	$LN13@soap_has_c
$LN12@soap_has_c:

; 2256 :   return SOAP_OK;

	xor	eax, eax
$LN15@soap_has_c:

; 2257 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_has_copies ENDP
_TEXT	ENDS
PUBLIC	_soap_size_block
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_size_block
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_size_block PROC					; COMDAT

; 2359 : { if (soap->blist->ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN1@soap_size_

; 2360 :   { soap->blist->size -= *(size_t*)(soap->blist->ptr + sizeof(char*)) - n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR [eax+8], ecx

; 2361 :     *(size_t*)(soap->blist->ptr + sizeof(char*)) = n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN1@soap_size_:

; 2362 :   }
; 2363 :   return soap->blist->size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	eax, DWORD PTR [ecx+8]

; 2364 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_size_block ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FIJCGCGD@First?5block?6?$AA@		; `string'
PUBLIC	_soap_first_block
;	COMDAT ??_C@_0N@FIJCGCGD@First?5block?6?$AA@
CONST	SEGMENT
??_C@_0N@FIJCGCGD@First?5block?6?$AA@ DB 'First block', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_first_block
_TEXT	SEGMENT
_fdebug$83596 = -44					; size = 4
_r$ = -32						; size = 4
_q$ = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_first_block PROC					; COMDAT

; 2373 : { char *p, *q, *r;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2374 :   p = soap->blist->ptr;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx

; 2375 :   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN7@soap_first

; 2376 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_first
$LN7@soap_first:

; 2377 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "First block\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_first
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_first
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_first:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_first
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83596[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0N@FIJCGCGD@First?5block?6?$AA@
	mov	eax, DWORD PTR _fdebug$83596[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83596[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_first:

; 2378 :   r = NULL;

	mov	DWORD PTR _r$[ebp], 0
$LN3@soap_first:

; 2379 :   do
; 2380 :   { q = *(char**)p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$[ebp], ecx

; 2381 :     *(char**)p = r;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax], ecx

; 2382 :     r = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _r$[ebp], eax

; 2383 :     p = q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 2384 :   } while (p);

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN3@soap_first

; 2385 :   soap->blist->ptr = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2386 :   return r + sizeof(char*) + sizeof(size_t);

	mov	eax, DWORD PTR _r$[ebp]
	add	eax, 8
$LN8@soap_first:

; 2387 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_first_block ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_next_block@@9@4JA		; `soap_next_block'::`2'::__LINE__Var
PUBLIC	??_C@_0M@CCNPLEDA@Next?5block?6?$AA@		; `string'
PUBLIC	_soap_next_block
;	COMDAT ?__LINE__Var@?1??soap_next_block@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_next_block@@9@4JA DD 095cH	; `soap_next_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@CCNPLEDA@Next?5block?6?$AA@
CONST	SEGMENT
??_C@_0M@CCNPLEDA@Next?5block?6?$AA@ DB 'Next block', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_next_block
_TEXT	SEGMENT
_fdebug$83614 = -20					; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_next_block PROC					; COMDAT

; 2396 : { char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2397 :   p = soap->blist->ptr;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx

; 2398 :   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN5@soap_next_

; 2399 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Next block\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_next_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_next_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_next_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_next_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83614[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0M@CCNPLEDA@Next?5block?6?$AA@
	mov	eax, DWORD PTR _fdebug$83614[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83614[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_next_:

; 2400 :     soap->blist->ptr = *(char**)p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 2401 :     SOAP_FREE(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_next_block@@9@4JA
	add	ecx, 5
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 2402 :     if (soap->blist->ptr)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@soap_next_

; 2403 :       return soap->blist->ptr + sizeof(char*) + sizeof(size_t);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8
	jmp	SHORT $LN6@soap_next_
$LN5@soap_next_:

; 2404 :   }
; 2405 :   return NULL;

	xor	eax, eax
$LN6@soap_next_:

; 2406 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_next_block ENDP
_TEXT	ENDS
PUBLIC	_soap_block_size
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_block_size
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_block_size PROC					; COMDAT

; 2415 : { return *(size_t*)(soap->blist->ptr + sizeof(char*));

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]

; 2416 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_block_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FDGKFFGN@Restore?5previous?5block?5sequence?6@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_end_block@@9@4JA		; `soap_end_block'::`2'::__LINE__Var
PUBLIC	??_C@_0DC@MEJFONII@End?5of?5block?5sequence?0?5free?5all?5@ ; `string'
PUBLIC	_soap_end_block
;	COMDAT ??_C@_0CB@FDGKFFGN@Restore?5previous?5block?5sequence?6@
CONST	SEGMENT
??_C@_0CB@FDGKFFGN@Restore?5previous?5block?5sequence?6@ DB 'Restore prev'
	DB	'ious block sequence', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_end_block@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_end_block@@9@4JA DD 0979H		; `soap_end_block'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@MEJFONII@End?5of?5block?5sequence?0?5free?5all?5@
CONST	SEGMENT
??_C@_0DC@MEJFONII@End?5of?5block?5sequence?0?5free?5all?5@ DB 'End of bl'
	DB	'ock sequence, free all remaining blocks', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_end_block
_TEXT	SEGMENT
_fdebug$83648 = -56					; size = 4
_fdebug$83637 = -44					; size = 4
_q$ = -32						; size = 4
_p$ = -20						; size = 4
_bp$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_end_block PROC					; COMDAT

; 2425 : { struct soap_blist *bp;

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2426 :   char *p, *q;
; 2427 :   bp = soap->blist;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR _bp$[ebp], ecx

; 2428 :   if (bp)

	cmp	DWORD PTR _bp$[ebp], 0
	je	$LN11@soap_end_b

; 2429 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of block sequence, free all remaining blocks\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_end_b
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_end_b
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_end_b:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_end_b
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83637[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0DC@MEJFONII@End?5of?5block?5sequence?0?5free?5all?5@
	mov	eax, DWORD PTR _fdebug$83637[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83637[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_end_b:

; 2430 :     for (p = bp->ptr; p; p = q)

	mov	eax, DWORD PTR _bp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN7@soap_end_b
$LN6@soap_end_b:
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN7@soap_end_b:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN5@soap_end_b

; 2431 :     { q = *(char**)p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$[ebp], ecx

; 2432 :       SOAP_FREE(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_end_block@@9@4JA
	add	ecx, 7
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 2433 :     }

	jmp	SHORT $LN6@soap_end_b
$LN5@soap_end_b:

; 2434 :     soap->blist = bp->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+92], edx

; 2435 :     SOAP_FREE(soap, bp);

	mov	eax, DWORD PTR _bp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_end_block@@9@4JA
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN11@soap_end_b:

; 2436 :   }
; 2437 :   DBGLOG(TEST, if (soap->blist) SOAP_MESSAGE(fdebug, "Restore previous block sequence\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN12@soap_end_b
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_end_b
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_end_b:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_end_b
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83648[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN1@soap_end_b
	mov	esi, esp
	push	OFFSET ??_C@_0CB@FDGKFFGN@Restore?5previous?5block?5sequence?6@
	mov	eax, DWORD PTR _fdebug$83648[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_end_b:
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83648[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_end_b:

; 2438 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_end_block ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@BMDACPAM@Copy?5?$CFu?5bytes?5from?5?$CFp?5to?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0EB@LACMEIOI@Save?5all?5blocks?5in?5contiguous?5me@ ; `string'
PUBLIC	_soap_save_block
;	COMDAT ??_C@_0BN@BMDACPAM@Copy?5?$CFu?5bytes?5from?5?$CFp?5to?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BN@BMDACPAM@Copy?5?$CFu?5bytes?5from?5?$CFp?5to?5?$CFp?6?$AA@ DB 'C'
	DB	'opy %u bytes from %p to %p', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LACMEIOI@Save?5all?5blocks?5in?5contiguous?5me@
CONST	SEGMENT
??_C@_0EB@LACMEIOI@Save?5all?5blocks?5in?5contiguous?5me@ DB 'Save all bl'
	DB	'ocks in contiguous memory space of %u bytes (%p->%p)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_save_block
_TEXT	SEGMENT
_fdebug$83678 = -56					; size = 4
_fdebug$83663 = -44					; size = 4
_s$ = -32						; size = 4
_q$ = -20						; size = 4
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_flag$ = 16						; size = 4
_soap_save_block PROC					; COMDAT

; 2447 : { register size_t n;

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2448 :   register char *q, *s;
; 2449 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Save all blocks in contiguous memory space of %u bytes (%p->%p)\n", (unsigned int)soap->blist->size, soap->blist->ptr, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN14@soap_save_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN13@soap_save_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN13@soap_save_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN14@soap_save_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83663[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0EB@LACMEIOI@Save?5all?5blocks?5in?5contiguous?5me@
	mov	ecx, DWORD PTR _fdebug$83663[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83663[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@soap_save_:

; 2450 :   if (soap->blist->size)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN11@soap_save_

; 2451 :   { if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN10@soap_save_

; 2452 :       p = (char*)soap_malloc(soap, soap->blist->size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN10@soap_save_:

; 2453 :     if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN9@soap_save_

; 2454 :     { for (s = p, q = soap_first_block(soap); q; q = soap_next_block(soap))

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_first_block
	add	esp, 4
	mov	DWORD PTR _q$[ebp], eax
	jmp	SHORT $LN8@soap_save_
$LN7@soap_save_:
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_next_block
	add	esp, 4
	mov	DWORD PTR _q$[ebp], eax
$LN8@soap_save_:
	cmp	DWORD PTR _q$[ebp], 0
	je	$LN6@soap_save_

; 2455 :       { n = soap_block_size(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_block_size
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 2456 : #ifndef WITH_NOIDREF
; 2457 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN5@soap_save_

; 2458 :           soap_update_ptrs(soap, q, q + n, s, q);

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	add	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_update_ptrs
	add	esp, 20					; 00000014H
$LN5@soap_save_:

; 2459 : #endif
; 2460 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy %u bytes from %p to %p\n", (unsigned int)n, q, s));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_save_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_save_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_save_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_save_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83678[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	push	OFFSET ??_C@_0BN@BMDACPAM@Copy?5?$CFu?5bytes?5from?5?$CFp?5to?5?$CFp?6?$AA@
	mov	eax, DWORD PTR _fdebug$83678[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83678[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_save_:

; 2461 :         memcpy(s, q, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2462 :         s += n;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 2463 :       }

	jmp	$LN7@soap_save_
$LN6@soap_save_:

; 2464 :     }
; 2465 :     else

	jmp	SHORT $LN11@soap_save_
$LN9@soap_save_:

; 2466 :       soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
$LN11@soap_save_:

; 2467 :   }
; 2468 :   soap_end_block(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_block
	add	esp, 4

; 2469 :   return p;

	mov	eax, DWORD PTR _p$[ebp]

; 2470 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_save_block ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BN@FEFABKLO@Copy?5list?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@BNDAHGGB@Copy?5chain?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@HMHJFIJG@Link?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NOBOCPCO@Update?5id?$DN?8?$CFs?8?5?$CFp?5?9?$DO?5?$CFp?6?$AA@ ; `string'
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FEFABKLO@Copy?5list?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BN@FEFABKLO@Copy?5list?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ DB 'C'
	DB	'opy list update id=''%s'' %p', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNDAHGGB@Copy?5chain?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BO@BNDAHGGB@Copy?5chain?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ DB 'C'
	DB	'opy chain update id=''%s'' %p', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HMHJFIJG@Link?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BI@HMHJFIJG@Link?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@ DB 'Link u'
	DB	'pdate id=''%s'' %p', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NOBOCPCO@Update?5id?$DN?8?$CFs?8?5?$CFp?5?9?$DO?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BJ@NOBOCPCO@Update?5id?$DN?8?$CFs?8?5?$CFp?5?9?$DO?5?$CFp?6?$AA@ DB 'U'
	DB	'pdate id=''%s'' %p -> %p', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_update_ptrs
_TEXT	SEGMENT
tv238 = -328						; size = 4
_fdebug$83401 = -128					; size = 4
_fdebug$83388 = -116					; size = 4
_fdebug$83375 = -104					; size = 4
_fdebug$83361 = -92					; size = 4
_fdebug$83346 = -80					; size = 4
_q$ = -68						; size = 4
_p$ = -56						; size = 4
_xp$ = -44						; size = 4
_fp$ = -32						; size = 4
_ip$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_p1$ = 20						; size = 4
_p2$ = 24						; size = 4
_soap_update_ptrs PROC					; COMDAT

; 2187 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2188 :   register struct soap_ilist *ip = NULL;

	mov	DWORD PTR _ip$[ebp], 0

; 2189 :   register struct soap_flist *fp = NULL;

	mov	DWORD PTR _fp$[ebp], 0

; 2190 : #ifndef WITH_LEANER
; 2191 :   register struct soap_xlist *xp = NULL;

	mov	DWORD PTR _xp$[ebp], 0

; 2192 : #endif
; 2193 :   register void *p, **q;
; 2194 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN38@soap_updat
$LN37@soap_updat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN38@soap_updat:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN36@soap_updat

; 2195 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN35@soap_updat
$LN34@soap_updat:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN35@soap_updat:
	cmp	DWORD PTR _ip$[ebp], 0
	je	$LN33@soap_updat

; 2196 :     { if (ip->ptr && (char*)ip->ptr >= start && (char*)ip->ptr < end)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN32@soap_updat
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _start$[ebp]
	jb	$LN32@soap_updat
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	$LN32@soap_updat

; 2197 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update id='%s' %p -> %p\n", ip->id, ip->ptr, (char*)ip->ptr + (p1-p2)));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN31@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN30@soap_updat
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN30@soap_updat:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN31@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83346[ebp], ecx
	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _ip$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_0BJ@NOBOCPCO@Update?5id?$DN?8?$CFs?8?5?$CFp?5?9?$DO?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83346[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83346[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN31@soap_updat:

; 2198 :         ip->ptr = (char*)ip->ptr + (p1-p2);

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _ip$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN32@soap_updat:

; 2199 :       }
; 2200 :       for (q = &ip->link; q; q = (void**)p)

	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _q$[ebp], eax
	jmp	SHORT $LN28@soap_updat
$LN27@soap_updat:
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _q$[ebp], eax
$LN28@soap_updat:
	cmp	DWORD PTR _q$[ebp], 0
	je	$LN26@soap_updat

; 2201 :       { p = *q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 2202 :         if (p && (char*)p >= start && (char*)p < end)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN25@soap_updat
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jb	$LN25@soap_updat
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	$LN25@soap_updat

; 2203 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Link update id='%s' %p\n", ip->id, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN24@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN23@soap_updat
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN23@soap_updat:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN24@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83361[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_0BI@HMHJFIJG@Link?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83361[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83361[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@soap_updat:

; 2204 :           *q = (char*)p + (p1-p2);

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	add	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx], eax
$LN25@soap_updat:

; 2205 :         }
; 2206 :       }

	jmp	$LN27@soap_updat
$LN26@soap_updat:

; 2207 :       for (q = &ip->copy; q; q = (void**)p)

	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _q$[ebp], eax
	jmp	SHORT $LN21@soap_updat
$LN20@soap_updat:
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _q$[ebp], eax
$LN21@soap_updat:
	cmp	DWORD PTR _q$[ebp], 0
	je	$LN19@soap_updat

; 2208 :       { p = *q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 2209 :         if (p && (char*)p >= start && (char*)p < end)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN18@soap_updat
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jb	$LN18@soap_updat
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	$LN18@soap_updat

; 2210 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy chain update id='%s' %p\n", ip->id, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN17@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN16@soap_updat
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN16@soap_updat:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN17@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83375[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_0BO@BNDAHGGB@Copy?5chain?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83375[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83375[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@soap_updat:

; 2211 :           *q = (char*)p + (p1-p2);

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	add	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx], eax
$LN18@soap_updat:

; 2212 :         }
; 2213 :       }

	jmp	$LN20@soap_updat
$LN19@soap_updat:

; 2214 :       for (fp = ip->flist; fp; fp = fp->next)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
	jmp	SHORT $LN14@soap_updat
$LN13@soap_updat:
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fp$[ebp], ecx
$LN14@soap_updat:
	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN12@soap_updat

; 2215 :       { if ((char*)fp->ptr >= start && (char*)fp->ptr < end)

	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _start$[ebp]
	jb	$LN11@soap_updat
	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	$LN11@soap_updat

; 2216 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy list update id='%s' %p\n", ip->id, fp));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_updat
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_updat:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83388[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_0BN@FEFABKLO@Copy?5list?5update?5id?$DN?8?$CFs?8?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83388[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83388[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_updat:

; 2217 :           fp->ptr = (char*)fp->ptr + (p1-p2);

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _fp$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _fp$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN11@soap_updat:

; 2218 :         }
; 2219 :       }

	jmp	$LN13@soap_updat
$LN12@soap_updat:

; 2220 :     }

	jmp	$LN34@soap_updat
$LN33@soap_updat:

; 2221 :   }

	jmp	$LN37@soap_updat
$LN36@soap_updat:

; 2222 : #ifndef WITH_LEANER
; 2223 :   for (xp = soap->xlist; xp; xp = xp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90544]
	mov	DWORD PTR _xp$[ebp], ecx
	jmp	SHORT $LN7@soap_updat
$LN6@soap_updat:
	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xp$[ebp], ecx
$LN7@soap_updat:
	cmp	DWORD PTR _xp$[ebp], 0
	je	$LN39@soap_updat

; 2224 :   { if (xp->ptr && (char*)xp->ptr >= start && (char*)xp->ptr < end)

	mov	eax, DWORD PTR _xp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN4@soap_updat
	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _start$[ebp]
	jb	$LN4@soap_updat
	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	$LN4@soap_updat

; 2225 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update id='%s' %p -> %p\n", xp->id?xp->id:"", xp->ptr, (char*)xp->ptr + (p1-p2)));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN3@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_updat
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_updat:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_updat
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83401[ebp], ecx
	mov	eax, DWORD PTR _xp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN41@soap_updat
	mov	ecx, DWORD PTR _xp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv238[ebp], edx
	jmp	SHORT $LN42@soap_updat
$LN41@soap_updat:
	mov	DWORD PTR tv238[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@soap_updat:
	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _xp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv238[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@NOBOCPCO@Update?5id?$DN?8?$CFs?8?5?$CFp?5?9?$DO?5?$CFp?6?$AA@
	mov	edx, DWORD PTR _fdebug$83401[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83401[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_updat:

; 2226 :       xp->ptr = (unsigned char**)((char*)xp->ptr + (p1-p2));

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _xp$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2227 :       xp->size = (int*)((char*)xp->size + (p1-p2));

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _xp$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2228 :       xp->type = (char**)((char*)xp->type + (p1-p2));

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _xp$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2229 :       xp->options = (char**)((char*)xp->options + (p1-p2));

	mov	eax, DWORD PTR _p1$[ebp]
	sub	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _xp$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _xp$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN4@soap_updat:

; 2230 :     }

	jmp	$LN6@soap_updat
$LN39@soap_updat:

; 2231 :   }
; 2232 : #endif
; 2233 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_update_ptrs ENDP
_TEXT	ENDS
PUBLIC	_soap_putsizes
PUBLIC	_soap_putsize
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_putsize
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_size$ = 16						; size = 4
_soap_putsize PROC					; COMDAT

; 2479 : { return soap_putsizes(soap, type, &size, 1);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	1
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_putsizes
	add	esp, 16					; 00000010H

; 2480 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putsize ENDP
_TEXT	ENDS
PUBLIC	_soap_putsizesoffsets
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_putsizes
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_size$ = 16						; size = 4
_dim$ = 20						; size = 4
_soap_putsizes PROC					; COMDAT

; 2489 : { return soap_putsizesoffsets(soap, type, size, NULL, dim);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _dim$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putsizesoffsets
	add	esp, 20					; 00000014H

; 2490 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putsizes ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_03LEIBKMN@?0?$CFd?$AA@			; `string'
PUBLIC	??_C@_03EBJOKFHF@?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@		; `string'
EXTRN	_strcat:PROC
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEIBKMN@?0?$CFd?$AA@
CONST	SEGMENT
??_C@_03LEIBKMN@?0?$CFd?$AA@ DB ',%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBJOKFHF@?5?$CFd?$AA@
CONST	SEGMENT
??_C@_03EBJOKFHF@?5?$CFd?$AA@ DB ' %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
CONST	SEGMENT
??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@ DB '%s[%d', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putsizesoffsets
_TEXT	SEGMENT
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_size$ = 16						; size = 4
_offset$ = 20						; size = 4
_dim$ = 24						; size = 4
_soap_putsizesoffsets PROC				; COMDAT

; 2499 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2500 :   if (!type)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN14@soap_putsi

; 2501 :     return NULL;

	xor	eax, eax
	jmp	$LN15@soap_putsi
$LN14@soap_putsi:

; 2502 :   if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	$LN13@soap_putsi

; 2503 :   { sprintf(soap->type, "%s[%d", type, size[0]);

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	OFFSET ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2504 :     for (i = 1; i < dim; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN12@soap_putsi
$LN11@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN10@soap_putsi

; 2505 :       sprintf(soap->type + strlen(soap->type), " %d", size[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_03EBJOKFHF@?5?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+83124]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN11@soap_putsi
$LN10@soap_putsi:

; 2506 :   }
; 2507 :   else

	jmp	$LN9@soap_putsi
$LN13@soap_putsi:

; 2508 :   { if (offset)

	cmp	DWORD PTR _offset$[ebp], 0
	je	$LN8@soap_putsi

; 2509 :     { sprintf(soap->type, "%s[%d", type, size[0] + offset[0]);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2510 :       for (i = 1; i < dim; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@soap_putsi
$LN6@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN5@soap_putsi

; 2511 :         sprintf(soap->type + strlen(soap->type), ",%d", size[i] + offset[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_03LEIBKMN@?0?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 83124				; 000144b4H
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+83124]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN6@soap_putsi
$LN5@soap_putsi:

; 2512 :     }
; 2513 :     else

	jmp	$LN4@soap_putsi
$LN8@soap_putsi:

; 2514 :     { sprintf(soap->type, "%s[%d", type, size[0]);

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	OFFSET ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2515 :       for (i = 1; i < dim; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@soap_putsi
$LN2@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_putsi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN4@soap_putsi

; 2516 :         sprintf(soap->type + strlen(soap->type), ",%d", size[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_03LEIBKMN@?0?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+83124]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@soap_putsi
$LN4@soap_putsi:

; 2517 :     }
; 2518 :     strcat(soap->type, "]");

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	call	_strcat
	add	esp, 8
$LN9@soap_putsi:

; 2519 :   }
; 2520 :   return soap->type;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
$LN15@soap_putsi:

; 2521 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putsizesoffsets ENDP
_TEXT	ENDS
PUBLIC	_soap_putoffsets
PUBLIC	_soap_putoffset
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_putoffset
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_offset$ = 12						; size = 4
_soap_putoffset PROC					; COMDAT

; 2530 : { return soap_putoffsets(soap, &offset, 1);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	1
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_putoffsets
	add	esp, 12					; 0000000cH

; 2531 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putoffset ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PNKAICOI@?$FL?$CFd?$AA@			; `string'
;	COMDAT ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
CONST	SEGMENT
??_C@_03PNKAICOI@?$FL?$CFd?$AA@ DB '[%d', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putoffsets
_TEXT	SEGMENT
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_offset$ = 12						; size = 4
_dim$ = 16						; size = 4
_soap_putoffsets PROC					; COMDAT

; 2540 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2541 :   sprintf(soap->arrayOffset, "[%d", offset[0]);

	mov	esi, esp
	mov	eax, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 86196				; 000150b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2542 :   for (i = 1; i < dim; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@soap_putof
$LN2@soap_putof:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_putof:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN1@soap_putof

; 2543 :     sprintf(soap->arrayOffset + strlen(soap->arrayOffset), ",%d", offset[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_03LEIBKMN@?0?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 86196				; 000150b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+86196]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@soap_putof
$LN1@soap_putof:

; 2544 :   strcat(soap->arrayOffset, "]");

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 86196				; 000150b4H
	push	eax
	call	_strcat
	add	esp, 8

; 2545 :   return soap->arrayOffset;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 86196				; 000150b4H

; 2546 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putoffsets ENDP
_TEXT	ENDS
PUBLIC	_soap_size
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_size
_TEXT	SEGMENT
_n$ = -20						; size = 4
_i$ = -8						; size = 4
_size$ = 8						; size = 4
_dim$ = 12						; size = 4
_soap_size PROC						; COMDAT

; 2555 : { register int i, n = size[0];

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[ebp], ecx

; 2556 :   for (i = 1; i < dim; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@soap_size
$LN2@soap_size:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_size:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN1@soap_size

; 2557 :     n *= size[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	imul	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _n$[ebp], edx
	jmp	SHORT $LN2@soap_size
$LN1@soap_size:

; 2558 :   return n;

	mov	eax, DWORD PTR _n$[ebp]

; 2559 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_size ENDP
_TEXT	ENDS
PUBLIC	_soap_getoffsets
EXTRN	__imp__strchr:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getoffsets
_TEXT	SEGMENT
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_attr$ = 8						; size = 4
_size$ = 12						; size = 4
_offset$ = 16						; size = 4
_dim$ = 20						; size = 4
_soap_getoffsets PROC					; COMDAT

; 2568 : { register int i, j = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _j$[ebp], 0

; 2569 :   if (offset)

	cmp	DWORD PTR _offset$[ebp], 0
	je	$LN8@soap_getof

; 2570 :     for (i = 0; i < dim && attr && *attr; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@soap_getof
$LN6@soap_getof:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@soap_getof:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN5@soap_getof
	cmp	DWORD PTR _attr$[ebp], 0
	je	SHORT $LN5@soap_getof
	mov	eax, DWORD PTR _attr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@soap_getof

; 2571 :     { attr++;

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, 1
	mov	DWORD PTR _attr$[ebp], eax

; 2572 :       j *= size[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _j$[ebp], edx

; 2573 :       j += offset[i] = (int)atol(attr);

	mov	esi, esp
	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _j$[ebp], edx

; 2574 :       attr = strchr(attr, ',');

	mov	esi, esp
	push	44					; 0000002cH
	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _attr$[ebp], eax
	jmp	$LN6@soap_getof
$LN5@soap_getof:

; 2575 :     }

	jmp	SHORT $LN4@soap_getof
$LN8@soap_getof:

; 2576 :   else
; 2577 :     for (i = 0; i < dim && attr && *attr; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_getof
$LN2@soap_getof:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_getof:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dim$[ebp]
	jge	SHORT $LN4@soap_getof
	cmp	DWORD PTR _attr$[ebp], 0
	je	SHORT $LN4@soap_getof
	mov	eax, DWORD PTR _attr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@soap_getof

; 2578 :     { attr++;

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, 1
	mov	DWORD PTR _attr$[ebp], eax

; 2579 :       j *= size[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _j$[ebp], edx

; 2580 :       j += (int)atol(attr);

	mov	esi, esp
	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _j$[ebp], eax

; 2581 :       attr = strchr(attr, ',');

	mov	esi, esp
	push	44					; 0000002cH
	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _attr$[ebp], eax

; 2582 :     }

	jmp	SHORT $LN2@soap_getof
$LN4@soap_getof:

; 2583 :   return j;

	mov	eax, DWORD PTR _j$[ebp]

; 2584 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getoffsets ENDP
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	_soap_getsize
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getsize
_TEXT	SEGMENT
_s$ = -32						; size = 4
_k$ = -20						; size = 4
_n$ = -8						; size = 4
_attr1$ = 8						; size = 4
_attr2$ = 12						; size = 4
_j$ = 16						; size = 4
_soap_getsize PROC					; COMDAT

; 2593 : { register int n, k;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2594 :   char *s;
; 2595 :   *j = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax], 0

; 2596 :   if (!*attr1)

	mov	eax, DWORD PTR _attr1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@soap_getsi

; 2597 :     return -1;

	or	eax, -1
	jmp	$LN11@soap_getsi
$LN10@soap_getsi:

; 2598 :   if (*attr1 == '[')

	mov	eax, DWORD PTR _attr1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN9@soap_getsi

; 2599 :     attr1++;

	mov	eax, DWORD PTR _attr1$[ebp]
	add	eax, 1
	mov	DWORD PTR _attr1$[ebp], eax
$LN9@soap_getsi:

; 2600 :   n = 1;

	mov	DWORD PTR _n$[ebp], 1
$LN8@soap_getsi:

; 2601 :   for (;;)
; 2602 :   { k = (int)soap_strtol(attr1, &s, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attr1$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _k$[ebp], eax

; 2603 :     n *= k;

	mov	eax, DWORD PTR _n$[ebp]
	imul	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 2604 :     if (k < 0 || n > SOAP_MAXARRAYSIZE || s == attr1)

	cmp	DWORD PTR _k$[ebp], 0
	jl	SHORT $LN5@soap_getsi
	cmp	DWORD PTR _n$[ebp], 100000		; 000186a0H
	jg	SHORT $LN5@soap_getsi
	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _attr1$[ebp]
	jne	SHORT $LN6@soap_getsi
$LN5@soap_getsi:

; 2605 :       return -1;

	or	eax, -1
	jmp	$LN11@soap_getsi
$LN6@soap_getsi:

; 2606 :     attr1 = strchr(s, ',');

	push	44					; 0000002cH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _attr1$[ebp], eax

; 2607 :     if (!attr1)

	cmp	DWORD PTR _attr1$[ebp], 0
	jne	SHORT $LN4@soap_getsi

; 2608 :       attr1 = strchr(s, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _attr1$[ebp], eax
$LN4@soap_getsi:

; 2609 :     if (attr2 && *attr2)

	cmp	DWORD PTR _attr2$[ebp], 0
	je	SHORT $LN3@soap_getsi
	mov	eax, DWORD PTR _attr2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@soap_getsi

; 2610 :     { attr2++;

	mov	eax, DWORD PTR _attr2$[ebp]
	add	eax, 1
	mov	DWORD PTR _attr2$[ebp], eax

; 2611 :       *j *= k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx], ecx

; 2612 :       k = (int)soap_strtol(attr2, &s, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attr2$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _k$[ebp], eax

; 2613 :       *j += k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx], ecx

; 2614 :       if (k < 0)

	cmp	DWORD PTR _k$[ebp], 0
	jge	SHORT $LN2@soap_getsi

; 2615 :         return -1;

	or	eax, -1
	jmp	SHORT $LN11@soap_getsi
$LN2@soap_getsi:

; 2616 :       attr2 = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _attr2$[ebp], eax
$LN3@soap_getsi:

; 2617 :     }
; 2618 :     if (!attr1)

	cmp	DWORD PTR _attr1$[ebp], 0
	jne	SHORT $LN1@soap_getsi

; 2619 :       break;

	jmp	SHORT $LN7@soap_getsi
$LN1@soap_getsi:

; 2620 :     attr1++;

	mov	eax, DWORD PTR _attr1$[ebp]
	add	eax, 1
	mov	DWORD PTR _attr1$[ebp], eax

; 2621 :   }

	jmp	$LN8@soap_getsi
$LN7@soap_getsi:

; 2622 :   return n - *j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
$LN11@soap_getsi:

; 2623 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@soap_getsi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@soap_getsi:
	DD	1
	DD	$LN14@soap_getsi
$LN14@soap_getsi:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN13@soap_getsi
$LN13@soap_getsi:
	DB	115					; 00000073H
	DB	0
_soap_getsize ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\string.h
_TEXT	ENDS
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 184  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
PUBLIC	_soap_getsizes
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
;	COMDAT _soap_getsizes
_TEXT	SEGMENT
_n$ = -32						; size = 4
_k$ = -20						; size = 4
_i$ = -8						; size = 4
_attr$ = 8						; size = 4
_size$ = 12						; size = 4
_dim$ = 16						; size = 4
_soap_getsizes PROC					; COMDAT

; 2632 : { register int i, k, n;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2633 :   if (!*attr)

	mov	eax, DWORD PTR _attr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@soap_getsi@2

; 2634 :     return -1;

	or	eax, -1
	jmp	$LN13@soap_getsi@2
$LN12@soap_getsi@2:

; 2635 :   i = (int)strlen(attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 2636 :   n = 1;

	mov	DWORD PTR _n$[ebp], 1
$LN11@soap_getsi@2:

; 2637 :   do
; 2638 :   { for (i = i-1; i >= 0; i--)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN8@soap_getsi@2
$LN7@soap_getsi@2:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@soap_getsi@2:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN6@soap_getsi@2

; 2639 :       if (attr[i] == '[' || attr[i] == ',' || attr[i] == ' ')

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $LN4@soap_getsi@2
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN4@soap_getsi@2
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN5@soap_getsi@2
$LN4@soap_getsi@2:

; 2640 :         break;

	jmp	SHORT $LN6@soap_getsi@2
$LN5@soap_getsi@2:

; 2641 :     k = (int)atol(attr + i + 1);

	jmp	SHORT $LN7@soap_getsi@2
$LN6@soap_getsi@2:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _attr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _k$[ebp], eax

; 2642 :     n *= size[--dim] = k;

	mov	eax, DWORD PTR _dim$[ebp]
	sub	eax, 1
	mov	DWORD PTR _dim$[ebp], eax
	mov	ecx, DWORD PTR _dim$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _n$[ebp]
	imul	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 2643 :     if (k < 0 || n > SOAP_MAXARRAYSIZE)

	cmp	DWORD PTR _k$[ebp], 0
	jl	SHORT $LN2@soap_getsi@2
	cmp	DWORD PTR _n$[ebp], 100000		; 000186a0H
	jle	SHORT $LN10@soap_getsi@2
$LN2@soap_getsi@2:

; 2644 :       return -1;

	or	eax, -1
	jmp	SHORT $LN13@soap_getsi@2
$LN10@soap_getsi@2:

; 2645 :   } while (i >= 0 && attr[i] != '[');

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN9@soap_getsi@2
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	jne	$LN11@soap_getsi@2
$LN9@soap_getsi@2:

; 2646 :   return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN13@soap_getsi@2:

; 2647 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getsizes ENDP
_TEXT	ENDS
PUBLIC	_soap_getposition
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getposition
_TEXT	SEGMENT
_n$ = -20						; size = 4
_i$ = -8						; size = 4
_attr$ = 8						; size = 4
_pos$ = 12						; size = 4
_soap_getposition PROC					; COMDAT

; 2656 : { register int i, n;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2657 :   if (!*attr)

	mov	eax, DWORD PTR _attr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN8@soap_getpo

; 2658 :     return -1;

	or	eax, -1
	jmp	$LN9@soap_getpo
$LN8@soap_getpo:

; 2659 :   n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 2660 :   i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN7@soap_getpo:

; 2661 :   do
; 2662 :   { pos[n++] = (int)atol(attr + i);

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN4@soap_getpo:

; 2663 :     while (attr[i] && attr[i] != ',' && attr[i] != ']')

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@soap_getpo
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN3@soap_getpo
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN3@soap_getpo

; 2664 :       i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@soap_getpo
$LN3@soap_getpo:

; 2665 :     if (attr[i] == ',')

	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN6@soap_getpo

; 2666 :       i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@soap_getpo:

; 2667 :   } while (n < SOAP_MAXDIMS && attr[i] && attr[i] != ']');

	cmp	DWORD PTR _n$[ebp], 16			; 00000010H
	jge	SHORT $LN5@soap_getpo
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@soap_getpo
	mov	eax, DWORD PTR _attr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	$LN7@soap_getpo
$LN5@soap_getpo:

; 2668 :   return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN9@soap_getpo:

; 2669 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getposition ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@CHKEGLLG@Push?5OK?5?$CI?8?$CFs?8?5matches?5?8?$CFs?8?5in?5na@ ; `string'
PUBLIC	??_C@_0FJ@JEKLGAGO@Push?5NOT?5OK?3?5no?5match?5found?5for?5@ ; `string'
PUBLIC	??_C@_0CN@POAHAGLK@Push?5namespace?5binding?5?$CIlevel?$DN?$CFu@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_push_namespace@@9@4JA	; `soap_push_namespace'::`2'::__LINE__Var
PUBLIC	_soap_push_namespace
;	COMDAT ??_C@_0DA@CHKEGLLG@Push?5OK?5?$CI?8?$CFs?8?5matches?5?8?$CFs?8?5in?5na@
CONST	SEGMENT
??_C@_0DA@CHKEGLLG@Push?5OK?5?$CI?8?$CFs?8?5matches?5?8?$CFs?8?5in?5na@ DB 'P'
	DB	'ush OK (''%s'' matches ''%s'' in namespace table)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@JEKLGAGO@Push?5NOT?5OK?3?5no?5match?5found?5for?5@
CONST	SEGMENT
??_C@_0FJ@JEKLGAGO@Push?5NOT?5OK?3?5no?5match?5found?5for?5@ DB 'Push NOT'
	DB	' OK: no match found for ''%s'' in namespace mapping table (ad'
	DB	'ded to stack anyway)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@POAHAGLK@Push?5namespace?5binding?5?$CIlevel?$DN?$CFu@
CONST	SEGMENT
??_C@_0CN@POAHAGLK@Push?5namespace?5binding?5?$CIlevel?$DN?$CFu@ DB 'Push'
	DB	' namespace binding (level=%u) ''%s'' ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_push_namespace@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_push_namespace@@9@4JA DD 0a76H	; `soap_push_namespace'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_push_namespace
_TEXT	SEGMENT
_fdebug$83867 = -92					; size = 4
_fdebug$83860 = -80					; size = 4
_fdebug$83853 = -68					; size = 4
_k$ = -56						; size = 4
_n$ = -44						; size = 4
_i$ = -32						; size = 2
_p$ = -20						; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_ns$ = 16						; size = 4
_soap_push_namespace PROC				; COMDAT

; 2678 : { register struct soap_nlist *np;

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2679 :   register struct Namespace *p;
; 2680 :   register short i = -1;

	or	eax, -1
	mov	WORD PTR _i$[ebp], ax

; 2681 :   register size_t n, k;
; 2682 :   n = strlen(id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 2683 :   k = strlen(ns) + 1;

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 2684 :   p = soap->local_namespaces;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _p$[ebp], ecx

; 2685 :   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN27@soap_push_@2

; 2686 :   { for (i = 0; p->id; p++, i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN26@soap_push_@2
$LN25@soap_push_@2:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN26@soap_push_@2:
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN24@soap_push_@2

; 2687 :     { if (p->ns && !strcmp(ns, p->ns))

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN23@soap_push_@2
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@soap_push_@2

; 2688 :       { if (p->out)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN22@soap_push_@2

; 2689 :         { SOAP_FREE(soap, p->out);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_push_namespace@@9@4JA
	add	edx, 11					; 0000000bH
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 2690 :           p->out = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN22@soap_push_@2:

; 2691 :         }
; 2692 :         break;

	jmp	$LN24@soap_push_@2
$LN23@soap_push_@2:

; 2693 :       }
; 2694 :       if (p->out)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN21@soap_push_@2

; 2695 :       { if (!strcmp(ns, p->out))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@soap_push_@2

; 2696 :           break;

	jmp	SHORT $LN24@soap_push_@2
$LN20@soap_push_@2:

; 2697 :       }

	jmp	SHORT $LN19@soap_push_@2
$LN21@soap_push_@2:

; 2698 :       else if (p->in)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN19@soap_push_@2

; 2699 :       { if (!soap_tag_cmp(ns, p->in))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ns$[ebp]
	push	edx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@soap_push_@2

; 2700 :         { if ((p->out = (char*)SOAP_MALLOC(soap, k)))

	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_push_namespace@@9@4JA
	add	ecx, 22					; 00000016H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN16@soap_push_@2

; 2701 :             strcpy(p->out, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_strcpy
	add	esp, 8
$LN16@soap_push_@2:

; 2702 :           break;

	jmp	SHORT $LN24@soap_push_@2
$LN19@soap_push_@2:

; 2703 :         }
; 2704 :       }
; 2705 :     }

	jmp	$LN25@soap_push_@2
$LN24@soap_push_@2:

; 2706 :     if (!p || !p->id)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN14@soap_push_@2
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN27@soap_push_@2
$LN14@soap_push_@2:

; 2707 :       i = -1;

	or	eax, -1
	mov	WORD PTR _i$[ebp], ax
$LN27@soap_push_@2:

; 2708 :   }
; 2709 :   if (i >= 0)

	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jl	SHORT $LN13@soap_push_@2

; 2710 :     k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN13@soap_push_@2:

; 2711 :   np = (struct soap_nlist*)SOAP_MALLOC(soap, sizeof(struct soap_nlist) + n + k);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_push_namespace@@9@4JA
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _np$[ebp], eax

; 2712 :   if (!np)

	cmp	DWORD PTR _np$[ebp], 0
	jne	SHORT $LN12@soap_push_@2

; 2713 :     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN28@soap_push_@2
$LN12@soap_push_@2:

; 2714 :   np->next = soap->nlist;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax], edx

; 2715 :   soap->nlist = np;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 2716 :   np->level = soap->level;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	mov	DWORD PTR [eax+4], edx

; 2717 :   np->index = i;

	mov	eax, DWORD PTR _np$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+8], cx

; 2718 :   strcpy(np->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_strcpy
	add	esp, 8

; 2719 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push namespace binding (level=%u) '%s' '%s'\n", soap->level, id, ns));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN11@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN10@soap_push_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN10@soap_push_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN11@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83853[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12444]
	push	eax
	push	OFFSET ??_C@_0CN@POAHAGLK@Push?5namespace?5binding?5?$CIlevel?$DN?$CFu@
	mov	ecx, DWORD PTR _fdebug$83853[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83853[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@soap_push_@2:

; 2720 :   if (i < 0)

	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jge	$LN8@soap_push_@2

; 2721 :   { np->ns = np->id + n + 1;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	lea	edx, DWORD PTR [ecx+eax+17]
	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+12], edx

; 2722 :     strcpy(np->ns, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_strcpy
	add	esp, 8

; 2723 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push NOT OK: no match found for '%s' in namespace mapping table (added to stack anyway)\n", ns));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_push_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_push_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83860[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	OFFSET ??_C@_0FJ@JEKLGAGO@Push?5NOT?5OK?3?5no?5match?5found?5for?5@
	mov	ecx, DWORD PTR _fdebug$83860[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83860[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_push_@2:

; 2724 :   }
; 2725 :   else

	jmp	SHORT $LN4@soap_push_@2
$LN8@soap_push_@2:

; 2726 :   { np->ns = NULL;

	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+12], 0

; 2727 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push OK ('%s' matches '%s' in namespace table)\n", id, p->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_push_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_push_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_push_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83867[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	push	OFFSET ??_C@_0DA@CHKEGLLG@Push?5OK?5?$CI?8?$CFs?8?5matches?5?8?$CFs?8?5in?5na@
	mov	eax, DWORD PTR _fdebug$83867[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83867[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_push_@2:

; 2728 :   }
; 2729 :   return SOAP_OK;

	xor	eax, eax
$LN28@soap_push_@2:

; 2730 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_push_namespace ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_pop_namespace@@9@4JA	; `soap_pop_namespace'::`2'::__LINE__Var
PUBLIC	??_C@_0CH@MHECBOHN@Pop?5namespace?5binding?5?$CIlevel?$DN?$CFu?$CJ@ ; `string'
PUBLIC	_soap_pop_namespace
;	COMDAT ?__LINE__Var@?1??soap_pop_namespace@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_pop_namespace@@9@4JA DD 0ab3H	; `soap_pop_namespace'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@MHECBOHN@Pop?5namespace?5binding?5?$CIlevel?$DN?$CFu?$CJ@
CONST	SEGMENT
??_C@_0CH@MHECBOHN@Pop?5namespace?5binding?5?$CIlevel?$DN?$CFu?$CJ@ DB 'P'
	DB	'op namespace binding (level=%u) ''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_pop_namespace
_TEXT	SEGMENT
_fdebug$83881 = -32					; size = 4
_nq$ = -20						; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_pop_namespace PROC				; COMDAT

; 2739 : { register struct soap_nlist *np, *nq;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2740 :   for (np = soap->nlist; np && np->level >= soap->level; np = nq)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN6@soap_pop_n
$LN5@soap_pop_n:
	mov	eax, DWORD PTR _nq$[ebp]
	mov	DWORD PTR _np$[ebp], eax
$LN6@soap_pop_n:
	cmp	DWORD PTR _np$[ebp], 0
	je	$LN4@soap_pop_n
	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+12444]
	jb	$LN4@soap_pop_n

; 2741 :   { nq = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nq$[ebp], ecx

; 2742 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop namespace binding (level=%u) '%s'\n", soap->level, np->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_pop_n
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_pop_n
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_pop_n:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_pop_n
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83881[ebp], ecx
	mov	eax, DWORD PTR _np$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	push	edx
	push	OFFSET ??_C@_0CH@MHECBOHN@Pop?5namespace?5binding?5?$CIlevel?$DN?$CFu?$CJ@
	mov	eax, DWORD PTR _fdebug$83881[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83881[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_pop_n:

; 2743 :     SOAP_FREE(soap, np);

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_pop_namespace@@9@4JA
	add	ecx, 4
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 2744 :   }

	jmp	$LN5@soap_pop_n
$LN4@soap_pop_n:

; 2745 :   soap->nlist = np;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 2746 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_pop_namespace ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PJHHNEEI@xml?$AA@			; `string'
PUBLIC	_soap_match_namespace
;	COMDAT ??_C@_03PJHHNEEI@xml?$AA@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml?$AA@ DB 'xml', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_match_namespace
_TEXT	SEGMENT
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_id1$ = 12						; size = 4
_id2$ = 16						; size = 4
_n1$ = 20						; size = 4
_n2$ = 24						; size = 4
_soap_match_namespace PROC				; COMDAT

; 2755 : { register struct soap_nlist *np = soap->nlist;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx
$LN8@soap_match:

; 2756 :   while (np && (strncmp(np->id, id1, n1) || np->id[n1]))

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN7@soap_match
	mov	esi, esp
	mov	eax, DWORD PTR _n1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _np$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN6@soap_match
	mov	eax, DWORD PTR _np$[ebp]
	add	eax, DWORD PTR _n1$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN7@soap_match
$LN6@soap_match:

; 2757 :     np = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN8@soap_match
$LN7@soap_match:

; 2758 :   if (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN5@soap_match

; 2759 :   { if (np->index < 0
; 2760 :      || (soap->local_namespaces[np->index].id
; 2761 :       && (strncmp(soap->local_namespaces[np->index].id, id2, n2)
; 2762 :        || soap->local_namespaces[np->index].id[n2])))

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	jl	SHORT $LN3@soap_match
	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+84]
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $LN4@soap_match
	mov	esi, esp
	mov	eax, DWORD PTR _n2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _np$[ebp]
	movsx	eax, WORD PTR [edx+8]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@soap_match
	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _n2$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN4@soap_match
$LN3@soap_match:

; 2763 :       return SOAP_NAMESPACE;

	mov	eax, 9
	jmp	SHORT $LN9@soap_match
$LN4@soap_match:

; 2764 :     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN9@soap_match
$LN5@soap_match:

; 2765 :   }
; 2766 :   if (n1 == 3 && n1 == n2 && !strncmp(id1, "xml", 3) && !strncmp(id1, id2, 3))

	cmp	DWORD PTR _n1$[ebp], 3
	jne	SHORT $LN1@soap_match
	mov	eax, DWORD PTR _n1$[ebp]
	cmp	eax, DWORD PTR _n2$[ebp]
	jne	SHORT $LN1@soap_match
	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	mov	eax, DWORD PTR _id1$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_match
	mov	esi, esp
	push	3
	mov	eax, DWORD PTR _id2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id1$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_match

; 2767 :     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN9@soap_match
$LN1@soap_match:

; 2768 :   return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 5
	mov	eax, 5
$LN9@soap_match:

; 2769 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_match_namespace ENDP
_TEXT	ENDS
PUBLIC	_soap_current_namespace
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_current_namespace
_TEXT	SEGMENT
_s$ = -20						; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_current_namespace PROC				; COMDAT

; 2778 : { register struct soap_nlist *np;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2779 :   register const char *s;
; 2780 :   if (!tag || !strncmp(tag, "xml", 3))

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN12@soap_curre
	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN13@soap_curre
$LN12@soap_curre:

; 2781 :     return NULL;

	xor	eax, eax
	jmp	$LN14@soap_curre
$LN13@soap_curre:

; 2782 :   np = soap->nlist;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx

; 2783 :   if (!(s = strchr(tag, ':')))

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN7@soap_curre
$LN10@soap_curre:

; 2784 :   { while (np && *np->id) /* find default namespace, if present */

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN9@soap_curre
	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN9@soap_curre

; 2785 :       np = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN10@soap_curre
$LN9@soap_curre:

; 2786 :   }
; 2787 :   else

	jmp	SHORT $LN8@soap_curre
$LN7@soap_curre:

; 2788 :   { while (np && (strncmp(np->id, tag, s - tag) || np->id[s - tag]))

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN6@soap_curre
	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _np$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN5@soap_curre
	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+16]
	test	edx, edx
	je	SHORT $LN6@soap_curre
$LN5@soap_curre:

; 2789 :       np = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN7@soap_curre
$LN6@soap_curre:

; 2790 :     if (!np)

	cmp	DWORD PTR _np$[ebp], 0
	jne	SHORT $LN8@soap_curre

; 2791 :       soap->error = SOAP_NAMESPACE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 9
$LN8@soap_curre:

; 2792 :   }
; 2793 :   if (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN3@soap_curre

; 2794 :   { if (np->index >= 0)

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	jl	SHORT $LN2@soap_curre

; 2795 :       return soap->namespaces[np->index].ns;

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN14@soap_curre
$LN2@soap_curre:

; 2796 :     if (np->ns)

	mov	eax, DWORD PTR _np$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN3@soap_curre

; 2797 :       return soap_strdup(soap, np->ns);

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	jmp	SHORT $LN14@soap_curre
$LN3@soap_curre:

; 2798 :   }
; 2799 :   return NULL;

	xor	eax, eax
$LN14@soap_curre:

; 2800 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_current_namespace ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_tag_cmp
_TEXT	SEGMENT
_c2$83931 = -20						; size = 4
_c1$83930 = -8						; size = 4
_s$ = 8							; size = 4
_t$ = 12						; size = 4
_soap_tag_cmp PROC					; COMDAT

; 2809 : { for (;;)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN19@soap_tag_c:

; 2810 :   { register int c1 = *s;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$83930[ebp], ecx

; 2811 :     register int c2 = *t;

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c2$83931[ebp], ecx

; 2812 :     if (!c1 || c1 == '"')

	cmp	DWORD PTR _c1$83930[ebp], 0
	je	SHORT $LN16@soap_tag_c
	cmp	DWORD PTR _c1$83930[ebp], 34		; 00000022H
	jne	SHORT $LN17@soap_tag_c
$LN16@soap_tag_c:

; 2813 :       break;

	jmp	$LN18@soap_tag_c
$LN17@soap_tag_c:

; 2814 :     if (c2 != '-')

	cmp	DWORD PTR _c2$83931[ebp], 45		; 0000002dH
	je	$LN15@soap_tag_c

; 2815 :     { if (c1 != c2)

	mov	eax, DWORD PTR _c1$83930[ebp]
	cmp	eax, DWORD PTR _c2$83931[ebp]
	je	SHORT $LN14@soap_tag_c

; 2816 :       { if (c1 >= 'A' && c1 <= 'Z')

	cmp	DWORD PTR _c1$83930[ebp], 65		; 00000041H
	jl	SHORT $LN13@soap_tag_c
	cmp	DWORD PTR _c1$83930[ebp], 90		; 0000005aH
	jg	SHORT $LN13@soap_tag_c

; 2817 :           c1 += 'a' - 'A';

	mov	eax, DWORD PTR _c1$83930[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _c1$83930[ebp], eax
$LN13@soap_tag_c:

; 2818 :         if (c2 >= 'A' && c2 <= 'Z')

	cmp	DWORD PTR _c2$83931[ebp], 65		; 00000041H
	jl	SHORT $LN14@soap_tag_c
	cmp	DWORD PTR _c2$83931[ebp], 90		; 0000005aH
	jg	SHORT $LN14@soap_tag_c

; 2819 :           c2 += 'a' - 'A';

	mov	eax, DWORD PTR _c2$83931[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _c2$83931[ebp], eax
$LN14@soap_tag_c:

; 2820 :       }
; 2821 :       if (c1 != c2)

	mov	eax, DWORD PTR _c1$83930[ebp]
	cmp	eax, DWORD PTR _c2$83931[ebp]
	je	$LN15@soap_tag_c

; 2822 :       { if (c2 != '*')

	cmp	DWORD PTR _c2$83931[ebp], 42		; 0000002aH
	je	SHORT $LN10@soap_tag_c

; 2823 :           return 1;

	mov	eax, 1
	jmp	$LN20@soap_tag_c
$LN10@soap_tag_c:

; 2824 :         c2 = *++t;

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c2$83931[ebp], edx

; 2825 :         if (!c2)

	cmp	DWORD PTR _c2$83931[ebp], 0
	jne	SHORT $LN9@soap_tag_c

; 2826 :           return 0;

	xor	eax, eax
	jmp	$LN20@soap_tag_c
$LN9@soap_tag_c:

; 2827 :         if (c2 >= 'A' && c2 <= 'Z')

	cmp	DWORD PTR _c2$83931[ebp], 65		; 00000041H
	jl	SHORT $LN7@soap_tag_c
	cmp	DWORD PTR _c2$83931[ebp], 90		; 0000005aH
	jg	SHORT $LN7@soap_tag_c

; 2828 :           c2 += 'a' - 'A';

	mov	eax, DWORD PTR _c2$83931[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _c2$83931[ebp], eax
$LN7@soap_tag_c:

; 2829 :         for (;;)
; 2830 :         { c1 = *s;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$83930[ebp], ecx

; 2831 :           if (!c1 || c1 == '"')

	cmp	DWORD PTR _c1$83930[ebp], 0
	je	SHORT $LN4@soap_tag_c
	cmp	DWORD PTR _c1$83930[ebp], 34		; 00000022H
	jne	SHORT $LN5@soap_tag_c
$LN4@soap_tag_c:

; 2832 :             break;

	jmp	SHORT $LN6@soap_tag_c
$LN5@soap_tag_c:

; 2833 :           if (c1 >= 'A' && c1 <= 'Z')

	cmp	DWORD PTR _c1$83930[ebp], 65		; 00000041H
	jl	SHORT $LN3@soap_tag_c
	cmp	DWORD PTR _c1$83930[ebp], 90		; 0000005aH
	jg	SHORT $LN3@soap_tag_c

; 2834 :             c1 += 'a' - 'A';

	mov	eax, DWORD PTR _c1$83930[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _c1$83930[ebp], eax
$LN3@soap_tag_c:

; 2835 :           if (c1 == c2 && !soap_tag_cmp(s + 1, t + 1))

	mov	eax, DWORD PTR _c1$83930[ebp]
	cmp	eax, DWORD PTR _c2$83931[ebp]
	jne	SHORT $LN2@soap_tag_c
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	push	ecx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_tag_c

; 2836 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN20@soap_tag_c
$LN2@soap_tag_c:

; 2837 :           s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 2838 :         }

	jmp	SHORT $LN7@soap_tag_c
$LN6@soap_tag_c:

; 2839 :         break;

	jmp	SHORT $LN18@soap_tag_c
$LN15@soap_tag_c:

; 2840 :       }
; 2841 :     }
; 2842 :     s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 2843 :     t++;

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax

; 2844 :   }

	jmp	$LN19@soap_tag_c
$LN18@soap_tag_c:

; 2845 :   if (*t == '*' && !t[1])

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN1@soap_tag_c
	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	jne	SHORT $LN1@soap_tag_c

; 2846 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN20@soap_tag_c
$LN1@soap_tag_c:

; 2847 :   return *t;

	mov	eax, DWORD PTR _t$[ebp]
	movsx	eax, BYTE PTR [eax]
$LN20@soap_tag_c:

; 2848 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_tag_cmp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@OMNLOJHP@Tags?5match?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@FGAFBKAN@Tags?5and?5?$CIdefault?$CJ?5namespaces?5ma@ ; `string'
PUBLIC	??_C@_0DA@OJDPBOJF@Tags?5?8?$CFs?8?5and?5?8?$CFs?8?5match?5but?5nam@ ; `string'
PUBLIC	_soap_match_tag
;	COMDAT ??_C@_0BH@OMNLOJHP@Tags?5match?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BH@OMNLOJHP@Tags?5match?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@ DB 'Tags ma'
	DB	'tch: ''%s'' ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FGAFBKAN@Tags?5and?5?$CIdefault?$CJ?5namespaces?5ma@
CONST	SEGMENT
??_C@_0DA@FGAFBKAN@Tags?5and?5?$CIdefault?$CJ?5namespaces?5ma@ DB 'Tags a'
	DB	'nd (default) namespaces match: ''%s'' ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OJDPBOJF@Tags?5?8?$CFs?8?5and?5?8?$CFs?8?5match?5but?5nam@
CONST	SEGMENT
??_C@_0DA@OJDPBOJF@Tags?5?8?$CFs?8?5and?5?8?$CFs?8?5match?5but?5nam@ DB 'T'
	DB	'ags ''%s'' and ''%s'' match but namespaces differ', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_match_tag
_TEXT	SEGMENT
_fdebug$83995 = -80					; size = 4
_fdebug$83985 = -68					; size = 4
_fdebug$83979 = -56					; size = 4
_fdebug$83968 = -44					; size = 4
_err$ = -32						; size = 4
_t$ = -20						; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag1$ = 12						; size = 4
_tag2$ = 16						; size = 4
_soap_match_tag PROC					; COMDAT

; 2857 : { register const char *s, *t;

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2858 :   register int err;
; 2859 :   if (!tag1 || !tag2 || !*tag2)

	cmp	DWORD PTR _tag1$[ebp], 0
	je	SHORT $LN27@soap_match@2
	cmp	DWORD PTR _tag2$[ebp], 0
	je	SHORT $LN27@soap_match@2
	mov	eax, DWORD PTR _tag2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN28@soap_match@2
$LN27@soap_match@2:

; 2860 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN29@soap_match@2
$LN28@soap_match@2:

; 2861 :   s = strchr(tag1, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag1$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$[ebp], eax

; 2862 :   t = strchr(tag2, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$[ebp], eax

; 2863 :   if (t)

	cmp	DWORD PTR _t$[ebp], 0
	je	$LN26@soap_match@2

; 2864 :   { if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN25@soap_match@2

; 2865 :     { if (t[1] && SOAP_STRCMP(s + 1, t + 1))

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN24@soap_match@2
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@soap_match@2

; 2866 :         return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	$LN29@soap_match@2
$LN24@soap_match@2:

; 2867 :       if (t != tag2 && (err = soap_match_namespace(soap, tag1, tag2, s - tag1, t - tag2)))

	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _tag2$[ebp]
	je	$LN23@soap_match@2
	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag2$[ebp]
	push	edx
	mov	eax, DWORD PTR _tag1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_namespace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	$LN23@soap_match@2

; 2868 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags '%s' and '%s' match but namespaces differ\n", tag1, tag2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN22@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN21@soap_match@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN21@soap_match@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN22@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83968[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@OJDPBOJF@Tags?5?8?$CFs?8?5and?5?8?$CFs?8?5match?5but?5nam@
	mov	edx, DWORD PTR _fdebug$83968[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83968[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@soap_match@2:

; 2869 :         if (err == SOAP_NAMESPACE)

	cmp	DWORD PTR _err$[ebp], 9
	jne	SHORT $LN19@soap_match@2

; 2870 :           return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	$LN29@soap_match@2
$LN19@soap_match@2:

; 2871 :         return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN29@soap_match@2
$LN23@soap_match@2:

; 2872 :       }
; 2873 :     }

	jmp	$LN18@soap_match@2
$LN25@soap_match@2:

; 2874 :     else if (SOAP_STRCMP(tag1, t + 1))

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@soap_match@2

; 2875 :     { return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	$LN29@soap_match@2
	jmp	$LN18@soap_match@2
$LN17@soap_match@2:

; 2876 :     }
; 2877 :     else if (t != tag2 && (err = soap_match_namespace(soap, tag1, tag2, 0, t - tag2)))

	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _tag2$[ebp]
	je	$LN18@soap_match@2
	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag2$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _tag2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag1$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_match_namespace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	$LN18@soap_match@2

; 2878 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags '%s' and '%s' match but namespaces differ\n", tag1, tag2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN14@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN13@soap_match@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN13@soap_match@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN14@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83979[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@OJDPBOJF@Tags?5?8?$CFs?8?5and?5?8?$CFs?8?5match?5but?5nam@
	mov	edx, DWORD PTR _fdebug$83979[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83979[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@soap_match@2:

; 2879 :       if (err == SOAP_NAMESPACE)

	cmp	DWORD PTR _err$[ebp], 9
	jne	SHORT $LN11@soap_match@2

; 2880 :         return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	$LN29@soap_match@2
$LN11@soap_match@2:

; 2881 :       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN29@soap_match@2
$LN18@soap_match@2:

; 2882 :     }
; 2883 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags and (default) namespaces match: '%s' '%s'\n", tag1, tag2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_match@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_match@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83985[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@FGAFBKAN@Tags?5and?5?$CIdefault?$CJ?5namespaces?5ma@
	mov	edx, DWORD PTR _fdebug$83985[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83985[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_match@2:

; 2884 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN29@soap_match@2
$LN26@soap_match@2:

; 2885 :   }
; 2886 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN7@soap_match@2

; 2887 :   { if (SOAP_STRCMP(s + 1, tag2))

	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_match@2

; 2888 :       return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	$LN29@soap_match@2
$LN6@soap_match@2:

; 2889 :   }

	jmp	SHORT $LN5@soap_match@2
$LN7@soap_match@2:

; 2890 :   else if (SOAP_STRCMP(tag1, tag2))

	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_match@2

; 2891 :     return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	SHORT $LN29@soap_match@2
$LN5@soap_match@2:

; 2892 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags match: '%s' '%s'\n", tag1, tag2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_match@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_match@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_match@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$83995[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@OMNLOJHP@Tags?5match?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@
	mov	edx, DWORD PTR _fdebug$83995[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$83995[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_match@2:

; 2893 :   return SOAP_OK;

	xor	eax, eax
$LN29@soap_match@2:

; 2894 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_match_tag ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@ECKCECKJ@Array?5type?5mismatch?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@		; `string'
PUBLIC	??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@		; `string'
PUBLIC	_soap_match_array
;	COMDAT ??_C@_0CA@ECKCECKJ@Array?5type?5mismatch?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0CA@ECKCECKJ@Array?5type?5mismatch?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@ DB 'A'
	DB	'rray type mismatch: ''%s'' ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@
CONST	SEGMENT
??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@ DB 'xsd:ur-type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
CONST	SEGMENT
??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@ DB 'xsd:anyType', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_match_array
_TEXT	SEGMENT
_fdebug$84009 = -8					; size = 4
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_soap_match_array PROC					; COMDAT

; 2903 : { if (*soap->arrayType)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+84148]
	test	ecx, ecx
	je	$LN5@soap_match@3

; 2904 :     if (soap_match_tag(soap, soap->arrayType, type)
; 2905 :      && soap_match_tag(soap, soap->arrayType, "xsd:anyType")
; 2906 :      && soap_match_tag(soap, soap->arrayType, "xsd:ur-type")
; 2907 :    )

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 84148				; 000148b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@soap_match@3
	push	OFFSET ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 84148				; 000148b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@soap_match@3
	push	OFFSET ??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 84148				; 000148b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_match@3

; 2908 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array type mismatch: '%s' '%s'\n", soap->arrayType, type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_match@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_match@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_match@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_match@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84009[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 84148				; 000148b4H
	push	ecx
	push	OFFSET ??_C@_0CA@ECKCECKJ@Array?5type?5mismatch?3?5?8?$CFs?8?5?8?$CFs?8?6?$AA@
	mov	edx, DWORD PTR _fdebug$84009[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84009[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_match@3:

; 2909 :       return SOAP_TAG_MISMATCH;

	mov	eax, 3
	jmp	SHORT $LN6@soap_match@3
$LN5@soap_match@3:

; 2910 :     }
; 2911 :   return SOAP_OK;

	xor	eax, eax
$LN6@soap_match@3:

; 2912 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_match_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EHENFOGH@Free?5logfiles?6?$AA@		; `string'
PUBLIC	_soap_poll
PUBLIC	??_C@_0BG@OBLNGLHM@Removing?5plugin?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	_soap_closesock
PUBLIC	?__LINE__Var@?1??soap_done@@9@4JA		; `soap_done'::`2'::__LINE__Var
PUBLIC	_soap_free_temp
PUBLIC	??_C@_0BD@JMKMFCLB@Done?5with?5context?6?$AA@	; `string'
PUBLIC	_soap_done
;	COMDAT ??_C@_0P@EHENFOGH@Free?5logfiles?6?$AA@
CONST	SEGMENT
??_C@_0P@EHENFOGH@Free?5logfiles?6?$AA@ DB 'Free logfiles', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OBLNGLHM@Removing?5plugin?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BG@OBLNGLHM@Removing?5plugin?5?8?$CFs?8?6?$AA@ DB 'Removing plugin'
	DB	' ''%s''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_done@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_done@@9@4JA DD 0ce8H		; `soap_done'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@JMKMFCLB@Done?5with?5context?6?$AA@
CONST	SEGMENT
??_C@_0BD@JMKMFCLB@Done?5with?5context?6?$AA@ DB 'Done with context', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_done
_TEXT	SEGMENT
_fdebug$84061 = -68					; size = 4
_fdebug$84049 = -56					; size = 4
_p$84044 = -44						; size = 4
_p$84039 = -32						; size = 4
_fdebug$84034 = -20					; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_done PROC						; COMDAT

; 3304 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3305 : #ifdef SOAP_DEBUG
; 3306 :   int i;
; 3307 : #endif
; 3308 :   if (soap_check_state(soap))

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN22@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN23@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN23@soap_done
$LN22@soap_done:

; 3309 :     return;

	jmp	$LN24@soap_done
$LN23@soap_done:

; 3310 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Done with context\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN20@soap_done
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN20@soap_done:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84034[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BD@JMKMFCLB@Done?5with?5context?6?$AA@
	mov	eax, DWORD PTR _fdebug$84034[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84034[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_done:

; 3311 :   soap_free_temp(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_temp
	add	esp, 4
$LN18@soap_done:

; 3312 :   while (soap->clist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN17@soap_done

; 3313 :   { struct soap_clist *p = soap->clist->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$84039[ebp], edx

; 3314 :     SOAP_FREE(soap, soap->clist);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_done@@9@4JA
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 3315 :     soap->clist = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _p$84039[ebp]
	mov	DWORD PTR [eax+96], ecx

; 3316 :   }

	jmp	SHORT $LN18@soap_done
$LN17@soap_done:

; 3317 :   soap->keep_alive = 0; /* to force close the socket */

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 3318 :   soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
$LN16@soap_done:

; 3319 : #ifdef WITH_COOKIES
; 3320 :   soap_free_cookies(soap);
; 3321 : #endif
; 3322 :   while (soap->plugins)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12220], 0
	je	$LN15@soap_done

; 3323 :   { register struct soap_plugin *p = soap->plugins->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$84044[ebp], edx

; 3324 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Removing plugin '%s'\n", soap->plugins->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN14@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN13@soap_done
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN13@soap_done:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN14@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84049[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_0BG@OBLNGLHM@Removing?5plugin?5?8?$CFs?8?6?$AA@
	mov	eax, DWORD PTR _fdebug$84049[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84049[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@soap_done:

; 3325 :     if (soap->plugins->fcopy || soap->state == SOAP_INIT)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN10@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN11@soap_done
$LN10@soap_done:

; 3326 :       soap->plugins->fdelete(soap, soap->plugins);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@soap_done:

; 3327 :     SOAP_FREE(soap, soap->plugins);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_done@@9@4JA
	add	edx, 23					; 00000017H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 3328 :     soap->plugins = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _p$84044[ebp]
	mov	DWORD PTR [eax+12220], ecx

; 3329 :   }

	jmp	$LN16@soap_done
$LN15@soap_done:

; 3330 :   soap->fplugin = fplugin;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12332], OFFSET _fplugin

; 3331 :   soap->fmalloc = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12336], 0

; 3332 : #ifndef WITH_NOHTTP
; 3333 :   soap->fpost = http_post;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12232], OFFSET _http_post

; 3334 :   soap->fget = http_get;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12236], OFFSET _http_get

; 3335 :   soap->fput = http_put;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12240], OFFSET _http_put

; 3336 :   soap->fdel = http_del;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12244], OFFSET _http_del

; 3337 :   soap->fhead = http_head;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12248], OFFSET _http_head

; 3338 :   soap->fform = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12252], 0

; 3339 :   soap->fposthdr = http_post_header;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12256], OFFSET _http_post_header

; 3340 :   soap->fresponse = http_response;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12260], OFFSET _http_response

; 3341 :   soap->fparse = http_parse;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12264], OFFSET _http_parse

; 3342 :   soap->fparsehdr = http_parse_header;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12268], OFFSET _http_parse_header

; 3343 : #endif
; 3344 :   soap->fheader = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12272], 0

; 3345 : #ifndef WITH_NOIO
; 3346 : #ifndef WITH_IPV6
; 3347 :   soap->fresolve = tcp_gethost;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12276], OFFSET _tcp_gethost

; 3348 : #else
; 3349 :   soap->fresolve = NULL;
; 3350 : #endif
; 3351 :   soap->faccept = tcp_accept;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12300], OFFSET _tcp_accept

; 3352 :   soap->fopen = tcp_connect;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12296], OFFSET _tcp_connect

; 3353 :   soap->fclose = tcp_disconnect;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12304], OFFSET _tcp_disconnect

; 3354 :   soap->fclosesocket = tcp_closesocket;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12288], OFFSET _tcp_closesocket

; 3355 :   soap->fshutdownsocket = tcp_shutdownsocket;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12292], OFFSET _tcp_shutdownsocket

; 3356 :   soap->fsend = fsend;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12308], OFFSET _fsend

; 3357 :   soap->frecv = frecv;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12312], OFFSET _frecv

; 3358 :   soap->fpoll = soap_poll;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12316], OFFSET _soap_poll

; 3359 : #else
; 3360 :   soap->fopen = NULL;
; 3361 :   soap->fclose = NULL;
; 3362 :   soap->fpoll = NULL;
; 3363 : #endif
; 3364 : #ifndef WITH_LEANER
; 3365 :   soap->fprepareinit = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12340], 0

; 3366 :   soap->fpreparesend = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12344], 0

; 3367 :   soap->fpreparerecv = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12348], 0

; 3368 :   soap->fpreparefinal = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12352], 0

; 3369 : #endif
; 3370 :   soap->fseterror = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12320], 0

; 3371 :   soap->fignore = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12324], 0

; 3372 :   soap->fserveloop = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12328], 0

; 3373 : #ifdef WITH_OPENSSL
; 3374 :   if (soap->session)
; 3375 :   { SSL_SESSION_free(soap->session);
; 3376 :     soap->session = NULL;
; 3377 :   }
; 3378 : #endif
; 3379 :   if (soap->state == SOAP_INIT)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN9@soap_done

; 3380 :   { if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	je	SHORT $LN9@soap_done

; 3381 :     { soap->fclosesocket(soap, soap->master);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12404]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12288]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3382 :       soap->master = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12404], -1
$LN9@soap_done:

; 3383 :     }
; 3384 : #ifdef WITH_OPENSSL
; 3385 :     if (soap->ctx)
; 3386 :     { SSL_CTX_free(soap->ctx);
; 3387 :       soap->ctx = NULL;
; 3388 :     }
; 3389 : #endif
; 3390 :   }
; 3391 : #ifdef WITH_ZLIB
; 3392 :   if (soap->d_stream)
; 3393 :   { SOAP_FREE(soap, (void*)soap->d_stream);
; 3394 :     soap->d_stream = NULL;
; 3395 :   }
; 3396 :   if (soap->z_buf)
; 3397 :   { SOAP_FREE(soap, (void*)soap->z_buf);
; 3398 :     soap->z_buf = NULL;
; 3399 :   }
; 3400 : #endif
; 3401 : #ifdef SOAP_DEBUG
; 3402 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free logfiles\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_done
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_done:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_done
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84061[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0P@EHENFOGH@Free?5logfiles?6?$AA@
	mov	eax, DWORD PTR _fdebug$84061[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84061[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_done:

; 3403 :   for (i = 0; i < SOAP_MAXLOGS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@soap_done
$LN3@soap_done:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@soap_done:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN2@soap_done

; 3404 :   { if (soap->logfile[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [ecx+eax*4+90548], 0
	je	SHORT $LN1@soap_done

; 3405 :     { SOAP_FREE(soap, (void*)soap->logfile[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90548]
	push	edx
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_done@@9@4JA
	add	eax, 101				; 00000065H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 3406 :       soap->logfile[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90548], 0
$LN1@soap_done:

; 3407 :     }
; 3408 :     soap_close_logfile(soap, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_close_logfile
	add	esp, 8

; 3409 :   }

	jmp	SHORT $LN3@soap_done
$LN2@soap_done:

; 3410 :   soap->state = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+4], ax

; 3411 : #endif
; 3412 : #ifdef SOAP_MEM_DEBUG
; 3413 :   soap_free_mht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_mht
	add	esp, 4
$LN24@soap_done:

; 3414 : #endif
; 3415 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_done ENDP
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp__rand:PROC
EXTRN	_send@16:PROC
EXTRN	_sendto@24:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	_select@20:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _fsend
_TEXT	SEGMENT
tv78 = -1120						; size = 4
_fd$82396 = -920					; size = 260
_timeout$82395 = -652					; size = 8
_r$82392 = -636						; size = 4
_udp_delay$82366 = -624					; size = 4
_udp_repeat$82365 = -612				; size = 4
_fd$82364 = -600					; size = 260
_timeout$82363 = -332					; size = 8
_r$82340 = -316						; size = 4
_fd$82339 = -304					; size = 260
_timeout$82338 = -36					; size = 8
_err$ = -20						; size = 4
_nwritten$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_fsend	PROC						; COMDAT

; 504  : { register int nwritten, err;

	push	ebp
	mov	ebp, esp
	sub	esp, 1120				; 00000460H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1120]
	mov	ecx, 280				; 00000118H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 505  : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 506  :   if (soap->os)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12412], 0
	je	SHORT $LN50@fsend

; 507  :   { soap->os->write(s, (std::streamsize)n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+12412]
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 508  :     if (soap->os->good())

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12412]
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR tv78[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN51@fsend

; 509  :       return SOAP_OK;

	xor	eax, eax
	jmp	$LN53@fsend
$LN51@fsend:

; 510  :     soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 511  :     return SOAP_EOF;

	or	eax, -1
	jmp	$LN53@fsend
$LN50@fsend:

; 512  :   }
; 513  : #endif
; 514  :   while (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	$LN49@fsend

; 515  :   { if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	$LN48@fsend

; 516  :     {
; 517  : #ifndef WITH_LEAN
; 518  :       if (soap->send_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN47@fsend
$LN46@fsend:

; 519  :       {
; 520  : #ifndef WIN32
; 521  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 522  :           return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 523  : #endif
; 524  :         for (;;)
; 525  :         { struct timeval timeout;
; 526  :           fd_set fd;
; 527  :           register int r;
; 528  :           if (soap->send_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LN44@fsend

; 529  :           { timeout.tv_sec = soap->send_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _timeout$82338[ebp], ecx

; 530  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$82338[ebp+4], 0

; 531  :           }
; 532  :           else

	jmp	SHORT $LN43@fsend
$LN44@fsend:

; 533  :           { timeout.tv_sec = -soap->send_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+52]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82338[ebp], eax

; 534  :             timeout.tv_usec = -soap->send_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+52]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82338[ebp+4], edx
$LN43@fsend:

; 535  :           }
; 536  :           FD_ZERO(&fd);

	mov	DWORD PTR _fd$82339[ebp], 0
$LN42@fsend:

; 537  :           FD_SET(soap->socket, &fd);

	cmp	DWORD PTR _fd$82339[ebp], 64		; 00000040H
	jae	SHORT $LN41@fsend
	mov	eax, DWORD PTR _fd$82339[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _fd$82339[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$82339[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$82339[ebp], eax
$LN41@fsend:
	xor	eax, eax
	jne	SHORT $LN42@fsend

; 538  : #ifdef WITH_OPENSSL
; 539  :           if (soap->ssl)
; 540  :             r = select((int)soap->socket + 1, &fd, &fd, &fd, &timeout);
; 541  :           else
; 542  : #endif
; 543  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$82338[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$82339[ebp]
	push	ecx
	lea	edx, DWORD PTR _fd$82339[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	add	ecx, 1
	push	ecx
	call	_select@20
	mov	DWORD PTR _r$82340[ebp], eax

; 544  :           if (r > 0)

	cmp	DWORD PTR _r$82340[ebp], 0
	jle	SHORT $LN38@fsend

; 545  :             break;

	jmp	SHORT $LN47@fsend
$LN38@fsend:

; 546  :           if (!r)

	cmp	DWORD PTR _r$82340[ebp], 0
	jne	SHORT $LN37@fsend

; 547  :           { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 548  :             return SOAP_EOF;

	or	eax, -1
	jmp	$LN53@fsend
$LN37@fsend:

; 549  :           }
; 550  :           err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _err$[ebp], eax

; 551  :           if (err != SOAP_EINTR && err != SOAP_EAGAIN && err != SOAP_EWOULDBLOCK)

	cmp	DWORD PTR _err$[ebp], 10004		; 00002714H
	je	SHORT $LN36@fsend
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN36@fsend
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN36@fsend

; 552  :           { soap->errnum = err;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 553  :             return SOAP_EOF;

	or	eax, -1
	jmp	$LN53@fsend
$LN36@fsend:

; 554  :           }
; 555  :         }

	jmp	$LN46@fsend
$LN47@fsend:

; 556  :       }
; 557  : #endif
; 558  : #ifdef WITH_OPENSSL
; 559  :       if (soap->ssl)
; 560  :         nwritten = SSL_write(soap->ssl, s, (int)n);
; 561  :       else if (soap->bio)
; 562  :         nwritten = BIO_write(soap->bio, s, (int)n);
; 563  :       else
; 564  : #endif
; 565  : #ifndef WITH_LEAN
; 566  :       if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	$LN35@fsend

; 567  :       { if (soap->peerlen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+94708], 0
	je	SHORT $LN34@fsend

; 568  :           nwritten = sendto(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, (SOAP_WINSOCKINT)soap->peerlen);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+94708]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 94692				; 000171e4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_sendto@24
	mov	DWORD PTR _nwritten$[ebp], eax

; 569  :         else

	jmp	SHORT $LN33@fsend
$LN34@fsend:

; 570  :           nwritten = send(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_send@16
	mov	DWORD PTR _nwritten$[ebp], eax
$LN33@fsend:

; 571  :         /* retry and back-off algorithm */
; 572  :         /* TODO: this is not very clear from specs so verify and limit conditions under which we should loop (e.g. ENOBUFS) */
; 573  :         if (nwritten < 0)

	cmp	DWORD PTR _nwritten$[ebp], 0
	jge	$LN32@fsend

; 574  :         { struct timeval timeout;
; 575  :           fd_set fd;
; 576  :           int udp_repeat;
; 577  :           int udp_delay;
; 578  : #ifndef WIN32
; 579  :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 580  :             return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 581  : #endif
; 582  :           if ((soap->connect_flags & SO_BROADCAST))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 32					; 00000020H
	je	SHORT $LN31@fsend

; 583  :             udp_repeat = 3; /* SOAP-over-UDP MULTICAST_UDP_REPEAT - 1 */

	mov	DWORD PTR _udp_repeat$82365[ebp], 3

; 584  :           else

	jmp	SHORT $LN30@fsend
$LN31@fsend:

; 585  :             udp_repeat = 1; /* SOAP-over-UDP UNICAST_UDP_REPEAT - 1 */

	mov	DWORD PTR _udp_repeat$82365[ebp], 1
$LN30@fsend:

; 586  :           udp_delay = (soap_random % 201) + 50; /* UDP_MIN_DELAY .. UDP_MAX_DELAY */

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 201				; 000000c9H
	idiv	ecx
	add	edx, 50					; 00000032H
	mov	DWORD PTR _udp_delay$82366[ebp], edx
$LN29@fsend:

; 587  :           do
; 588  :           { timeout.tv_sec = 0;

	mov	DWORD PTR _timeout$82363[ebp], 0

; 589  :             timeout.tv_usec = 1000 * udp_delay; /* ms */

	mov	eax, DWORD PTR _udp_delay$82366[ebp]
	imul	eax, 1000				; 000003e8H
	mov	DWORD PTR _timeout$82363[ebp+4], eax

; 590  :             FD_ZERO(&fd);

	mov	DWORD PTR _fd$82364[ebp], 0
$LN26@fsend:

; 591  :             FD_SET(soap->socket, &fd);

	cmp	DWORD PTR _fd$82364[ebp], 64		; 00000040H
	jae	SHORT $LN25@fsend
	mov	eax, DWORD PTR _fd$82364[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _fd$82364[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$82364[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$82364[ebp], eax
$LN25@fsend:
	xor	eax, eax
	jne	SHORT $LN26@fsend

; 592  :             select((int)soap->socket + 1, NULL, NULL, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$82363[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$82364[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12408]
	add	eax, 1
	push	eax
	call	_select@20

; 593  :             if (soap->peerlen)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+94708], 0
	je	SHORT $LN22@fsend

; 594  :               nwritten = sendto(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, (SOAP_WINSOCKINT)soap->peerlen);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+94708]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 94692				; 000171e4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_sendto@24
	mov	DWORD PTR _nwritten$[ebp], eax

; 595  :             else

	jmp	SHORT $LN21@fsend
$LN22@fsend:

; 596  :               nwritten = send(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_send@16
	mov	DWORD PTR _nwritten$[ebp], eax
$LN21@fsend:

; 597  :             udp_delay <<= 1;

	mov	eax, DWORD PTR _udp_delay$82366[ebp]
	shl	eax, 1
	mov	DWORD PTR _udp_delay$82366[ebp], eax

; 598  :             if (udp_delay > 500) /* UDP_UPPER_DELAY */

	cmp	DWORD PTR _udp_delay$82366[ebp], 500	; 000001f4H
	jle	SHORT $LN28@fsend

; 599  :               udp_delay = 500;

	mov	DWORD PTR _udp_delay$82366[ebp], 500	; 000001f4H
$LN28@fsend:

; 600  :           }
; 601  :           while (nwritten < 0 && --udp_repeat > 0);

	cmp	DWORD PTR _nwritten$[ebp], 0
	jge	SHORT $LN32@fsend
	mov	eax, DWORD PTR _udp_repeat$82365[ebp]
	sub	eax, 1
	mov	DWORD PTR _udp_repeat$82365[ebp], eax
	cmp	DWORD PTR _udp_repeat$82365[ebp], 0
	jg	$LN29@fsend
$LN32@fsend:

; 602  :         }
; 603  :       }
; 604  :       else

	jmp	SHORT $LN18@fsend
$LN35@fsend:

; 605  : #endif
; 606  : #if !defined(PALM) && !defined(AS400)
; 607  :         nwritten = send(soap->socket, s, (int)n, soap->socket_flags);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_send@16
	mov	DWORD PTR _nwritten$[ebp], eax
$LN18@fsend:

; 608  : #else
; 609  :         nwritten = send(soap->socket, (void*)s, n, soap->socket_flags);
; 610  : #endif
; 611  :       if (nwritten <= 0)

	cmp	DWORD PTR _nwritten$[ebp], 0
	jg	$LN17@fsend

; 612  :       {
; 613  : #if defined(WITH_OPENSSL) || !defined(WITH_LEAN)
; 614  :         register int r = 0;

	mov	DWORD PTR _r$82392[ebp], 0

; 615  : #endif
; 616  :         err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _err$[ebp], eax

; 617  : #ifdef WITH_OPENSSL
; 618  :         if (soap->ssl && (r = SSL_get_error(soap->ssl, nwritten)) != SSL_ERROR_NONE && r != SSL_ERROR_WANT_READ && r != SSL_ERROR_WANT_WRITE)
; 619  :         { soap->errnum = err;
; 620  :           return SOAP_EOF;
; 621  :         }
; 622  : #endif
; 623  :         if (err == SOAP_EWOULDBLOCK || err == SOAP_EAGAIN)

	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN15@fsend
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	jne	$LN16@fsend
$LN15@fsend:

; 624  :         {
; 625  : #ifndef WITH_LEAN
; 626  :           struct timeval timeout;
; 627  :           fd_set fd;
; 628  : #ifndef WIN32
; 629  :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 630  :             return SOAP_FD_EXCEEDED; /* Hint: MUST increase FD_SETSIZE */
; 631  : #endif
; 632  :           if (soap->send_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LN14@fsend

; 633  :           { timeout.tv_sec = soap->send_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _timeout$82395[ebp], ecx

; 634  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$82395[ebp+4], 0
	jmp	SHORT $LN13@fsend
$LN14@fsend:

; 635  :           }
; 636  :           else if (soap->send_timeout < 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jge	SHORT $LN12@fsend

; 637  :           { timeout.tv_sec = -soap->send_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+52]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82395[ebp], eax

; 638  :             timeout.tv_usec = -soap->send_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+52]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82395[ebp+4], edx

; 639  :           }
; 640  :           else

	jmp	SHORT $LN13@fsend
$LN12@fsend:

; 641  :           { timeout.tv_sec = 0;

	mov	DWORD PTR _timeout$82395[ebp], 0

; 642  :             timeout.tv_usec = 10000;

	mov	DWORD PTR _timeout$82395[ebp+4], 10000	; 00002710H
$LN13@fsend:

; 643  :           }
; 644  :           FD_ZERO(&fd);

	mov	DWORD PTR _fd$82396[ebp], 0
$LN10@fsend:

; 645  :           FD_SET(soap->socket, &fd);

	cmp	DWORD PTR _fd$82396[ebp], 64		; 00000040H
	jae	SHORT $LN9@fsend
	mov	eax, DWORD PTR _fd$82396[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _fd$82396[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$82396[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$82396[ebp], eax
$LN9@fsend:
	xor	eax, eax
	jne	SHORT $LN10@fsend

; 646  : #ifdef WITH_OPENSSL
; 647  :           if (soap->ssl && r == SSL_ERROR_WANT_READ)
; 648  :             r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 649  :           else
; 650  :             r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);
; 651  : #else
; 652  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$82395[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$82396[ebp]
	push	ecx
	lea	edx, DWORD PTR _fd$82396[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	add	ecx, 1
	push	ecx
	call	_select@20
	mov	DWORD PTR _r$82392[ebp], eax

; 653  : #endif
; 654  :           if (r < 0 && (r = soap_socket_errno(soap->socket)) != SOAP_EINTR)

	cmp	DWORD PTR _r$82392[ebp], 0
	jge	SHORT $LN6@fsend
	call	_WSAGetLastError@0
	mov	DWORD PTR _r$82392[ebp], eax
	cmp	DWORD PTR _r$82392[ebp], 10004		; 00002714H
	je	SHORT $LN6@fsend

; 655  :           { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$82392[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 656  :             return SOAP_EOF;

	or	eax, -1
	jmp	$LN53@fsend
$LN6@fsend:

; 657  :           }
; 658  : #endif
; 659  :         }

	jmp	SHORT $LN5@fsend
$LN16@fsend:

; 660  :         else if (err && err != SOAP_EINTR)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN5@fsend
	cmp	DWORD PTR _err$[ebp], 10004		; 00002714H
	je	SHORT $LN5@fsend

; 661  :         { soap->errnum = err;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 662  :           return SOAP_EOF;

	or	eax, -1
	jmp	$LN53@fsend
$LN5@fsend:

; 663  :         }
; 664  :         nwritten = 0; /* and call write() again */

	mov	DWORD PTR _nwritten$[ebp], 0
$LN17@fsend:

; 665  :       }
; 666  :     }
; 667  :     else

	jmp	SHORT $LN3@fsend
$LN48@fsend:

; 668  :     {
; 669  : #ifdef WITH_FASTCGI
; 670  :       nwritten = fwrite((void*)s, 1, n, stdout);
; 671  :       fflush(stdout);
; 672  : #else
; 673  : #ifdef UNDER_CE
; 674  :       nwritten = fwrite(s, 1, n, soap->sendfd);
; 675  : #else
; 676  : #ifdef VXWORKS
; 677  : #ifdef WMW_RPM_IO
; 678  :       if (soap->rpmreqid)
; 679  :         nwritten = (httpBlockPut(soap->rpmreqid, s, n) == 0) ? n : -1;
; 680  :       else
; 681  : #endif
; 682  :         nwritten = fwrite(s, sizeof(char), n, fdopen(soap->sendfd, "w"));
; 683  : #else
; 684  :       nwritten = write(soap->sendfd, s, (unsigned int)n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12420]
	push	eax
	call	DWORD PTR __imp__write
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nwritten$[ebp], eax

; 685  : #endif
; 686  : #endif
; 687  : #endif
; 688  :       if (nwritten <= 0)

	cmp	DWORD PTR _nwritten$[ebp], 0
	jg	SHORT $LN3@fsend

; 689  :       { err = soap_errno;

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax

; 690  :         if (err && err != SOAP_EINTR && err != SOAP_EWOULDBLOCK && err != SOAP_EAGAIN)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN1@fsend
	cmp	DWORD PTR _err$[ebp], 10004		; 00002714H
	je	SHORT $LN1@fsend
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN1@fsend
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN1@fsend

; 691  :         { soap->errnum = err;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 692  :           return SOAP_EOF;

	or	eax, -1
	jmp	SHORT $LN53@fsend
$LN1@fsend:

; 693  :         }
; 694  :         nwritten = 0; /* and call write() again */

	mov	DWORD PTR _nwritten$[ebp], 0
$LN3@fsend:

; 695  :       }
; 696  :     }
; 697  :     n -= nwritten;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _nwritten$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 698  :     s += nwritten;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _nwritten$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 699  :   }

	jmp	$LN50@fsend
$LN49@fsend:

; 700  :   return SOAP_OK;

	xor	eax, eax
$LN53@fsend:

; 701  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN62@fsend
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 1120				; 00000460H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@fsend:
	DD	6
	DD	$LN61@fsend
$LN61@fsend:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN55@fsend
	DD	-304					; fffffed0H
	DD	260					; 00000104H
	DD	$LN56@fsend
	DD	-332					; fffffeb4H
	DD	8
	DD	$LN57@fsend
	DD	-600					; fffffda8H
	DD	260					; 00000104H
	DD	$LN58@fsend
	DD	-652					; fffffd74H
	DD	8
	DD	$LN59@fsend
	DD	-920					; fffffc68H
	DD	260					; 00000104H
	DD	$LN60@fsend
$LN60@fsend:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN59@fsend:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN58@fsend:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN57@fsend:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN56@fsend:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN55@fsend:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_fsend	ENDP
_TEXT	ENDS
EXTRN	__imp__read:PROC
EXTRN	_recv@16:PROC
EXTRN	_ntohl@4:PROC
EXTRN	_recvfrom@24:PROC
EXTRN	_memset:PROC
EXTRN	__imp_?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ:PROC
EXTRN	__imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _frecv
_TEXT	SEGMENT
tv231 = -800						; size = 4
tv75 = -800						; size = 4
_fd$82530 = -600					; size = 260
_timeout$82529 = -332					; size = 8
_k$82518 = -316						; size = 4
_fd$82502 = -304					; size = 260
_timeout$82501 = -36					; size = 8
_retries$ = -20						; size = 4
_r$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_frecv	PROC						; COMDAT

; 856  : { register int r;

	push	ebp
	mov	ebp, esp
	sub	esp, 800				; 00000320H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-800]
	mov	ecx, 200				; 000000c8H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : #ifndef WITH_LEAN
; 858  :   register int retries = 100; /* max 100 retries with non-blocking sockets */

	mov	DWORD PTR _retries$[ebp], 100		; 00000064H

; 859  : #endif
; 860  :   soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 861  : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 862  :   if (soap->is)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12416], 0
	je	SHORT $LN34@frecv

; 863  :   { if (soap->is->good())

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12416]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv75[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@frecv

; 864  :       return soap->is->read(s, (std::streamsize)n).gcount();

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+12416]
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN35@frecv
$LN33@frecv:

; 865  :     return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN34@frecv:

; 866  :   }
; 867  : #endif
; 868  :   if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	$LN32@frecv
$LN31@frecv:

; 869  :   { for (;;)
; 870  :     {
; 871  : #ifdef WITH_OPENSSL
; 872  :       register int err = 0;
; 873  : #endif
; 874  : #ifndef WITH_LEAN
; 875  : #ifdef WITH_OPENSSL
; 876  :       if (soap->recv_timeout && !soap->ssl) /* SSL: sockets are nonblocking */
; 877  : #else
; 878  :       if (soap->recv_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN29@frecv
$LN28@frecv:

; 879  : #endif
; 880  :       {
; 881  : #ifndef WIN32
; 882  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 883  :         { soap->error = SOAP_FD_EXCEEDED;
; 884  :           return 0;	/* Hint: MUST increase FD_SETSIZE */
; 885  :         }
; 886  : #endif
; 887  :         for (;;)
; 888  :         { struct timeval timeout;
; 889  :           fd_set fd;
; 890  :           if (soap->recv_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jle	SHORT $LN26@frecv

; 891  :           { timeout.tv_sec = soap->recv_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _timeout$82501[ebp], ecx

; 892  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$82501[ebp+4], 0

; 893  :           }
; 894  :           else

	jmp	SHORT $LN25@frecv
$LN26@frecv:

; 895  :           { timeout.tv_sec = -soap->recv_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+48]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82501[ebp], eax

; 896  :             timeout.tv_usec = -soap->recv_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+48]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82501[ebp+4], edx
$LN25@frecv:

; 897  :           }
; 898  :           FD_ZERO(&fd);

	mov	DWORD PTR _fd$82502[ebp], 0
$LN24@frecv:

; 899  :           FD_SET(soap->socket, &fd);

	cmp	DWORD PTR _fd$82502[ebp], 64		; 00000040H
	jae	SHORT $LN23@frecv
	mov	eax, DWORD PTR _fd$82502[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _fd$82502[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$82502[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$82502[ebp], eax
$LN23@frecv:
	xor	eax, eax
	jne	SHORT $LN24@frecv

; 900  :           r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$82501[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$82502[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _fd$82502[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	add	ecx, 1
	push	ecx
	call	_select@20
	mov	DWORD PTR _r$[ebp], eax

; 901  :           if (r > 0)

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN20@frecv

; 902  :             break;

	jmp	SHORT $LN29@frecv
$LN20@frecv:

; 903  :           if (!r)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN19@frecv

; 904  :           { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 905  :             return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN19@frecv:

; 906  :           }
; 907  :           r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _r$[ebp], eax

; 908  :           if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	DWORD PTR _r$[ebp], 10004		; 00002714H
	je	SHORT $LN18@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN18@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN18@frecv

; 909  :           { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 910  :             return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN18@frecv:

; 911  :           }
; 912  :         }

	jmp	$LN28@frecv
$LN29@frecv:

; 913  :       }
; 914  : #endif
; 915  : #ifdef WITH_OPENSSL
; 916  :       if (soap->ssl)
; 917  :       { r = SSL_read(soap->ssl, s, (int)n);
; 918  :         if (r > 0)
; 919  :           return (size_t)r;
; 920  :         err = SSL_get_error(soap->ssl, r);
; 921  :         if (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE)
; 922  :           return 0;
; 923  :       }
; 924  :       else if (soap->bio)
; 925  :       { r = BIO_read(soap->bio, s, (int)n);
; 926  :         if (r > 0)
; 927  :           return (size_t)r;
; 928  :         return 0;
; 929  :       }
; 930  :       else
; 931  : #endif
; 932  :       {
; 933  : #ifndef WITH_LEAN
; 934  :         if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN17@frecv

; 935  :         { SOAP_SOCKLEN_T k = (SOAP_SOCKLEN_T)sizeof(soap->peer);

	mov	DWORD PTR _k$82518[ebp], 16		; 00000010H

; 936  :           memset((void*)&soap->peer, 0, sizeof(soap->peer));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 937  :           r = recvfrom(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, &k);	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	lea	eax, DWORD PTR _k$82518[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 94692				; 000171e4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	call	_recvfrom@24
	mov	DWORD PTR _r$[ebp], eax

; 938  :           soap->peerlen = (size_t)k;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _k$82518[ebp]
	mov	DWORD PTR [eax+94708], ecx

; 939  : #ifndef WITH_IPV6
; 940  :           soap->ip = ntohl(soap->peer.sin_addr.s_addr);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+94696]
	push	ecx
	call	_ntohl@4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90404], eax

; 941  : #endif
; 942  :         }
; 943  :         else

	jmp	SHORT $LN16@frecv
$LN17@frecv:

; 944  : #endif
; 945  :           r = recv(soap->socket, s, (int)n, soap->socket_flags);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_recv@16
	mov	DWORD PTR _r$[ebp], eax
$LN16@frecv:

; 946  : #ifdef PALM
; 947  :         /* CycleSyncDisplay(curStatusMsg); */
; 948  : #endif
; 949  :         if (r >= 0)

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN15@frecv

; 950  :           return (size_t)r;

	mov	eax, DWORD PTR _r$[ebp]
	jmp	$LN35@frecv
$LN15@frecv:

; 951  :         r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _r$[ebp], eax

; 952  :         if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	DWORD PTR _r$[ebp], 10004		; 00002714H
	je	SHORT $LN14@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN14@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN14@frecv

; 953  :         { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 954  :           return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN14@frecv:

; 955  :         }
; 956  :       }
; 957  : #ifndef WITH_LEAN
; 958  :       { struct timeval timeout;
; 959  :         fd_set fd;
; 960  :         if (soap->recv_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jle	SHORT $LN13@frecv

; 961  :         { timeout.tv_sec = soap->recv_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _timeout$82529[ebp], ecx

; 962  :           timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$82529[ebp+4], 0
	jmp	SHORT $LN12@frecv
$LN13@frecv:

; 963  :         }
; 964  :         else if (soap->recv_timeout < 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jge	SHORT $LN11@frecv

; 965  :         { timeout.tv_sec = -soap->recv_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+48]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82529[ebp], eax

; 966  :           timeout.tv_usec = -soap->recv_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+48]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$82529[ebp+4], edx

; 967  :         }
; 968  :         else

	jmp	SHORT $LN12@frecv
$LN11@frecv:

; 969  :         { timeout.tv_sec = 5;

	mov	DWORD PTR _timeout$82529[ebp], 5

; 970  :           timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$82529[ebp+4], 0
$LN12@frecv:

; 971  :         }
; 972  : #ifndef WIN32
; 973  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 974  :         { soap->error = SOAP_FD_EXCEEDED;
; 975  :           return 0;	/* Hint: MUST increase FD_SETSIZE */
; 976  :         }
; 977  : #endif
; 978  :         FD_ZERO(&fd);

	mov	DWORD PTR _fd$82530[ebp], 0
$LN9@frecv:

; 979  :         FD_SET(soap->socket, &fd);

	cmp	DWORD PTR _fd$82530[ebp], 64		; 00000040H
	jae	SHORT $LN8@frecv
	mov	eax, DWORD PTR _fd$82530[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _fd$82530[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$82530[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$82530[ebp], eax
$LN8@frecv:
	xor	eax, eax
	jne	SHORT $LN9@frecv

; 980  : #ifdef WITH_OPENSSL
; 981  :         if (soap->ssl && err == SSL_ERROR_WANT_WRITE)
; 982  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);
; 983  :         else
; 984  :           r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 985  : #else
; 986  :         r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$82529[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$82530[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _fd$82530[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	add	ecx, 1
	push	ecx
	call	_select@20
	mov	DWORD PTR _r$[ebp], eax

; 987  : #endif
; 988  :         if (!r && soap->recv_timeout)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN5@frecv
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@frecv

; 989  :         { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 990  :           return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN5@frecv:

; 991  :         }
; 992  :         if (r < 0)

	cmp	DWORD PTR _r$[ebp], 0
	jge	SHORT $LN4@frecv

; 993  :         { r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _r$[ebp], eax

; 994  :           if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	DWORD PTR _r$[ebp], 10004		; 00002714H
	je	SHORT $LN4@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN4@frecv
	cmp	DWORD PTR _r$[ebp], 10035		; 00002733H
	je	SHORT $LN4@frecv

; 995  :           { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 996  :             return 0;

	xor	eax, eax
	jmp	$LN35@frecv
$LN4@frecv:

; 997  :           }
; 998  :         }
; 999  :         if (retries-- <= 0)

	mov	eax, DWORD PTR _retries$[ebp]
	mov	ecx, DWORD PTR _retries$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _retries$[ebp], ecx
	test	eax, eax
	jg	SHORT $LN37@frecv
	mov	DWORD PTR tv231[ebp], 1
	jmp	SHORT $LN38@frecv
$LN37@frecv:
	mov	DWORD PTR tv231[ebp], 0
$LN38@frecv:
	cmp	DWORD PTR tv231[ebp], 0
	je	SHORT $LN2@frecv

; 1000 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 1001 :           return 0;

	xor	eax, eax
	jmp	SHORT $LN35@frecv
$LN2@frecv:

; 1002 :         }
; 1003 :       }
; 1004 : #endif
; 1005 : #ifdef PALM
; 1006 :       r = soap_socket_errno(soap->socket);
; 1007 :       if (r != SOAP_EINTR && retries-- <= 0)
; 1008 :       { soap->errnum = r;
; 1009 :         return 0;
; 1010 :       }
; 1011 : #endif
; 1012 :     }

	jmp	$LN31@frecv
$LN32@frecv:

; 1013 :   }
; 1014 : #ifdef WITH_FASTCGI
; 1015 :   return fread(s, 1, n, stdin);
; 1016 : #else
; 1017 : #ifdef UNDER_CE
; 1018 :   return fread(s, 1, n, soap->recvfd);
; 1019 : #else
; 1020 : #ifdef WMW_RPM_IO
; 1021 :   if (soap->rpmreqid)
; 1022 :     r = httpBlockRead(soap->rpmreqid, s, n);
; 1023 :   else
; 1024 : #endif
; 1025 :     r = read(soap->recvfd, s, (unsigned int)n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12424]
	push	eax
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _r$[ebp], eax

; 1026 :   if (r >= 0)

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN1@frecv

; 1027 :     return (size_t)r;

	mov	eax, DWORD PTR _r$[ebp]
	jmp	SHORT $LN35@frecv
$LN1@frecv:

; 1028 :   soap->errnum = soap_errno;

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 1029 :   return 0;

	xor	eax, eax
$LN35@frecv:

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN45@frecv
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 800				; 00000320H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN45@frecv:
	DD	5
	DD	$LN44@frecv
$LN44@frecv:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN39@frecv
	DD	-304					; fffffed0H
	DD	260					; 00000104H
	DD	$LN40@frecv
	DD	-316					; fffffec4H
	DD	4
	DD	$LN41@frecv
	DD	-332					; fffffeb4H
	DD	8
	DD	$LN42@frecv
	DD	-600					; fffffda8H
	DD	260					; 00000104H
	DD	$LN43@frecv
$LN43@frecv:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN42@frecv:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN41@frecv:
	DB	107					; 0000006bH
	DB	0
$LN40@frecv:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN39@frecv:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_frecv	ENDP
_TEXT	ENDS
PUBLIC	_soap_cleanup
EXTRN	_WSACleanup@0:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_cleanup
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_cleanup PROC					; COMDAT

; 3425 : { soap_done(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_done
	add	esp, 4

; 3426 : #ifdef WIN32
; 3427 :   if (!tcp_done)

	cmp	DWORD PTR _tcp_done, 0
	jne	SHORT $LN1@soap_clean

; 3428 :     return;

	jmp	SHORT $LN2@soap_clean
$LN1@soap_clean:

; 3429 :   tcp_done = 0;

	mov	DWORD PTR _tcp_done, 0

; 3430 :   WSACleanup();

	call	_WSACleanup@0
$LN2@soap_clean:

; 3431 : #endif
; 3432 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@OBANLCOB@Host?5name?5not?5found?6?$AA@ ; `string'
EXTRN	_gethostbyname@4:PROC
EXTRN	_inet_addr@4:PROC
;	COMDAT ??_C@_0BF@OBANLCOB@Host?5name?5not?5found?6?$AA@
CONST	SEGMENT
??_C@_0BF@OBANLCOB@Host?5name?5not?5found?6?$AA@ DB 'Host name not found', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _tcp_gethost
_TEXT	SEGMENT
_fdebug$84107 = -56					; size = 4
_host$ = -44						; size = 4
_hostent$ = -32						; size = 16
_iadd$ = -8						; size = 4
_soap$ = 8						; size = 4
_addr$ = 12						; size = 4
_inaddr$ = 16						; size = 4
_tcp_gethost PROC					; COMDAT

; 3487 : { soap_int32 iadd = -1;

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _iadd$[ebp], -1

; 3488 :   struct hostent hostent, *host = &hostent;

	lea	eax, DWORD PTR _hostent$[ebp]
	mov	DWORD PTR _host$[ebp], eax

; 3489 : #ifdef VXWORKS
; 3490 :   int hostint;
; 3491 :   /* inet_addr(), and hostGetByName() expect "char *"; addr is a "const char *". */
; 3492 :   iadd = inet_addr((char*)addr);
; 3493 : #else
; 3494 : #if defined(_AIX43) || defined(TRU64)
; 3495 :   struct hostent_data ht_data;
; 3496 : #endif
; 3497 : #ifdef AS400
; 3498 :   iadd = inet_addr((void*)addr);
; 3499 : #else
; 3500 :   iadd = inet_addr(addr);

	mov	eax, DWORD PTR _addr$[ebp]
	push	eax
	call	_inet_addr@4
	mov	DWORD PTR _iadd$[ebp], eax

; 3501 : #endif
; 3502 : #endif
; 3503 :   if (iadd != -1)

	cmp	DWORD PTR _iadd$[ebp], -1
	je	SHORT $LN6@tcp_gethos

; 3504 :   { memcpy(inaddr, &iadd, sizeof(iadd));

	push	4
	lea	eax, DWORD PTR _iadd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inaddr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3505 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN7@tcp_gethos
$LN6@tcp_gethos:

; 3506 :   }
; 3507 : #if defined(__GLIBC__) || (defined(HAVE_GETHOSTBYNAME_R) && (defined(FREEBSD) || defined(__FreeBSD__)))
; 3508 :   if (gethostbyname_r(addr, &hostent, soap->buf, SOAP_BUFLEN, &host, &soap->errnum) < 0)
; 3509 :     host = NULL;
; 3510 : #elif defined(_AIX43) || defined(TRU64)
; 3511 :   memset((void*)&ht_data, 0, sizeof(ht_data));
; 3512 :   if (gethostbyname_r(addr, &hostent, &ht_data) < 0)
; 3513 :   { host = NULL;
; 3514 :     soap->errnum = h_errno;
; 3515 :   }
; 3516 : #elif defined(HAVE_GETHOSTBYNAME_R)
; 3517 :   host = gethostbyname_r(addr, &hostent, soap->buf, SOAP_BUFLEN, &soap->errnum);
; 3518 : #elif defined(VXWORKS)
; 3519 :   /* If the DNS resolver library resolvLib has been configured in the vxWorks
; 3520 :    * image, a query for the host IP address is sent to the DNS server, if the
; 3521 :    * name was not found in the local host table. */
; 3522 :   hostint = hostGetByName((char*)addr);
; 3523 :   if (hostint == ERROR)
; 3524 :   { host = NULL;
; 3525 :     soap->errnum = soap_errno;
; 3526 :   }
; 3527 : #else
; 3528 : #ifdef AS400
; 3529 :   if (!(host = gethostbyname((void*)addr)))
; 3530 :     soap->errnum = h_errno;
; 3531 : #else
; 3532 :   if (!(host = gethostbyname(addr)))

	mov	eax, DWORD PTR _addr$[ebp]
	push	eax
	call	_gethostbyname@4
	mov	DWORD PTR _host$[ebp], eax
	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN5@tcp_gethos

; 3533 :     soap->errnum = h_errno;

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax
$LN5@tcp_gethos:

; 3534 : #endif
; 3535 : #endif
; 3536 :   if (!host)

	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN4@tcp_gethos

; 3537 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Host name not found\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@tcp_gethos
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@tcp_gethos
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@tcp_gethos:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@tcp_gethos
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84107[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BF@OBANLCOB@Host?5name?5not?5found?6?$AA@
	mov	eax, DWORD PTR _fdebug$84107[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84107[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@tcp_gethos:

; 3538 :     return SOAP_ERR;

	or	eax, -1
	jmp	SHORT $LN7@tcp_gethos
$LN4@tcp_gethos:

; 3539 :   }
; 3540 : #ifdef VXWORKS
; 3541 :   inaddr->s_addr = hostint;
; 3542 : #else
; 3543 :   memcpy(inaddr, host->h_addr, host->h_length);

	mov	eax, DWORD PTR _host$[ebp]
	movsx	ecx, WORD PTR [eax+10]
	push	ecx
	mov	edx, DWORD PTR _host$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _inaddr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3544 : #endif
; 3545 :   return SOAP_OK;

	xor	eax, eax
$LN7@tcp_gethos:

; 3546 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@tcp_gethos
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@tcp_gethos:
	DD	2
	DD	$LN11@tcp_gethos
$LN11@tcp_gethos:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN9@tcp_gethos
	DD	-32					; ffffffe0H
	DD	16					; 00000010H
	DD	$LN10@tcp_gethos
$LN10@tcp_gethos:
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN9@tcp_gethos:
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	0
_tcp_gethost ENDP
_TEXT	ENDS
PUBLIC	??_C@_07NHIIGDKE@https?3?$CK?$AA@		; `string'
PUBLIC	??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@ ; `string'
PUBLIC	??_C@_07MKALMBDJ@Timeout?$AA@			; `string'
PUBLIC	??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@BEPNKKBF@Connect?5timeout?6?$AA@	; `string'
PUBLIC	??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@ ; `string'
PUBLIC	??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@ ; `string'
PUBLIC	??_C@_0CI@OHPNMFEP@Opening?5socket?5?$CFd?5to?5host?$DN?8?$CFs?8?5p@ ; `string'
PUBLIC	??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@ ; `string'
PUBLIC	??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ ; `string'
PUBLIC	_soap_set_sender_error
PUBLIC	??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@ ; `string'
EXTRN	_getsockopt@20:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
;	COMDAT ??_C@_07NHIIGDKE@https?3?$CK?$AA@
CONST	SEGMENT
??_C@_07NHIIGDKE@https?3?$CK?$AA@ DB 'https:*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@
CONST	SEGMENT
??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@ DB 'Could not con'
	DB	'nect to host', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKALMBDJ@Timeout?$AA@
CONST	SEGMENT
??_C@_07MKALMBDJ@Timeout?$AA@ DB 'Timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ DB 'conn'
	DB	'ect failed in tcp_connect()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BEPNKKBF@Connect?5timeout?6?$AA@
CONST	SEGMENT
??_C@_0BB@BEPNKKBF@Connect?5timeout?6?$AA@ DB 'Connect timeout', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@
CONST	SEGMENT
??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@ DB 'get host b'
	DB	'y name failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@
CONST	SEGMENT
??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@ DB 'get proxy '
	DB	'host by name failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OHPNMFEP@Opening?5socket?5?$CFd?5to?5host?$DN?8?$CFs?8?5p@
CONST	SEGMENT
??_C@_0CI@OHPNMFEP@Opening?5socket?5?$CFd?5to?5host?$DN?8?$CFs?8?5p@ DB 'O'
	DB	'pening socket %d to host=''%s'' port=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TCP'
	DB	'_NODELAY failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@
CONST	SEGMENT
??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@ DB 'setsockopt fai'
	DB	'led in tcp_connect()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_LINGER failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ DB 'socket '
	DB	'failed in tcp_connect()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@
CONST	SEGMENT
??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@ DB 'TCP in'
	DB	'it failed in tcp_connect()', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _tcp_connect
_TEXT	SEGMENT
tv357 = -684						; size = 4
_blocking$84265 = -484					; size = 4
_nonblocking$84261 = -472				; size = 4
_fdebug$84256 = -460					; size = 4
_fdebug$84248 = -448					; size = 4
_fdebug$84238 = -436					; size = 4
_fdebug$84228 = -424					; size = 4
_r$84210 = -412						; size = 4
_fds$84209 = -400					; size = 260
_timeout$84208 = -132					; size = 8
_k$84204 = -116						; size = 4
_blocking$84191 = -104					; size = 4
_nonblocking$84187 = -92				; size = 4
_fdebug$84172 = -80					; size = 4
_linger$84134 = -68					; size = 4
_set$ = -56						; size = 4
_len$ = -44						; size = 4
_retry$ = -32						; size = 4
_err$ = -20						; size = 4
_fd$ = -8						; size = 4
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_host$ = 16						; size = 4
_port$ = 20						; size = 4
_tcp_connect PROC					; COMDAT

; 3556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-684]
	mov	ecx, 171				; 000000abH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3557 : #ifdef WITH_IPV6
; 3558 :   struct addrinfo hints, *res, *ressave;
; 3559 : #endif
; 3560 :   SOAP_SOCKET fd;
; 3561 :   int err = 0;

	mov	DWORD PTR _err$[ebp], 0

; 3562 : #ifndef WITH_LEAN
; 3563 :   int retry = 10;

	mov	DWORD PTR _retry$[ebp], 10		; 0000000aH

; 3564 :   int len = SOAP_BUFLEN;

	mov	DWORD PTR _len$[ebp], 65536		; 00010000H

; 3565 :   int set = 1;

	mov	DWORD PTR _set$[ebp], 1

; 3566 : #endif
; 3567 :   if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN63@tcp_connec

; 3568 :     soap->fclosesocket(soap, soap->socket);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12288]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN63@tcp_connec:

; 3569 :   soap->socket = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12408], -1

; 3570 :   if (tcp_init(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_init
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@tcp_connec

; 3571 :   { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 3572 :     soap_set_sender_error(soap, tcp_error(soap), "TCP init failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3573 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN62@tcp_connec:

; 3574 :   }
; 3575 :   soap->errmode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 0
$again$84126:

; 3576 : #ifdef WITH_IPV6
; 3577 :   memset((void*)&hints, 0, sizeof(hints));
; 3578 :   hints.ai_family = PF_UNSPEC;
; 3579 : #ifndef WITH_LEAN
; 3580 :   if ((soap->omode & SOAP_IO_UDP))
; 3581 :     hints.ai_socktype = SOCK_DGRAM;
; 3582 :   else
; 3583 : #endif
; 3584 :     hints.ai_socktype = SOCK_STREAM;
; 3585 :   soap->errmode = 2;
; 3586 :   if (soap->proxy_host)
; 3587 :     err = getaddrinfo(soap->proxy_host, soap_int2s(soap, soap->proxy_port), &hints, &res);
; 3588 :   else
; 3589 :     err = getaddrinfo(host, soap_int2s(soap, port), &hints, &res);
; 3590 :   if (err)
; 3591 :   { soap_set_sender_error(soap, SOAP_GAI_STRERROR(err), "getaddrinfo failed in tcp_connect()", SOAP_TCP_ERROR);
; 3592 :     return SOAP_INVALID_SOCKET;
; 3593 :   }
; 3594 :   ressave = res;
; 3595 : again:
; 3596 :   fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
; 3597 :   soap->errmode = 0;
; 3598 : #else
; 3599 : #ifndef WITH_LEAN
; 3600 : again:
; 3601 : #endif
; 3602 : #ifndef WITH_LEAN
; 3603 :   if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN61@tcp_connec

; 3604 :     fd = socket(AF_INET, SOCK_DGRAM, 0);

	push	0
	push	2
	push	2
	call	_socket@12
	mov	DWORD PTR _fd$[ebp], eax

; 3605 :   else

	jmp	SHORT $LN60@tcp_connec
$LN61@tcp_connec:

; 3606 : #endif
; 3607 :     fd = socket(AF_INET, SOCK_STREAM, 0);

	push	0
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _fd$[ebp], eax
$LN60@tcp_connec:

; 3608 : #endif
; 3609 :   if (!soap_valid_socket(fd))

	cmp	DWORD PTR _fd$[ebp], -1
	jne	SHORT $LN59@tcp_connec

; 3610 :   {
; 3611 : #ifdef WITH_IPV6
; 3612 :     if (res->ai_next)
; 3613 :     { res = res->ai_next;
; 3614 :       goto again;
; 3615 :     }
; 3616 : #endif
; 3617 :     soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3618 :     soap_set_sender_error(soap, tcp_error(soap), "socket failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3619 : #ifdef WITH_IPV6
; 3620 :     freeaddrinfo(ressave);
; 3621 : #endif
; 3622 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN59@tcp_connec:

; 3623 :   }
; 3624 : #ifdef SOCKET_CLOSE_ON_EXEC
; 3625 : #ifdef WIN32
; 3626 : #ifndef UNDER_CE
; 3627 :   SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0);
; 3628 : #endif
; 3629 : #else
; 3630 :   fcntl(fd, F_SETFD, 1);
; 3631 : #endif
; 3632 : #endif
; 3633 : #ifndef WITH_LEAN
; 3634 :   if (soap->connect_flags == SO_LINGER)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+68], 128			; 00000080H
	jne	$LN58@tcp_connec

; 3635 :   { struct linger linger;
; 3636 :     memset((void*)&linger, 0, sizeof(linger));

	push	4
	push	0
	lea	eax, DWORD PTR _linger$84134[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3637 :     linger.l_onoff = 1;

	mov	eax, 1
	mov	WORD PTR _linger$84134[ebp], ax

; 3638 :     linger.l_linger = 0;

	xor	eax, eax
	mov	WORD PTR _linger$84134[ebp+2], ax

; 3639 :     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(struct linger)))

	push	4
	lea	eax, DWORD PTR _linger$84134[ebp]
	push	eax
	push	128					; 00000080H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN57@tcp_connec

; 3640 :     { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3641 :       soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_LINGER failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3642 :       soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3643 : #ifdef WITH_IPV6
; 3644 :       freeaddrinfo(ressave);
; 3645 : #endif
; 3646 :       return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN57@tcp_connec:

; 3647 :     }
; 3648 :   }

	jmp	SHORT $LN56@tcp_connec
$LN58@tcp_connec:

; 3649 :   else if (soap->connect_flags && setsockopt(fd, SOL_SOCKET, soap->connect_flags, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN56@tcp_connec
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN56@tcp_connec

; 3650 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3651 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3652 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3653 : #ifdef WITH_IPV6
; 3654 :     freeaddrinfo(ressave);
; 3655 : #endif
; 3656 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN56@tcp_connec:

; 3657 :   }
; 3658 :   if ((soap->keep_alive || soap->tcp_keep_alive) && setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jne	SHORT $LN53@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90414]
	test	ecx, ecx
	je	SHORT $LN54@tcp_connec
$LN53@tcp_connec:
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	8
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN54@tcp_connec

; 3659 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3660 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3661 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3662 : #ifdef WITH_IPV6
; 3663 :     freeaddrinfo(ressave);
; 3664 : #endif
; 3665 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN54@tcp_connec:

; 3666 :   }
; 3667 :   if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN52@tcp_connec

; 3668 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3669 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3670 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3671 : #ifdef WITH_IPV6
; 3672 :     freeaddrinfo(ressave);
; 3673 : #endif
; 3674 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN52@tcp_connec:

; 3675 :   }
; 3676 :   if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN51@tcp_connec

; 3677 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3678 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3679 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3680 : #ifdef WITH_IPV6
; 3681 :     freeaddrinfo(ressave);
; 3682 : #endif
; 3683 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN51@tcp_connec:

; 3684 :   }
; 3685 : #ifdef TCP_KEEPIDLE
; 3686 :   if (soap->tcp_keep_idle && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPIDLE, (unsigned int*)&(soap->tcp_keep_idle), sizeof(int)))
; 3687 :   { soap->errnum = soap_socket_errno(fd);
; 3688 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPIDLE failed in tcp_connect()", SOAP_TCP_ERROR);
; 3689 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3690 : #ifdef WITH_IPV6
; 3691 :     freeaddrinfo(ressave);
; 3692 : #endif
; 3693 :     return SOAP_INVALID_SOCKET;
; 3694 :   }
; 3695 : #endif
; 3696 : #ifdef TCP_KEEPINTVL
; 3697 :   if (soap->tcp_keep_intvl && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPINTVL, (unsigned int*)&(soap->tcp_keep_intvl), sizeof(int)))
; 3698 :   { soap->errnum = soap_socket_errno(fd);
; 3699 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPINTVL failed in tcp_connect()", SOAP_TCP_ERROR);
; 3700 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3701 : #ifdef WITH_IPV6
; 3702 :     freeaddrinfo(ressave);
; 3703 : #endif
; 3704 :     return SOAP_INVALID_SOCKET;
; 3705 :   }
; 3706 : #endif
; 3707 : #ifdef TCP_KEEPCNT
; 3708 :   if (soap->tcp_keep_cnt && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPCNT, (unsigned int*)&(soap->tcp_keep_cnt), sizeof(int)))
; 3709 :   { soap->errnum = soap_socket_errno(fd);
; 3710 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPCNT failed in tcp_connect()", SOAP_TCP_ERROR);
; 3711 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3712 : #ifdef WITH_IPV6
; 3713 :     freeaddrinfo(ressave);
; 3714 : #endif
; 3715 :     return SOAP_INVALID_SOCKET;
; 3716 :   }
; 3717 : #endif
; 3718 : #ifdef TCP_NODELAY
; 3719 :   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	jne	SHORT $LN50@tcp_connec
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	1
	push	6
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN50@tcp_connec

; 3720 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 3721 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3722 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3723 : #ifdef WITH_IPV6
; 3724 :     freeaddrinfo(ressave);
; 3725 : #endif
; 3726 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN50@tcp_connec:

; 3727 :   }
; 3728 : #endif
; 3729 : #endif
; 3730 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Opening socket %d to host='%s' port=%d\n", fd, host, port));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN49@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN48@tcp_connec
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN48@tcp_connec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN49@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84172[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@OHPNMFEP@Opening?5socket?5?$CFd?5to?5host?$DN?8?$CFs?8?5p@
	mov	eax, DWORD PTR _fdebug$84172[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84172[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN49@tcp_connec:

; 3731 : #ifndef WITH_IPV6
; 3732 :   soap->peerlen = sizeof(soap->peer);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94708], 16		; 00000010H

; 3733 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3734 :   soap->peer.sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+94692], ax

; 3735 :   soap->errmode = 2;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 2

; 3736 :   if (soap->proxy_host)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90436], 0
	je	$LN46@tcp_connec

; 3737 :   { if (soap->fresolve(soap, soap->proxy_host, &soap->peer.sin_addr))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94696				; 000171e8H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90436]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12276]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN45@tcp_connec

; 3738 :     { soap_set_sender_error(soap, tcp_error(soap), "get proxy host by name failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3739 :       soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3740 : #ifdef WITH_IPV6
; 3741 :       freeaddrinfo(ressave);
; 3742 : #endif
; 3743 :       return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN45@tcp_connec:

; 3744 :     }
; 3745 :     soap->peer.sin_port = htons((short)soap->proxy_port);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90440]
	call	@_RTC_Check_4_to_2@4
	movzx	ecx, ax
	push	ecx
	call	_htons@4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [edx+94694], ax

; 3746 :   }
; 3747 :   else

	jmp	$LN44@tcp_connec
$LN46@tcp_connec:

; 3748 :   { if (soap->fresolve(soap, host, &soap->peer.sin_addr))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94696				; 000171e8H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12276]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN43@tcp_connec

; 3749 :     { soap_set_sender_error(soap, tcp_error(soap), "get host by name failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3750 :       soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3751 : #ifdef WITH_IPV6
; 3752 :       freeaddrinfo(ressave);
; 3753 : #endif
; 3754 :       return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN43@tcp_connec:

; 3755 :     }
; 3756 :     soap->peer.sin_port = htons((short)port);

	mov	ecx, DWORD PTR _port$[ebp]
	call	@_RTC_Check_4_to_2@4
	movzx	eax, ax
	push	eax
	call	_htons@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+94694], ax
$LN44@tcp_connec:

; 3757 :   }
; 3758 :   soap->errmode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 0

; 3759 : #ifndef WITH_LEAN
; 3760 :   if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN42@tcp_connec

; 3761 :   {
; 3762 : #ifdef WITH_IPV6
; 3763 :     freeaddrinfo(ressave);
; 3764 : #endif
; 3765 :     return fd;

	mov	eax, DWORD PTR _fd$[ebp]
	jmp	$LN64@tcp_connec
$LN42@tcp_connec:

; 3766 :   }
; 3767 : #endif
; 3768 : #endif
; 3769 : #ifndef WITH_LEAN
; 3770 :   if (soap->connect_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN41@tcp_connec

; 3771 :     SOAP_SOCKNONBLOCK(fd)

	mov	DWORD PTR _nonblocking$84187[ebp], 1
	lea	eax, DWORD PTR _nonblocking$84187[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_ioctlsocket@12

; 3772 :   else

	jmp	SHORT $LN39@tcp_connec
$LN41@tcp_connec:

; 3773 :     SOAP_SOCKBLOCK(fd)

	mov	DWORD PTR _blocking$84191[ebp], 0
	lea	eax, DWORD PTR _blocking$84191[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_ioctlsocket@12
$LN39@tcp_connec:

; 3774 : #endif
; 3775 :   for (;;)
; 3776 :   {
; 3777 : #ifdef WITH_IPV6
; 3778 :     if (connect(fd, res->ai_addr, (int)res->ai_addrlen))
; 3779 : #else
; 3780 :     if (connect(fd, (struct sockaddr*)&soap->peer, sizeof(soap->peer)))

	push	16					; 00000010H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_connect@12
	test	eax, eax
	je	$LN37@tcp_connec

; 3781 : #endif
; 3782 :     { err = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR _err$[ebp], eax

; 3783 : #ifndef WITH_LEAN
; 3784 :       if (err == SOAP_EADDRINUSE)

	cmp	DWORD PTR _err$[ebp], 10048		; 00002740H
	jne	SHORT $LN36@tcp_connec

; 3785 :       { soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3786 :         if (retry-- > 0)

	mov	eax, DWORD PTR _retry$[ebp]
	mov	ecx, DWORD PTR _retry$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _retry$[ebp], ecx
	test	eax, eax
	jle	SHORT $LN66@tcp_connec
	mov	DWORD PTR tv357[ebp], 1
	jmp	SHORT $LN67@tcp_connec
$LN66@tcp_connec:
	mov	DWORD PTR tv357[ebp], 0
$LN67@tcp_connec:
	cmp	DWORD PTR tv357[ebp], 0
	je	SHORT $LN35@tcp_connec

; 3787 :           goto again;

	jmp	$again$84126
$LN35@tcp_connec:

; 3788 :       }

	jmp	$LN34@tcp_connec
$LN36@tcp_connec:

; 3789 :       else if (soap->connect_timeout && (err == SOAP_EINPROGRESS || err == SOAP_EAGAIN || err == SOAP_EWOULDBLOCK))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	$LN34@tcp_connec
	cmp	DWORD PTR _err$[ebp], 10036		; 00002734H
	je	SHORT $LN31@tcp_connec
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	je	SHORT $LN31@tcp_connec
	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	jne	$LN34@tcp_connec
$LN31@tcp_connec:

; 3790 :       {
; 3791 :         SOAP_SOCKLEN_T k;
; 3792 : #ifndef WIN32
; 3793 :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 3794 :         { soap->error = SOAP_FD_EXCEEDED;
; 3795 : #ifdef WITH_IPV6
; 3796 :           freeaddrinfo(ressave);
; 3797 : #endif
; 3798 :           return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 3799 :         }
; 3800 : #endif
; 3801 :         for (;;)
; 3802 :         { struct timeval timeout;
; 3803 :           fd_set fds;
; 3804 :           register int r;
; 3805 :           if (soap->connect_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jle	SHORT $LN29@tcp_connec

; 3806 :           { timeout.tv_sec = soap->connect_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _timeout$84208[ebp], ecx

; 3807 :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$84208[ebp+4], 0

; 3808 :           }
; 3809 :           else

	jmp	SHORT $LN28@tcp_connec
$LN29@tcp_connec:

; 3810 :           { timeout.tv_sec = -soap->connect_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+56]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$84208[ebp], eax

; 3811 :             timeout.tv_usec = -soap->connect_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+56]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$84208[ebp+4], edx
$LN28@tcp_connec:

; 3812 :           }
; 3813 :           FD_ZERO(&fds);

	mov	DWORD PTR _fds$84209[ebp], 0
$LN27@tcp_connec:

; 3814 :           FD_SET(fd, &fds);

	cmp	DWORD PTR _fds$84209[ebp], 64		; 00000040H
	jae	SHORT $LN26@tcp_connec
	mov	eax, DWORD PTR _fds$84209[ebp]
	mov	ecx, DWORD PTR _fd$[ebp]
	mov	DWORD PTR _fds$84209[ebp+eax*4+4], ecx
	mov	edx, DWORD PTR _fds$84209[ebp]
	add	edx, 1
	mov	DWORD PTR _fds$84209[ebp], edx
$LN26@tcp_connec:
	xor	eax, eax
	jne	SHORT $LN27@tcp_connec

; 3815 :           r = select((int)fd + 1, NULL, &fds, NULL, &timeout);

	lea	eax, DWORD PTR _timeout$84208[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fds$84209[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _fd$[ebp]
	add	edx, 1
	push	edx
	call	_select@20
	mov	DWORD PTR _r$84210[ebp], eax

; 3816 :           if (r > 0)

	cmp	DWORD PTR _r$84210[ebp], 0
	jle	SHORT $LN23@tcp_connec

; 3817 :             break;

	jmp	$LN30@tcp_connec
$LN23@tcp_connec:

; 3818 :           if (!r)

	cmp	DWORD PTR _r$84210[ebp], 0
	jne	$LN22@tcp_connec

; 3819 :           { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 3820 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connect timeout\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN20@tcp_connec
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN20@tcp_connec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84228[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BB@BEPNKKBF@Connect?5timeout?6?$AA@
	mov	eax, DWORD PTR _fdebug$84228[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84228[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@tcp_connec:

; 3821 :             soap_set_sender_error(soap, "Timeout", "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	push	OFFSET ??_C@_07MKALMBDJ@Timeout?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3822 :             soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3823 : #ifdef WITH_IPV6
; 3824 :             freeaddrinfo(ressave);
; 3825 : #endif
; 3826 :             return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN22@tcp_connec:

; 3827 :           }
; 3828 :           r = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR _r$84210[ebp], eax

; 3829 :           if (r != SOAP_EINTR)

	cmp	DWORD PTR _r$84210[ebp], 10004		; 00002714H
	je	$LN18@tcp_connec

; 3830 :           { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$84210[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 3831 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN17@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN16@tcp_connec
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN16@tcp_connec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN17@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84238[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@
	mov	eax, DWORD PTR _fdebug$84238[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84238[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@tcp_connec:

; 3832 :             soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3833 :             soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3834 : #ifdef WITH_IPV6
; 3835 :             freeaddrinfo(ressave);
; 3836 : #endif
; 3837 :             return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN18@tcp_connec:

; 3838 :           }
; 3839 :         }

	jmp	$LN31@tcp_connec
$LN30@tcp_connec:

; 3840 :         k = (SOAP_SOCKLEN_T)sizeof(soap->errnum);

	mov	DWORD PTR _k$84204[ebp], 4

; 3841 :         if (!getsockopt(fd, SOL_SOCKET, SO_ERROR, (char*)&soap->errnum, &k) && !soap->errnum)	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	lea	eax, DWORD PTR _k$84204[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 90468				; 00016164H
	push	ecx
	push	4103					; 00001007H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	_getsockopt@20
	test	eax, eax
	jne	SHORT $LN14@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90468], 0
	jne	SHORT $LN14@tcp_connec

; 3842 :           break;

	jmp	$LN38@tcp_connec
$LN14@tcp_connec:

; 3843 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN13@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN12@tcp_connec
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN12@tcp_connec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN13@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84248[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@
	mov	eax, DWORD PTR _fdebug$84248[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84248[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@tcp_connec:

; 3844 :         if (!soap->errnum)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90468], 0
	jne	SHORT $LN10@tcp_connec

; 3845 :           soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax
$LN10@tcp_connec:

; 3846 :         soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3847 :         soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3848 : #ifdef WITH_IPV6
; 3849 :         freeaddrinfo(ressave);
; 3850 : #endif
; 3851 :         return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN34@tcp_connec:

; 3852 :       }
; 3853 : #endif
; 3854 : #ifdef WITH_IPV6
; 3855 :       if (res->ai_next)
; 3856 :       { res = res->ai_next;
; 3857 :         soap->fclosesocket(soap, fd);
; 3858 :         goto again;
; 3859 :       }
; 3860 : #endif
; 3861 :       if (err && err != SOAP_EINTR)

	cmp	DWORD PTR _err$[ebp], 0
	je	$LN9@tcp_connec
	cmp	DWORD PTR _err$[ebp], 10004		; 00002714H
	je	$LN9@tcp_connec

; 3862 :       { soap->errnum = err;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 3863 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@tcp_connec
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@tcp_connec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84256[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@IKANDFCK@Could?5not?5connect?5to?5host?6?$AA@
	mov	eax, DWORD PTR _fdebug$84256[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84256[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@tcp_connec:

; 3864 :         soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 3865 :         soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3866 : #ifdef WITH_IPV6
; 3867 :         freeaddrinfo(ressave);
; 3868 : #endif
; 3869 :         return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN64@tcp_connec
$LN9@tcp_connec:

; 3870 :       }
; 3871 :     }
; 3872 :     else

	jmp	SHORT $LN5@tcp_connec
$LN37@tcp_connec:

; 3873 :       break;

	jmp	SHORT $LN38@tcp_connec
$LN5@tcp_connec:

; 3874 :   }

	jmp	$LN39@tcp_connec
$LN38@tcp_connec:

; 3875 : #ifdef WITH_IPV6
; 3876 :   soap->peerlen = 0; /* IPv6: already connected so use send() */
; 3877 :   freeaddrinfo(ressave);
; 3878 : #endif
; 3879 : #ifndef WITH_LEAN
; 3880 :   if (soap->recv_timeout || soap->send_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN3@tcp_connec
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN4@tcp_connec
$LN3@tcp_connec:

; 3881 :     SOAP_SOCKNONBLOCK(fd)

	mov	DWORD PTR _nonblocking$84261[ebp], 1
	lea	eax, DWORD PTR _nonblocking$84261[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_ioctlsocket@12

; 3882 :   else

	jmp	SHORT $LN2@tcp_connec
$LN4@tcp_connec:

; 3883 :     SOAP_SOCKBLOCK(fd)

	mov	DWORD PTR _blocking$84265[ebp], 0
	lea	eax, DWORD PTR _blocking$84265[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_ioctlsocket@12
$LN2@tcp_connec:

; 3884 : #endif
; 3885 :   soap->socket = fd;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _fd$[ebp]
	mov	DWORD PTR [eax+12408], ecx

; 3886 :   soap->imode &= ~SOAP_ENC_SSL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -2049				; fffff7ffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3887 :   soap->omode &= ~SOAP_ENC_SSL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2049				; fffff7ffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 3888 :   if (!soap_tag_cmp(endpoint, "https:*"))

	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@tcp_connec

; 3889 :   {
; 3890 : #ifdef WITH_OPENSSL
; 3891 :     BIO *bio;
; 3892 :     int r;
; 3893 :     if (soap->proxy_host)
; 3894 :     { unsigned int k = soap->omode; /* make sure we only parse HTTP */
; 3895 :       size_t n = soap->count; /* save the content length */
; 3896 :       char *userid, *passwd;
; 3897 :       soap->omode &= ~SOAP_ENC; /* mask IO and ENC */
; 3898 :       soap->omode |= SOAP_IO_BUFFER;
; 3899 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connecting to %s proxy server\n", soap->proxy_http_version));
; 3900 :       sprintf(soap->tmpbuf, "CONNECT %s:%d HTTP/%s", host, port, soap->proxy_http_version);
; 3901 :       if (soap_begin_send(soap)
; 3902 :        || (soap->error = soap->fposthdr(soap, soap->tmpbuf, NULL)))
; 3903 :       { soap->fclosesocket(soap, fd);
; 3904 :         return SOAP_INVALID_SOCKET;
; 3905 :       }
; 3906 : #ifndef WITH_LEAN
; 3907 :       if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
; 3908 :       { sprintf(soap->tmpbuf + 262, "%s:%s", soap->proxy_userid, soap->proxy_passwd);
; 3909 :         strcpy(soap->tmpbuf, "Basic ");
; 3910 :         soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));
; 3911 :         if ((soap->error = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf)))
; 3912 :         { soap->fclosesocket(soap, fd);
; 3913 :           return soap->error;
; 3914 :         }
; 3915 :       }
; 3916 : #endif
; 3917 :       if ((soap->error = soap->fposthdr(soap, NULL, NULL))
; 3918 :        || soap_flush(soap))
; 3919 :       { soap->fclosesocket(soap, fd);
; 3920 :         return SOAP_INVALID_SOCKET;
; 3921 :       }
; 3922 :       soap->omode = k;
; 3923 :       k = soap->imode;
; 3924 :       soap->imode &= ~SOAP_ENC; /* mask IO and ENC */
; 3925 :       userid = soap->userid; /* preserve */
; 3926 :       passwd = soap->passwd; /* preserve */
; 3927 :       if ((soap->error = soap->fparse(soap)))
; 3928 :       { soap->fclosesocket(soap, fd);
; 3929 :         return SOAP_INVALID_SOCKET;
; 3930 :       }
; 3931 :       soap->userid = userid; /* restore */
; 3932 :       soap->passwd = passwd; /* restore */
; 3933 :       soap->imode = k; /* restore */
; 3934 :       soap->count = n; /* restore */
; 3935 :       if (soap_begin_send(soap))
; 3936 :       { soap->fclosesocket(soap, fd);
; 3937 :         return SOAP_INVALID_SOCKET;
; 3938 :       }
; 3939 :       if (endpoint)
; 3940 :         strncpy(soap->endpoint, endpoint, sizeof(soap->endpoint)-1); /* restore */
; 3941 :     }
; 3942 :     if (!soap->ctx && (soap->error = soap->fsslauth(soap)))
; 3943 :     { soap_set_sender_error(soap, "SSL error", "SSL authentication failed in tcp_connect(): check password, key file, and ca file.", SOAP_SSL_ERROR);
; 3944 :       soap->fclosesocket(soap, fd);
; 3945 :       return SOAP_INVALID_SOCKET;
; 3946 :     }
; 3947 :     soap->ssl = SSL_new(soap->ctx);
; 3948 :     if (!soap->ssl)
; 3949 :     { soap->fclosesocket(soap, fd);
; 3950 :       soap->error = SOAP_SSL_ERROR;
; 3951 :       return SOAP_INVALID_SOCKET;
; 3952 :     }
; 3953 :     if (soap->session)
; 3954 :     { if (!strcmp(soap->session_host, host) && soap->session_port == port)
; 3955 :         SSL_set_session(soap->ssl, soap->session);
; 3956 :       SSL_SESSION_free(soap->session);
; 3957 :       soap->session = NULL;
; 3958 :     }
; 3959 :     soap->imode |= SOAP_ENC_SSL;
; 3960 :     soap->omode |= SOAP_ENC_SSL;
; 3961 :     bio = BIO_new_socket(fd, BIO_NOCLOSE);
; 3962 :     SSL_set_bio(soap->ssl, bio, bio);
; 3963 : #ifndef WITH_LEAN
; 3964 :     /* Connect timeout: set SSL sockets to non-blocking */
; 3965 :     if (soap->connect_timeout)
; 3966 :       SOAP_SOCKNONBLOCK(fd)
; 3967 :     else
; 3968 :       SOAP_SOCKBLOCK(fd)
; 3969 :     /* Try connecting until success or timeout */
; 3970 :     for (;;)
; 3971 :     { if ((r = SSL_connect(soap->ssl)) <= 0)
; 3972 :       { int err = SSL_get_error(soap->ssl, r);
; 3973 :         if (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE)
; 3974 :         { soap_set_sender_error(soap, soap_ssl_error(soap, r), "SSL connect failed in tcp_connect()", SOAP_SSL_ERROR);
; 3975 :           soap->fclosesocket(soap, fd);
; 3976 :           return SOAP_INVALID_SOCKET;
; 3977 :         }
; 3978 :         if (soap->connect_timeout)
; 3979 :         {
; 3980 : #ifndef WIN32
; 3981 :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 3982 :           { soap->error = SOAP_FD_EXCEEDED;
; 3983 :             return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 3984 :           }
; 3985 : #endif
; 3986 :           for (;;)
; 3987 :           { struct timeval timeout;
; 3988 :             fd_set fds;
; 3989 :             register int r;
; 3990 :             if (soap->connect_timeout > 0)
; 3991 :             { timeout.tv_sec = soap->connect_timeout;
; 3992 :               timeout.tv_usec = 0;
; 3993 :             }
; 3994 :             else
; 3995 :             { timeout.tv_sec = -soap->connect_timeout/1000000;
; 3996 :               timeout.tv_usec = -soap->connect_timeout%1000000;
; 3997 :             }
; 3998 :             FD_ZERO(&fds);
; 3999 :             FD_SET(fd, &fds);
; 4000 :             r = select((int)fd + 1, &fds, &fds, &fds, &timeout);
; 4001 :             if (r > 0)
; 4002 :               break;
; 4003 :             if (!r)
; 4004 :             { soap->errnum = 0;
; 4005 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connect timeout\n"));
; 4006 :               soap_set_sender_error(soap, "Timeout", "connect failed in tcp_connect()", SOAP_TCP_ERROR);
; 4007 :               soap->fclosesocket(soap, fd);
; 4008 :               return SOAP_INVALID_SOCKET;
; 4009 :             }
; 4010 :           }
; 4011 :           continue;
; 4012 :         }
; 4013 :       }
; 4014 :       break;
; 4015 :     }
; 4016 :     /* Set SSL sockets to nonblocking */
; 4017 :     SOAP_SOCKNONBLOCK(fd)
; 4018 : #endif
; 4019 :     /* Check server credentials when required */
; 4020 :     if ((soap->ssl_flags & SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION))
; 4021 :     { int err;
; 4022 :       if ((err = SSL_get_verify_result(soap->ssl)) != X509_V_OK)
; 4023 :       { soap_set_sender_error(soap, X509_verify_cert_error_string(err), "SSL certificate presented by peer cannot be verified in tcp_connect()", SOAP_SSL_ERROR);
; 4024 :         soap->fclosesocket(soap, fd);
; 4025 :         return SOAP_INVALID_SOCKET;
; 4026 :       }
; 4027 :       if (!(soap->ssl_flags & SOAP_SSL_SKIP_HOST_CHECK))
; 4028 :       { X509_NAME *subj;
; 4029 :         int ext_count;
; 4030 :         int ok = 0;
; 4031 :         X509 *peer;
; 4032 :         peer = SSL_get_peer_certificate(soap->ssl);
; 4033 :         if (!peer)
; 4034 :         { soap_set_sender_error(soap, "SSL error", "No SSL certificate was presented by the peer in tcp_connect()", SOAP_SSL_ERROR);
; 4035 :           soap->fclosesocket(soap, fd);
; 4036 :           return SOAP_INVALID_SOCKET;
; 4037 :         }
; 4038 :         ext_count = X509_get_ext_count(peer);
; 4039 :         if (ext_count > 0)
; 4040 :         { int i;
; 4041 :           for (i = 0; i < ext_count; i++)
; 4042 :           { X509_EXTENSION *ext = X509_get_ext(peer, i);
; 4043 :             const char *ext_str = OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(ext)));
; 4044 :             if (ext_str && !strcmp(ext_str, "subjectAltName"))
; 4045 :             { X509V3_EXT_METHOD *meth = X509V3_EXT_get(ext);
; 4046 :               void *ext_data;
; 4047 : #if (OPENSSL_VERSION_NUMBER >= 0x0090800fL)
; 4048 :               const unsigned char *data;
; 4049 : #else
; 4050 :               unsigned char *data;
; 4051 : #endif
; 4052 :               STACK_OF(CONF_VALUE) *val;
; 4053 :               int j;
; 4054 :               if (!meth)
; 4055 :                 break;
; 4056 :               data = ext->value->data;
; 4057 : #if (OPENSSL_VERSION_NUMBER > 0x00907000L)
; 4058 :               if (meth->it)
; 4059 :                 ext_data = ASN1_item_d2i(NULL, &data, ext->value->length, ASN1_ITEM_ptr(meth->it));
; 4060 :               else
; 4061 :               { /* OpenSSL not perfectly portable at this point (?):
; 4062 :                    Some compilers appear to prefer
; 4063 :                    meth->d2i(NULL, (const unsigned char**)&data, ...
; 4064 :                    or
; 4065 :                    meth->d2i(NULL, &data, ext->value->length);
; 4066 :                 */
; 4067 :                 ext_data = meth->d2i(NULL, &data, ext->value->length);
; 4068 :               }
; 4069 : #else
; 4070 :               ext_data = meth->d2i(NULL, &data, ext->value->length);
; 4071 : #endif
; 4072 :               val = meth->i2v(meth, ext_data, NULL);
; 4073 :               for (j = 0; j < sk_CONF_VALUE_num(val); j++)
; 4074 :               { CONF_VALUE *nval = sk_CONF_VALUE_value(val, j);
; 4075 :                 if (nval && !strcmp(nval->name, "DNS") && !strcmp(nval->value, host))
; 4076 :                 { ok = 1;
; 4077 :                   break;
; 4078 :                 }
; 4079 :               }
; 4080 :             }
; 4081 :             if (ok)
; 4082 :               break;
; 4083 :           }
; 4084 :         }
; 4085 :         if (!ok && (subj = X509_get_subject_name(peer)))
; 4086 :         { int i = -1;
; 4087 :           do
; 4088 :           { ASN1_STRING *name;
; 4089 :             i = X509_NAME_get_index_by_NID(subj, NID_commonName, i);
; 4090 :             if (i == -1)
; 4091 :               break;
; 4092 :             name = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(subj, i));
; 4093 :             if (name)
; 4094 :             { if (!soap_tag_cmp(host, (const char*)name))
; 4095 :                 ok = 1;
; 4096 :               else
; 4097 :               { unsigned char *tmp = NULL;
; 4098 :                 ASN1_STRING_to_UTF8(&tmp, name);
; 4099 :                 if (tmp)
; 4100 :                 { if (!soap_tag_cmp(host, (const char*)tmp))
; 4101 :                     ok = 1;
; 4102 :                   OPENSSL_free(tmp);
; 4103 :                 }
; 4104 :               }
; 4105 :             }
; 4106 :           } while (!ok);
; 4107 :         }
; 4108 :         X509_free(peer);
; 4109 :         if (!ok)
; 4110 :         { soap_set_sender_error(soap, "SSL error", "SSL certificate host name mismatch in tcp_connect()", SOAP_SSL_ERROR);
; 4111 :           soap->fclosesocket(soap, fd);
; 4112 :           return SOAP_INVALID_SOCKET;
; 4113 :         }
; 4114 :       }
; 4115 :     }
; 4116 : #else
; 4117 :     soap->fclosesocket(soap, fd);

	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12288]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4118 :     soap->error = SOAP_SSL_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 30		; 0000001eH

; 4119 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN64@tcp_connec
$LN1@tcp_connec:

; 4120 : #endif
; 4121 :   }
; 4122 :   return fd;

	mov	eax, DWORD PTR _fd$[ebp]
$LN64@tcp_connec:

; 4123 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN79@tcp_connec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 684				; 000002acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN79@tcp_connec:
	DD	10					; 0000000aH
	DD	$LN78@tcp_connec
$LN78@tcp_connec:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN68@tcp_connec
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN69@tcp_connec
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN70@tcp_connec
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN71@tcp_connec
	DD	-104					; ffffff98H
	DD	4
	DD	$LN72@tcp_connec
	DD	-116					; ffffff8cH
	DD	4
	DD	$LN73@tcp_connec
	DD	-132					; ffffff7cH
	DD	8
	DD	$LN74@tcp_connec
	DD	-400					; fffffe70H
	DD	260					; 00000104H
	DD	$LN75@tcp_connec
	DD	-472					; fffffe28H
	DD	4
	DD	$LN76@tcp_connec
	DD	-484					; fffffe1cH
	DD	4
	DD	$LN77@tcp_connec
$LN77@tcp_connec:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN76@tcp_connec:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN75@tcp_connec:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN74@tcp_connec:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN73@tcp_connec:
	DB	107					; 0000006bH
	DB	0
$LN72@tcp_connec:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN71@tcp_connec:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN70@tcp_connec:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN69@tcp_connec:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN68@tcp_connec:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_tcp_connect ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_WSAStartup@8:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _tcp_init
_TEXT	SEGMENT
_w$84016 = -408						; size = 400
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_tcp_init PROC						; COMDAT

; 3282 : { soap->errmode = 1;

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-604]
	mov	ecx, 151				; 00000097H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 1

; 3283 : #ifdef WIN32
; 3284 :   if (tcp_done)

	cmp	DWORD PTR _tcp_done, 0
	je	SHORT $LN3@tcp_init

; 3285 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN4@tcp_init

; 3286 :   else

	jmp	SHORT $LN2@tcp_init
$LN3@tcp_init:

; 3287 :   { WSADATA w;
; 3288 :     if (WSAStartup(MAKEWORD(1, 1), &w))

	lea	eax, DWORD PTR _w$84016[ebp]
	push	eax
	push	257					; 00000101H
	call	_WSAStartup@8
	test	eax, eax
	je	SHORT $LN1@tcp_init

; 3289 :       return -1;

	or	eax, -1
	jmp	SHORT $LN4@tcp_init
$LN1@tcp_init:

; 3290 :     tcp_done = 1;

	mov	DWORD PTR _tcp_done, 1
$LN2@tcp_init:

; 3291 :   }
; 3292 : #endif
; 3293 :   return 0;

	xor	eax, eax
$LN4@tcp_init:

; 3294 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@tcp_init
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 604				; 0000025cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@tcp_init:
	DD	1
	DD	$LN7@tcp_init
$LN7@tcp_init:
	DD	-408					; fffffe68H
	DD	400					; 00000190H
	DD	$LN6@tcp_init
$LN6@tcp_init:
	DB	119					; 00000077H
	DB	0
_tcp_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@	; `string'
;	COMDAT ??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@ DB 'TCP/UDP IP error %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@
CONST	SEGMENT
??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@ DB 'WSAStartup failed', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _tcp_error
_TEXT	SEGMENT
tv65 = -208						; size = 4
_msg$ = -8						; size = 4
_soap$ = 8						; size = 4
_tcp_error PROC						; COMDAT

; 3441 : { register const char *msg = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _msg$[ebp], 0

; 3442 :   switch (soap->errmode)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90464]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN4@tcp_error
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN3@tcp_error
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN2@tcp_error
	jmp	SHORT $LN5@tcp_error
$LN4@tcp_error:

; 3443 :   { case 0:
; 3444 :       msg = soap_strerror(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_strerror
	add	esp, 4
	mov	DWORD PTR _msg$[ebp], eax

; 3445 :       break;

	jmp	SHORT $LN5@tcp_error
$LN3@tcp_error:

; 3446 :     case 1:
; 3447 :       msg = "WSAStartup failed";

	mov	DWORD PTR _msg$[ebp], OFFSET ??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@

; 3448 :       break;

	jmp	SHORT $LN5@tcp_error
$LN2@tcp_error:

; 3449 :     case 2:
; 3450 :     {
; 3451 : #ifndef WITH_LEAN
; 3452 :       msg = soap_code_str(h_error_codes, soap->errnum);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90468]
	push	ecx
	push	OFFSET _h_error_codes
	call	_soap_code_str
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax

; 3453 :       if (!msg)

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN5@tcp_error

; 3454 : #endif
; 3455 :       { sprintf(soap->msgbuf, "TCP/UDP IP error %d", soap->errnum);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90468]
	push	ecx
	push	OFFSET ??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78004				; 000130b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3456 :         msg = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	DWORD PTR _msg$[ebp], eax
$LN5@tcp_error:

; 3457 :       }
; 3458 :     }
; 3459 :   }
; 3460 :   return msg;

	mov	eax, DWORD PTR _msg$[ebp]

; 3461 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BI@OGKHECJC@Could?5not?5bind?5to?5host?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@ ; `string'
PUBLIC	??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	_soap_set_receiver_error
PUBLIC	??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	_soap_bind
EXTRN	_listen@8:PROC
EXTRN	_bind@12:PROC
EXTRN	_htonl@4:PROC
;	COMDAT ??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'listen '
	DB	'failed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'bind fail'
	DB	'ed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OGKHECJC@Could?5not?5bind?5to?5host?6?$AA@
CONST	SEGMENT
??_C@_0BI@OGKHECJC@Could?5not?5bind?5to?5host?6?$AA@ DB 'Could not bind t'
	DB	'o host', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@
CONST	SEGMENT
??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@ DB 'get host b'
	DB	'y name failed in soap_bind()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TC'
	DB	'P_NODELAY failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@
CONST	SEGMENT
??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@ DB 'setsock'
	DB	'opt failed in soap_bind()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'socket '
	DB	'failed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'TCP '
	DB	'init failed in soap_bind()', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_bind
_TEXT	SEGMENT
_fdebug$84344 = -44					; size = 4
_fdebug$84335 = -32					; size = 4
_set$ = -20						; size = 4
_len$ = -8						; size = 4
_soap$ = 8						; size = 4
_host$ = 12						; size = 4
_port$ = 16						; size = 4
_backlog$ = 20						; size = 4
_soap_bind PROC						; COMDAT

; 4134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4135 : #ifdef WITH_IPV6
; 4136 :   struct addrinfo *addrinfo = NULL;
; 4137 :   struct addrinfo hints;
; 4138 :   struct addrinfo res;
; 4139 :   int err;
; 4140 : #endif
; 4141 : #ifndef WITH_LEAN
; 4142 :   int len = SOAP_BUFLEN;

	mov	DWORD PTR _len$[ebp], 65536		; 00010000H

; 4143 :   int set = 1;

	mov	DWORD PTR _set$[ebp], 1

; 4144 : #endif
; 4145 :   if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	je	SHORT $LN22@soap_bind

; 4146 :   { soap->fclosesocket(soap, soap->master);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12404]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12288]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4147 :     soap->master = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12404], -1
$LN22@soap_bind:

; 4148 :   }
; 4149 :   soap->socket = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12408], -1

; 4150 :   soap->errmode = 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 1

; 4151 :   if (tcp_init(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_init
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@soap_bind

; 4152 :   { soap_set_receiver_error(soap, tcp_error(soap), "TCP init failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4153 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN21@soap_bind:

; 4154 :   }
; 4155 : #ifdef WITH_IPV6
; 4156 :   memset((void*)&hints, 0, sizeof(hints));
; 4157 :   hints.ai_family = PF_UNSPEC;
; 4158 : #ifndef WITH_LEAN
; 4159 :   if ((soap->omode & SOAP_IO_UDP))
; 4160 :     hints.ai_socktype = SOCK_DGRAM;
; 4161 :   else
; 4162 : #endif
; 4163 :     hints.ai_socktype = SOCK_STREAM;
; 4164 :   hints.ai_flags = AI_PASSIVE;
; 4165 :   soap->errmode = 2;
; 4166 :   err = getaddrinfo(host, soap_int2s(soap, port), &hints, &addrinfo);
; 4167 :   if (addrinfo)
; 4168 :   { res = *addrinfo;
; 4169 :     memcpy(&soap->peer, addrinfo->ai_addr, addrinfo->ai_addrlen);
; 4170 :     soap->peerlen = addrinfo->ai_addrlen;
; 4171 :     res.ai_addr = (struct sockaddr*)&soap->peer;
; 4172 :     res.ai_addrlen = soap->peerlen;
; 4173 :     freeaddrinfo(addrinfo);
; 4174 :   }
; 4175 :   if (err || !addrinfo)
; 4176 :   { soap_set_receiver_error(soap, SOAP_GAI_STRERROR(err), "getaddrinfo failed in soap_bind()", SOAP_TCP_ERROR);
; 4177 :     return SOAP_INVALID_SOCKET;
; 4178 :   }
; 4179 :   soap->master = (int)socket(res.ai_family, res.ai_socktype, res.ai_protocol);
; 4180 : #else
; 4181 : #ifndef WITH_LEAN
; 4182 :   if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN20@soap_bind

; 4183 :     soap->master = (int)socket(AF_INET, SOCK_DGRAM, 0);

	push	0
	push	2
	push	2
	call	_socket@12
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12404], eax

; 4184 :   else

	jmp	SHORT $LN19@soap_bind
$LN20@soap_bind:

; 4185 : #endif
; 4186 :     soap->master = (int)socket(AF_INET, SOCK_STREAM, 0);

	push	0
	push	1
	push	2
	call	_socket@12
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12404], eax
$LN19@soap_bind:

; 4187 : #endif
; 4188 :   soap->errmode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 0

; 4189 :   if (!soap_valid_socket(soap->master))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	jne	SHORT $LN18@soap_bind

; 4190 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4191 :     soap_set_receiver_error(soap, tcp_error(soap), "socket failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4192 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN18@soap_bind:

; 4193 :   }
; 4194 : #ifndef WITH_LEAN
; 4195 :   if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN17@soap_bind

; 4196 :     soap->socket = soap->master;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	mov	DWORD PTR [eax+12408], edx
$LN17@soap_bind:

; 4197 : #endif
; 4198 : #ifdef SOCKET_CLOSE_ON_EXEC
; 4199 : #ifdef WIN32
; 4200 : #ifndef UNDER_CE
; 4201 :   SetHandleInformation((HANDLE)soap->master, HANDLE_FLAG_INHERIT, 0);
; 4202 : #endif
; 4203 : #else
; 4204 :   fcntl(soap->master, F_SETFD, 1);
; 4205 : #endif
; 4206 : #endif
; 4207 : #ifndef WITH_LEAN
; 4208 :   if (soap->bind_flags && setsockopt(soap->master, SOL_SOCKET, soap->bind_flags, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN16@soap_bind
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12404]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN16@soap_bind

; 4209 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4210 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4211 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN16@soap_bind:

; 4212 :   }
; 4213 :   if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && setsockopt(soap->master, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12]
	or	edx, DWORD PTR [ecx+16]
	and	edx, 16					; 00000010H
	je	SHORT $LN15@soap_bind
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	8
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN15@soap_bind

; 4214 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4215 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4216 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN15@soap_bind:

; 4217 :   }
; 4218 :   if (setsockopt(soap->master, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN14@soap_bind

; 4219 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4220 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4221 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN14@soap_bind:

; 4222 :   }
; 4223 :   if (setsockopt(soap->master, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN13@soap_bind

; 4224 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4225 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4226 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN13@soap_bind:

; 4227 :   }
; 4228 : #ifdef TCP_NODELAY
; 4229 :   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	jne	SHORT $LN12@soap_bind
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	1
	push	6
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN12@soap_bind

; 4230 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4231 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4232 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN12@soap_bind:

; 4233 :   }
; 4234 : #endif
; 4235 : #endif
; 4236 : #ifdef WITH_IPV6
; 4237 :   soap->errmode = 0;
; 4238 :   if (bind(soap->master, res.ai_addr, (int)res.ai_addrlen))
; 4239 :   { soap->errnum = soap_socket_errno(soap->master);
; 4240 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));
; 4241 :     soap_closesock(soap);
; 4242 :     soap_set_receiver_error(soap, tcp_error(soap), "bind failed in soap_bind()", SOAP_TCP_ERROR);
; 4243 :     return SOAP_INVALID_SOCKET;
; 4244 :   }
; 4245 : #else
; 4246 :   soap->peerlen = sizeof(soap->peer);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94708], 16		; 00000010H

; 4247 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4248 :   soap->peer.sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+94692], ax

; 4249 :   soap->errmode = 2;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 2

; 4250 :   if (host)

	cmp	DWORD PTR _host$[ebp], 0
	je	SHORT $LN11@soap_bind

; 4251 :   { if (soap->fresolve(soap, host, &soap->peer.sin_addr))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94696				; 000171e8H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12276]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN10@soap_bind

; 4252 :     { soap_set_receiver_error(soap, tcp_error(soap), "get host by name failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4253 :       return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN10@soap_bind:

; 4254 :     }
; 4255 :   }
; 4256 :   else

	jmp	SHORT $LN9@soap_bind
$LN11@soap_bind:

; 4257 :     soap->peer.sin_addr.s_addr = htonl(INADDR_ANY);

	push	0
	call	_htonl@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+94696], eax
$LN9@soap_bind:

; 4258 :   soap->peer.sin_port = htons((short)port);

	mov	ecx, DWORD PTR _port$[ebp]
	call	@_RTC_Check_4_to_2@4
	movzx	eax, ax
	push	eax
	call	_htons@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+94694], ax

; 4259 :   soap->errmode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 0

; 4260 :   if (bind(soap->master, (struct sockaddr*)&soap->peer, (int)soap->peerlen))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+94708]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 94692				; 000171e4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12404]
	push	ecx
	call	_bind@12
	test	eax, eax
	je	$LN8@soap_bind

; 4261 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4262 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_bind
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_bind
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_bind:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_bind
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84335[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@OGKHECJC@Could?5not?5bind?5to?5host?6?$AA@
	mov	eax, DWORD PTR _fdebug$84335[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84335[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_bind:

; 4263 :     soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4264 :     soap_set_receiver_error(soap, tcp_error(soap), "bind failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4265 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN23@soap_bind
$LN8@soap_bind:

; 4266 :   }
; 4267 : #endif
; 4268 :   if (!(soap->omode & SOAP_IO_UDP) && listen(soap->master, backlog))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	jne	$LN4@soap_bind
	mov	eax, DWORD PTR _backlog$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_listen@8
	test	eax, eax
	je	$LN4@soap_bind

; 4269 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4270 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_bind
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_bind
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_bind:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_bind
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84344[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@OGKHECJC@Could?5not?5bind?5to?5host?6?$AA@
	mov	eax, DWORD PTR _fdebug$84344[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84344[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_bind:

; 4271 :     soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4272 :     soap_set_receiver_error(soap, tcp_error(soap), "listen failed in soap_bind()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4273 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN23@soap_bind
$LN4@soap_bind:

; 4274 :   }
; 4275 :   return soap->master;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+12404]
$LN23@soap_bind:

; 4276 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@soap_bind
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@soap_bind:
	DD	2
	DD	$LN27@soap_bind
$LN27@soap_bind:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN25@soap_bind
	DD	-20					; ffffffecH
	DD	4
	DD	$LN26@soap_bind
$LN26@soap_bind:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN25@soap_bind:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_soap_bind ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@IDBKHPIE@Polling?3?5other?5end?5down?5on?5socke@ ; `string'
PUBLIC	??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@ ; `string'
EXTRN	___WSAFDIsSet@8:PROC
;	COMDAT ??_C@_0DA@IDBKHPIE@Polling?3?5other?5end?5down?5on?5socke@
CONST	SEGMENT
??_C@_0DA@IDBKHPIE@Polling?3?5other?5end?5down?5on?5socke@ DB 'Polling: o'
	DB	'ther end down on socket=%d select=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@ DB 'select '
	DB	'failed in soap_poll()', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_poll
_TEXT	SEGMENT
_fdebug$84417 = -840					; size = 4
_r$ = -828						; size = 4
_xfd$ = -816						; size = 260
_sfd$ = -548						; size = 260
_rfd$ = -280						; size = 260
_timeout$ = -12						; size = 8
_soap$ = 8						; size = 4
_soap_poll PROC						; COMDAT

; 4287 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1036				; 0000040cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1036]
	mov	ecx, 259				; 00000103H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4288 : #ifndef WITH_LEAN
; 4289 :   struct timeval timeout;
; 4290 :   fd_set rfd, sfd, xfd;
; 4291 :   register int r;
; 4292 : #ifndef WIN32
; 4293 :   if ((int)soap->socket >= (int)FD_SETSIZE)
; 4294 :     return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 4295 : #endif
; 4296 :   timeout.tv_sec = 0;

	mov	DWORD PTR _timeout$[ebp], 0

; 4297 :   timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$[ebp+4], 0

; 4298 :   FD_ZERO(&rfd);

	mov	DWORD PTR _rfd$[ebp], 0

; 4299 :   FD_ZERO(&sfd);

	mov	DWORD PTR _sfd$[ebp], 0

; 4300 :   FD_ZERO(&xfd);

	mov	DWORD PTR _xfd$[ebp], 0

; 4301 :   if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	$LN32@soap_poll
$LN31@soap_poll:

; 4302 :   { FD_SET(soap->socket, &rfd);

	cmp	DWORD PTR _rfd$[ebp], 64		; 00000040H
	jae	SHORT $LN30@soap_poll
	mov	eax, DWORD PTR _rfd$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _rfd$[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _rfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _rfd$[ebp], eax
$LN30@soap_poll:
	xor	eax, eax
	jne	SHORT $LN31@soap_poll
$LN27@soap_poll:

; 4303 :     FD_SET(soap->socket, &sfd);

	cmp	DWORD PTR _sfd$[ebp], 64		; 00000040H
	jae	SHORT $LN26@soap_poll
	mov	eax, DWORD PTR _sfd$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _sfd$[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _sfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _sfd$[ebp], eax
$LN26@soap_poll:
	xor	eax, eax
	jne	SHORT $LN27@soap_poll
$LN23@soap_poll:

; 4304 :     FD_SET(soap->socket, &xfd);

	cmp	DWORD PTR _xfd$[ebp], 64		; 00000040H
	jae	SHORT $LN22@soap_poll
	mov	eax, DWORD PTR _xfd$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _xfd$[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _xfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _xfd$[ebp], eax
$LN22@soap_poll:
	xor	eax, eax
	jne	SHORT $LN23@soap_poll

; 4305 :     r = select((int)soap->socket + 1, &rfd, &sfd, &xfd, &timeout);

	lea	eax, DWORD PTR _timeout$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xfd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sfd$[ebp]
	push	edx
	lea	eax, DWORD PTR _rfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	add	edx, 1
	push	edx
	call	_select@20
	mov	DWORD PTR _r$[ebp], eax

; 4306 :     if (r > 0 && FD_ISSET(soap->socket, &xfd))

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN19@soap_poll
	lea	eax, DWORD PTR _xfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN19@soap_poll

; 4307 :       r = -1;

	mov	DWORD PTR _r$[ebp], -1
$LN19@soap_poll:

; 4308 :   }

	jmp	SHORT $LN18@soap_poll
$LN32@soap_poll:

; 4309 :   else if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	je	SHORT $LN17@soap_poll
$LN16@soap_poll:

; 4310 :   { FD_SET(soap->master, &sfd);

	cmp	DWORD PTR _sfd$[ebp], 64		; 00000040H
	jae	SHORT $LN15@soap_poll
	mov	eax, DWORD PTR _sfd$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	mov	DWORD PTR _sfd$[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _sfd$[ebp]
	add	eax, 1
	mov	DWORD PTR _sfd$[ebp], eax
$LN15@soap_poll:
	xor	eax, eax
	jne	SHORT $LN16@soap_poll

; 4311 :     r = select((int)soap->master + 1, NULL, &sfd, NULL, &timeout);

	lea	eax, DWORD PTR _timeout$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _sfd$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12404]
	add	eax, 1
	push	eax
	call	_select@20
	mov	DWORD PTR _r$[ebp], eax

; 4312 :   }
; 4313 :   else

	jmp	SHORT $LN18@soap_poll
$LN17@soap_poll:

; 4314 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN33@soap_poll
$LN18@soap_poll:

; 4315 :   if (r > 0)

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN11@soap_poll

; 4316 :   {
; 4317 : #ifdef WITH_OPENSSL
; 4318 :     if (soap->imode & SOAP_ENC_SSL)
; 4319 :     {
; 4320 :       if (soap_valid_socket(soap->socket)
; 4321 :        && FD_ISSET(soap->socket, &sfd)
; 4322 :        && (!FD_ISSET(soap->socket, &rfd)
; 4323 :         || SSL_peek(soap->ssl, soap->tmpbuf, 1) > 0))
; 4324 :         return SOAP_OK;
; 4325 :     }
; 4326 :     else
; 4327 : #endif
; 4328 :       if (soap_valid_socket(soap->socket)
; 4329 :        && FD_ISSET(soap->socket, &sfd)
; 4330 :        && (!FD_ISSET(soap->socket, &rfd)
; 4331 :         || recv(soap->socket, soap->tmpbuf, 1, MSG_PEEK) > 0))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN10@soap_poll
	lea	eax, DWORD PTR _sfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN10@soap_poll
	lea	eax, DWORD PTR _rfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN9@soap_poll
	push	2
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_recv@16
	test	eax, eax
	jle	SHORT $LN10@soap_poll
$LN9@soap_poll:

; 4332 :         return SOAP_OK;

	xor	eax, eax
	jmp	$LN33@soap_poll
$LN10@soap_poll:

; 4333 :   }

	jmp	$LN8@soap_poll
$LN11@soap_poll:

; 4334 :   else if (r < 0)

	cmp	DWORD PTR _r$[ebp], 0
	jge	SHORT $LN7@soap_poll

; 4335 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4336 :     if ((soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) && soap_socket_errno(soap->master) != SOAP_EINTR)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	jne	SHORT $LN5@soap_poll
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN6@soap_poll
$LN5@soap_poll:
	call	_WSAGetLastError@0
	cmp	eax, 10004				; 00002714H
	je	SHORT $LN6@soap_poll

; 4337 :     { soap_set_receiver_error(soap, tcp_error(soap), "select failed in soap_poll()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4338 :       return soap->error = SOAP_TCP_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 28		; 0000001cH
	mov	eax, 28					; 0000001cH
	jmp	$LN33@soap_poll
$LN6@soap_poll:

; 4339 :     }
; 4340 :   }
; 4341 :   else

	jmp	SHORT $LN8@soap_poll
$LN7@soap_poll:

; 4342 :     soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0
$LN8@soap_poll:

; 4343 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Polling: other end down on socket=%d select=%d\n", soap->socket, r));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_poll
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_poll
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_poll:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_poll
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84417[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	push	OFFSET ??_C@_0DA@IDBKHPIE@Polling?3?5other?5end?5down?5on?5socke@
	mov	eax, DWORD PTR _fdebug$84417[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84417[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_poll:

; 4344 :   return SOAP_EOF;

	or	eax, -1
$LN33@soap_poll:

; 4345 : #else
; 4346 :   return SOAP_OK;
; 4347 : #endif
; 4348 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@soap_poll
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 1036				; 0000040cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN40@soap_poll:
	DD	4
	DD	$LN39@soap_poll
$LN39@soap_poll:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN35@soap_poll
	DD	-280					; fffffee8H
	DD	260					; 00000104H
	DD	$LN36@soap_poll
	DD	-548					; fffffddcH
	DD	260					; 00000104H
	DD	$LN37@soap_poll
	DD	-816					; fffffcd0H
	DD	260					; 00000104H
	DD	$LN38@soap_poll
$LN38@soap_poll:
	DB	120					; 00000078H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN37@soap_poll:
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN36@soap_poll:
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN35@soap_poll:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_soap_poll ENDP
_TEXT	ENDS
EXTRN	_accept@12:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _tcp_accept
_TEXT	SEGMENT
_fd$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_tcp_accept PROC					; COMDAT

; 4357 : { SOAP_SOCKET fd;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4358 :   fd = accept(s, a, (SOAP_SOCKLEN_T*)n);	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_accept@12
	mov	DWORD PTR _fd$[ebp], eax

; 4359 : #ifdef SOCKET_CLOSE_ON_EXEC
; 4360 : #ifdef WIN32
; 4361 : #ifndef UNDER_CE
; 4362 :   SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0);
; 4363 : #endif
; 4364 : #else
; 4365 :   fcntl(fd, F_SETFD, FD_CLOEXEC);
; 4366 : #endif
; 4367 : #endif
; 4368 :   return fd;

	mov	eax, DWORD PTR _fd$[ebp]

; 4369 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_accept ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@ ; `string'
PUBLIC	??_C@_0BH@CKMALKEH@Accept?5failed?5from?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@ ; `string'
PUBLIC	??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0DB@HPLFKJCH@Accept?5socket?5?$CFd?5at?5port?5?$CFd?5from@ ; `string'
PUBLIC	??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@ ; `string'
PUBLIC	_soap_accept
EXTRN	_ntohs@4:PROC
;	COMDAT ??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@
CONST	SEGMENT
??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@ DB 'no master'
	DB	' socket in soap_accept()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CKMALKEH@Accept?5failed?5from?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@CKMALKEH@Accept?5failed?5from?5?$CFs?6?$AA@ DB 'Accept failed f'
	DB	'rom %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TC'
	DB	'P_NODELAY failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@
CONST	SEGMENT
??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@ DB 'setsockopt fa'
	DB	'iled in soap_accept()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_LINGER failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HPLFKJCH@Accept?5socket?5?$CFd?5at?5port?5?$CFd?5from@
CONST	SEGMENT
??_C@_0DB@HPLFKJCH@Accept?5socket?5?$CFd?5at?5port?5?$CFd?5from@ DB 'Acce'
	DB	'pt socket %d at port %d from IP %d.%d.%d.%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@ DB 'accep'
	DB	't failed in soap_accept()', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_accept
_TEXT	SEGMENT
_fdebug$84534 = -400					; size = 4
_linger$84496 = -388					; size = 4
_fdebug$84489 = -376					; size = 4
_blocking$84477 = -364					; size = 4
_nonblocking$84473 = -352				; size = 4
_r$84450 = -340						; size = 4
_fd$84449 = -328					; size = 260
_timeout$84448 = -60					; size = 8
_err$84439 = -44					; size = 4
_set$ = -32						; size = 4
_len$ = -20						; size = 4
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_accept PROC					; COMDAT

; 4380 : { int n = (int)sizeof(soap->peer);

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-596]
	mov	ecx, 149				; 00000095H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _n$[ebp], 16			; 00000010H

; 4381 : #ifndef WITH_LEAN
; 4382 :   int len = SOAP_BUFLEN;

	mov	DWORD PTR _len$[ebp], 65536		; 00010000H

; 4383 :   int set = 1;

	mov	DWORD PTR _set$[ebp], 1

; 4384 : #endif
; 4385 :   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 4386 : #ifndef WITH_LEAN
; 4387 :   if ((soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	je	SHORT $LN40@soap_accep

; 4388 :     return soap->socket = soap->master;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	mov	DWORD PTR [eax+12408], edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+12408]
	jmp	$LN41@soap_accep
$LN40@soap_accep:

; 4389 : #endif
; 4390 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4391 :   soap->socket = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12408], -1

; 4392 :   soap->errmode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90464], 0

; 4393 :   soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 4394 :   if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	je	$LN39@soap_accep
$LN38@soap_accep:

; 4395 :   { register int err;
; 4396 :     for (;;)
; 4397 :     {
; 4398 : #ifndef WITH_LEAN
; 4399 :       if (soap->accept_timeout || soap->send_timeout || soap->recv_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN34@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN34@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN36@soap_accep
$LN34@soap_accep:

; 4400 :       {
; 4401 : #ifndef WIN32
; 4402 :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 4403 :         { soap->error = SOAP_FD_EXCEEDED;
; 4404 :           return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 4405 :         }
; 4406 : #endif
; 4407 :         for (;;)
; 4408 :         { struct timeval timeout;
; 4409 :           fd_set fd;
; 4410 :           register int r;
; 4411 :           if (soap->accept_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jle	SHORT $LN32@soap_accep

; 4412 :           { timeout.tv_sec = soap->accept_timeout;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _timeout$84448[ebp], ecx

; 4413 :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$84448[ebp+4], 0
	jmp	SHORT $LN31@soap_accep
$LN32@soap_accep:

; 4414 :           }
; 4415 :           else if (soap->accept_timeout < 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jge	SHORT $LN30@soap_accep

; 4416 :           { timeout.tv_sec = -soap->accept_timeout/1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+60]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$84448[ebp], eax

; 4417 :             timeout.tv_usec = -soap->accept_timeout%1000000;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+60]
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$84448[ebp+4], edx

; 4418 :           }
; 4419 : 	  else

	jmp	SHORT $LN31@soap_accep
$LN30@soap_accep:

; 4420 :           { timeout.tv_sec = 60;

	mov	DWORD PTR _timeout$84448[ebp], 60	; 0000003cH

; 4421 :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$84448[ebp+4], 0
$LN31@soap_accep:

; 4422 :           }
; 4423 :           FD_ZERO(&fd);

	mov	DWORD PTR _fd$84449[ebp], 0
$LN28@soap_accep:

; 4424 :           FD_SET(soap->master, &fd);

	cmp	DWORD PTR _fd$84449[ebp], 64		; 00000040H
	jae	SHORT $LN27@soap_accep
	mov	eax, DWORD PTR _fd$84449[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	mov	DWORD PTR _fd$84449[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _fd$84449[ebp]
	add	eax, 1
	mov	DWORD PTR _fd$84449[ebp], eax
$LN27@soap_accep:
	xor	eax, eax
	jne	SHORT $LN28@soap_accep

; 4425 :           r = select((int)soap->master + 1, &fd, &fd, &fd, &timeout);

	lea	eax, DWORD PTR _timeout$84448[ebp]
	push	eax
	lea	ecx, DWORD PTR _fd$84449[ebp]
	push	ecx
	lea	edx, DWORD PTR _fd$84449[ebp]
	push	edx
	lea	eax, DWORD PTR _fd$84449[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	add	edx, 1
	push	edx
	call	_select@20
	mov	DWORD PTR _r$84450[ebp], eax

; 4426 :           if (r > 0)

	cmp	DWORD PTR _r$84450[ebp], 0
	jle	SHORT $LN24@soap_accep

; 4427 :             break;

	jmp	$LN36@soap_accep
$LN24@soap_accep:

; 4428 :           if (!r && soap->accept_timeout)

	cmp	DWORD PTR _r$84450[ebp], 0
	jne	SHORT $LN23@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN23@soap_accep

; 4429 :           { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 4430 :             soap_set_receiver_error(soap, "Timeout", "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
	push	OFFSET ??_C@_07MKALMBDJ@Timeout?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4431 :             return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN23@soap_accep:

; 4432 :           }
; 4433 : 	  if (r < 0)

	cmp	DWORD PTR _r$84450[ebp], 0
	jge	SHORT $LN22@soap_accep

; 4434 :           { r = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR _r$84450[ebp], eax

; 4435 :             if (r != SOAP_EINTR)

	cmp	DWORD PTR _r$84450[ebp], 10004		; 00002714H
	je	SHORT $LN22@soap_accep

; 4436 :             { soap->errnum = r;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _r$84450[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 4437 :               soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4438 :               soap_set_sender_error(soap, tcp_error(soap), "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_sender_error
	add	esp, 16					; 00000010H

; 4439 :               return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN22@soap_accep:

; 4440 :             }
; 4441 : 	  }
; 4442 :         }

	jmp	$LN34@soap_accep
$LN36@soap_accep:

; 4443 :       }
; 4444 :       if (soap->accept_timeout || soap->send_timeout || soap->recv_timeout)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN19@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN19@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN20@soap_accep
$LN19@soap_accep:

; 4445 :         SOAP_SOCKNONBLOCK(soap->master)

	mov	DWORD PTR _nonblocking$84473[ebp], 1
	lea	eax, DWORD PTR _nonblocking$84473[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_ioctlsocket@12

; 4446 :       else

	jmp	SHORT $LN18@soap_accep
$LN20@soap_accep:

; 4447 :         SOAP_SOCKBLOCK(soap->master)

	mov	DWORD PTR _blocking$84477[ebp], 0
	lea	eax, DWORD PTR _blocking$84477[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12404]
	push	edx
	call	_ioctlsocket@12
$LN18@soap_accep:

; 4448 : #endif
; 4449 :       soap->socket = soap->faccept(soap, soap->master, (struct sockaddr*)&soap->peer, &n);

	mov	esi, esp
	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 94692				; 000171e4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12404]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12300]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12408], eax

; 4450 :       soap->peerlen = (size_t)n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+94708], ecx

; 4451 :       if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	$LN17@soap_accep

; 4452 :       {
; 4453 : #ifdef WITH_IPV6
; 4454 : /* Use soap->host to store the numeric form of the remote host */
; 4455 :         getnameinfo((struct sockaddr*)&soap->peer, n, soap->host, sizeof(soap->host), NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);
; 4456 :         DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept socket %d from %s\n", soap->socket, soap->host));
; 4457 :         soap->ip = 0; /* info stored in soap->peer and soap->host */
; 4458 :         soap->port = 0; /* info stored in soap->peer and soap->host */
; 4459 : #else
; 4460 :         soap->ip = ntohl(soap->peer.sin_addr.s_addr);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+94696]
	push	ecx
	call	_ntohl@4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90404], eax

; 4461 :         soap->port = (int)ntohs(soap->peer.sin_port); /* does not return port number on some systems */

	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, WORD PTR [eax+94694]
	push	ecx
	call	_ntohs@4
	movzx	edx, ax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90408], edx

; 4462 :         DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept socket %d at port %d from IP %d.%d.%d.%d\n", soap->socket, soap->port, (int)(soap->ip>>24)&0xFF, (int)(soap->ip>>16)&0xFF, (int)(soap->ip>>8)&0xFF, (int)soap->ip&0xFF));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN16@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN15@soap_accep
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN15@soap_accep:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN16@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84489[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90404]
	and	ecx, 255				; 000000ffH
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90404]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90404]
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90404]
	shr	ecx, 24					; 00000018H
	and	ecx, 255				; 000000ffH
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90408]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	push	OFFSET ??_C@_0DB@HPLFKJCH@Accept?5socket?5?$CFd?5at?5port?5?$CFd?5from@
	mov	eax, DWORD PTR _fdebug$84489[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84489[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@soap_accep:

; 4463 : #endif
; 4464 : #ifndef WITH_LEAN
; 4465 :         if (soap->accept_flags == SO_LINGER)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+76], 128			; 00000080H
	jne	$LN13@soap_accep

; 4466 :         { struct linger linger;
; 4467 :           memset((void*)&linger, 0, sizeof(linger));

	push	4
	push	0
	lea	eax, DWORD PTR _linger$84496[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4468 :           linger.l_onoff = 1;

	mov	eax, 1
	mov	WORD PTR _linger$84496[ebp], ax

; 4469 :           linger.l_linger = 0;

	xor	eax, eax
	mov	WORD PTR _linger$84496[ebp+2], ax

; 4470 :           if (setsockopt(soap->socket, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(struct linger)))

	push	4
	lea	eax, DWORD PTR _linger$84496[ebp]
	push	eax
	push	128					; 00000080H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN12@soap_accep

; 4471 :           { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4472 :             soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_LINGER failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4473 :             soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4474 :             return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN12@soap_accep:

; 4475 :           }
; 4476 :         }

	jmp	SHORT $LN11@soap_accep
$LN13@soap_accep:

; 4477 :         else if (soap->accept_flags && setsockopt(soap->socket, SOL_SOCKET, soap->accept_flags, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN11@soap_accep
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN11@soap_accep

; 4478 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4479 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4480 :           soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4481 :           return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN11@soap_accep:

; 4482 :         }
; 4483 :         if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && setsockopt(soap->socket, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12]
	or	edx, DWORD PTR [ecx+16]
	and	edx, 16					; 00000010H
	je	SHORT $LN9@soap_accep
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	8
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN9@soap_accep

; 4484 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4485 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4486 :           soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4487 :           return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN9@soap_accep:

; 4488 :         }
; 4489 :         if (setsockopt(soap->socket, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN8@soap_accep

; 4490 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4491 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4492 :           soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4493 :           return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN8@soap_accep:

; 4494 :         }
; 4495 :         if (setsockopt(soap->socket, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN7@soap_accep

; 4496 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4497 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4498 :           soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4499 :           return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN7@soap_accep:

; 4500 :         }
; 4501 : #ifdef TCP_NODELAY
; 4502 :         if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->socket, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	jne	SHORT $LN6@soap_accep
	push	4
	lea	eax, DWORD PTR _set$[ebp]
	push	eax
	push	1
	push	6
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN6@soap_accep

; 4503 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90468], eax

; 4504 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4505 :           soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4506 :           return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	$LN41@soap_accep
$LN6@soap_accep:

; 4507 :         }
; 4508 : #endif
; 4509 : #endif
; 4510 :         soap->keep_alive = (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) != 0);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12]
	or	edx, DWORD PTR [ecx+16]
	and	edx, 16					; 00000010H
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	WORD PTR [eax+90412], dx

; 4511 :         return soap->socket;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+12408]
	jmp	$LN41@soap_accep
$LN17@soap_accep:

; 4512 :       }
; 4513 :       err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0
	mov	DWORD PTR _err$84439[ebp], eax

; 4514 :       if (err != 0 && err != SOAP_EINTR && err != SOAP_EAGAIN && err != SOAP_EWOULDBLOCK)

	cmp	DWORD PTR _err$84439[ebp], 0
	je	$LN5@soap_accep
	cmp	DWORD PTR _err$84439[ebp], 10004	; 00002714H
	je	$LN5@soap_accep
	cmp	DWORD PTR _err$84439[ebp], 10035	; 00002733H
	je	$LN5@soap_accep
	cmp	DWORD PTR _err$84439[ebp], 10035	; 00002733H
	je	$LN5@soap_accep

; 4515 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept failed from %s\n", soap->host));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_accep
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_accep:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_accep
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84534[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 89368				; 00015d18H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BH@CKMALKEH@Accept?5failed?5from?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$84534[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84534[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_accep:

; 4516 :         soap->errnum = err;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _err$84439[ebp]
	mov	DWORD PTR [eax+90468], ecx

; 4517 :         soap_set_receiver_error(soap, tcp_error(soap), "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4518 :         soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 4519 :         return SOAP_INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN41@soap_accep
$LN5@soap_accep:

; 4520 :       }
; 4521 :     }

	jmp	$LN38@soap_accep

; 4522 :   }
; 4523 :   else

	jmp	SHORT $LN41@soap_accep
$LN39@soap_accep:

; 4524 :   { soap->errnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90468], 0

; 4525 :     soap_set_receiver_error(soap, tcp_error(soap), "no master socket in soap_accept()", SOAP_TCP_ERROR);

	push	28					; 0000001cH
	push	OFFSET ??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H

; 4526 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
$LN41@soap_accep:

; 4527 :   }
; 4528 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN52@soap_accep
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 596				; 00000254H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN52@soap_accep:
	DD	8
	DD	$LN51@soap_accep
$LN51@soap_accep:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN43@soap_accep
	DD	-20					; ffffffecH
	DD	4
	DD	$LN44@soap_accep
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN45@soap_accep
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN46@soap_accep
	DD	-328					; fffffeb8H
	DD	260					; 00000104H
	DD	$LN47@soap_accep
	DD	-352					; fffffea0H
	DD	4
	DD	$LN48@soap_accep
	DD	-364					; fffffe94H
	DD	4
	DD	$LN49@soap_accep
	DD	-388					; fffffe7cH
	DD	4
	DD	$LN50@soap_accep
$LN50@soap_accep:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN49@soap_accep:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN48@soap_accep:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN47@soap_accep:
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN46@soap_accep:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN45@soap_accep:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN44@soap_accep:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN43@soap_accep:
	DB	110					; 0000006eH
	DB	0
_soap_accept ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _tcp_disconnect
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tcp_disconnect PROC					; COMDAT

; 4537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4538 : #ifdef WITH_OPENSSL
; 4539 :   if (soap->ssl)
; 4540 :   { int r, s = 0;
; 4541 :     if (soap->session)
; 4542 :     { SSL_SESSION_free(soap->session);
; 4543 :       soap->session = NULL;
; 4544 :     }
; 4545 :     if (*soap->host)
; 4546 :     { soap->session = SSL_get1_session(soap->ssl);
; 4547 :       if (soap->session)
; 4548 :       { strcpy(soap->session_host, soap->host);
; 4549 :         soap->session_port = soap->port;
; 4550 :       }
; 4551 :     }
; 4552 :     r = SSL_shutdown(soap->ssl);
; 4553 :     if (r == 0)
; 4554 :     { if (soap_valid_socket(soap->socket))
; 4555 :       { struct timeval timeout;
; 4556 :         fd_set fd;
; 4557 :         if (soap->fshutdownsocket(soap, soap->socket, 1))
; 4558 :         { /*
; 4559 :           wait up to 10 seconds for close_notify to be sent by peer (if peer not
; 4560 :           present, this avoids calling SSL_shutdown() which has a lengthy return
; 4561 :           timeout)
; 4562 :           */
; 4563 : #ifndef WIN32
; 4564 :           if ((int)soap->socket < (int)FD_SETSIZE)
; 4565 :           {
; 4566 : #endif
; 4567 :             timeout.tv_sec = 10;
; 4568 :             timeout.tv_usec = 0;
; 4569 :             FD_ZERO(&fd);
; 4570 :             FD_SET(soap->socket, &fd);
; 4571 :             r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 4572 :             if (r <= 0 && soap_socket_errno(soap->socket) != SOAP_EINTR)
; 4573 :             { soap->errnum = 0;
; 4574 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
; 4575 :               soap->fclosesocket(soap, soap->socket);
; 4576 :               soap->socket = SOAP_INVALID_SOCKET;
; 4577 :               SSL_free(soap->ssl);
; 4578 :               soap->ssl = NULL;
; 4579 :               ERR_remove_state(0);
; 4580 :               return SOAP_OK;
; 4581 :             }
; 4582 : #ifndef WIN32
; 4583 :           }
; 4584 : #endif
; 4585 :         }
; 4586 :       }
; 4587 :       r = SSL_shutdown(soap->ssl);
; 4588 :     }
; 4589 :     if (r != 1)
; 4590 :     { s = ERR_get_error();
; 4591 :       if (s)
; 4592 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Shutdown failed: %d\n", SSL_get_error(soap->ssl, r)));
; 4593 :         if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))
; 4594 :         { soap->fclosesocket(soap, soap->socket);
; 4595 :           soap->socket = SOAP_INVALID_SOCKET;
; 4596 :         }
; 4597 :         SSL_free(soap->ssl);
; 4598 :         soap->ssl = NULL;
; 4599 :         ERR_remove_state(0);
; 4600 :         return SOAP_SSL_ERROR;
; 4601 :       }
; 4602 :     }
; 4603 :     SSL_free(soap->ssl);
; 4604 :     soap->ssl = NULL;
; 4605 :     ERR_remove_state(0);
; 4606 :   }
; 4607 : #endif
; 4608 :   if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN1@tcp_discon
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 4
	jne	SHORT $LN1@tcp_discon

; 4609 :   { soap->fshutdownsocket(soap, soap->socket, 2);

	mov	esi, esp
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12292]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4610 :     soap->fclosesocket(soap, soap->socket);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12288]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4611 :     soap->socket = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12408], -1
$LN1@tcp_discon:

; 4612 :   }
; 4613 :   return SOAP_OK;

	xor	eax, eax

; 4614 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_disconnect ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CIJIHBEA@Close?5socket?5?$CFd?6?$AA@	; `string'
EXTRN	_closesocket@4:PROC
;	COMDAT ??_C@_0BB@CIJIHBEA@Close?5socket?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@CIJIHBEA@Close?5socket?5?$CFd?6?$AA@ DB 'Close socket %d', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _tcp_closesocket
_TEXT	SEGMENT
_fdebug$84554 = -8					; size = 4
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_tcp_closesocket PROC					; COMDAT

; 4623 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Close socket %d\n", (int)fd));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@tcp_closes
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@tcp_closes
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@tcp_closes:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@tcp_closes
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84554[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@CIJIHBEA@Close?5socket?5?$CFd?6?$AA@
	mov	ecx, DWORD PTR _fdebug$84554[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84554[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@tcp_closes:

; 4624 :   return soap_closesocket(fd);

	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	_closesocket@4

; 4625 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_closesocket ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HBIKFHED@Shutdown?5socket?5?$CFd?5how?$DN?$CFd?6?$AA@ ; `string'
EXTRN	_shutdown@8:PROC
;	COMDAT ??_C@_0BL@HBIKFHED@Shutdown?5socket?5?$CFd?5how?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@HBIKFHED@Shutdown?5socket?5?$CFd?5how?$DN?$CFd?6?$AA@ DB 'Shutd'
	DB	'own socket %d how=%d', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _tcp_shutdownsocket
_TEXT	SEGMENT
_fdebug$84566 = -8					; size = 4
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_how$ = 16						; size = 4
_tcp_shutdownsocket PROC				; COMDAT

; 4634 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Shutdown socket %d how=%d\n", (int)fd, how));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@tcp_shutdo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@tcp_shutdo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@tcp_shutdo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@tcp_shutdo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84566[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _how$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BL@HBIKFHED@Shutdown?5socket?5?$CFd?5how?$DN?$CFd?6?$AA@
	mov	edx, DWORD PTR _fdebug$84566[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84566[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@tcp_shutdo:

; 4635 :   return shutdown(fd, how);

	mov	eax, DWORD PTR _how$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_shutdown@8

; 4636 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_shutdownsocket ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_closesock
_TEXT	SEGMENT
_status$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_closesock PROC					; COMDAT

; 4646 : { register int status = soap->error;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR _status$[ebp], ecx

; 4647 :   if (status == SOAP_EOF || status == SOAP_TCP_ERROR || status == SOAP_SSL_ERROR || !soap->keep_alive)

	cmp	DWORD PTR _status$[ebp], -1
	je	SHORT $LN2@soap_close
	cmp	DWORD PTR _status$[ebp], 28		; 0000001cH
	je	SHORT $LN2@soap_close
	cmp	DWORD PTR _status$[ebp], 30		; 0000001eH
	je	SHORT $LN2@soap_close
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jne	SHORT $LN3@soap_close
$LN2@soap_close:

; 4648 :   { if (soap->fclose && (soap->error = soap->fclose(soap)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12304], 0
	je	SHORT $LN1@soap_close
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12304]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN1@soap_close

; 4649 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN4@soap_close
$LN1@soap_close:

; 4650 :     soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN3@soap_close:

; 4651 :   }
; 4652 : #ifdef WITH_ZLIB
; 4653 :   if (soap->zlib_state == SOAP_ZLIB_DEFLATE)
; 4654 :     deflateEnd(soap->d_stream);
; 4655 :   else if (soap->zlib_state == SOAP_ZLIB_INFLATE)
; 4656 :     inflateEnd(soap->d_stream);
; 4657 :   soap->zlib_state = SOAP_ZLIB_NONE;
; 4658 : #endif
; 4659 :   return soap->error = status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+90460], ecx
	mov	eax, DWORD PTR _status$[ebp]
$LN4@soap_close:

; 4660 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_closesock ENDP
_TEXT	ENDS
PUBLIC	_soap_hash
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_hash
_TEXT	SEGMENT
_h$ = -8						; size = 4
_s$ = 8							; size = 4
_soap_hash PROC						; COMDAT

; 4670 : { register size_t h = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _h$[ebp], 0
$LN2@soap_hash:

; 4671 :   while (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@soap_hash

; 4672 :     h = 65599*h + *s++;

	mov	eax, DWORD PTR _h$[ebp]
	imul	eax, 65599				; 0001003fH
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	add	eax, edx
	mov	DWORD PTR _h$[ebp], eax
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN2@soap_hash
$LN1@soap_hash:

; 4673 :   return h % SOAP_IDHASH;

	mov	eax, DWORD PTR _h$[ebp]
	xor	edx, edx
	mov	ecx, 1999				; 000007cfH
	div	ecx
	mov	eax, edx

; 4674 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_hash ENDP
_TEXT	ENDS
PUBLIC	_soap_new2
PUBLIC	_soap_new1
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_new1
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_soap_new1 PROC						; COMDAT

; 4699 : { return soap_new2(mode, mode);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	call	_soap_new2
	add	esp, 8

; 4700 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_new1 ENDP
_TEXT	ENDS
PUBLIC	_soap_new
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_new
_TEXT	SEGMENT
_soap_new PROC						; COMDAT

; 4709 : { return soap_new2(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	call	_soap_new2
	add	esp, 8

; 4710 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_new ENDP
_TEXT	ENDS
PUBLIC	_soap_init2
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_new2
_TEXT	SEGMENT
_soap$ = -8						; size = 4
_imode$ = 8						; size = 4
_omode$ = 12						; size = 4
_soap_new2 PROC						; COMDAT

; 4719 : { struct soap *soap = (struct soap*)malloc(sizeof(struct soap));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	push	95832					; 00017658H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _soap$[ebp], eax

; 4720 :   if (soap)

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN1@soap_new2

; 4721 :     soap_init2(soap, imode, omode);

	mov	eax, DWORD PTR _omode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _imode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_init2
	add	esp, 12					; 0000000cH
$LN1@soap_new2:

; 4722 :   return soap;

	mov	eax, DWORD PTR _soap$[ebp]

; 4723 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_new2 ENDP
_TEXT	ENDS
PUBLIC	_soap_free
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_free
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_free PROC						; COMDAT

; 4732 : { soap_done(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_done
	add	esp, 4

; 4733 :   free(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4734 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_free ENDP
_TEXT	ENDS
PUBLIC	_soap_del
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_del
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_del PROC						; COMDAT

; 4743 : { free(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4744 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_del ENDP
_TEXT	ENDS
PUBLIC	_soap_set_embedded
PUBLIC	_soap_is_single
PUBLIC	_soap_is_embedded
PUBLIC	_soap_pointer_lookup
PUBLIC	_soap_array_pointer_lookup
PUBLIC	_soap_embed
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_embed
_TEXT	SEGMENT
_pp$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_tag$ = 24						; size = 4
_type$ = 28						; size = 4
_soap_embed PROC					; COMDAT

; 4774 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4775 :   struct soap_plist *pp;
; 4776 :   if (soap->version != 1)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	je	SHORT $LN6@soap_embed

; 4777 :     soap->encoding = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax
$LN6@soap_embed:

; 4778 :   if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN5@soap_embed

; 4779 :     i = soap_array_pointer_lookup(soap, p, a, n, type, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_array_pointer_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], eax

; 4780 :   else

	jmp	SHORT $LN4@soap_embed
$LN5@soap_embed:

; 4781 :     i = soap_pointer_lookup(soap, p, type, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
$LN4@soap_embed:

; 4782 :   if (i)

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN3@soap_embed

; 4783 :   { if (soap_is_embedded(soap, pp)
; 4784 :      || soap_is_single(soap, pp))

	mov	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_is_embedded
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_embed
	mov	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_is_single
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_embed
$LN1@soap_embed:

; 4785 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN7@soap_embed
$LN2@soap_embed:

; 4786 :     soap_set_embedded(soap, pp);

	mov	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_embedded
	add	esp, 8
$LN3@soap_embed:

; 4787 :   }
; 4788 :   return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN7@soap_embed:

; 4789 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@soap_embed
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@soap_embed:
	DD	1
	DD	$LN10@soap_embed
$LN10@soap_embed:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN9@soap_embed
$LN9@soap_embed:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_embed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DHOLBNGD@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?3?5not?5@ ; `string'
PUBLIC	??_C@_0CC@JNIMGPGO@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?5id?$DN?$CFd@ ; `string'
;	COMDAT ??_C@_0CH@DHOLBNGD@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?3?5not?5@
CONST	SEGMENT
??_C@_0CH@DHOLBNGD@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?3?5not?5@ DB 'L'
	DB	'ookup location=%p type=%d: not found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNIMGPGO@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?5id?$DN?$CFd@
CONST	SEGMENT
??_C@_0CC@JNIMGPGO@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?5id?$DN?$CFd@ DB 'L'
	DB	'ookup location=%p type=%d id=%d', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_pointer_lookup
_TEXT	SEGMENT
_fdebug$84676 = -32					; size = 4
_fdebug$84670 = -20					; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_ppp$ = 20						; size = 4
_soap_pointer_lookup PROC				; COMDAT

; 4800 : { register struct soap_plist *pp;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4801 :   *ppp = NULL;

	mov	eax, DWORD PTR _ppp$[ebp]
	mov	DWORD PTR [eax], 0

; 4802 :   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN11@soap_point

; 4803 :   { for (pp = soap->pht[soap_hash_ptr(p)]; pp; pp = pp->next)

	mov	eax, DWORD PTR _p$[ebp]
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8100]
	mov	DWORD PTR _pp$[ebp], edx
	jmp	SHORT $LN10@soap_point
$LN9@soap_point:
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pp$[ebp], ecx
$LN10@soap_point:
	cmp	DWORD PTR _pp$[ebp], 0
	je	$LN11@soap_point

; 4804 :     { if (pp->ptr == p && pp->type == type)

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _p$[ebp]
	jne	$LN7@soap_point
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	$LN7@soap_point

; 4805 :       { *ppp = pp;

	mov	eax, DWORD PTR _ppp$[ebp]
	mov	ecx, DWORD PTR _pp$[ebp]
	mov	DWORD PTR [eax], ecx

; 4806 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup location=%p type=%d id=%d\n", p, type, pp->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_point
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_point
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_point:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_point
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84670[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@JNIMGPGO@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?5id?$DN?$CFd@
	mov	ecx, DWORD PTR _fdebug$84670[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84670[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_point:

; 4807 :         return pp->id;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN12@soap_point
$LN7@soap_point:

; 4808 :       }
; 4809 :     }

	jmp	$LN9@soap_point
$LN11@soap_point:

; 4810 :   }
; 4811 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup location=%p type=%d: not found\n", p, type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_point
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_point
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_point:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_point
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84676[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@DHOLBNGD@Lookup?5location?$DN?$CFp?5type?$DN?$CFd?3?5not?5@
	mov	edx, DWORD PTR _fdebug$84676[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84676[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_point:

; 4812 :   return 0;

	xor	eax, eax
$LN12@soap_point:

; 4813 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_pointer_lookup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@JJPFJJNM@Pointer?5enter?5location?$DN?$CFp?5array?$DN@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_pointer_enter@@9@4JA	; `soap_pointer_enter'::`2'::__LINE__Var
PUBLIC	_soap_pointer_enter
;	COMDAT ??_C@_0EB@JJPFJJNM@Pointer?5enter?5location?$DN?$CFp?5array?$DN@
CONST	SEGMENT
??_C@_0EB@JJPFJJNM@Pointer?5enter?5location?$DN?$CFp?5array?$DN@ DB 'Poin'
	DB	'ter enter location=%p array=%p size=%d dim=%d type=%d id=%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_pointer_enter@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_pointer_enter@@9@4JA DD 012d8H	; `soap_pointer_enter'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_pointer_enter
_TEXT	SEGMENT
tv148 = -248						; size = 4
tv145 = -244						; size = 4
_fdebug$84705 = -44					; size = 4
_pb$84690 = -32						; size = 4
_pp$ = -20						; size = 4
_h$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_type$ = 24						; size = 4
_ppp$ = 28						; size = 4
_soap_pointer_enter PROC				; COMDAT

; 4824 : { register size_t h;

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4825 :   register struct soap_plist *pp;
; 4826 :   if (!soap->pblk || soap->pidx >= SOAP_PTRBLK)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12196], 0
	je	SHORT $LN7@soap_point@2
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12200]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN8@soap_point@2
$LN7@soap_point@2:

; 4827 :   { register struct soap_pblk *pb = (struct soap_pblk*)SOAP_MALLOC(soap, sizeof(struct soap_pblk));

	push	772					; 00000304H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_pointer_enter@@9@4JA
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pb$84690[ebp], eax

; 4828 :     if (!pb)

	cmp	DWORD PTR _pb$84690[ebp], 0
	jne	SHORT $LN6@soap_point@2

; 4829 :     { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 4830 :       return 0;

	xor	eax, eax
	jmp	$LN9@soap_point@2
$LN6@soap_point@2:

; 4831 :     }
; 4832 :     pb->next = soap->pblk;

	mov	eax, DWORD PTR _pb$84690[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12196]
	mov	DWORD PTR [eax], edx

; 4833 :     soap->pblk = pb;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _pb$84690[ebp]
	mov	DWORD PTR [eax+12196], ecx

; 4834 :     soap->pidx = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12200], ax
$LN8@soap_point@2:

; 4835 :   }
; 4836 :   *ppp = pp = &soap->pblk->plist[soap->pidx++];

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12196]
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+12200]
	imul	eax, 24					; 00000018H
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _pp$[ebp], ecx
	mov	edx, DWORD PTR _ppp$[ebp]
	mov	eax, DWORD PTR _pp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	dx, WORD PTR [ecx+12200]
	add	dx, 1
	mov	eax, DWORD PTR _soap$[ebp]
	mov	WORD PTR [eax+12200], dx

; 4837 :   if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN5@soap_point@2

; 4838 :     h = soap_hash_ptr(a->__ptr);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 3
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _h$[ebp], ecx

; 4839 :   else

	jmp	SHORT $LN4@soap_point@2
$LN5@soap_point@2:

; 4840 :     h = soap_hash_ptr(p);

	mov	eax, DWORD PTR _p$[ebp]
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _h$[ebp], eax
$LN4@soap_point@2:

; 4841 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pointer enter location=%p array=%p size=%d dim=%d type=%d id=%d\n", p, a?a->__ptr:NULL, a?a->__size:0, n, type, soap->idnum+1));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN3@soap_point@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_point@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_point@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN3@soap_point@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84705[ebp], ecx
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN11@soap_point@2
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv145[ebp], ecx
	jmp	SHORT $LN12@soap_point@2
$LN11@soap_point@2:
	mov	DWORD PTR tv145[ebp], 0
$LN12@soap_point@2:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN13@soap_point@2
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $LN14@soap_point@2
$LN13@soap_point@2:
	mov	DWORD PTR tv148[ebp], 0
$LN14@soap_point@2:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12212]
	add	edx, 1
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv145[ebp]
	push	edx
	mov	eax, DWORD PTR tv148[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EB@JJPFJJNM@Pointer?5enter?5location?$DN?$CFp?5array?$DN@
	mov	edx, DWORD PTR _fdebug$84705[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84705[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_point@2:

; 4842 :   pp->next = soap->pht[h];

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8100]
	mov	DWORD PTR [eax], ecx

; 4843 :   pp->type = type;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4844 :   pp->mark1 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 0

; 4845 :   pp->mark2 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 0

; 4846 :   pp->ptr = p;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4847 :   pp->array = a;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4848 :   soap->pht[h] = pp;

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _pp$[ebp]
	mov	DWORD PTR [ecx+eax*4+8100], edx

; 4849 :   pp->id = ++soap->idnum;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12212]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12212], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12212]
	mov	DWORD PTR [eax+16], edx

; 4850 :   return pp->id;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	eax, DWORD PTR [eax+16]
$LN9@soap_point@2:

; 4851 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_pointer_enter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@LJBIOHE@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@ ; `string'
PUBLIC	??_C@_0CI@GLLDPNBA@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@ ; `string'
;	COMDAT ??_C@_0CN@LJBIOHE@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@
CONST	SEGMENT
??_C@_0CN@LJBIOHE@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@ DB 'Ar'
	DB	'ray lookup location=%p type=%d: not found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GLLDPNBA@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@
CONST	SEGMENT
??_C@_0CI@GLLDPNBA@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@ DB 'A'
	DB	'rray lookup location=%p type=%d id=%d', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_array_pointer_lookup
_TEXT	SEGMENT
_fdebug$84742 = -44					; size = 4
_fdebug$84736 = -32					; size = 4
_i$84724 = -20						; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_type$ = 24						; size = 4
_ppp$ = 28						; size = 4
_soap_array_pointer_lookup PROC				; COMDAT

; 4862 : { register struct soap_plist *pp;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4863 :   *ppp = NULL;

	mov	eax, DWORD PTR _ppp$[ebp]
	mov	DWORD PTR [eax], 0

; 4864 :   if (!p || !a->__ptr)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN16@soap_array
	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@soap_array
$LN16@soap_array:

; 4865 :     return 0;

	xor	eax, eax
	jmp	$LN18@soap_array
$LN17@soap_array:

; 4866 :   for (pp = soap->pht[soap_hash_ptr(a->__ptr)]; pp; pp = pp->next)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 3
	and	ecx, 1023				; 000003ffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+8100]
	mov	DWORD PTR _pp$[ebp], eax
	jmp	SHORT $LN15@soap_array
$LN14@soap_array:
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pp$[ebp], ecx
$LN15@soap_array:
	cmp	DWORD PTR _pp$[ebp], 0
	je	$LN13@soap_array

; 4867 :   { if (pp->type == type && pp->array && pp->array->__ptr == a->__ptr)

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	$LN12@soap_array
	mov	eax, DWORD PTR _pp$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$LN12@soap_array
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	$LN12@soap_array

; 4868 :     { register int i;
; 4869 :       for (i = 0; i < n; i++)

	mov	DWORD PTR _i$84724[ebp], 0
	jmp	SHORT $LN11@soap_array
$LN10@soap_array:
	mov	eax, DWORD PTR _i$84724[ebp]
	add	eax, 1
	mov	DWORD PTR _i$84724[ebp], eax
$LN11@soap_array:
	mov	eax, DWORD PTR _i$84724[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN9@soap_array

; 4870 :         if (((const int*)&pp->array->__size)[i] != ((const int*)&a->__size)[i])

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$84724[ebp]
	mov	eax, DWORD PTR _i$84724[ebp]
	mov	esi, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	cmp	ecx, DWORD PTR [esi+eax*4+4]
	je	SHORT $LN8@soap_array

; 4871 :           break;

	jmp	SHORT $LN9@soap_array
$LN8@soap_array:

; 4872 :       if (i == n)

	jmp	SHORT $LN10@soap_array
$LN9@soap_array:
	mov	eax, DWORD PTR _i$84724[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jne	$LN12@soap_array

; 4873 :       { *ppp = pp;

	mov	eax, DWORD PTR _ppp$[ebp]
	mov	ecx, DWORD PTR _pp$[ebp]
	mov	DWORD PTR [eax], ecx

; 4874 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array lookup location=%p type=%d id=%d\n", a->__ptr, type, pp->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_array
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_array
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_array:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_array
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84736[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CI@GLLDPNBA@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@
	mov	edx, DWORD PTR _fdebug$84736[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84736[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_array:

; 4875 :         return pp->id;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN18@soap_array
$LN12@soap_array:

; 4876 :       }
; 4877 :     }
; 4878 :   }

	jmp	$LN14@soap_array
$LN13@soap_array:

; 4879 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array lookup location=%p type=%d: not found\n", a->__ptr, type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_array
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_array
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_array:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_array
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84742[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CN@LJBIOHE@Array?5lookup?5location?$DN?$CFp?5type?$DN?$CFd@
	mov	eax, DWORD PTR _fdebug$84742[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84742[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_array:

; 4880 :   return 0;

	xor	eax, eax
$LN18@soap_array:

; 4881 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_array_pointer_lookup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@GJEGNELB@Begin?5count?5phase?5?$CIsocket?$DN?$CFd?5mod@ ; `string'
PUBLIC	_soap_set_local_namespaces
PUBLIC	_soap_clr_attr
PUBLIC	_soap_begin_count
;	COMDAT ??_C@_0DD@GJEGNELB@Begin?5count?5phase?5?$CIsocket?$DN?$CFd?5mod@
CONST	SEGMENT
??_C@_0DD@GJEGNELB@Begin?5count?5phase?5?$CIsocket?$DN?$CFd?5mod@ DB 'Beg'
	DB	'in count phase (socket=%d mode=0x%x count=%lu)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_begin_count
_TEXT	SEGMENT
_fdebug$84762 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_begin_count PROC					; COMDAT

; 4891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4892 : #ifndef WITH_LEANER
; 4893 :   if ((soap->mode & SOAP_ENC_DIME) || (soap->omode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN14@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 128				; 00000080H
	je	SHORT $LN15@soap_begin
$LN14@soap_begin:

; 4894 :     soap->mode = soap->omode | SOAP_IO_LENGTH | SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 8
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4895 :   else

	jmp	SHORT $LN13@soap_begin
$LN15@soap_begin:

; 4896 : #endif
; 4897 :   { soap->mode = soap->omode;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], edx

; 4898 :     if ((soap->mode & SOAP_IO) == SOAP_IO_STORE
; 4899 :      || (((soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_ENC_XML))
; 4900 : #ifndef WITH_LEANER
; 4901 :       && !soap->fpreparesend
; 4902 : #endif
; 4903 :      ))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	je	SHORT $LN11@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	je	SHORT $LN10@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	je	SHORT $LN12@soap_begin
$LN10@soap_begin:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12344], 0
	jne	SHORT $LN12@soap_begin
$LN11@soap_begin:

; 4904 :       soap->mode &= ~SOAP_IO_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4905 :     else

	jmp	SHORT $LN13@soap_begin
$LN12@soap_begin:

; 4906 :       soap->mode |= SOAP_IO_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN13@soap_begin:

; 4907 :   }
; 4908 : #ifdef WITH_ZLIB
; 4909 :   if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
; 4910 :   { if (!(soap->mode & SOAP_ENC_DIME))
; 4911 :       soap->mode &= ~SOAP_IO_LENGTH;
; 4912 :     if (soap->mode & SOAP_ENC_XML)
; 4913 :       soap->mode |= SOAP_IO_BUFFER;
; 4914 :     else
; 4915 :       soap->mode |= SOAP_IO_STORE;
; 4916 :   }
; 4917 : #endif
; 4918 :   if (!soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN8@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN8@soap_begin

; 4919 :     soap->mode |= SOAP_XML_TREE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN8@soap_begin:

; 4920 : #ifndef WITH_LEANER
; 4921 :   if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN7@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@soap_begin

; 4922 :     soap->mode |= SOAP_ENC_MIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4923 :   else

	jmp	SHORT $LN6@soap_begin
$LN7@soap_begin:

; 4924 :     soap->mode &= ~SOAP_ENC_MTOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN6@soap_begin:

; 4925 :   if (soap->mode & SOAP_ENC_MIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN5@soap_begin

; 4926 :     soap_select_mime_boundary(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_select_mime_boundary
	add	esp, 4
$LN5@soap_begin:

; 4927 :   soap->dime.list = soap->dime.last;	/* keep track of last DIME attachment */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90520]
	mov	DWORD PTR [eax+90512], edx

; 4928 : #endif
; 4929 :   soap->count = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], 0

; 4930 :   soap->ns = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87302], ax

; 4931 :   soap->null = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 4932 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 4933 :   soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax

; 4934 :   soap->encoding = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax

; 4935 :   soap->part = SOAP_BEGIN;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 4936 :   soap->idnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12212], 0

; 4937 :   soap_clr_attr(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_clr_attr
	add	esp, 4

; 4938 :   soap_set_local_namespaces(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_local_namespaces
	add	esp, 4

; 4939 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin count phase (socket=%d mode=0x%x count=%lu)\n", soap->socket, soap->mode, (unsigned long)soap->count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_begin
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_begin:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84762[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	push	OFFSET ??_C@_0DD@GJEGNELB@Begin?5count?5phase?5?$CIsocket?$DN?$CFd?5mod@
	mov	eax, DWORD PTR _fdebug$84762[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84762[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_begin:

; 4940 : #ifndef WITH_LEANER
; 4941 :   soap->dime.count = 0; /* count # of attachments */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90476], 0

; 4942 :   soap->dime.size = 0; /* accumulate total size of attachments */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90480], 0

; 4943 :   if (soap->fprepareinit && (soap->mode & SOAP_IO) != SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12340], 0
	je	SHORT $LN1@soap_begin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	je	SHORT $LN1@soap_begin

; 4944 :     return soap->error = soap->fprepareinit(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12340]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90460]
	jmp	SHORT $LN16@soap_begin
$LN1@soap_begin:

; 4945 : #endif
; 4946 :   return SOAP_OK;

	xor	eax, eax
$LN16@soap_begin:

; 4947 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_begin_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FFBLCEMP@End?5of?5count?5phase?6?$AA@	; `string'
PUBLIC	_soap_end_count
;	COMDAT ??_C@_0BE@FFBLCEMP@End?5of?5count?5phase?6?$AA@
CONST	SEGMENT
??_C@_0BE@FFBLCEMP@End?5of?5count?5phase?6?$AA@ DB 'End of count phase', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_end_count
_TEXT	SEGMENT
_fdebug$84774 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_end_count PROC					; COMDAT

; 4956 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4957 : #ifndef WITH_LEANER
; 4958 :   if (soap->fpreparefinal)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12352], 0
	je	SHORT $LN4@soap_end_c

; 4959 :     return soap->error = soap->fpreparefinal(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12352]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90460]
	jmp	SHORT $LN5@soap_end_c
$LN4@soap_end_c:

; 4960 : #endif
; 4961 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of count phase\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_end_c
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_end_c
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_end_c:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_end_c
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84774[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BE@FFBLCEMP@End?5of?5count?5phase?6?$AA@
	mov	eax, DWORD PTR _fdebug$84774[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84774[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_end_c:

; 4962 :   return SOAP_OK;

	xor	eax, eax
$LN5@soap_end_c:

; 4963 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_end_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@PFLIEGLG@Begin?5send?5phase?5?$CIsocket?$DN?$CFd?5mode@ ; `string'
PUBLIC	??_C@_0BJ@KKKJODLA@Initializing?5for?5output?6?$AA@ ; `string'
PUBLIC	_soap_begin_send
EXTRN	__imp___setmode:PROC
;	COMDAT ??_C@_0DC@PFLIEGLG@Begin?5send?5phase?5?$CIsocket?$DN?$CFd?5mode@
CONST	SEGMENT
??_C@_0DC@PFLIEGLG@Begin?5send?5phase?5?$CIsocket?$DN?$CFd?5mode@ DB 'Beg'
	DB	'in send phase (socket=%d mode=0x%x count=%lu)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KKKJODLA@Initializing?5for?5output?6?$AA@
CONST	SEGMENT
??_C@_0BJ@KKKJODLA@Initializing?5for?5output?6?$AA@ DB 'Initializing for '
	DB	'output', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_begin_send
_TEXT	SEGMENT
_fdebug$84805 = -20					; size = 4
_fdebug$84783 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_begin_send PROC					; COMDAT

; 4972 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for output\n"));

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN20@soap_begin@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN20@soap_begin@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84783[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@KKKJODLA@Initializing?5for?5output?6?$AA@
	mov	eax, DWORD PTR _fdebug$84783[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84783[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_begin@2:

; 4973 :   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 4974 :   soap->mode = soap->omode | (soap->mode & (SOAP_IO_LENGTH | SOAP_ENC_DIME));

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 136				; 00000088H
	mov	edx, DWORD PTR _soap$[ebp]
	or	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4975 : #ifdef WITH_ZLIB
; 4976 :   if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
; 4977 :   { if (soap->mode & SOAP_ENC_XML)
; 4978 :       soap->mode |= SOAP_IO_BUFFER;
; 4979 :     else
; 4980 :       soap->mode |= SOAP_IO_STORE;
; 4981 :   }
; 4982 : #endif
; 4983 : #ifndef WITH_LEAN
; 4984 :   if ((soap->mode & SOAP_IO_UDP))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN18@soap_begin@2

; 4985 :   { soap->mode |= SOAP_ENC_XML;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4986 :     if (soap->count > SOAP_BUFLEN)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12448], 65536		; 00010000H
	jbe	SHORT $LN18@soap_begin@2

; 4987 :       return soap->error = SOAP_UDP_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 27		; 0000001bH
	mov	eax, 27					; 0000001bH
	jmp	$LN22@soap_begin@2
$LN18@soap_begin@2:

; 4988 :   }
; 4989 : #endif
; 4990 :   if ((soap->mode & SOAP_IO) == SOAP_IO_FLUSH && soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	jne	SHORT $LN16@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN16@soap_begin@2

; 4991 :   { if (soap->count || (soap->mode & SOAP_IO_LENGTH) || (soap->mode & SOAP_ENC_XML))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12448], 0
	jne	SHORT $LN14@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	jne	SHORT $LN14@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	je	SHORT $LN15@soap_begin@2
$LN14@soap_begin@2:

; 4992 :       soap->mode |= SOAP_IO_BUFFER;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4993 :     else

	jmp	SHORT $LN16@soap_begin@2
$LN15@soap_begin@2:

; 4994 :       soap->mode |= SOAP_IO_STORE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 2
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN16@soap_begin@2:

; 4995 :   }
; 4996 :   soap->mode &= ~SOAP_IO_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4997 :   if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	SHORT $LN12@soap_begin@2

; 4998 :     soap_new_block(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_block
	add	esp, 4
$LN12@soap_begin@2:

; 4999 :   if (!(soap->mode & SOAP_IO_KEEPALIVE))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN11@soap_begin@2

; 5000 :     soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN11@soap_begin@2:

; 5001 :   if (!soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN10@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN10@soap_begin@2

; 5002 :     soap->mode |= SOAP_XML_TREE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN10@soap_begin@2:

; 5003 : #ifndef WITH_LEANER
; 5004 :   if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN9@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN9@soap_begin@2

; 5005 :   { soap->mode |= SOAP_ENC_MIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 5006 :     soap->mode &= ~SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 5007 :   }
; 5008 :   else

	jmp	SHORT $LN8@soap_begin@2
$LN9@soap_begin@2:

; 5009 :     soap->mode &= ~SOAP_ENC_MTOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN8@soap_begin@2:

; 5010 :   if (soap->mode & SOAP_ENC_MIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN7@soap_begin@2

; 5011 :     soap_select_mime_boundary(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_select_mime_boundary
	add	esp, 4
$LN7@soap_begin@2:

; 5012 : #ifdef WIN32
; 5013 : #ifndef UNDER_CE
; 5014 : #ifndef WITH_FASTCGI
; 5015 :   if (!soap_valid_socket(soap->socket)) /* Set win32 stdout or soap->sendfd to BINARY, e.g. to support DIME */

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	jne	SHORT $LN6@soap_begin@2

; 5016 : #ifdef __BORLANDC__
; 5017 :     setmode(soap->sendfd, O_BINARY);
; 5018 : #else
; 5019 :     _setmode(soap->sendfd, _O_BINARY);

	mov	esi, esp
	push	32768					; 00008000H
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12420]
	push	ecx
	call	DWORD PTR __imp___setmode
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_begin@2:

; 5020 : #endif
; 5021 : #endif
; 5022 : #endif
; 5023 : #endif
; 5024 : #endif
; 5025 :   if (soap->mode & SOAP_IO)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	je	SHORT $LN5@soap_begin@2

; 5026 :   { soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0

; 5027 :     soap->buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], 0
$LN5@soap_begin@2:

; 5028 :   }
; 5029 :   soap->chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87312], 0

; 5030 :   soap->ns = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87302], ax

; 5031 :   soap->null = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 5032 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 5033 :   soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax

; 5034 :   soap->encoding = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax

; 5035 :   soap->idnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12212], 0

; 5036 :   soap->level = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12444], 0

; 5037 :   soap_clr_attr(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_clr_attr
	add	esp, 4

; 5038 :   soap_set_local_namespaces(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_local_namespaces
	add	esp, 4

; 5039 : #ifdef WITH_ZLIB
; 5040 :   soap->z_ratio_out = 1.0;
; 5041 :   if ((soap->mode & SOAP_ENC_ZLIB) && soap->zlib_state != SOAP_ZLIB_DEFLATE)
; 5042 :   { if (!soap->z_buf)
; 5043 :       soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 5044 :     soap->d_stream->next_out = (Byte*)soap->z_buf;
; 5045 :     soap->d_stream->avail_out = SOAP_BUFLEN;
; 5046 : #ifdef WITH_GZIP
; 5047 :     if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
; 5048 :     { memcpy(soap->z_buf, "\37\213\10\0\0\0\0\0\0\377", 10);
; 5049 :       soap->d_stream->next_out = (Byte*)soap->z_buf + 10;
; 5050 :       soap->d_stream->avail_out = SOAP_BUFLEN - 10;
; 5051 :       soap->z_crc = crc32(0L, NULL, 0);
; 5052 :       soap->zlib_out = SOAP_ZLIB_GZIP;
; 5053 :       if (deflateInit2(soap->d_stream, soap->z_level, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY) != Z_OK)
; 5054 :         return soap->error = SOAP_ZLIB_ERROR;
; 5055 :     }
; 5056 :     else
; 5057 : #endif
; 5058 :     if (deflateInit(soap->d_stream, soap->z_level) != Z_OK)
; 5059 :       return soap->error = SOAP_ZLIB_ERROR;
; 5060 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflate initialized\n"));
; 5061 :     soap->zlib_state = SOAP_ZLIB_DEFLATE;
; 5062 :   }
; 5063 : #endif
; 5064 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin send phase (socket=%d mode=0x%x count=%lu)\n", soap->socket, soap->mode, (unsigned long)soap->count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_begin@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_begin@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84805[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	push	OFFSET ??_C@_0DC@PFLIEGLG@Begin?5send?5phase?5?$CIsocket?$DN?$CFd?5mode@
	mov	eax, DWORD PTR _fdebug$84805[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84805[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_begin@2:

; 5065 :   soap->part = SOAP_BEGIN;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 5066 : #ifndef WITH_LEANER
; 5067 :   if (soap->fprepareinit && (soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12340], 0
	je	SHORT $LN1@soap_begin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	SHORT $LN1@soap_begin@2

; 5068 :     soap->fprepareinit(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12340]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_begin@2:

; 5069 : #endif
; 5070 :   return SOAP_OK;

	xor	eax, eax
$LN22@soap_begin@2:

; 5071 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_begin_send ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@KFHILHO@Embedded?5?$CFp?5type?$DN?$CFd?5mark?5set?5to?5@ ; `string'
PUBLIC	_soap_embedded
;	COMDAT ??_C@_0CD@KFHILHO@Embedded?5?$CFp?5type?$DN?$CFd?5mark?5set?5to?5@
CONST	SEGMENT
??_C@_0CD@KFHILHO@Embedded?5?$CFp?5type?$DN?$CFd?5mark?5set?5to?5@ DB 'Em'
	DB	'bedded %p type=%d mark set to 1', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_embedded
_TEXT	SEGMENT
_fdebug$84820 = -20					; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_embedded PROC					; COMDAT

; 5081 : { struct soap_plist *pp;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5082 :   if (soap_pointer_lookup(soap, p, t, &pp))

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@soap_embed@2

; 5083 :   { pp->mark1 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 1

; 5084 :     pp->mark2 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 1

; 5085 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded %p type=%d mark set to 1\n", p, t));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_embed@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_embed@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_embed@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_embed@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84820[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@KFHILHO@Embedded?5?$CFp?5type?$DN?$CFd?5mark?5set?5to?5@
	mov	edx, DWORD PTR _fdebug$84820[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84820[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_embed@2:

; 5086 :   }
; 5087 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_embed@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@soap_embed@2:
	DD	1
	DD	$LN8@soap_embed@2
$LN8@soap_embed@2:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN7@soap_embed@2
$LN7@soap_embed@2:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_embedded ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@CAIAJLEO@Reference?5?$CFp?5type?$DN?$CFd?5?$CI?$CFd?5?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	_soap_reference
;	COMDAT ??_C@_0BO@CAIAJLEO@Reference?5?$CFp?5type?$DN?$CFd?5?$CI?$CFd?5?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BO@CAIAJLEO@Reference?5?$CFp?5type?$DN?$CFd?5?$CI?$CFd?5?$CFd?$CJ?6?$AA@ DB 'R'
	DB	'eference %p type=%d (%d %d)', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_reference
_TEXT	SEGMENT
_fdebug$84839 = -20					; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_reference PROC					; COMDAT

; 5098 : { struct soap_plist *pp;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5099 :   if (!p || (soap->mode & SOAP_XML_TREE))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN9@soap_refer
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN10@soap_refer
$LN9@soap_refer:

; 5100 :     return 1;

	mov	eax, 1
	jmp	$LN11@soap_refer
$LN10@soap_refer:

; 5101 :   if (soap_pointer_lookup(soap, p, t, &pp))

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN8@soap_refer

; 5102 :   { if (pp->mark1 == 0)

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $LN7@soap_refer

; 5103 :     { pp->mark1 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 2

; 5104 :       pp->mark2 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 2
$LN7@soap_refer:

; 5105 :     }
; 5106 :   }

	jmp	SHORT $LN6@soap_refer
$LN8@soap_refer:

; 5107 :   else if (soap_pointer_enter(soap, p, NULL, 0, t, &pp))

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN5@soap_refer

; 5108 :   { pp->mark1 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 0

; 5109 :     pp->mark2 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 0

; 5110 :   }
; 5111 :   else

	jmp	SHORT $LN6@soap_refer
$LN5@soap_refer:

; 5112 :     return 1;

	mov	eax, 1
	jmp	$LN11@soap_refer
$LN6@soap_refer:

; 5113 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reference %p type=%d (%d %d)\n", p, t, (int)pp->mark1, (int)pp->mark2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_refer
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_refer
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_refer:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_refer
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84839[ebp], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@CAIAJLEO@Reference?5?$CFp?5type?$DN?$CFd?5?$CI?$CFd?5?$CFd?$CJ?6?$AA@
	mov	eax, DWORD PTR _fdebug$84839[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84839[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_refer:

; 5114 :   return pp->mark1;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+20]
$LN11@soap_refer:

; 5115 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@soap_refer
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@soap_refer:
	DD	1
	DD	$LN14@soap_refer
$LN14@soap_refer:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN13@soap_refer
$LN13@soap_refer:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_reference ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@CMNINNOJ@Array?5reference?5?$CFp?5ptr?$DN?$CFp?5dim?$DN?$CFd@ ; `string'
PUBLIC	_soap_array_reference
;	COMDAT ??_C@_0DC@CMNINNOJ@Array?5reference?5?$CFp?5ptr?$DN?$CFp?5dim?$DN?$CFd@
CONST	SEGMENT
??_C@_0DC@CMNINNOJ@Array?5reference?5?$CFp?5ptr?$DN?$CFp?5dim?$DN?$CFd@ DB 'A'
	DB	'rray reference %p ptr=%p dim=%d type=%d (%d %d)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_array_reference
_TEXT	SEGMENT
_fdebug$84863 = -32					; size = 4
_pp$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_array_reference PROC				; COMDAT

; 5126 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5127 :   struct soap_plist *pp;
; 5128 :   if (!p || !a->__ptr)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN9@soap_array@2
	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@soap_array@2
$LN9@soap_array@2:

; 5129 :     return 1;

	mov	eax, 1
	jmp	$LN11@soap_array@2
$LN10@soap_array@2:

; 5130 :   i = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_array_pointer_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], eax

; 5131 :   if (i)

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN8@soap_array@2

; 5132 :   { if (pp->mark1 == 0)

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	jne	SHORT $LN7@soap_array@2

; 5133 :     { pp->mark1 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 2

; 5134 :       pp->mark2 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 2
$LN7@soap_array@2:

; 5135 :     }
; 5136 :   }

	jmp	SHORT $LN6@soap_array@2
$LN8@soap_array@2:

; 5137 :   else if (!soap_pointer_enter(soap, p, a, n, t, &pp))

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_pointer_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN5@soap_array@2

; 5138 :     return 1;

	mov	eax, 1
	jmp	$LN11@soap_array@2

; 5139 :   else

	jmp	SHORT $LN6@soap_array@2
$LN5@soap_array@2:

; 5140 :   { pp->mark1 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 0

; 5141 :     pp->mark2 = 0;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 0
$LN6@soap_array@2:

; 5142 :   }
; 5143 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array reference %p ptr=%p dim=%d type=%d (%d %d)\n", p, a->__ptr, n, t, (int)pp->mark1, (int)pp->mark2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN3@soap_array@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_array@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_array@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_array@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84863[ebp], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@CMNINNOJ@Array?5reference?5?$CFp?5ptr?$DN?$CFp?5dim?$DN?$CFd@
	mov	eax, DWORD PTR _fdebug$84863[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84863[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_array@2:

; 5144 :   return pp->mark1;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+20]
$LN11@soap_array@2:

; 5145 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@soap_array@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@soap_array@2:
	DD	1
	DD	$LN14@soap_array@2
$LN14@soap_array@2:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN13@soap_array@2
$LN13@soap_array@2:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_array_reference ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@JMHLEJME@Embedded_id?5embedded?5ref?5id?$DN?$CFd?5?$CF@ ; `string'
PUBLIC	??_C@_0DB@HHIPIGJ@Embedded_id?5multiref?5id?$DN?$CFd?5?$CFp?5ty@ ; `string'
PUBLIC	??_C@_0BO@JCFOJEAB@Embedded_id?5?$CFp?5type?$DN?$CFd?5id?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	_soap_embedded_id
;	COMDAT ??_C@_0DF@JMHLEJME@Embedded_id?5embedded?5ref?5id?$DN?$CFd?5?$CF@
CONST	SEGMENT
??_C@_0DF@JMHLEJME@Embedded_id?5embedded?5ref?5id?$DN?$CFd?5?$CF@ DB 'Emb'
	DB	'edded_id embedded ref id=%d %p type=%d = (%d %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HHIPIGJ@Embedded_id?5multiref?5id?$DN?$CFd?5?$CFp?5ty@
CONST	SEGMENT
??_C@_0DB@HHIPIGJ@Embedded_id?5multiref?5id?$DN?$CFd?5?$CFp?5ty@ DB 'Embe'
	DB	'dded_id multiref id=%d %p type=%d = (%d %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JCFOJEAB@Embedded_id?5?$CFp?5type?$DN?$CFd?5id?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@JCFOJEAB@Embedded_id?5?$CFp?5type?$DN?$CFd?5id?$DN?$CFd?6?$AA@ DB 'E'
	DB	'mbedded_id %p type=%d id=%d', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_embedded_id
_TEXT	SEGMENT
_fdebug$84904 = -44					; size = 4
_fdebug$84890 = -32					; size = 4
_fdebug$84879 = -20					; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_p$ = 16						; size = 4
_t$ = 20						; size = 4
_soap_embedded_id PROC					; COMDAT

; 5156 : { struct soap_plist *pp = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _pp$[ebp], 0

; 5157 :   if (soap->mode & SOAP_XML_TREE)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN21@soap_embed@3

; 5158 :     return id;

	mov	eax, DWORD PTR _id$[ebp]
	jmp	$LN22@soap_embed@3
$LN21@soap_embed@3:

; 5159 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id %p type=%d id=%d\n", p, t, id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN20@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN19@soap_embed@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN19@soap_embed@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN20@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84879[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@JCFOJEAB@Embedded_id?5?$CFp?5type?$DN?$CFd?5id?$DN?$CFd?6?$AA@
	mov	eax, DWORD PTR _fdebug$84879[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84879[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@soap_embed@3:

; 5160 :   if (soap->version == 1 && soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH) && soap->part != SOAP_IN_HEADER)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	jne	$LN17@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN17@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	jne	$LN17@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 3
	je	$LN17@soap_embed@3

; 5161 :   { if (id < 0)

	cmp	DWORD PTR _id$[ebp], 0
	jge	$LN16@soap_embed@3

; 5162 :     { id = soap_pointer_lookup(soap, p, t, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _id$[ebp], eax

; 5163 :       if (id)

	cmp	DWORD PTR _id$[ebp], 0
	je	$LN15@soap_embed@3

; 5164 :       { if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN14@soap_embed@3

; 5165 :           pp->mark1 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 2

; 5166 :         else

	jmp	SHORT $LN13@soap_embed@3
$LN14@soap_embed@3:

; 5167 :           pp->mark2 = 2;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 2
$LN13@soap_embed@3:

; 5168 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id multiref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN15@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_embed@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_embed@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN15@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84890[ebp], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@HHIPIGJ@Embedded_id?5multiref?5id?$DN?$CFd?5?$CFp?5ty@
	mov	ecx, DWORD PTR _fdebug$84890[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84890[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_embed@3:

; 5169 :       }
; 5170 :       return -1;

	or	eax, -1
	jmp	$LN22@soap_embed@3
$LN16@soap_embed@3:

; 5171 :     }
; 5172 :     return id;

	mov	eax, DWORD PTR _id$[ebp]
	jmp	$LN22@soap_embed@3
$LN17@soap_embed@3:

; 5173 :   }
; 5174 :   if (id < 0)

	cmp	DWORD PTR _id$[ebp], 0
	jge	SHORT $LN9@soap_embed@3

; 5175 :     id = soap_pointer_lookup(soap, p, t, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _id$[ebp], eax
	jmp	SHORT $LN8@soap_embed@3
$LN9@soap_embed@3:

; 5176 :   else if (id && !soap_pointer_lookup(soap, p, t, &pp))

	cmp	DWORD PTR _id$[ebp], 0
	je	SHORT $LN8@soap_embed@3
	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN8@soap_embed@3

; 5177 :     return 0;

	xor	eax, eax
	jmp	$LN22@soap_embed@3
$LN8@soap_embed@3:

; 5178 :   if (id && pp)

	cmp	DWORD PTR _id$[ebp], 0
	je	$LN6@soap_embed@3
	cmp	DWORD PTR _pp$[ebp], 0
	je	$LN6@soap_embed@3

; 5179 :   { if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN5@soap_embed@3

; 5180 :       pp->mark1 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 1

; 5181 :     else

	jmp	SHORT $LN4@soap_embed@3
$LN5@soap_embed@3:

; 5182 :       pp->mark2 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 1
$LN4@soap_embed@3:

; 5183 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id embedded ref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_embed@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_embed@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_embed@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84904[ebp], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@JMHLEJME@Embedded_id?5embedded?5ref?5id?$DN?$CFd?5?$CF@
	mov	ecx, DWORD PTR _fdebug$84904[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84904[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_embed@3:

; 5184 :   }
; 5185 :   return id;

	mov	eax, DWORD PTR _id$[ebp]
$LN22@soap_embed@3:

; 5186 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@soap_embed@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN26@soap_embed@3:
	DD	1
	DD	$LN25@soap_embed@3
$LN25@soap_embed@3:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN24@soap_embed@3
$LN24@soap_embed@3:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_embedded_id ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@BHKFGDMG@Is?5embedded?$DP?5?$CFd?5?$CFd?6?$AA@ ; `string'
;	COMDAT ??_C@_0BE@BHKFGDMG@Is?5embedded?$DP?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@BHKFGDMG@Is?5embedded?$DP?5?$CFd?5?$CFd?6?$AA@ DB 'Is embedded?'
	DB	' %d %d', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_is_embedded
_TEXT	SEGMENT
_fdebug$84917 = -8					; size = 4
_soap$ = 8						; size = 4
_pp$ = 12						; size = 4
_soap_is_embedded PROC					; COMDAT

; 5197 : { if (!pp)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _pp$[ebp], 0
	jne	SHORT $LN7@soap_is_em

; 5198 :     return 0;

	xor	eax, eax
	jmp	$LN8@soap_is_em
$LN7@soap_is_em:

; 5199 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Is embedded? %d %d\n", (int)pp->mark1, (int)pp->mark2));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_is_em
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_is_em
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_is_em:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_is_em
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84917[ebp], ecx
	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_0BE@BHKFGDMG@Is?5embedded?$DP?5?$CFd?5?$CFd?6?$AA@
	mov	ecx, DWORD PTR _fdebug$84917[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84917[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_is_em:

; 5200 :   if (soap->version == 1 && soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH) && soap->part != SOAP_IN_HEADER)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	jne	SHORT $LN3@soap_is_em
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN3@soap_is_em
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN3@soap_is_em
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 3
	je	SHORT $LN3@soap_is_em

; 5201 :   { if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN2@soap_is_em

; 5202 :       return pp->mark1 != 0;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+20]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN8@soap_is_em
$LN2@soap_is_em:

; 5203 :     return pp->mark2 != 0;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+21]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN8@soap_is_em
$LN3@soap_is_em:

; 5204 :   }
; 5205 :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN1@soap_is_em

; 5206 :     return pp->mark1 == 1;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+20]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN8@soap_is_em
$LN1@soap_is_em:

; 5207 :   return pp->mark2 == 1;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+21]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
$LN8@soap_is_em:

; 5208 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_is_embedded ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_is_single
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_pp$ = 12						; size = 4
_soap_is_single PROC					; COMDAT

; 5219 : { if (soap->part == SOAP_IN_HEADER)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 3
	jne	SHORT $LN3@soap_is_si

; 5220 :     return 1;

	mov	eax, 1
	jmp	SHORT $LN4@soap_is_si
$LN3@soap_is_si:

; 5221 :   if (!pp)

	cmp	DWORD PTR _pp$[ebp], 0
	jne	SHORT $LN2@soap_is_si

; 5222 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN4@soap_is_si
$LN2@soap_is_si:

; 5223 :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN1@soap_is_si

; 5224 :     return pp->mark1 == 0;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+20]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN4@soap_is_si
$LN1@soap_is_si:

; 5225 :   return pp->mark2 == 0;

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	eax, BYTE PTR [eax+21]
	neg	eax
	sbb	eax, eax
	add	eax, 1
$LN4@soap_is_si:

; 5226 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_is_single ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_set_embedded
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_pp$ = 12						; size = 4
_soap_set_embedded PROC					; COMDAT

; 5237 : { if (!pp)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _pp$[ebp], 0
	jne	SHORT $LN3@soap_set_e

; 5238 :     return;

	jmp	SHORT $LN4@soap_set_e
$LN3@soap_set_e:

; 5239 :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN2@soap_set_e

; 5240 :     pp->mark1 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 1

; 5241 :   else

	jmp	SHORT $LN4@soap_set_e
$LN2@soap_set_e:

; 5242 :     pp->mark2 = 1;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 1
$LN4@soap_set_e:

; 5243 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_embedded ENDP
_TEXT	ENDS
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
PUBLIC	??_C@_04MLBGAAHD@cid?3?$AA@			; `string'
PUBLIC	_soap_element_end_out
PUBLIC	_soap_element_href
PUBLIC	??_C@_04CMBCJJJD@href?$AA@			; `string'
PUBLIC	_soap_element_begin_out
PUBLIC	??_C@_0CM@ILDKLAOP@Attachment?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFs?8?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	_soap_element_id
PUBLIC	_soap_attachment
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLBGAAHD@cid?3?$AA@
CONST	SEGMENT
??_C@_04MLBGAAHD@cid?3?$AA@ DB 'cid:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href?$AA@
CONST	SEGMENT
??_C@_04CMBCJJJD@href?$AA@ DB 'href', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ILDKLAOP@Attachment?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFs?8?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CM@ILDKLAOP@Attachment?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFs?8?5?$CI?$CFd?$CJ@ DB 'A'
	DB	'ttachment tag=''%s'' id=''%s'' (%d) type=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_attachment
_TEXT	SEGMENT
tv94 = -260						; size = 4
tv90 = -256						; size = 4
_s$84982 = -56						; size = 4
_content$84973 = -44					; size = 4
_fdebug$84959 = -32					; size = 4
_i$ = -20						; size = 4
_pp$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_a$ = 24						; size = 4
_aid$ = 28						; size = 4
_atype$ = 32						; size = 4
_aoptions$ = 36						; size = 4
_n$ = 40						; size = 4
_type$ = 44						; size = 4
_t$ = 48						; size = 4
_soap_attachment PROC					; COMDAT

; 5254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5255 : #ifndef WITH_NOIDREF
; 5256 :   struct soap_plist *pp;
; 5257 :   int i;
; 5258 :   if (!p || !a->__ptr || (!aid && !atype))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN24@soap_attac
	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN24@soap_attac
	cmp	DWORD PTR _aid$[ebp], 0
	jne	SHORT $LN25@soap_attac
	cmp	DWORD PTR _atype$[ebp], 0
	jne	SHORT $LN25@soap_attac
$LN24@soap_attac:

; 5259 :     return soap_element_id(soap, tag, id, p, a, n, type, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_id
	add	esp, 32					; 00000020H
	jmp	$LN26@soap_attac
$LN25@soap_attac:

; 5260 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Attachment tag='%s' id='%s' (%d) type='%s'\n", tag, aid?aid:"", id, atype?atype:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN23@soap_attac
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN22@soap_attac
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN22@soap_attac:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN23@soap_attac
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84959[ebp], ecx
	cmp	DWORD PTR _atype$[ebp], 0
	je	SHORT $LN28@soap_attac
	mov	eax, DWORD PTR _atype$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN29@soap_attac
$LN28@soap_attac:
	mov	DWORD PTR tv90[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN29@soap_attac:
	cmp	DWORD PTR _aid$[ebp], 0
	je	SHORT $LN30@soap_attac
	mov	ecx, DWORD PTR _aid$[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN31@soap_attac
$LN30@soap_attac:
	mov	DWORD PTR tv94[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@soap_attac:
	mov	esi, esp
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	push	OFFSET ??_C@_0CM@ILDKLAOP@Attachment?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFs?8?5?$CI?$CFd?$CJ@
	mov	eax, DWORD PTR _fdebug$84959[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84959[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@soap_attac:

; 5261 :   i = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_array_pointer_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], eax

; 5262 :   if (!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN20@soap_attac

; 5263 :   { i = soap_pointer_enter(soap, p, a, n, t, &pp);

	lea	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_pointer_enter
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], eax

; 5264 :     if (!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN20@soap_attac

; 5265 :     { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 5266 :       return -1;

	or	eax, -1
	jmp	$LN26@soap_attac
$LN20@soap_attac:

; 5267 :     }
; 5268 :   }
; 5269 :   if (id <= 0)

	cmp	DWORD PTR _id$[ebp], 0
	jg	SHORT $LN18@soap_attac

; 5270 :     id = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN18@soap_attac:

; 5271 :   if (!aid)

	cmp	DWORD PTR _aid$[ebp], 0
	jne	SHORT $LN17@soap_attac

; 5272 :   { sprintf(soap->tmpbuf, soap->dime_id_format, id);

	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5273 :     aid = soap_strdup(soap, soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _aid$[ebp], eax
$LN17@soap_attac:

; 5274 :   }
; 5275 :   /* Add MTOM xop:Include element when necessary */
; 5276 :   /* TODO: this code to be obsoleted with new import/xop.h conventions */
; 5277 :   if ((soap->mode & SOAP_ENC_MTOM) && strcmp(tag, "xop:Include"))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN16@soap_attac
	push	OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_attac

; 5278 :   { if (soap_element_begin_out(soap, tag, 0, type)
; 5279 :      || soap_element_href(soap, "xop:Include", 0, "href", aid)
; 5280 :      || soap_element_end_out(soap, tag))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN14@soap_attac
	mov	eax, DWORD PTR _aid$[ebp]
	push	eax
	push	OFFSET ??_C@_04CMBCJJJD@href?$AA@
	push	0
	push	OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_href
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN14@soap_attac
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@soap_attac
$LN14@soap_attac:

; 5281 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN26@soap_attac
$LN15@soap_attac:

; 5282 :   }

	jmp	SHORT $LN13@soap_attac
$LN16@soap_attac:

; 5283 :   else if (soap_element_href(soap, tag, 0, "href", aid))

	mov	eax, DWORD PTR _aid$[ebp]
	push	eax
	push	OFFSET ??_C@_04CMBCJJJD@href?$AA@
	push	0
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element_href
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN13@soap_attac

; 5284 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN26@soap_attac
$LN13@soap_attac:

; 5285 :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	$LN11@soap_attac

; 5286 :   { if (pp->mark1 != 3)

	mov	eax, DWORD PTR _pp$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 3
	je	$LN10@soap_attac

; 5287 :     { struct soap_multipart *content;
; 5288 :       if (soap->mode & SOAP_ENC_MTOM)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN9@soap_attac

; 5289 :         content = soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, (char*)a->__ptr, a->__size);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 90540				; 000161acH
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 90536				; 000161a8H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_multipart
	add	esp, 20					; 00000014H
	mov	DWORD PTR _content$84973[ebp], eax

; 5290 :       else

	jmp	SHORT $LN8@soap_attac
$LN9@soap_attac:

; 5291 :         content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, (char*)a->__ptr, a->__size);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 90520				; 00016198H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 90516				; 00016194H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_multipart
	add	esp, 20					; 00000014H
	mov	DWORD PTR _content$84973[ebp], eax
$LN8@soap_attac:

; 5292 :       if (!content)

	cmp	DWORD PTR _content$84973[ebp], 0
	jne	SHORT $LN7@soap_attac

; 5293 :       { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 5294 :         return -1;

	or	eax, -1
	jmp	$LN26@soap_attac
$LN7@soap_attac:

; 5295 :       }
; 5296 :       if (!strncmp(aid, "cid:", 4)) /* RFC 2111 */

	mov	esi, esp
	push	4
	push	OFFSET ??_C@_04MLBGAAHD@cid?3?$AA@
	mov	eax, DWORD PTR _aid$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN6@soap_attac

; 5297 :       { if (soap->mode & SOAP_ENC_MTOM)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN5@soap_attac

; 5298 :         { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);

	mov	eax, DWORD PTR _aid$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _s$84982[ebp], eax

; 5299 :           if (s)

	cmp	DWORD PTR _s$84982[ebp], 0
	je	SHORT $LN4@soap_attac

; 5300 :           { *s = '<';

	mov	eax, DWORD PTR _s$84982[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH

; 5301 :             strcpy(s + 1, aid + 4);

	mov	eax, DWORD PTR _aid$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _s$84982[ebp]
	add	ecx, 1
	push	ecx
	call	_strcpy
	add	esp, 8

; 5302 :             strcat(s, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	eax, DWORD PTR _s$84982[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 5303 :             content->id = s;

	mov	eax, DWORD PTR _content$84973[ebp]
	mov	ecx, DWORD PTR _s$84982[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN4@soap_attac:

; 5304 :           }
; 5305 :         }
; 5306 :         else

	jmp	SHORT $LN3@soap_attac
$LN5@soap_attac:

; 5307 :           content->id = aid + 4;

	mov	eax, DWORD PTR _aid$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _content$84973[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN3@soap_attac:

; 5308 :       }
; 5309 :       else

	jmp	SHORT $LN2@soap_attac
$LN6@soap_attac:

; 5310 :         content->id = aid;

	mov	eax, DWORD PTR _content$84973[ebp]
	mov	ecx, DWORD PTR _aid$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN2@soap_attac:

; 5311 :       content->type = atype;

	mov	eax, DWORD PTR _content$84973[ebp]
	mov	ecx, DWORD PTR _atype$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 5312 :       content->options = aoptions;

	mov	eax, DWORD PTR _content$84973[ebp]
	mov	ecx, DWORD PTR _aoptions$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 5313 :       content->encoding = SOAP_MIME_BINARY;

	mov	eax, DWORD PTR _content$84973[ebp]
	mov	DWORD PTR [eax+24], 3

; 5314 :       pp->mark1 = 3;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+20], 3
$LN10@soap_attac:

; 5315 :     }
; 5316 :   }
; 5317 :   else

	jmp	SHORT $LN1@soap_attac
$LN11@soap_attac:

; 5318 :     pp->mark2 = 3;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	BYTE PTR [eax+21], 3
$LN1@soap_attac:

; 5319 : #endif
; 5320 :   return -1;

	or	eax, -1
$LN26@soap_attac:

; 5321 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@soap_attac
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@soap_attac:
	DD	1
	DD	$LN33@soap_attac
$LN33@soap_attac:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN32@soap_attac
$LN32@soap_attac:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_lookup
_TEXT	SEGMENT
_ip$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_lookup PROC					; COMDAT

; 5369 : { register struct soap_ilist *ip = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _ip$[ebp], 0

; 5370 :   for (ip = soap->iht[soap_hash(id)]; ip; ip = ip->next)

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_soap_hash
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN4@soap_looku
$LN3@soap_looku:
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ip$[ebp], ecx
$LN4@soap_looku:
	cmp	DWORD PTR _ip$[ebp], 0
	je	SHORT $LN2@soap_looku

; 5371 :     if (!strcmp(ip->id, id))

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_looku

; 5372 :       return ip;

	mov	eax, DWORD PTR _ip$[ebp]
	jmp	SHORT $LN5@soap_looku
$LN1@soap_looku:

; 5373 :   return NULL;

	jmp	SHORT $LN3@soap_looku
$LN2@soap_looku:
	xor	eax, eax
$LN5@soap_looku:

; 5374 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_lookup ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_enter@@9@4JA		; `soap_enter'::`2'::__LINE__Var
PUBLIC	_soap_enter
;	COMDAT ?__LINE__Var@?1??soap_enter@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_enter@@9@4JA DD 01509H		; `soap_enter'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_enter
_TEXT	SEGMENT
_ip$ = -20						; size = 4
_h$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_enter PROC					; COMDAT

; 5385 : { register size_t h;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5386 :   register struct soap_ilist *ip;
; 5387 :   ip = (struct soap_ilist*)SOAP_MALLOC(soap, sizeof(struct soap_ilist) + strlen(id));

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_enter@@9@4JA
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ip$[ebp], eax

; 5388 :   if (ip)

	cmp	DWORD PTR _ip$[ebp], 0
	je	SHORT $LN1@soap_enter

; 5389 :   { h = soap_hash(id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_soap_hash
	add	esp, 4
	mov	DWORD PTR _h$[ebp], eax

; 5390 :     strcpy(ip->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5391 :     ip->next = soap->iht[h];

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+104]
	mov	DWORD PTR [eax], ecx

; 5392 :     soap->iht[h] = ip;

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [ecx+eax*4+104], edx

; 5393 :     return ip;

	mov	eax, DWORD PTR _ip$[ebp]
	jmp	SHORT $LN2@soap_enter
$LN1@soap_enter:

; 5394 :   }
; 5395 :   return NULL;

	xor	eax, eax
$LN2@soap_enter:

; 5396 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_enter ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_malloc@@9@4JA		; `soap_malloc'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??soap_malloc@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_malloc@@9@4JA DD 0151eH		; `soap_malloc'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_malloc
_TEXT	SEGMENT
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_malloc PROC					; COMDAT

; 5406 : { register char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5407 :   if (!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN5@soap_mallo

; 5408 :     return (void*)SOAP_NON_NULL;

	mov	eax, OFFSET _soap_padding
	jmp	$LN6@soap_mallo
$LN5@soap_mallo:

; 5409 :   if (!soap)

	cmp	DWORD PTR _soap$[ebp], 0
	jne	SHORT $LN4@soap_mallo

; 5410 :     return SOAP_MALLOC(soap, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_malloc@@9@4JA
	add	ecx, 4
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	jmp	$LN6@soap_mallo
$LN4@soap_mallo:

; 5411 :   if (soap->fmalloc)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12336], 0
	je	SHORT $LN3@soap_mallo

; 5412 :     p = (char*)soap->fmalloc(soap, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12336]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _p$[ebp], eax

; 5413 :   else

	jmp	$LN2@soap_mallo
$LN3@soap_mallo:

; 5414 :   { n += sizeof(short);

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 2
	mov	DWORD PTR _n$[ebp], eax

; 5415 :     n += (-(long)n) & (sizeof(void*)-1); /* align at 4-, 8- or 16-byte boundary */

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	and	eax, 3
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 5416 :     if (!(p = (char*)SOAP_MALLOC(soap, n + sizeof(void*) + sizeof(size_t))))

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_malloc@@9@4JA
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN1@soap_mallo

; 5417 :     { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 5418 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@soap_mallo
$LN1@soap_mallo:

; 5419 :     }
; 5420 :     /* set the canary to detect corruption */
; 5421 :     *(short*)(p + n - sizeof(short)) = (short)SOAP_CANARY;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, -16162				; ffffc0deH
	mov	WORD PTR [eax-2], cx

; 5422 :     /* keep chain of alloced cells for destruction */
; 5423 :     *(void**)(p + n) = soap->alist;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax], edx

; 5424 :     *(size_t*)(p + n + sizeof(void*)) = n;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5425 :     soap->alist = p + n;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+100], eax
$LN2@soap_mallo:

; 5426 :   }
; 5427 :   soap->alloced = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87306], ax

; 5428 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN6@soap_mallo:

; 5429 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_malloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EN@GGAKCFPA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CJ?5?$DN?5?$CFp?5not?5freed?5@ ; `string'
EXTRN	__imp____iob_func:PROC
;	COMDAT ??_C@_0EN@GGAKCFPA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CJ?5?$DN?5?$CFp?5not?5freed?5@
CONST	SEGMENT
??_C@_0EN@GGAKCFPA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CJ?5?$DN?5?$CFp?5not?5freed?5@ DB '%'
	DB	's(%d): malloc() = %p not freed (memory leak or forgot to call'
	DB	' soap_end()?)', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_free_mht
_TEXT	SEGMENT
_mq$ = -32						; size = 4
_mp$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_free_mht PROC					; COMDAT

; 5446 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5447 :   register struct soap_mlist *mp, *mq;
; 5448 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@soap_free_
$LN6@soap_free_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@soap_free_:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN8@soap_free_

; 5449 :   { for (mp = soap->mht[i]; mp; mp = mq)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90572]
	mov	DWORD PTR _mp$[ebp], edx
	jmp	SHORT $LN4@soap_free_
$LN3@soap_free_:
	mov	eax, DWORD PTR _mq$[ebp]
	mov	DWORD PTR _mp$[ebp], eax
$LN4@soap_free_:
	cmp	DWORD PTR _mp$[ebp], 0
	je	SHORT $LN2@soap_free_

; 5450 :     { mq = mp->next;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mq$[ebp], ecx

; 5451 :       if (mp->live)

	mov	eax, DWORD PTR _mp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN1@soap_free_

; 5452 :         fprintf(stderr, "%s(%d): malloc() = %p not freed (memory leak or forgot to call soap_end()?)\n", mp->file, mp->line, mp->ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0EN@GGAKCFPA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CJ?5?$DN?5?$CFp?5not?5freed?5@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_free_:

; 5453 :       free(mp);

	mov	esi, esp
	mov	eax, DWORD PTR _mp$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5454 :     }

	jmp	SHORT $LN3@soap_free_
$LN2@soap_free_:

; 5455 :     soap->mht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90572], 0
	jmp	$LN6@soap_free_
$LN8@soap_free_:

; 5456 :   }
; 5457 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_free_mht ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JICNEMEA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CFlu?$CJ?5?$DN?5?$CFp?6?$AA@ ; `string'
;	COMDAT ??_C@_0BK@JICNEMEA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CFlu?$CJ?5?$DN?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BK@JICNEMEA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CFlu?$CJ?5?$DN?5?$CFp?6?$AA@ DB '%'
	DB	's(%d): malloc(%lu) = %p', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_track_malloc
_TEXT	SEGMENT
_fdebug$85112 = -44					; size = 4
_mp$85104 = -32						; size = 4
_h$85101 = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_size$ = 20						; size = 4
_soap_track_malloc PROC					; COMDAT

; 5466 : { register void *p = malloc(size);

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _p$[ebp], eax

; 5467 :   if (soap)

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN5@soap_track

; 5468 :   { register size_t h = soap_hash_ptr(p);

	mov	eax, DWORD PTR _p$[ebp]
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _h$85101[ebp], eax

; 5469 :     register struct soap_mlist *mp = (struct soap_mlist*)malloc(sizeof(struct soap_mlist));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _mp$85104[ebp], eax

; 5470 :     if (soap->fdebug[SOAP_INDEX_TEST])

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_track

; 5471 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%s(%d): malloc(%lu) = %p\n", file, line, (unsigned long)size, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_track
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_track
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_track:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_track
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85112[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@JICNEMEA@?$CFs?$CI?$CFd?$CJ?3?5malloc?$CI?$CFlu?$CJ?5?$DN?5?$CFp?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85112[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85112[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_track:

; 5472 :     }
; 5473 :     mp->next = soap->mht[h];

	mov	eax, DWORD PTR _mp$85104[ebp]
	mov	ecx, DWORD PTR _h$85101[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+90572]
	mov	DWORD PTR [eax], ecx

; 5474 :     mp->ptr = p;

	mov	eax, DWORD PTR _mp$85104[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5475 :     mp->file = file;

	mov	eax, DWORD PTR _mp$85104[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5476 :     mp->line = line;

	mov	eax, DWORD PTR _mp$85104[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5477 :     mp->live = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _mp$85104[ebp]
	mov	WORD PTR [ecx+16], ax

; 5478 :     soap->mht[h] = mp;

	mov	eax, DWORD PTR _h$85101[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _mp$85104[ebp]
	mov	DWORD PTR [ecx+eax*4+90572], edx
$LN5@soap_track:

; 5479 :   }
; 5480 :   return p;

	mov	eax, DWORD PTR _p$[ebp]

; 5481 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_track_malloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@FKHECBLG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5pointer?5not?5mal@ ; `string'
PUBLIC	??_C@_0DM@JCJBPCCG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5double?5free?5of?5@ ; `string'
PUBLIC	??_C@_0BC@BHLLEIIH@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0CH@FKHECBLG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5pointer?5not?5mal@
CONST	SEGMENT
??_C@_0CH@FKHECBLG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5pointer?5not?5mal@ DB '%'
	DB	's(%d): free(%p) pointer not malloced', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@JCJBPCCG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5double?5free?5of?5@
CONST	SEGMENT
??_C@_0DM@JCJBPCCG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5double?5free?5of?5@ DB '%'
	DB	's(%d): free(%p) double free of pointer malloced at %s(%d)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHLLEIIH@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BC@BHLLEIIH@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?6?$AA@ DB '%s('
	DB	'%d): free(%p)', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_track_free
_TEXT	SEGMENT
_fdebug$85136 = -32					; size = 4
_mp$ = -20						; size = 4
_h$ = -8						; size = 4
_soap$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_p$ = 20						; size = 4
_soap_track_free PROC					; COMDAT

; 5490 : { register size_t h = soap_hash_ptr(p);

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _p$[ebp]
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _h$[ebp], eax

; 5491 :   register struct soap_mlist *mp;
; 5492 :   for (mp = soap->mht[h]; mp; mp = mp->next)

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90572]
	mov	DWORD PTR _mp$[ebp], edx
	jmp	SHORT $LN12@soap_track@2
$LN11@soap_track@2:
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mp$[ebp], ecx
$LN12@soap_track@2:
	cmp	DWORD PTR _mp$[ebp], 0
	je	SHORT $LN10@soap_track@2

; 5493 :     if (mp->ptr == p)

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _p$[ebp]
	jne	SHORT $LN9@soap_track@2

; 5494 :       break;

	jmp	SHORT $LN10@soap_track@2
$LN9@soap_track@2:

; 5495 :   if (mp)

	jmp	SHORT $LN11@soap_track@2
$LN10@soap_track@2:
	cmp	DWORD PTR _mp$[ebp], 0
	je	$LN8@soap_track@2

; 5496 :   { if (mp->live)

	mov	eax, DWORD PTR _mp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	$LN7@soap_track@2

; 5497 :     { free(p);

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5498 :       if (soap->fdebug[SOAP_INDEX_TEST])

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_track@2

; 5499 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%s(%d): free(%p)\n", file, line, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_track@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_track@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_track@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_track@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85136[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@BHLLEIIH@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?6?$AA@
	mov	eax, DWORD PTR _fdebug$85136[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85136[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_track@2:

; 5500 :       }
; 5501 :       mp->live = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	WORD PTR [ecx+16], ax

; 5502 :     }
; 5503 :     else

	jmp	SHORT $LN2@soap_track@2
$LN7@soap_track@2:

; 5504 :       fprintf(stderr, "%s(%d): free(%p) double free of pointer malloced at %s(%d)\n", file, line, p, mp->file, mp->line);

	mov	esi, esp
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@JCJBPCCG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5double?5free?5of?5@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@soap_track@2:

; 5505 :   }
; 5506 :   else

	jmp	SHORT $LN13@soap_track@2
$LN8@soap_track@2:

; 5507 :     fprintf(stderr, "%s(%d): free(%p) pointer not malloced\n", file, line, p);

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@FKHECBLG@?$CFs?$CI?$CFd?$CJ?3?5free?$CI?$CFp?$CJ?5pointer?5not?5mal@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@soap_track@2:

; 5508 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_track_free ENDP
_TEXT	ENDS
PUBLIC	_soap_clr_mime
PUBLIC	??_C@_0BN@OEGKEGDI@Free?5all?5soap_malloc?$CI?$CJ?5data?6?$AA@ ; `string'
PUBLIC	_soap_delete
PUBLIC	?__LINE__Var@?1??soap_dealloc@@9@4JA		; `soap_dealloc'::`2'::__LINE__Var
PUBLIC	??_C@_0BC@DKLAHGFF@Freed?5data?5at?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_07FBIADCHA@?$CF2?42X?5?5?$AA@		; `string'
PUBLIC	??_C@_0BC@GPEJLMGK@Data?5corruption?3?6?$AA@	; `string'
PUBLIC	??_C@_0DC@BAMNMPBJ@Data?5corruption?5in?5dynamic?5alloc@ ; `string'
PUBLIC	_soap_dealloc
;	COMDAT ??_C@_0BN@OEGKEGDI@Free?5all?5soap_malloc?$CI?$CJ?5data?6?$AA@
CONST	SEGMENT
??_C@_0BN@OEGKEGDI@Free?5all?5soap_malloc?$CI?$CJ?5data?6?$AA@ DB 'Free a'
	DB	'll soap_malloc() data', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_dealloc@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_dealloc@@9@4JA DD 0159bH		; `soap_dealloc'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@DKLAHGFF@Freed?5data?5at?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BC@DKLAHGFF@Freed?5data?5at?5?$CFp?6?$AA@ DB 'Freed data at %p', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBIADCHA@?$CF2?42X?5?5?$AA@
CONST	SEGMENT
??_C@_07FBIADCHA@?$CF2?42X?5?5?$AA@ DB '%2.2X  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GPEJLMGK@Data?5corruption?3?6?$AA@
CONST	SEGMENT
??_C@_0BC@GPEJLMGK@Data?5corruption?3?6?$AA@ DB 'Data corruption:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BAMNMPBJ@Data?5corruption?5in?5dynamic?5alloc@
CONST	SEGMENT
??_C@_0DC@BAMNMPBJ@Data?5corruption?5in?5dynamic?5alloc@ DB 'Data corrupt'
	DB	'ion in dynamic allocation (see logs)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_dealloc
_TEXT	SEGMENT
tv246 = -340						; size = 4
tv143 = -340						; size = 4
_fdebug$85245 = -140					; size = 4
_s$85235 = -128						; size = 4
_i$85234 = -116						; size = 4
_fdebug$85230 = -104					; size = 4
_fdebug$85215 = -92					; size = 4
_q$85210 = -80						; size = 4
_fdebug$85206 = -68					; size = 4
_fdebug$85195 = -56					; size = 4
_s$85184 = -44						; size = 4
_i$85183 = -32						; size = 4
_fdebug$85178 = -20					; size = 4
_q$85162 = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_dealloc PROC					; COMDAT

; 5531 : { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN41@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN42@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN42@soap_deall
$LN41@soap_deall:

; 5532 :     return;

	jmp	$LN43@soap_deall
$LN42@soap_deall:

; 5533 :   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN40@soap_deall

; 5534 :   { register char **q;
; 5535 :     for (q = (char**)&soap->alist; *q; q = *(char***)q)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _q$85162[ebp], eax
	jmp	SHORT $LN39@soap_deall
$LN38@soap_deall:
	mov	eax, DWORD PTR _q$85162[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$85162[ebp], ecx
$LN39@soap_deall:
	mov	eax, DWORD PTR _q$85162[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN37@soap_deall

; 5536 :     {
; 5537 :       if (*(short*)(char*)(*q - sizeof(short)) != (short)SOAP_CANARY)

	mov	eax, DWORD PTR _q$85162[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, WORD PTR [ecx-2]
	cmp	edx, -16162				; ffffc0deH
	je	$LN36@soap_deall

; 5538 :       {
; 5539 : #ifdef SOAP_MEM_DEBUG
; 5540 :         fprintf(stderr, "Data corruption in dynamic allocation (see logs)\n");

	mov	esi, esp
	push	OFFSET ??_C@_0DC@BAMNMPBJ@Data?5corruption?5in?5dynamic?5alloc@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5541 : #endif
; 5542 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Data corruption:\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN35@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN34@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN34@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN35@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85178[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BC@GPEJLMGK@Data?5corruption?3?6?$AA@
	mov	eax, DWORD PTR _fdebug$85178[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85178[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@soap_deall:

; 5543 :         DBGHEX(TEST, *q - 200, 200);

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN32@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN31@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN31@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN32@soap_deall
	mov	eax, DWORD PTR _q$85162[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 200				; 000000c8H
	mov	DWORD PTR _s$85184[ebp], ecx
	mov	DWORD PTR _i$85183[ebp], 200		; 000000c8H
	jmp	SHORT $LN29@soap_deall
$LN28@soap_deall:
	mov	eax, DWORD PTR _i$85183[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$85183[ebp], eax
$LN29@soap_deall:
	cmp	DWORD PTR _i$85183[ebp], 0
	je	SHORT $LN27@soap_deall
	mov	eax, DWORD PTR _s$85184[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv143[ebp], ecx
	mov	edx, DWORD PTR _s$85184[ebp]
	add	edx, 1
	mov	DWORD PTR _s$85184[ebp], edx
	mov	esi, esp
	mov	eax, DWORD PTR tv143[ebp]
	push	eax
	push	OFFSET ??_C@_07FBIADCHA@?$CF2?42X?5?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90568]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN28@soap_deall
$LN27@soap_deall:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@soap_deall:

; 5544 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN26@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN25@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN25@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN26@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85195[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _fdebug$85195[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85195[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@soap_deall:

; 5545 :         soap->error = SOAP_MOE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 21		; 00000015H

; 5546 :         return;

	jmp	$LN43@soap_deall
$LN36@soap_deall:

; 5547 :       }
; 5548 :       if (p == (void*)(*q - *(size_t*)(*q + sizeof(void*))))

	mov	eax, DWORD PTR _q$85162[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _q$85162[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR _p$[ebp], eax
	jne	$LN23@soap_deall

; 5549 :       { *q = **(char***)q;

	mov	eax, DWORD PTR _q$85162[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _q$85162[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5550 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Freed data at %p\n", p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN22@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN21@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN21@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN22@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85206[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@DKLAHGFF@Freed?5data?5at?5?$CFp?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85206[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85206[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@soap_deall:

; 5551 :         SOAP_FREE(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_dealloc@@9@4JA
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5552 :         return;

	jmp	$LN43@soap_deall
$LN23@soap_deall:

; 5553 :       }
; 5554 :     }

	jmp	$LN38@soap_deall
$LN37@soap_deall:

; 5555 :     soap_delete(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_delete
	add	esp, 8

; 5556 :   }
; 5557 :   else

	jmp	$LN43@soap_deall
$LN40@soap_deall:

; 5558 :   { register char *q;
; 5559 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free all soap_malloc() data\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN15@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN17@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN17@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN15@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85215[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BN@OEGKEGDI@Free?5all?5soap_malloc?$CI?$CJ?5data?6?$AA@
	mov	eax, DWORD PTR _fdebug$85215[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85215[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_deall:

; 5560 :     while (soap->alist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$LN14@soap_deall

; 5561 :     { q = (char*)soap->alist;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _q$85210[ebp], ecx

; 5562 :       if (*(short*)(char*)(q - sizeof(short)) != (short)SOAP_CANARY)

	mov	eax, DWORD PTR _q$85210[ebp]
	movsx	ecx, WORD PTR [eax-2]
	cmp	ecx, -16162				; ffffc0deH
	je	$LN13@soap_deall

; 5563 :       {
; 5564 : #ifdef SOAP_MEM_DEBUG
; 5565 :         fprintf(stderr, "Data corruption in dynamic allocation (see logs)\n");

	mov	esi, esp
	push	OFFSET ??_C@_0DC@BAMNMPBJ@Data?5corruption?5in?5dynamic?5alloc@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5566 : #endif
; 5567 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Data corruption:\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN12@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85230[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BC@GPEJLMGK@Data?5corruption?3?6?$AA@
	mov	eax, DWORD PTR _fdebug$85230[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85230[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_deall:

; 5568 :         DBGHEX(TEST, q - 200, 200);

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN9@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN9@soap_deall
	mov	eax, DWORD PTR _q$85210[ebp]
	sub	eax, 200				; 000000c8H
	mov	DWORD PTR _s$85235[ebp], eax
	mov	DWORD PTR _i$85234[ebp], 200		; 000000c8H
	jmp	SHORT $LN6@soap_deall
$LN5@soap_deall:
	mov	eax, DWORD PTR _i$85234[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$85234[ebp], eax
$LN6@soap_deall:
	cmp	DWORD PTR _i$85234[ebp], 0
	je	SHORT $LN4@soap_deall
	mov	eax, DWORD PTR _s$85235[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv246[ebp], ecx
	mov	edx, DWORD PTR _s$85235[ebp]
	add	edx, 1
	mov	DWORD PTR _s$85235[ebp], edx
	mov	esi, esp
	mov	eax, DWORD PTR tv246[ebp]
	push	eax
	push	OFFSET ??_C@_07FBIADCHA@?$CF2?42X?5?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90568]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN5@soap_deall
$LN4@soap_deall:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_deall:

; 5569 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_deall
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_deall:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_deall
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85245[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _fdebug$85245[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85245[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_deall:

; 5570 :         soap->error = SOAP_MOE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 21		; 00000015H

; 5571 :         return;

	jmp	$LN43@soap_deall
$LN13@soap_deall:

; 5572 :       }
; 5573 :       soap->alist = *(void**)q;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _q$85210[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+100], edx

; 5574 :       q -= *(size_t*)(q + sizeof(void*));

	mov	eax, DWORD PTR _q$85210[ebp]
	mov	ecx, DWORD PTR _q$85210[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _q$85210[ebp], ecx

; 5575 :       SOAP_FREE(soap, q);

	mov	eax, DWORD PTR _q$85210[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_dealloc@@9@4JA
	add	ecx, 44					; 0000002cH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5576 :     }

	jmp	$LN15@soap_deall
$LN14@soap_deall:

; 5577 :     /* we must assume these were deallocated: */
; 5578 :     soap->action = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90392], 0

; 5579 :     soap->fault = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12208], 0

; 5580 :     soap->header = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12204], 0

; 5581 :     soap->userid = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12224], 0

; 5582 :     soap->passwd = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12228], 0

; 5583 :     soap->authrealm = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90396], 0

; 5584 :     soap->http_content = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+36], 0

; 5585 : #ifndef WITH_LEANER
; 5586 :     soap_clr_mime(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_clr_mime
	add	esp, 4
$LN43@soap_deall:

; 5587 : #endif
; 5588 :   }
; 5589 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BLMOFNCH@Could?5not?5dealloc?5data?5?$CFp?3?5addre@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_delete@@9@4JA		; `soap_delete'::`2'::__LINE__Var
PUBLIC	??_C@_0EA@LCIGDMJF@new?$CIobject?5type?5?$DN?5?$CFd?$CJ?5?$DN?5?$CFp?5not?5f@ ; `string'
PUBLIC	??_C@_0EI@CPFJIHPP@Could?5not?5dealloc?5data?5?$CFp?3?5delet@ ; `string'
;	COMDAT ??_C@_0DA@BLMOFNCH@Could?5not?5dealloc?5data?5?$CFp?3?5addre@
CONST	SEGMENT
??_C@_0DA@BLMOFNCH@Could?5not?5dealloc?5data?5?$CFp?3?5addre@ DB 'Could n'
	DB	'ot dealloc data %p: address not in list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_delete@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_delete@@9@4JA DD 015deH		; `soap_delete'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EA@LCIGDMJF@new?$CIobject?5type?5?$DN?5?$CFd?$CJ?5?$DN?5?$CFp?5not?5f@
CONST	SEGMENT
??_C@_0EA@LCIGDMJF@new?$CIobject?5type?5?$DN?5?$CFd?$CJ?5?$DN?5?$CFp?5not?5f@ DB 'n'
	DB	'ew(object type = %d) = %p not freed: deletion callback failed'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@CPFJIHPP@Could?5not?5dealloc?5data?5?$CFp?3?5delet@
CONST	SEGMENT
??_C@_0EI@CPFJIHPP@Could?5not?5dealloc?5data?5?$CFp?3?5delet@ DB 'Could n'
	DB	'ot dealloc data %p: deletion callback failed for object type '
	DB	'%d', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_delete
_TEXT	SEGMENT
_fdebug$85287 = -68					; size = 4
_q$85281 = -56						; size = 4
_fdebug$85275 = -44					; size = 4
_fdebug$85267 = -32					; size = 4
_q$85261 = -20						; size = 4
_cp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_delete PROC					; COMDAT

; 5598 : { register struct soap_clist **cp;

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5599 :   if (soap_check_state(soap))

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN20@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN20@soap_delet
$LN19@soap_delet:

; 5600 :     return;

	jmp	$LN21@soap_delet
$LN20@soap_delet:

; 5601 :   cp = &soap->clist;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR _cp$[ebp], eax

; 5602 :   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN6@soap_delet
$LN17@soap_delet:

; 5603 :   { while (*cp)

	mov	eax, DWORD PTR _cp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN16@soap_delet

; 5604 :     { if (p == (*cp)->ptr)

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN15@soap_delet

; 5605 :       { register struct soap_clist *q = *cp;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$85261[ebp], ecx

; 5606 :         *cp = q->next;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _q$85261[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 5607 :         if (q->fdelete(q))

	mov	esi, esp
	mov	eax, DWORD PTR _q$85261[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$85261[ebp]
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN14@soap_delet

; 5608 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN13@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN12@soap_delet
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN12@soap_delet:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN13@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85267[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _q$85261[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _q$85261[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0EI@CPFJIHPP@Could?5not?5dealloc?5data?5?$CFp?3?5delet@
	mov	ecx, DWORD PTR _fdebug$85267[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85267[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@soap_delet:

; 5609 : #ifdef SOAP_MEM_DEBUG
; 5610 :           fprintf(stderr, "new(object type = %d) = %p not freed: deletion callback failed\n", q->type, q->ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _q$85261[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _q$85261[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0EA@LCIGDMJF@new?$CIobject?5type?5?$DN?5?$CFd?$CJ?5?$DN?5?$CFp?5not?5f@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@soap_delet:

; 5611 : #endif
; 5612 :         }
; 5613 :         SOAP_FREE(soap, q);

	mov	eax, DWORD PTR _q$85261[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_delete@@9@4JA
	add	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5614 :         return;

	jmp	$LN21@soap_delet
$LN15@soap_delet:

; 5615 :       }
; 5616 :       cp = &(*cp)->next;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cp$[ebp], ecx

; 5617 :     }

	jmp	$LN17@soap_delet
$LN16@soap_delet:

; 5618 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: address not in list\n", p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_delet
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_delet:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85275[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@BLMOFNCH@Could?5not?5dealloc?5data?5?$CFp?3?5addre@
	mov	ecx, DWORD PTR _fdebug$85275[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85275[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_delet:

; 5619 :   }
; 5620 :   else

	jmp	$LN7@soap_delet
$LN6@soap_delet:

; 5621 :   { while (*cp)

	mov	eax, DWORD PTR _cp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN7@soap_delet

; 5622 :     { register struct soap_clist *q = *cp;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$85281[ebp], ecx

; 5623 :       *cp = q->next;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _q$85281[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 5624 :       if (q->fdelete(q))

	mov	esi, esp
	mov	eax, DWORD PTR _q$85281[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$85281[ebp]
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN4@soap_delet

; 5625 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_delet
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_delet:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_delet
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85287[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _q$85281[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _q$85281[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0EI@CPFJIHPP@Could?5not?5dealloc?5data?5?$CFp?3?5delet@
	mov	ecx, DWORD PTR _fdebug$85287[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85287[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_delet:

; 5626 : #ifdef SOAP_MEM_DEBUG
; 5627 :         fprintf(stderr, "new(object type = %d) = %p not freed: deletion callback failed\n", q->type, q->ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _q$85281[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _q$85281[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0EA@LCIGDMJF@new?$CIobject?5type?5?$DN?5?$CFd?$CJ?5?$DN?5?$CFp?5not?5f@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_delet:

; 5628 : #endif
; 5629 :       }
; 5630 :       SOAP_FREE(soap, q);

	mov	eax, DWORD PTR _q$85281[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_delete@@9@4JA
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5631 :     }

	jmp	$LN6@soap_delet
$LN7@soap_delet:

; 5632 :   }
; 5633 :   soap->fault = NULL; /* this was possibly deallocated */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12208], 0

; 5634 :   soap->header = NULL; /* this was possibly deallocated */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12204], 0
$LN21@soap_delet:

; 5635 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_delete ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_link@@9@4JA		; `soap_link'::`2'::__LINE__Var
PUBLIC	_soap_link
;	COMDAT ?__LINE__Var@?1??soap_link@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_link@@9@4JA DD 0160cH		; `soap_link'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_link
_TEXT	SEGMENT
_cp$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_n$ = 20						; size = 4
_fdelete$ = 24						; size = 4
_soap_link PROC						; COMDAT

; 5644 : { register struct soap_clist *cp;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5645 :   if ((cp = (struct soap_clist*)SOAP_MALLOC(soap, sizeof(struct soap_clist))))

	push	20					; 00000014H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_link@@9@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cp$[ebp], eax
	cmp	DWORD PTR _cp$[ebp], 0
	je	SHORT $LN1@soap_link

; 5646 :   { cp->next = soap->clist;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax], edx

; 5647 :     cp->type = t;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5648 :     cp->size = n;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5649 :     cp->ptr = p;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5650 :     cp->fdelete = fdelete;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR _fdelete$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 5651 :     soap->clist = cp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [eax+96], ecx
$LN1@soap_link:

; 5652 :   }
; 5653 :   return cp;

	mov	eax, DWORD PTR _cp$[ebp]

; 5654 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_link ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_unlink@@9@4JA		; `soap_unlink'::`2'::__LINE__Var
PUBLIC	??_C@_0BM@NOFKDLEH@Unlinked?5class?5instance?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@PPHBDEMI@Unlinked?5data?5?$CFp?6?$AA@	; `string'
PUBLIC	_soap_unlink
;	COMDAT ?__LINE__Var@?1??soap_unlink@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_unlink@@9@4JA DD 0161fH		; `soap_unlink'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@NOFKDLEH@Unlinked?5class?5instance?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BM@NOFKDLEH@Unlinked?5class?5instance?5?$CFp?6?$AA@ DB 'Unlinked c'
	DB	'lass instance %p', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPHBDEMI@Unlinked?5data?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BC@PPHBDEMI@Unlinked?5data?5?$CFp?6?$AA@ DB 'Unlinked data %p', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_unlink
_TEXT	SEGMENT
_fdebug$85333 = -44					; size = 4
_fdebug$85323 = -32					; size = 4
_cp$ = -20						; size = 4
_q$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_unlink PROC					; COMDAT

; 5663 : { register char **q;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5664 :   register struct soap_clist **cp;
; 5665 :   if (!soap || !p)

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN15@soap_unlin
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN16@soap_unlin
$LN15@soap_unlin:

; 5666 :     return;

	jmp	$LN17@soap_unlin
$LN16@soap_unlin:

; 5667 :   for (q = (char**)&soap->alist; *q; q = *(char***)q)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _q$[ebp], eax
	jmp	SHORT $LN14@soap_unlin
$LN13@soap_unlin:
	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$[ebp], ecx
$LN14@soap_unlin:
	mov	eax, DWORD PTR _q$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN12@soap_unlin

; 5668 :   { if (p == (void*)(*q - *(size_t*)(*q + sizeof(void*))))

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR _p$[ebp], eax
	jne	$LN11@soap_unlin

; 5669 :     { *q = **(char***)q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5670 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unlinked data %p\n", p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_unlin
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_unlin
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_unlin:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_unlin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85323[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@PPHBDEMI@Unlinked?5data?5?$CFp?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85323[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85323[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_unlin:

; 5671 : #ifdef SOAP_MEM_DEBUG
; 5672 :       soap_track_unlink(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_unlink
	add	esp, 8

; 5673 : #endif
; 5674 :       return;

	jmp	$LN17@soap_unlin
$LN11@soap_unlin:

; 5675 :     }
; 5676 :   }

	jmp	$LN13@soap_unlin
$LN12@soap_unlin:

; 5677 :   for (cp = &soap->clist; *cp; cp = &(*cp)->next)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR _cp$[ebp], eax
	jmp	SHORT $LN7@soap_unlin
$LN6@soap_unlin:
	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cp$[ebp], ecx
$LN7@soap_unlin:
	mov	eax, DWORD PTR _cp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN17@soap_unlin

; 5678 :   { if (p == (*cp)->ptr)

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN4@soap_unlin

; 5679 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unlinked class instance %p\n", p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_unlin
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_unlin
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_unlin:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_unlin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85333[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@NOFKDLEH@Unlinked?5class?5instance?5?$CFp?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85333[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85333[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_unlin:

; 5680 :       q = (char**)*cp;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$[ebp], ecx

; 5681 :       *cp = (*cp)->next;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cp$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5682 :       SOAP_FREE(soap, q);

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_unlink@@9@4JA
	add	ecx, 19					; 00000013H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5683 :       return;

	jmp	SHORT $LN17@soap_unlin
$LN4@soap_unlin:

; 5684 :     }

	jmp	$LN6@soap_unlin
$LN17@soap_unlin:

; 5685 :   }
; 5686 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_unlink ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_track_unlink
_TEXT	SEGMENT
_mp$ = -20						; size = 4
_h$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_track_unlink PROC					; COMDAT

; 5515 : { register size_t h = soap_hash_ptr(p);

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _p$[ebp]
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _h$[ebp], eax

; 5516 :   register struct soap_mlist *mp;
; 5517 :   for (mp = soap->mht[h]; mp; mp = mp->next)

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90572]
	mov	DWORD PTR _mp$[ebp], edx
	jmp	SHORT $LN5@soap_track@3
$LN4@soap_track@3:
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mp$[ebp], ecx
$LN5@soap_track@3:
	cmp	DWORD PTR _mp$[ebp], 0
	je	SHORT $LN3@soap_track@3

; 5518 :     if (mp->ptr == p)

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _p$[ebp]
	jne	SHORT $LN2@soap_track@3

; 5519 :       break;

	jmp	SHORT $LN3@soap_track@3
$LN2@soap_track@3:

; 5520 :   if (mp)

	jmp	SHORT $LN4@soap_track@3
$LN3@soap_track@3:
	cmp	DWORD PTR _mp$[ebp], 0
	je	SHORT $LN6@soap_track@3

; 5521 :     mp->live = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	WORD PTR [ecx+16], ax
$LN6@soap_track@3:

; 5522 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_track_unlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@DMCDAEBB@lookup?5type?5id?$DN?8?$CFs?8?5NOT?5FOUND?$CB?5N@ ; `string'
PUBLIC	??_C@_0BI@HJLJKEOP@Lookup?5id?$DN?8?$CFs?8?5type?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	_soap_lookup_type
;	COMDAT ??_C@_0DN@DMCDAEBB@lookup?5type?5id?$DN?8?$CFs?8?5NOT?5FOUND?$CB?5N@
CONST	SEGMENT
??_C@_0DN@DMCDAEBB@lookup?5type?5id?$DN?8?$CFs?8?5NOT?5FOUND?$CB?5N@ DB 'l'
	DB	'ookup type id=''%s'' NOT FOUND! Need to get it from xsi:type', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HJLJKEOP@Lookup?5id?$DN?8?$CFs?8?5type?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@HJLJKEOP@Lookup?5id?$DN?8?$CFs?8?5type?$DN?$CFd?6?$AA@ DB 'Look'
	DB	'up id=''%s'' type=%d', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_lookup_type
_TEXT	SEGMENT
_fdebug$85354 = -32					; size = 4
_fdebug$85348 = -20					; size = 4
_ip$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_lookup_type PROC					; COMDAT

; 5696 : { register struct soap_ilist *ip;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5697 :   if (id && *id)

	cmp	DWORD PTR _id$[ebp], 0
	je	$LN8@soap_looku@2
	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN8@soap_looku@2

; 5698 :   { ip = soap_lookup(soap, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_lookup
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5699 :     if (ip)

	cmp	DWORD PTR _ip$[ebp], 0
	je	SHORT $LN8@soap_looku@2

; 5700 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup id='%s' type=%d\n", id, ip->type));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_looku@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_looku@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_looku@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_looku@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85348[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	push	OFFSET ??_C@_0BI@HJLJKEOP@Lookup?5id?$DN?8?$CFs?8?5type?$DN?$CFd?6?$AA@
	mov	eax, DWORD PTR _fdebug$85348[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85348[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_looku@2:

; 5701 :       return ip->type;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN9@soap_looku@2
$LN8@soap_looku@2:

; 5702 :     }
; 5703 :   }
; 5704 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "lookup type id='%s' NOT FOUND! Need to get it from xsi:type\n", id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_looku@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_looku@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_looku@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_looku@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85354[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@DMCDAEBB@lookup?5type?5id?$DN?8?$CFs?8?5NOT?5FOUND?$CB?5N@
	mov	ecx, DWORD PTR _fdebug$85354[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85354[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_looku@2:

; 5705 :   return 0;

	xor	eax, eax
$LN9@soap_looku@2:

; 5706 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_lookup_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@KNOIEAEC@Forwarded?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5loca@ ; `string'
PUBLIC	??_C@_0CK@MPHJNIDG@Resolving?5level?5?$CFu?5pointers?5to?5h@ ; `string'
PUBLIC	??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DJ@BNCNJHEH@Type?5incompatibility?3?5href?$DN?8?$CFs?8?5@ ; `string'
PUBLIC	??_C@_0DD@DDMOMBIK@Resolved?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5locat@ ; `string'
PUBLIC	??_C@_0DC@CHFHIBPP@Forwarding?5first?5href?$DN?8?$CFs?8?5type?$DN@ ; `string'
PUBLIC	_soap_id_lookup
;	COMDAT ??_C@_0DE@KNOIEAEC@Forwarded?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5loca@
CONST	SEGMENT
??_C@_0DE@KNOIEAEC@Forwarded?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5loca@ DB 'F'
	DB	'orwarded href=''%s'' type=%d location=%p (%u bytes)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MPHJNIDG@Resolving?5level?5?$CFu?5pointers?5to?5h@
CONST	SEGMENT
??_C@_0CK@MPHJNIDG@Resolving?5level?5?$CFu?5pointers?5to?5h@ DB 'Resolvin'
	DB	'g level %u pointers to href=''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@ DB 'Descending one'
	DB	' level...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BNCNJHEH@Type?5incompatibility?3?5href?$DN?8?$CFs?8?5@
CONST	SEGMENT
??_C@_0DJ@BNCNJHEH@Type?5incompatibility?3?5href?$DN?8?$CFs?8?5@ DB 'Type'
	DB	' incompatibility: href=''%s'' id-type=%d href-type=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DDMOMBIK@Resolved?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5locat@
CONST	SEGMENT
??_C@_0DD@DDMOMBIK@Resolved?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5locat@ DB 'R'
	DB	'esolved href=''%s'' type=%d location=%p (%u bytes)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CHFHIBPP@Forwarding?5first?5href?$DN?8?$CFs?8?5type?$DN@
CONST	SEGMENT
??_C@_0DC@CHFHIBPP@Forwarding?5first?5href?$DN?8?$CFs?8?5type?$DN@ DB 'Fo'
	DB	'rwarding first href=''%s'' type=%d %p (%u bytes)', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_id_lookup
_TEXT	SEGMENT
_fdebug$85450 = -140					; size = 4
_fdebug$85438 = -128					; size = 4
_fdebug$85430 = -116					; size = 4
_r$85417 = -104						; size = 4
_s$85416 = -92						; size = 4
_fdebug$85411 = -80					; size = 4
_fdebug$85403 = -68					; size = 4
_fdebug$85390 = -56					; size = 4
_fdebug$85382 = -44					; size = 4
_fdebug$85373 = -32					; size = 4
_q$ = -20						; size = 4
_ip$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_p$ = 16						; size = 4
_t$ = 20						; size = 4
_n$ = 24						; size = 4
_k$ = 28						; size = 4
_soap_id_lookup PROC					; COMDAT

; 5717 : { struct soap_ilist *ip;

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5718 :   void **q;
; 5719 :   if (!p || !id || !*id)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN41@soap_id_lo
	cmp	DWORD PTR _id$[ebp], 0
	je	SHORT $LN41@soap_id_lo
	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN42@soap_id_lo
$LN41@soap_id_lo:

; 5720 :     return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN43@soap_id_lo
$LN42@soap_id_lo:

; 5721 :   ip = soap_lookup(soap, id); /* lookup pointer to hash table entry for string id */

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_lookup
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5722 :   if (!ip)

	cmp	DWORD PTR _ip$[ebp], 0
	jne	$LN40@soap_id_lo

; 5723 :   { ip = soap_enter(soap, id); /* new hash table entry for string id */

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_enter
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5724 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding first href='%s' type=%d %p (%u bytes)\n", id, t, p, (unsigned int)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN39@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN38@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN38@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN39@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85373[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@CHFHIBPP@Forwarding?5first?5href?$DN?8?$CFs?8?5type?$DN@
	mov	ecx, DWORD PTR _fdebug$85373[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85373[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN39@soap_id_lo:

; 5725 :     ip->type = t;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5726 :     ip->size = n;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5727 :     ip->link = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5728 :     ip->copy = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+16], 0

; 5729 :     ip->flist = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5730 :     ip->ptr = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+24], 0

; 5731 :     ip->level = k;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 5732 :     *p = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	$LN36@soap_id_lo
$LN40@soap_id_lo:

; 5733 :   }
; 5734 :   else if (ip->ptr)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN35@soap_id_lo

; 5735 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolved href='%s' type=%d location=%p (%u bytes)\n", id, t, ip->ptr, (unsigned int)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN34@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN33@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN33@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN34@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85382[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@DDMOMBIK@Resolved?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5locat@
	mov	edx, DWORD PTR _fdebug$85382[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85382[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@soap_id_lo:

; 5736 :     if (ip->type != t)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _t$[ebp]
	je	$LN27@soap_id_lo

; 5737 :     { strcpy(soap->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5738 :       soap->error = SOAP_HREF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 26		; 0000001aH

; 5739 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility: href='%s' id-type=%d href-type=%d\n", id, ip->type, t));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN30@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN29@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN29@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN30@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85390[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@BNCNJHEH@Type?5incompatibility?3?5href?$DN?8?$CFs?8?5@
	mov	ecx, DWORD PTR _fdebug$85390[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85390[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@soap_id_lo:

; 5740 :       return NULL;

	xor	eax, eax
	jmp	$LN43@soap_id_lo
$LN27@soap_id_lo:

; 5741 :     }
; 5742 :     while (ip->level < k)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jae	$LN26@soap_id_lo

; 5743 :     { q = (void**)soap_malloc(soap, sizeof(void*));

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _q$[ebp], eax

; 5744 :       if (!q)

	cmp	DWORD PTR _q$[ebp], 0
	jne	SHORT $LN25@soap_id_lo

; 5745 :         return NULL;

	xor	eax, eax
	jmp	$LN43@soap_id_lo
$LN25@soap_id_lo:

; 5746 :       *p = (void*)q;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax], ecx

; 5747 :       p = q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5748 :       k--;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 5749 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN24@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN23@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN23@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN24@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85403[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@
	mov	eax, DWORD PTR _fdebug$85403[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85403[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@soap_id_lo:

; 5750 :     }

	jmp	$LN27@soap_id_lo
$LN26@soap_id_lo:

; 5751 :     *p = ip->ptr;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	jmp	$LN36@soap_id_lo
$LN35@soap_id_lo:

; 5752 :   }
; 5753 :   else if (ip->level > k)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jbe	$LN20@soap_id_lo

; 5754 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving level %u pointers to href='%s'\n", ip->level, id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN16@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN18@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN18@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN16@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85411[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	push	OFFSET ??_C@_0CK@MPHJNIDG@Resolving?5level?5?$CFu?5pointers?5to?5h@
	mov	eax, DWORD PTR _fdebug$85411[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85411[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@soap_id_lo:

; 5755 :     while (ip->level > k)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jbe	$LN15@soap_id_lo

; 5756 :     { void *s, **r = &ip->link;

	mov	eax, DWORD PTR _ip$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _r$85417[ebp], eax

; 5757 :       q = (void**)ip->link;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _q$[ebp], ecx
$LN14@soap_id_lo:

; 5758 :       while (q)

	cmp	DWORD PTR _q$[ebp], 0
	je	SHORT $LN13@soap_id_lo

; 5759 :       { *r = (void*)soap_malloc(soap, sizeof(void*));

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	ecx, DWORD PTR _r$85417[ebp]
	mov	DWORD PTR [ecx], eax

; 5760 :         s = *q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$85416[ebp], ecx

; 5761 :         *q = *r;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _r$85417[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 5762 :         r = (void**)*r;

	mov	eax, DWORD PTR _r$85417[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _r$85417[ebp], ecx

; 5763 :         q = (void**)s;

	mov	eax, DWORD PTR _s$85416[ebp]
	mov	DWORD PTR _q$[ebp], eax

; 5764 :       }

	jmp	SHORT $LN14@soap_id_lo
$LN13@soap_id_lo:

; 5765 :       *r = NULL;

	mov	eax, DWORD PTR _r$85417[ebp]
	mov	DWORD PTR [eax], 0

; 5766 :       ip->size = n;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5767 :       ip->copy = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+16], 0

; 5768 :       ip->level = ip->level - 1;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, 1
	mov	edx, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 5769 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN12@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85430[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@
	mov	eax, DWORD PTR _fdebug$85430[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85430[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_id_lo:

; 5770 :     }

	jmp	$LN16@soap_id_lo
$LN15@soap_id_lo:

; 5771 :     q = (void**)ip->link;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _q$[ebp], ecx

; 5772 :     ip->link = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5773 :     *p = (void*)q;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax], ecx

; 5774 :   }
; 5775 :   else

	jmp	$LN36@soap_id_lo
$LN20@soap_id_lo:

; 5776 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarded href='%s' type=%d location=%p (%u bytes)\n", id, t, p, (unsigned int)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85438[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@KNOIEAEC@Forwarded?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5loca@
	mov	ecx, DWORD PTR _fdebug$85438[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85438[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_id_lo:

; 5777 :     while (ip->level < k)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jae	$LN4@soap_id_lo

; 5778 :     { q = (void**)soap_malloc(soap, sizeof(void*));

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _q$[ebp], eax

; 5779 :       *p = q;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax], ecx

; 5780 :       p = q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5781 :       k--;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 5782 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_id_lo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_id_lo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_id_lo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85450[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@KJEHDJCO@Descending?5one?5level?4?4?4?6?$AA@
	mov	eax, DWORD PTR _fdebug$85450[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85450[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_id_lo:

; 5783 :     }

	jmp	$LN5@soap_id_lo
$LN4@soap_id_lo:

; 5784 :     q = (void**)ip->link;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _q$[ebp], ecx

; 5785 :     ip->link = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5786 :     *p = (void*)q;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax], ecx
$LN36@soap_id_lo:

; 5787 :   }
; 5788 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN43@soap_id_lo:

; 5789 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_id_lookup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GONKBNCI@Forwarding?5copying?5address?5?$CFp?5fo@ ; `string'
PUBLIC	??_C@_0FF@NBJOPLBK@Forwarding?5type?$DN?$CFd?5?$CItarget?5type?$DN@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_id_forward@@9@4JA		; `soap_id_forward'::`2'::__LINE__Var
PUBLIC	??_C@_0FE@HMHLFIHD@Type?5incompatibility?5id?$DN?8?$CFs?8?5exp@ ; `string'
PUBLIC	??_C@_0DL@JOMHFKOD@New?5entry?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5size@ ; `string'
PUBLIC	_soap_id_forward
;	COMDAT ??_C@_0DF@GONKBNCI@Forwarding?5copying?5address?5?$CFp?5fo@
CONST	SEGMENT
??_C@_0DF@GONKBNCI@Forwarding?5copying?5address?5?$CFp?5fo@ DB 'Forwardin'
	DB	'g copying address %p for type=%d href=''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@NBJOPLBK@Forwarding?5type?$DN?$CFd?5?$CItarget?5type?$DN@
CONST	SEGMENT
??_C@_0FF@NBJOPLBK@Forwarding?5type?$DN?$CFd?5?$CItarget?5type?$DN@ DB 'F'
	DB	'orwarding type=%d (target type=%d) size=%lu location=%p level'
	DB	'=%u len=%lu href=''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_id_forward@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_id_forward@@9@4JA DD 016a8H	; `soap_id_forward'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FE@HMHLFIHD@Type?5incompatibility?5id?$DN?8?$CFs?8?5exp@
CONST	SEGMENT
??_C@_0FE@HMHLFIHD@Type?5incompatibility?5id?$DN?8?$CFs?8?5exp@ DB 'Type '
	DB	'incompatibility id=''%s'' expect type=%d size=%lu level=%u go'
	DB	't type=%d size=%lu', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JOMHFKOD@New?5entry?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5size@
CONST	SEGMENT
??_C@_0DL@JOMHFKOD@New?5entry?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5size@ DB 'N'
	DB	'ew entry href=''%s'' type=%d size=%lu level=%d location=%p', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_id_forward
_TEXT	SEGMENT
_fdebug$85516 = -68					; size = 4
_fdebug$85507 = -56					; size = 4
_fp$85496 = -44						; size = 4
_fdebug$85489 = -32					; size = 4
_fdebug$85479 = -20					; size = 4
_ip$ = -8						; size = 4
_soap$ = 8						; size = 4
_href$ = 12						; size = 4
_p$ = 16						; size = 4
_len$ = 20						; size = 4
_st$ = 24						; size = 4
_tt$ = 28						; size = 4
_n$ = 32						; size = 4
_k$ = 36						; size = 4
_fcopy$ = 40						; size = 4
_soap_id_forward PROC					; COMDAT

; 5800 : { struct soap_ilist *ip;

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5801 :   if (!p || !href || !*href)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN23@soap_id_fo
	cmp	DWORD PTR _href$[ebp], 0
	je	SHORT $LN23@soap_id_fo
	mov	eax, DWORD PTR _href$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN24@soap_id_fo
$LN23@soap_id_fo:

; 5802 :     return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN25@soap_id_fo
$LN24@soap_id_fo:

; 5803 :   ip = soap_lookup(soap, href); /* lookup pointer to hash table entry for string id */

	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_lookup
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5804 :   if (!ip)

	cmp	DWORD PTR _ip$[ebp], 0
	jne	$LN22@soap_id_fo

; 5805 :   { ip = soap_enter(soap, href); /* new hash table entry for string id */

	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_enter
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5806 :     ip->type = st;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _st$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5807 :     ip->size = n;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5808 :     ip->link = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+12], 0

; 5809 :     ip->copy = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+16], 0

; 5810 :     ip->ptr = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+24], 0

; 5811 :     ip->level = 0;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+28], 0

; 5812 :     ip->flist = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5813 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "New entry href='%s' type=%d size=%lu level=%d location=%p\n", href, st, (unsigned long)n, k, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN20@soap_id_fo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN20@soap_id_fo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85479[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _st$[ebp]
	push	eax
	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DL@JOMHFKOD@New?5entry?5href?$DN?8?$CFs?8?5type?$DN?$CFd?5size@
	mov	edx, DWORD PTR _fdebug$85479[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85479[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_id_fo:
	jmp	$LN18@soap_id_fo
$LN22@soap_id_fo:

; 5814 :   }
; 5815 :   else if (ip->type != st || (ip->level == k && ip->size != n))

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _st$[ebp]
	jne	SHORT $LN16@soap_id_fo
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jne	$LN18@soap_id_fo
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _n$[ebp]
	je	$LN18@soap_id_fo
$LN16@soap_id_fo:

; 5816 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n", href, ip->type, (unsigned long)ip->size, k, st, (unsigned long)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN15@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN14@soap_id_fo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN14@soap_id_fo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN15@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85489[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _st$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FE@HMHLFIHD@Type?5incompatibility?5id?$DN?8?$CFs?8?5exp@
	mov	edx, DWORD PTR _fdebug$85489[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85489[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_id_fo:

; 5817 :     strcpy(soap->id, href);

	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5818 :     soap->error = SOAP_HREF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 26		; 0000001aH

; 5819 :     return NULL;

	xor	eax, eax
	jmp	$LN25@soap_id_fo
$LN18@soap_id_fo:

; 5820 :   }
; 5821 :   if (fcopy || n < sizeof(void*) || *href != '#')

	cmp	DWORD PTR _fcopy$[ebp], 0
	jne	SHORT $LN11@soap_id_fo
	cmp	DWORD PTR _n$[ebp], 4
	jb	SHORT $LN11@soap_id_fo
	mov	eax, DWORD PTR _href$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 35					; 00000023H
	je	$LN12@soap_id_fo
$LN11@soap_id_fo:

; 5822 :   { register struct soap_flist *fp = (struct soap_flist*)SOAP_MALLOC(soap, sizeof(struct soap_flist));

	push	24					; 00000018H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_id_forward@@9@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fp$85496[ebp], eax

; 5823 :     if (!fp)

	cmp	DWORD PTR _fp$85496[ebp], 0
	jne	SHORT $LN10@soap_id_fo

; 5824 :     { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 5825 :       return NULL;

	xor	eax, eax
	jmp	$LN25@soap_id_fo
$LN10@soap_id_fo:

; 5826 :     }
; 5827 :     fp->next = ip->flist;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 5828 :     fp->type = tt;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _tt$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5829 :     fp->ptr = p;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5830 :     fp->level = k;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5831 :     fp->len = len;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 5832 :     if (fcopy)

	cmp	DWORD PTR _fcopy$[ebp], 0
	je	SHORT $LN9@soap_id_fo

; 5833 :       fp->fcopy = fcopy;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	ecx, DWORD PTR _fcopy$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 5834 :     else

	jmp	SHORT $LN8@soap_id_fo
$LN9@soap_id_fo:

; 5835 :       fp->fcopy = soap_fcopy;

	mov	eax, DWORD PTR _fp$85496[ebp]
	mov	DWORD PTR [eax+20], OFFSET _soap_fcopy
$LN8@soap_id_fo:

; 5836 :     ip->flist = fp;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _fp$85496[ebp]
	mov	DWORD PTR [eax+20], ecx

; 5837 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding type=%d (target type=%d) size=%lu location=%p level=%u len=%lu href='%s'\n", st, tt, (unsigned long)n, p, k, (unsigned long)len, href));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_id_fo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_id_fo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85507[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tt$[ebp]
	push	edx
	mov	eax, DWORD PTR _st$[ebp]
	push	eax
	push	OFFSET ??_C@_0FF@NBJOPLBK@Forwarding?5type?$DN?$CFd?5?$CItarget?5type?$DN@
	mov	ecx, DWORD PTR _fdebug$85507[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85507[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_id_fo:

; 5838 :   }
; 5839 :   else

	jmp	$LN4@soap_id_fo
$LN12@soap_id_fo:

; 5840 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding copying address %p for type=%d href='%s'\n", p, st, href));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_id_fo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_id_fo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_id_fo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85516[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _st$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@GONKBNCI@Forwarding?5copying?5address?5?$CFp?5fo@
	mov	eax, DWORD PTR _fdebug$85516[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85516[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_id_fo:

; 5841 :     *(void**)p = ip->copy;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 5842 :     ip->copy = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN4@soap_id_fo:

; 5843 :   }
; 5844 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN25@soap_id_fo:

; 5845 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_id_forward ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@CJACDIFA@Update?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc@ ; `string'
PUBLIC	??_C@_0BK@INPBNCCP@Multiply?5defined?5id?$DN?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0DJ@GABBOBBE@New?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5size?$DN?$CF@ ; `string'
PUBLIC	??_C@_0CG@FEPGKFFB@Lookup?5entry?5id?$DN?8?$CFs?5for?5location@ ; `string'
PUBLIC	??_C@_0DA@BPIMOONM@Enter?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc?$DN?$CFp?5siz@ ; `string'
PUBLIC	_soap_id_enter
;	COMDAT ??_C@_0DM@CJACDIFA@Update?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc@
CONST	SEGMENT
??_C@_0DM@CJACDIFA@Update?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc@ DB 'U'
	DB	'pdate entry id=''%s'' type=%d location=%p size=%lu level=%u', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@INPBNCCP@Multiply?5defined?5id?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BK@INPBNCCP@Multiply?5defined?5id?$DN?8?$CFs?8?6?$AA@ DB 'Multiply'
	DB	' defined id=''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GABBOBBE@New?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5size?$DN?$CF@
CONST	SEGMENT
??_C@_0DJ@GABBOBBE@New?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5size?$DN?$CF@ DB 'N'
	DB	'ew entry id=''%s'' type=%d size=%lu level=%u location=%p', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FEPGKFFB@Lookup?5entry?5id?$DN?8?$CFs?5for?5location@
CONST	SEGMENT
??_C@_0CG@FEPGKFFB@Lookup?5entry?5id?$DN?8?$CFs?5for?5location@ DB 'Looku'
	DB	'p entry id=''%s for location=%p''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BPIMOONM@Enter?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc?$DN?$CFp?5siz@
CONST	SEGMENT
??_C@_0DA@BPIMOONM@Enter?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc?$DN?$CFp?5siz@ DB 'E'
	DB	'nter id=''%s'' type=%d loc=%p size=%lu level=%u', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_id_enter
_TEXT	SEGMENT
_fdebug$85587 = -80					; size = 4
_fdebug$85580 = -68					; size = 4
_fdebug$85571 = -56					; size = 4
_fdebug$85560 = -44					; size = 4
_fdebug$85553 = -32					; size = 4
_fdebug$85540 = -20					; size = 4
_ip$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_p$ = 16						; size = 4
_t$ = 20						; size = 4
_n$ = 24						; size = 4
_k$ = 28						; size = 4
_type$ = 32						; size = 4
_arrayType$ = 36					; size = 4
_finstantiate$ = 40					; size = 4
_soap_id_enter PROC					; COMDAT

; 5855 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5856 : #ifndef WITH_NOIDREF
; 5857 :   struct soap_ilist *ip;
; 5858 : #endif
; 5859 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Enter id='%s' type=%d loc=%p size=%lu level=%u\n", id, t, p, (unsigned long)n, k));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN32@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN31@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN31@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN32@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85540[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@BPIMOONM@Enter?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc?$DN?$CFp?5siz@
	mov	edx, DWORD PTR _fdebug$85540[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85540[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@soap_id_en:

; 5860 :   soap->alloced = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87306], ax

; 5861 :   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN29@soap_id_en

; 5862 :   { if (finstantiate)

	cmp	DWORD PTR _finstantiate$[ebp], 0
	je	SHORT $LN28@soap_id_en

; 5863 :       p = finstantiate(soap, t, type, arrayType, &n);

	mov	esi, esp
	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arrayType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	DWORD PTR _finstantiate$[ebp]
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _p$[ebp], eax

; 5864 :     else

	jmp	SHORT $LN27@soap_id_en
$LN28@soap_id_en:

; 5865 :       p = soap_malloc(soap, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN27@soap_id_en:

; 5866 :     if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN29@soap_id_en

; 5867 :       soap->alloced = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87306], ax
$LN29@soap_id_en:

; 5868 :   }
; 5869 : #ifndef WITH_NOIDREF
; 5870 :   if (!id || !*id)

	cmp	DWORD PTR _id$[ebp], 0
	je	SHORT $LN24@soap_id_en
	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN25@soap_id_en
$LN24@soap_id_en:

; 5871 : #endif
; 5872 :     return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN33@soap_id_en
$LN25@soap_id_en:

; 5873 : #ifndef WITH_NOIDREF
; 5874 :   ip = soap_lookup(soap, id); /* lookup pointer to hash table entry for string id */

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_lookup
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5875 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Lookup entry id='%s for location=%p'\n", id, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN23@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN22@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN22@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN23@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85553[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@FEPGKFFB@Lookup?5entry?5id?$DN?8?$CFs?5for?5location@
	mov	edx, DWORD PTR _fdebug$85553[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85553[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@soap_id_en:

; 5876 :   if (!ip)

	cmp	DWORD PTR _ip$[ebp], 0
	jne	$LN20@soap_id_en

; 5877 :   { ip = soap_enter(soap, id); /* new hash table entry for string id */

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_enter
	add	esp, 8
	mov	DWORD PTR _ip$[ebp], eax

; 5878 :     ip->type = t;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 5879 :     ip->link = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+12], 0

; 5880 :     ip->copy = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+16], 0

; 5881 :     ip->flist = NULL;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5882 :     ip->size = n;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5883 :     ip->ptr = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 5884 :     ip->level = k;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 5885 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "New entry id='%s' type=%d size=%lu level=%u location=%p\n", id, t, (unsigned long)n, k, p));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN18@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN18@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85560[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DJ@GABBOBBE@New?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5size?$DN?$CF@
	mov	edx, DWORD PTR _fdebug$85560[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85560[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_id_en:
	jmp	$LN16@soap_id_en
$LN20@soap_id_en:

; 5886 :   }
; 5887 :   else if ((ip->type != t || (ip->level == k && ip->size != n)) && (ip->copy || ip->flist))

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _t$[ebp]
	jne	SHORT $LN14@soap_id_en
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _k$[ebp]
	jne	$LN15@soap_id_en
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _n$[ebp]
	je	$LN15@soap_id_en
$LN14@soap_id_en:
	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN13@soap_id_en
	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN15@soap_id_en
$LN13@soap_id_en:

; 5888 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n", id, ip->type, (unsigned long)ip->size, k, t, (unsigned long)n));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN12@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85571[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FE@HMHLFIHD@Type?5incompatibility?5id?$DN?8?$CFs?8?5exp@
	mov	edx, DWORD PTR _fdebug$85571[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85571[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_id_en:

; 5889 :     strcpy(soap->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5890 :     soap->error = SOAP_HREF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 26		; 0000001aH

; 5891 :     return NULL;

	xor	eax, eax
	jmp	$LN33@soap_id_en
	jmp	$LN16@soap_id_en
$LN15@soap_id_en:

; 5892 :   }
; 5893 :   else if (ip->ptr)

	mov	eax, DWORD PTR _ip$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN8@soap_id_en

; 5894 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Multiply defined id='%s'\n", id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85580[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@INPBNCCP@Multiply?5defined?5id?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85580[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85580[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_id_en:

; 5895 :     strcpy(soap->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5896 :     soap->error = SOAP_DUPLICATE_ID;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 24		; 00000018H

; 5897 :     return NULL;

	xor	eax, eax
	jmp	$LN33@soap_id_en

; 5898 :   }
; 5899 :   else

	jmp	$LN16@soap_id_en
$LN8@soap_id_en:

; 5900 :   { ip->size = n;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5901 :     ip->ptr = p;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 5902 :     ip->level = k;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 5903 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update entry id='%s' type=%d location=%p size=%lu level=%u\n", id, t, p, (unsigned long)n, k));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN16@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_id_en
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_id_en:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN16@soap_id_en
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85587[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@CJACDIFA@Update?5entry?5id?$DN?8?$CFs?8?5type?$DN?$CFd?5loc@
	mov	edx, DWORD PTR _fdebug$85587[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85587[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@soap_id_en:

; 5904 :   }
; 5905 :   return ip->ptr;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [eax+24]
$LN33@soap_id_en:

; 5906 : #endif
; 5907 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_id_enter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@EEKPBANC@Copying?5data?5type?$DN?$CFd?5?$CItarget?5typ@ ; `string'
;	COMDAT ??_C@_0DM@EEKPBANC@Copying?5data?5type?$DN?$CFd?5?$CItarget?5typ@
CONST	SEGMENT
??_C@_0DM@EEKPBANC@Copying?5data?5type?$DN?$CFd?5?$CItarget?5typ@ DB 'Cop'
	DB	'ying data type=%d (target type=%d) %p -> %p (%lu bytes)', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_fcopy
_TEXT	SEGMENT
_fdebug$85603 = -8					; size = 4
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
_soap_fcopy PROC					; COMDAT

; 5916 : { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Copying data type=%d (target type=%d) %p -> %p (%lu bytes)\n", st, tt, q, p, (unsigned long)n));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_fcopy
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_fcopy
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_fcopy:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_fcopy
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85603[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _tt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _st$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@EEKPBANC@Copying?5data?5type?$DN?$CFd?5?$CItarget?5typ@
	mov	edx, DWORD PTR _fdebug$85603[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85603[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_fcopy:

; 5917 :   memcpy(p, q, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5918 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_fcopy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@EKPCINOC@End?5of?5send?5phase?6?$AA@	; `string'
PUBLIC	??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0CH@OAHIOLKH@Sending?5buffered?5message?5of?5leng@ ; `string'
PUBLIC	??_C@_09NJPHBKJC@End?5send?6?$AA@		; `string'
PUBLIC	_soap_putmime
PUBLIC	_soap_putdime
PUBLIC	_soap_end_send
;	COMDAT ??_C@_0BD@EKPCINOC@End?5of?5send?5phase?6?$AA@
CONST	SEGMENT
??_C@_0BD@EKPCINOC@End?5of?5send?5phase?6?$AA@ DB 'End of send phase', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@ DB 0dH, 0aH, '0', 0dH, 0aH, 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OAHIOLKH@Sending?5buffered?5message?5of?5leng@
CONST	SEGMENT
??_C@_0CH@OAHIOLKH@Sending?5buffered?5message?5of?5leng@ DB 'Sending buff'
	DB	'ered message of length %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NJPHBKJC@End?5send?6?$AA@
CONST	SEGMENT
??_C@_09NJPHBKJC@End?5send?6?$AA@ DB 'End send', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_end_send
_TEXT	SEGMENT
_fdebug$85659 = -68					; size = 4
_rc$85651 = -56						; size = 4
_rc$85642 = -44						; size = 4
_fdebug$85627 = -32					; size = 4
_p$85621 = -20						; size = 4
_fdebug$85616 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_end_send PROC					; COMDAT

; 5927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5928 : #ifndef WITH_LEANER
; 5929 :   if (soap->dime.list)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90512], 0
	je	SHORT $LN36@soap_end_s

; 5930 :   { /* SOAP body referenced attachments must appear first */
; 5931 :     soap->dime.last->next = soap->dime.first;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90520]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90516]
	mov	DWORD PTR [ecx], eax

; 5932 :     soap->dime.first = soap->dime.list->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90512]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+90516], eax

; 5933 :     soap->dime.list->next = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90512]
	mov	DWORD PTR [ecx], 0

; 5934 :     soap->dime.last = soap->dime.list;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90512]
	mov	DWORD PTR [eax+90520], edx
$LN36@soap_end_s:

; 5935 :   }
; 5936 :   if (soap_putdime(soap) || soap_putmime(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdime
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN34@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putmime
	add	esp, 4
	test	eax, eax
	je	SHORT $LN35@soap_end_s
$LN34@soap_end_s:

; 5937 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN37@soap_end_s
$LN35@soap_end_s:

; 5938 :   soap->mime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90532], 0

; 5939 :   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 5940 :   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 5941 :   soap->dime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90512], 0

; 5942 :   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 5943 :   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 5944 : #endif
; 5945 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End send\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN33@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN32@soap_end_s
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN32@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN33@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85616[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_09NJPHBKJC@End?5send?6?$AA@
	mov	eax, DWORD PTR _fdebug$85616[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85616[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN33@soap_end_s:

; 5946 :   if (soap->mode & SOAP_IO) /* need to flush the remaining data in buffer */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	je	$LN30@soap_end_s

; 5947 :   { if (soap_flush(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_flush
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@soap_end_s

; 5948 : #ifdef WITH_ZLIB
; 5949 :     { if (soap->mode & SOAP_ENC_ZLIB && soap->zlib_state == SOAP_ZLIB_DEFLATE)
; 5950 :       { soap->zlib_state = SOAP_ZLIB_NONE;
; 5951 :         deflateEnd(soap->d_stream);
; 5952 :       }
; 5953 :       return soap->error;
; 5954 :     }
; 5955 : #else
; 5956 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN37@soap_end_s
$LN29@soap_end_s:

; 5957 : #endif
; 5958 : #ifdef WITH_ZLIB
; 5959 :     if (soap->mode & SOAP_ENC_ZLIB)
; 5960 :     { int r;
; 5961 :       soap->d_stream->avail_in = 0;
; 5962 :       do
; 5963 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflating remainder\n"));
; 5964 :         r = deflate(soap->d_stream, Z_FINISH);
; 5965 :         if (soap->d_stream->avail_out != SOAP_BUFLEN)
; 5966 :         { if (soap_flush_raw(soap, soap->z_buf, SOAP_BUFLEN - soap->d_stream->avail_out))
; 5967 :           { soap->zlib_state = SOAP_ZLIB_NONE;
; 5968 :             deflateEnd(soap->d_stream);
; 5969 :             return soap->error;
; 5970 :           }
; 5971 :           soap->d_stream->next_out = (Byte*)soap->z_buf;
; 5972 :           soap->d_stream->avail_out = SOAP_BUFLEN;
; 5973 :         }
; 5974 :       } while (r == Z_OK);
; 5975 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 5976 :       soap->z_ratio_out = (float)soap->d_stream->total_out / (float)soap->d_stream->total_in;
; 5977 :       soap->mode &= ~SOAP_ENC_ZLIB;
; 5978 :       soap->zlib_state = SOAP_ZLIB_NONE;
; 5979 :       if (deflateEnd(soap->d_stream) != Z_OK || r != Z_STREAM_END)
; 5980 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to end deflate: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 5981 :         return soap->error = SOAP_ZLIB_ERROR;
; 5982 :       }
; 5983 : #ifdef WITH_GZIP
; 5984 :       if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
; 5985 :       { soap->z_buf[0] = soap->z_crc & 0xFF;
; 5986 :         soap->z_buf[1] = (soap->z_crc >> 8) & 0xFF;
; 5987 :         soap->z_buf[2] = (soap->z_crc >> 16) & 0xFF;
; 5988 :         soap->z_buf[3] = (soap->z_crc >> 24) & 0xFF;
; 5989 :         soap->z_buf[4] = soap->d_stream->total_in & 0xFF;
; 5990 :         soap->z_buf[5] = (soap->d_stream->total_in >> 8) & 0xFF;
; 5991 :         soap->z_buf[6] = (soap->d_stream->total_in >> 16) & 0xFF;
; 5992 :         soap->z_buf[7] = (soap->d_stream->total_in >> 24) & 0xFF;
; 5993 :         if (soap_flush_raw(soap, soap->z_buf, 8))
; 5994 :           return soap->error;
; 5995 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip crc32=%lu\n", (unsigned long)soap->z_crc));
; 5996 :       }
; 5997 : #endif
; 5998 :     }
; 5999 : #endif
; 6000 :     if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	$LN28@soap_end_s

; 6001 :     { char *p;
; 6002 : #ifndef WITH_NOHTTP
; 6003 :       if (!(soap->mode & SOAP_ENC_XML))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	jne	$LN27@soap_end_s

; 6004 :       { soap->mode--;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 6005 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending buffered message of length %u\n", (unsigned int)soap->blist->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN26@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN25@soap_end_s
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN25@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN26@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85627[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0CH@OAHIOLKH@Sending?5buffered?5message?5of?5leng@
	mov	eax, DWORD PTR _fdebug$85627[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85627[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@soap_end_s:

; 6006 :         if (soap->status >= SOAP_POST)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 2000		; 000007d0H
	jl	SHORT $LN23@soap_end_s

; 6007 :           soap->error = soap->fpost(soap, soap->endpoint, soap->host, soap->port, soap->path, soap->action, soap->blist->size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90392]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 88344				; 00015918H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 89368				; 00015d18H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87320				; 00015518H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12232]
	call	eax
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	jmp	SHORT $LN22@soap_end_s
$LN23@soap_end_s:

; 6008 :         else if (soap->status != SOAP_STOP)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 1000		; 000003e8H
	je	SHORT $LN22@soap_end_s

; 6009 :           soap->error = soap->fresponse(soap, soap->status, soap->blist->size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90456]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12260]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
$LN22@soap_end_s:

; 6010 :         if (soap->error || soap_flush(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	jne	SHORT $LN19@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_flush
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@soap_end_s
$LN19@soap_end_s:

; 6011 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN37@soap_end_s
$LN20@soap_end_s:

; 6012 :         soap->mode++;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN27@soap_end_s:

; 6013 :       }
; 6014 : #endif
; 6015 :       for (p = soap_first_block(soap); p; p = soap_next_block(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_first_block
	add	esp, 4
	mov	DWORD PTR _p$85621[ebp], eax
	jmp	SHORT $LN18@soap_end_s
$LN17@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_next_block
	add	esp, 4
	mov	DWORD PTR _p$85621[ebp], eax
$LN18@soap_end_s:
	cmp	DWORD PTR _p$85621[ebp], 0
	je	$LN16@soap_end_s

; 6016 :       { DBGMSG(SENT, p, soap_block_size(soap));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN15@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	jne	SHORT $LN14@soap_end_s
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN14@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	je	SHORT $LN15@soap_end_s
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_block_size
	add	esp, 4
	push	eax
	push	1
	mov	eax, DWORD PTR _p$85621[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$85642[ebp], eax
	cmp	DWORD PTR _rc$85642[ebp], 0
	jae	SHORT $LN12@soap_end_s
	mov	eax, DWORD PTR _rc$85642[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$85642[ebp], eax
$LN12@soap_end_s:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_end_s:

; 6017 :         if ((soap->error = soap->fsend(soap, p, soap_block_size(soap))))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_block_size
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _p$85621[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12308]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN11@soap_end_s

; 6018 :         { soap_end_block(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_block
	add	esp, 4

; 6019 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN37@soap_end_s
$LN11@soap_end_s:

; 6020 :         }
; 6021 :       }

	jmp	$LN17@soap_end_s
$LN16@soap_end_s:

; 6022 :       soap_end_block(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_block
	add	esp, 4
	jmp	$LN30@soap_end_s
$LN28@soap_end_s:

; 6023 :     }
; 6024 : #ifndef WITH_LEANER
; 6025 :     else if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	jne	$LN30@soap_end_s

; 6026 :     { DBGMSG(SENT, "\r\n0\r\n\r\n", 7);

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	jne	SHORT $LN7@soap_end_s
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90564], 0
	je	SHORT $LN8@soap_end_s
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	push	7
	push	1
	push	OFFSET ??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rc$85651[ebp], eax
	cmp	DWORD PTR _rc$85651[ebp], 0
	jae	SHORT $LN5@soap_end_s
	mov	eax, DWORD PTR _rc$85651[ebp]
	add	eax, 1
	mov	DWORD PTR _rc$85651[ebp], eax
$LN5@soap_end_s:
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90564]
	push	ecx
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_end_s:

; 6027 :       if ((soap->error = soap->fsend(soap, "\r\n0\r\n\r\n", 7)))

	mov	esi, esp
	push	7
	push	OFFSET ??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12308]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN30@soap_end_s

; 6028 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN37@soap_end_s
$LN30@soap_end_s:

; 6029 :     }
; 6030 : #endif
; 6031 :   }
; 6032 : #ifdef WITH_TCPFIN
; 6033 : #ifdef WITH_OPENSSL
; 6034 :   if (!soap->ssl && soap_valid_socket(soap->socket) && !soap->keep_alive && !(soap->omode & SOAP_IO_UDP))
; 6035 :     soap->fshutdownsocket(soap, soap->socket, 1); /* Send TCP FIN */
; 6036 : #else
; 6037 :   if (soap_valid_socket(soap->socket) && !soap->keep_alive && !(soap->omode & SOAP_IO_UDP))
; 6038 :     soap->fshutdownsocket(soap, soap->socket, 1); /* Send TCP FIN */
; 6039 : #endif
; 6040 : #endif
; 6041 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of send phase\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_end_s
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_end_s:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_end_s
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85659[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BD@EKPCINOC@End?5of?5send?5phase?6?$AA@
	mov	eax, DWORD PTR _fdebug$85659[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85659[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_end_s:

; 6042 :   soap->omode &= ~SOAP_XML_SEC;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -524289				; fff7ffffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 6043 :   soap->count = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], 0

; 6044 :   soap->part = SOAP_END;

	mov	eax, 9
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 6045 :   return SOAP_OK;

	xor	eax, eax
$LN37@soap_end_s:

; 6046 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_end_send ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@EFICFNIE@End?5of?5receive?5message?5ok?6?$AA@ ; `string'
PUBLIC	_soap_getmime
PUBLIC	_soap_getdime
PUBLIC	_soap_end_recv
;	COMDAT ??_C@_0BL@EFICFNIE@End?5of?5receive?5message?5ok?6?$AA@
CONST	SEGMENT
??_C@_0BL@EFICFNIE@End?5of?5receive?5message?5ok?6?$AA@ DB 'End of receiv'
	DB	'e message ok', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_end_recv
_TEXT	SEGMENT
_fdebug$85677 = -20					; size = 4
_content$85669 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_end_recv PROC					; COMDAT

; 6055 : { soap->part = SOAP_END;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 9
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 6056 : #ifndef WITH_LEANER
; 6057 :   if ((soap->mode & SOAP_ENC_DIME) && soap_getdime(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN18@soap_end_r
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdime
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@soap_end_r

; 6058 :   { soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 6059 :     soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 6060 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN19@soap_end_r
$LN18@soap_end_r:

; 6061 :   }
; 6062 :   soap->dime.list = soap->dime.first;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90516]
	mov	DWORD PTR [eax+90512], edx

; 6063 :   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 6064 :   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 6065 :   /* Check if MIME attachments and mime-post-check flag is set, if set call soap_resolve() and return */
; 6066 :   if (soap->mode & SOAP_ENC_MIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN17@soap_end_r

; 6067 :   {
; 6068 : #ifndef WITH_NOIDREF
; 6069 :     if (soap->mode & SOAP_MIME_POSTCHECK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN16@soap_end_r

; 6070 :     { soap_resolve(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_resolve
	add	esp, 4

; 6071 :       return SOAP_OK;

	xor	eax, eax
	jmp	$LN19@soap_end_r
$LN16@soap_end_r:

; 6072 :     }
; 6073 : #endif
; 6074 :     if (soap_getmime(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getmime
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@soap_end_r

; 6075 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN19@soap_end_r
$LN17@soap_end_r:

; 6076 :   }
; 6077 :   soap->mime.list = soap->mime.first;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90536]
	mov	DWORD PTR [eax+90532], edx

; 6078 :   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 6079 :   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 6080 :   soap->mime.boundary = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90524], 0

; 6081 :   if (soap->xlist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90544], 0
	je	SHORT $LN14@soap_end_r

; 6082 :   { struct soap_multipart *content;
; 6083 :     for (content = soap->mime.list; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90532]
	mov	DWORD PTR _content$85669[ebp], ecx
	jmp	SHORT $LN13@soap_end_r
$LN12@soap_end_r:
	mov	eax, DWORD PTR _content$85669[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$85669[ebp], ecx
$LN13@soap_end_r:
	cmp	DWORD PTR _content$85669[ebp], 0
	je	SHORT $LN14@soap_end_r

; 6084 :       soap_resolve_attachment(soap, content);

	mov	eax, DWORD PTR _content$85669[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_resolve_attachment
	add	esp, 8
	jmp	SHORT $LN12@soap_end_r
$LN14@soap_end_r:

; 6085 :   }
; 6086 : #endif
; 6087 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "End of receive message ok\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_end_r
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_end_r
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_end_r:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_end_r
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85677[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@EFICFNIE@End?5of?5receive?5message?5ok?6?$AA@
	mov	eax, DWORD PTR _fdebug$85677[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85677[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_end_r:

; 6088 : #ifdef WITH_ZLIB
; 6089 :   if (soap->mode & SOAP_ENC_ZLIB)
; 6090 :   { /* Make sure end of compressed content is reached */
; 6091 :     while (soap->d_stream->next_out != Z_NULL)
; 6092 :       if ((int)soap_get1(soap) == EOF)
; 6093 :         break;
; 6094 :     soap->mode &= ~SOAP_ENC_ZLIB;
; 6095 :     memcpy(soap->buf, soap->z_buf, SOAP_BUFLEN);
; 6096 :     soap->bufidx = (char*)soap->d_stream->next_in - soap->z_buf;
; 6097 :     soap->buflen = soap->z_buflen;
; 6098 :     soap->zlib_state = SOAP_ZLIB_NONE;
; 6099 :     if (inflateEnd(soap->d_stream) != Z_OK)
; 6100 :       return soap->error = SOAP_ZLIB_ERROR;
; 6101 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Inflate end ok\n"));
; 6102 : #ifdef WITH_GZIP
; 6103 :     if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 6104 :     { soap_wchar c;
; 6105 :       short i;
; 6106 :       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Inflate gzip crc check\n"));
; 6107 :       for (i = 0; i < 8; i++)
; 6108 :       { if ((int)(c = soap_get1(soap)) == EOF)
; 6109 :           return soap->error = SOAP_EOF;
; 6110 :         soap->z_buf[i] = (char)c;
; 6111 :       }
; 6112 :       if (soap->z_crc != ((uLong)(unsigned char)soap->z_buf[0] | ((uLong)(unsigned char)soap->z_buf[1] << 8) | ((uLong)(unsigned char)soap->z_buf[2] << 16) | ((uLong)(unsigned char)soap->z_buf[3] << 24)))
; 6113 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Gzip error: crc check failed, message corrupted? (crc32=%lu)\n", (unsigned long)soap->z_crc));
; 6114 :         return soap->error = SOAP_ZLIB_ERROR;
; 6115 :       }
; 6116 :       if (soap->d_stream->total_out != ((uLong)(unsigned char)soap->z_buf[4] | ((uLong)(unsigned char)soap->z_buf[5] << 8) | ((uLong)(unsigned char)soap->z_buf[6] << 16) | ((uLong)(unsigned char)soap->z_buf[7] << 24)))
; 6117 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Gzip error: incorrect message length\n"));
; 6118 :         return soap->error = SOAP_ZLIB_ERROR;
; 6119 :       }
; 6120 :     }
; 6121 :     soap->zlib_in = SOAP_ZLIB_NONE;
; 6122 : #endif
; 6123 :   }
; 6124 : #endif
; 6125 :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN7@soap_end_r
$LN6@soap_end_r:

; 6126 :     while ((int)soap_getchar(soap) != EOF) /* advance to last chunk */

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN7@soap_end_r

; 6127 :       ;

	jmp	SHORT $LN6@soap_end_r
$LN7@soap_end_r:

; 6128 :   if (soap->fdisconnect && (soap->error = soap->fdisconnect(soap)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12284], 0
	je	SHORT $LN4@soap_end_r
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12284]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN4@soap_end_r

; 6129 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN19@soap_end_r
$LN4@soap_end_r:

; 6130 : #ifndef WITH_NOIDREF
; 6131 :   if (soap_resolve(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_resolve
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@soap_end_r

; 6132 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN19@soap_end_r
$LN3@soap_end_r:

; 6133 : #endif
; 6134 : #ifndef WITH_LEANER
; 6135 :   if (soap->xlist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90544], 0
	je	SHORT $LN2@soap_end_r

; 6136 :   { if (soap->mode & SOAP_ENC_MTOM)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN1@soap_end_r

; 6137 :       return soap->error = SOAP_MIME_HREF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 37		; 00000025H
	mov	eax, 37					; 00000025H
	jmp	SHORT $LN19@soap_end_r
$LN1@soap_end_r:

; 6138 :     return soap->error = SOAP_DIME_HREF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 33		; 00000021H
	mov	eax, 33					; 00000021H
	jmp	SHORT $LN19@soap_end_r
$LN2@soap_end_r:

; 6139 :   }
; 6140 : #endif
; 6141 :   soap_free_temp(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_temp
	add	esp, 4

; 6142 :   return SOAP_OK;

	xor	eax, eax
$LN19@soap_end_r:

; 6143 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_end_recv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@DGKINHBM@Free?5attribute?5storage?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@GJMCKJFJ@Free?5any?5remaining?5temp?5blocks?6?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_free_temp@@9@4JA		; `soap_free_temp'::`2'::__LINE__Var
PUBLIC	??_C@_0BG@CFOLCIMD@Free?5namespace?5stack?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@DGKINHBM@Free?5attribute?5storage?6?$AA@
CONST	SEGMENT
??_C@_0BI@DGKINHBM@Free?5attribute?5storage?6?$AA@ DB 'Free attribute sto'
	DB	'rage', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GJMCKJFJ@Free?5any?5remaining?5temp?5blocks?6?$AA@
CONST	SEGMENT
??_C@_0CA@GJMCKJFJ@Free?5any?5remaining?5temp?5blocks?6?$AA@ DB 'Free any'
	DB	' remaining temp blocks', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_free_temp@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_free_temp@@9@4JA DD 01808H	; `soap_free_temp'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@CFOLCIMD@Free?5namespace?5stack?6?$AA@
CONST	SEGMENT
??_C@_0BG@CFOLCIMD@Free?5namespace?5stack?6?$AA@ DB 'Free namespace stack'
	DB	0aH, 00H					; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_free_temp
_TEXT	SEGMENT
_xp$85736 = -104					; size = 4
_fdebug$85719 = -92					; size = 4
_fdebug$85710 = -80					; size = 4
_fdebug$85700 = -68					; size = 4
_ns$ = -56						; size = 4
_tq$ = -44						; size = 4
_tp$ = -32						; size = 4
_nq$ = -20						; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_free_temp PROC					; COMDAT

; 6152 : { register struct soap_nlist *np, *nq;

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6153 :   register struct soap_attribute *tp, *tq;
; 6154 :   register struct Namespace *ns;
; 6155 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free namespace stack\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN28@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN27@soap_free_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN27@soap_free_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN28@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85700[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BG@CFOLCIMD@Free?5namespace?5stack?6?$AA@
	mov	eax, DWORD PTR _fdebug$85700[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85700[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@soap_free_@2:

; 6156 :   for (np = soap->nlist; np; np = nq)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN25@soap_free_@2
$LN24@soap_free_@2:
	mov	eax, DWORD PTR _nq$[ebp]
	mov	DWORD PTR _np$[ebp], eax
$LN25@soap_free_@2:
	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN23@soap_free_@2

; 6157 :   { nq = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nq$[ebp], ecx

; 6158 :     SOAP_FREE(soap, np);

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	ecx, 6
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6159 :   }

	jmp	SHORT $LN24@soap_free_@2
$LN23@soap_free_@2:

; 6160 :   soap->nlist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+88], 0

; 6161 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free any remaining temp blocks\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN21@soap_free_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN21@soap_free_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85710[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CA@GJMCKJFJ@Free?5any?5remaining?5temp?5blocks?6?$AA@
	mov	eax, DWORD PTR _fdebug$85710[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85710[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_free_@2:

; 6162 :   while (soap->blist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN18@soap_free_@2

; 6163 :     soap_end_block(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_block
	add	esp, 4
	jmp	SHORT $LN19@soap_free_@2
$LN18@soap_free_@2:

; 6164 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free attribute storage\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN17@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN16@soap_free_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN16@soap_free_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN17@soap_free_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85719[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@DGKINHBM@Free?5attribute?5storage?6?$AA@
	mov	eax, DWORD PTR _fdebug$85719[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85719[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@soap_free_@2:

; 6165 :   for (tp = soap->attributes; tp; tp = tq)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN14@soap_free_@2
$LN13@soap_free_@2:
	mov	eax, DWORD PTR _tq$[ebp]
	mov	DWORD PTR _tp$[ebp], eax
$LN14@soap_free_@2:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN12@soap_free_@2

; 6166 :   { tq = tp->next;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tq$[ebp], ecx

; 6167 :     if (tp->value)

	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@soap_free_@2

; 6168 :       SOAP_FREE(soap, tp->value);

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	edx, 16					; 00000010H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN11@soap_free_@2:

; 6169 :     SOAP_FREE(soap, tp);

	mov	eax, DWORD PTR _tp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	ecx, 17					; 00000011H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6170 :   }

	jmp	SHORT $LN13@soap_free_@2
$LN12@soap_free_@2:

; 6171 :   soap->attributes = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87292], 0

; 6172 : #ifdef WITH_FAST
; 6173 :   if (soap->labbuf)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12456], 0
	je	SHORT $LN10@soap_free_@2

; 6174 :     SOAP_FREE(soap, soap->labbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	edx, 22					; 00000016H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN10@soap_free_@2:

; 6175 :   soap->labbuf = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12456], 0

; 6176 :   soap->lablen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12460], 0

; 6177 :   soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0

; 6178 : #endif
; 6179 :   ns = soap->local_namespaces;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ns$[ebp], ecx

; 6180 :   if (ns)

	cmp	DWORD PTR _ns$[ebp], 0
	je	$LN2@soap_free_@2
	jmp	SHORT $LN8@soap_free_@2
$LN7@soap_free_@2:

; 6181 :   { for (; ns->id; ns++)

	mov	eax, DWORD PTR _ns$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _ns$[ebp], eax
$LN8@soap_free_@2:
	mov	eax, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@soap_free_@2

; 6182 :     { if (ns->out)

	mov	eax, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@soap_free_@2

; 6183 :       { if (soap->encodingStyle == ns->out)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN4@soap_free_@2

; 6184 :           soap->encodingStyle = SOAP_STR_EOS;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _soap_padding
$LN4@soap_free_@2:

; 6185 :         SOAP_FREE(soap, ns->out);

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	edx, 33					; 00000021H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6186 :         ns->out = NULL;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN5@soap_free_@2:

; 6187 :       }
; 6188 :       if (soap->encodingStyle == ns->ns)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@soap_free_@2

; 6189 :         soap->encodingStyle = SOAP_STR_EOS;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _soap_padding
$LN3@soap_free_@2:

; 6190 :     }

	jmp	SHORT $LN7@soap_free_@2
$LN6@soap_free_@2:

; 6191 :     SOAP_FREE(soap, soap->local_namespaces);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	edx, 39					; 00000027H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6192 :     soap->local_namespaces = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+84], 0
$LN2@soap_free_@2:

; 6193 :   }
; 6194 : #ifndef WITH_LEANER
; 6195 :   while (soap->xlist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90544], 0
	je	SHORT $LN1@soap_free_@2

; 6196 :   { struct soap_xlist *xp = soap->xlist->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90544]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _xp$85736[ebp], edx

; 6197 :     SOAP_FREE(soap, soap->xlist);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90544]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_free_temp@@9@4JA
	add	edx, 45					; 0000002dH
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6198 :     soap->xlist = xp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _xp$85736[ebp]
	mov	DWORD PTR [eax+90544], ecx

; 6199 :   }

	jmp	SHORT $LN2@soap_free_@2
$LN1@soap_free_@2:

; 6200 : #endif
; 6201 : #ifndef WITH_NOIDREF
; 6202 :   soap_free_pht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_pht
	add	esp, 4

; 6203 :   soap_free_iht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_iht
	add	esp, 4

; 6204 : #endif
; 6205 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_free_temp ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_free_pht@@9@4JA@6501541a	; `soap_free_pht'::`2'::__LINE__Var
PUBLIC	??_C@_0BI@BLPLPEIE@Free?5pointer?5hashtable?6?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??soap_free_pht@@9@4JA@6501541a
_DATA	SEGMENT
?__LINE__Var@?1??soap_free_pht@@9@4JA@6501541a DD 01290H ; `soap_free_pht'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@BLPLPEIE@Free?5pointer?5hashtable?6?$AA@
CONST	SEGMENT
??_C@_0BI@BLPLPEIE@Free?5pointer?5hashtable?6?$AA@ DB 'Free pointer hasht'
	DB	'able', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_free_pht
_TEXT	SEGMENT
_fdebug$84626 = -44					; size = 4
_i$ = -32						; size = 4
_next$ = -20						; size = 4
_pb$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_free_pht PROC					; COMDAT

; 4752 : { register struct soap_pblk *pb, *next;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4753 :   register int i;
; 4754 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free pointer hashtable\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_free_@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_free_@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_free_@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_free_@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84626[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@BLPLPEIE@Free?5pointer?5hashtable?6?$AA@
	mov	eax, DWORD PTR _fdebug$84626[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84626[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_free_@3:

; 4755 :   for (pb = soap->pblk; pb; pb = next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12196]
	mov	DWORD PTR _pb$[ebp], ecx
	jmp	SHORT $LN6@soap_free_@3
$LN5@soap_free_@3:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _pb$[ebp], eax
$LN6@soap_free_@3:
	cmp	DWORD PTR _pb$[ebp], 0
	je	SHORT $LN4@soap_free_@3

; 4756 :   { next = pb->next;

	mov	eax, DWORD PTR _pb$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 4757 :     SOAP_FREE(soap, pb);

	mov	eax, DWORD PTR _pb$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_free_pht@@9@4JA@6501541a
	add	ecx, 5
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 4758 :   }

	jmp	SHORT $LN5@soap_free_@3
$LN4@soap_free_@3:

; 4759 :   soap->pblk = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12196], 0

; 4760 :   soap->pidx = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12200], ax

; 4761 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_free_@3
$LN2@soap_free_@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_free_@3:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN10@soap_free_@3

; 4762 :     soap->pht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+8100], 0
	jmp	SHORT $LN2@soap_free_@3
$LN10@soap_free_@3:

; 4763 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_free_pht ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_free_iht@@9@4JA@6501541a	; `soap_free_iht'::`2'::__LINE__Var
PUBLIC	??_C@_0BD@BMIPCKKE@Free?5ID?5hashtable?6?$AA@	; `string'
;	COMDAT ?__LINE__Var@?1??soap_free_iht@@9@4JA@6501541a
_DATA	SEGMENT
?__LINE__Var@?1??soap_free_iht@@9@4JA@6501541a DD 014dfH ; `soap_free_iht'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@BMIPCKKE@Free?5ID?5hashtable?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMIPCKKE@Free?5ID?5hashtable?6?$AA@ DB 'Free ID hashtable', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_free_iht
_TEXT	SEGMENT
_fdebug$85014 = -68					; size = 4
_fq$ = -56						; size = 4
_fp$ = -44						; size = 4
_p$ = -32						; size = 4
_ip$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_free_iht PROC					; COMDAT

; 5343 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5344 :   register struct soap_ilist *ip = NULL, *p = NULL;

	mov	DWORD PTR _ip$[ebp], 0
	mov	DWORD PTR _p$[ebp], 0

; 5345 :   register struct soap_flist *fp = NULL, *fq = NULL;

	mov	DWORD PTR _fp$[ebp], 0
	mov	DWORD PTR _fq$[ebp], 0

; 5346 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free ID hashtable\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN12@soap_free_@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_free_@4
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_free_@4:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_free_@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85014[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BD@BMIPCKKE@Free?5ID?5hashtable?6?$AA@
	mov	eax, DWORD PTR _fdebug$85014[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85014[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_free_@4:

; 5347 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@soap_free_@4
$LN8@soap_free_@4:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@soap_free_@4:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	$LN13@soap_free_@4

; 5348 :   { for (ip = soap->iht[i]; ip; ip = p)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	mov	DWORD PTR _ip$[ebp], edx
	jmp	SHORT $LN6@soap_free_@4
$LN5@soap_free_@4:
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _ip$[ebp], eax
$LN6@soap_free_@4:
	cmp	DWORD PTR _ip$[ebp], 0
	je	SHORT $LN4@soap_free_@4

; 5349 :     { for (fp = ip->flist; fp; fp = fq)

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
	jmp	SHORT $LN3@soap_free_@4
$LN2@soap_free_@4:
	mov	eax, DWORD PTR _fq$[ebp]
	mov	DWORD PTR _fp$[ebp], eax
$LN3@soap_free_@4:
	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN1@soap_free_@4

; 5350 :       { fq = fp->next;

	mov	eax, DWORD PTR _fp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fq$[ebp], ecx

; 5351 :         SOAP_FREE(soap, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_free_iht@@9@4JA@6501541a
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5352 :       }

	jmp	SHORT $LN2@soap_free_@4
$LN1@soap_free_@4:

; 5353 :       p = ip->next;

	mov	eax, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 5354 :       SOAP_FREE(soap, ip);

	mov	eax, DWORD PTR _ip$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_free_iht@@9@4JA@6501541a
	add	ecx, 11					; 0000000bH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 5355 :     }

	jmp	SHORT $LN5@soap_free_@4
$LN4@soap_free_@4:

; 5356 :     soap->iht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+104], 0
	jmp	$LN8@soap_free_@4
$LN13@soap_free_@4:

; 5357 :   }
; 5358 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_free_iht ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
EXTRN	__imp__fopen:PROC
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_open_logfile
_TEXT	SEGMENT
tv73 = -196						; size = 4
_soap$ = 8						; size = 4
_i$ = 12						; size = 4
_soap_open_logfile PROC					; COMDAT

; 6226 : { if (soap->logfile[i])

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [ecx+eax*4+90548], 0
	je	SHORT $LN2@soap_open_

; 6227 :     soap->fdebug[i] = fopen(soap->logfile[i], i < 2 ? "ab" : "a");

	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@soap_open_
	mov	DWORD PTR tv73[ebp], OFFSET ??_C@_02BOGAIONP@ab?$AA@
	jmp	SHORT $LN5@soap_open_
$LN4@soap_open_:
	mov	DWORD PTR tv73[ebp], OFFSET ??_C@_01MCMALHOG@a?$AA@
$LN5@soap_open_:
	mov	esi, esp
	mov	eax, DWORD PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+90548]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+ecx*4+90560], eax
$LN2@soap_open_:

; 6228 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_open_logfile ENDP
_TEXT	ENDS
EXTRN	__imp__fclose:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_close_logfile
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_i$ = 12						; size = 4
_soap_close_logfile PROC				; COMDAT

; 6235 : { if (soap->fdebug[i])

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [ecx+eax*4+90560], 0
	je	SHORT $LN2@soap_close@2

; 6236 :   { fclose(soap->fdebug[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90560]
	push	edx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6237 :     soap->fdebug[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90560], 0
$LN2@soap_close@2:

; 6238 :   }
; 6239 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_close_logfile ENDP
_TEXT	ENDS
PUBLIC	_soap_close_logfiles
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_close_logfiles
_TEXT	SEGMENT
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_close_logfiles PROC				; COMDAT

; 6248 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6249 :   for (i = 0; i < SOAP_MAXLOGS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_close@3
$LN2@soap_close@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_close@3:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN4@soap_close@3

; 6250 :     soap_close_logfile(soap, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_close_logfile
	add	esp, 8
	jmp	SHORT $LN2@soap_close@3
$LN4@soap_close@3:

; 6251 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_close_logfiles ENDP
_TEXT	ENDS
PUBLIC	_soap_set_recv_logfile
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_recv_logfile
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_logfile$ = 12						; size = 4
_soap_set_recv_logfile PROC				; COMDAT

; 6278 : { soap_set_logfile(soap, SOAP_INDEX_RECV, logfile);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _logfile$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_logfile
	add	esp, 12					; 0000000cH

; 6279 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_recv_logfile ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_set_logfile@@9@4JA@6501541a ; `soap_set_logfile'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??soap_set_logfile@@9@4JA@6501541a
_DATA	SEGMENT
?__LINE__Var@?1??soap_set_logfile@@9@4JA@6501541a DD 01872H ; `soap_set_logfile'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_set_logfile
_TEXT	SEGMENT
_t$ = -20						; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_i$ = 12						; size = 4
_logfile$ = 16						; size = 4
_soap_set_logfile PROC					; COMDAT

; 6258 : { const char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6259 :   char *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 6260 :   soap_close_logfile(soap, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_close_logfile
	add	esp, 8

; 6261 :   s = soap->logfile[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+90548]
	mov	DWORD PTR _s$[ebp], edx

; 6262 :   soap->logfile[i] = logfile;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _logfile$[ebp]
	mov	DWORD PTR [ecx+eax*4+90548], edx

; 6263 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_set_l

; 6264 :     SOAP_FREE(soap, (void*)s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_logfile@@9@4JA@6501541a
	add	ecx, 6
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN3@soap_set_l:

; 6265 :   if (logfile)

	cmp	DWORD PTR _logfile$[ebp], 0
	je	SHORT $LN2@soap_set_l

; 6266 :     if ((t = (char*)SOAP_MALLOC(soap, strlen(logfile) + 1)))

	mov	eax, DWORD PTR _logfile$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_logfile@@9@4JA@6501541a
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN2@soap_set_l

; 6267 :       strcpy(t, logfile);

	mov	eax, DWORD PTR _logfile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN2@soap_set_l:

; 6268 :   soap->logfile[i] = t;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+eax*4+90548], edx

; 6269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_logfile ENDP
_TEXT	ENDS
PUBLIC	_soap_set_sent_logfile
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_sent_logfile
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_logfile$ = 12						; size = 4
_soap_set_sent_logfile PROC				; COMDAT

; 6288 : { soap_set_logfile(soap, SOAP_INDEX_SENT, logfile);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _logfile$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_logfile
	add	esp, 12					; 0000000cH

; 6289 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_sent_logfile ENDP
_TEXT	ENDS
PUBLIC	_soap_set_test_logfile
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_test_logfile
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_logfile$ = 12						; size = 4
_soap_set_test_logfile PROC				; COMDAT

; 6298 : { soap_set_logfile(soap, SOAP_INDEX_TEST, logfile);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _logfile$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_logfile
	add	esp, 12					; 0000000cH

; 6299 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_test_logfile ENDP
_TEXT	ENDS
PUBLIC	_soap_copy_context
PUBLIC	_soap_copy
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_copy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_copy PROC						; COMDAT

; 6308 : { return soap_copy_context((struct soap*)malloc(sizeof(struct soap)), soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	esi, esp
	push	95832					; 00017658H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_soap_copy_context
	add	esp, 8

; 6309 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@PKFIDKCF@Could?5not?5copy?5plugin?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@EIOAOACP@Copying?5plugin?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_copy_context@@9@4JA	; `soap_copy_context'::`2'::__LINE__Var
;	COMDAT ??_C@_0BM@PKFIDKCF@Could?5not?5copy?5plugin?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BM@PKFIDKCF@Could?5not?5copy?5plugin?5?8?$CFs?8?6?$AA@ DB 'Could n'
	DB	'ot copy plugin ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EIOAOACP@Copying?5plugin?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BF@EIOAOACP@Copying?5plugin?5?8?$CFs?8?6?$AA@ DB 'Copying plugin '''
	DB	'%s''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_copy_context@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_copy_context@@9@4JA DD 018aeH	; `soap_copy_context'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_copy_context
_TEXT	SEGMENT
_fdebug$85821 = -44					; size = 4
_fdebug$85814 = -32					; size = 4
_q$85805 = -20						; size = 4
_p$85800 = -8						; size = 4
_copy$ = 8						; size = 4
_soap$ = 12						; size = 4
_soap_copy_context PROC					; COMDAT

; 6318 : { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN13@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN14@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN14@soap_copy_
$LN13@soap_copy_:

; 6319 :     return NULL;

	xor	eax, eax
	jmp	$LN15@soap_copy_
$LN14@soap_copy_:

; 6320 :   if (copy)

	cmp	DWORD PTR _copy$[ebp], 0
	je	$LN12@soap_copy_

; 6321 :   { register struct soap_plugin *p = NULL;

	mov	DWORD PTR _p$85800[ebp], 0

; 6322 :     memcpy(copy, soap, sizeof(struct soap));

	push	95832					; 00017658H
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _copy$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6323 :     copy->state = SOAP_COPY;

	mov	eax, 2
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	WORD PTR [ecx+4], ax

; 6324 :     copy->error = SOAP_OK;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 6325 :     copy->userid = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12224], 0

; 6326 :     copy->passwd = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12228], 0

; 6327 :     copy->nlist = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+88], 0

; 6328 :     copy->blist = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+92], 0

; 6329 :     copy->clist = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+96], 0

; 6330 :     copy->alist = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+100], 0

; 6331 :     copy->attributes = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+87292], 0

; 6332 :     copy->labbuf = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12456], 0

; 6333 :     copy->lablen = 0;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12460], 0

; 6334 :     copy->labidx = 0;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12464], 0

; 6335 : #ifdef SOAP_MEM_DEBUG
; 6336 :     soap_init_mht(copy);

	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_soap_init_mht
	add	esp, 4

; 6337 : #endif
; 6338 : #ifdef SOAP_DEBUG
; 6339 :     soap_init_logs(copy);

	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_soap_init_logs
	add	esp, 4

; 6340 :     soap_set_recv_logfile(copy, soap->logfile[SOAP_INDEX_RECV]);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90548]
	push	ecx
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	call	_soap_set_recv_logfile
	add	esp, 8

; 6341 :     soap_set_sent_logfile(copy, soap->logfile[SOAP_INDEX_SENT]);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90552]
	push	ecx
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	call	_soap_set_sent_logfile
	add	esp, 8

; 6342 :     soap_set_test_logfile(copy, soap->logfile[SOAP_INDEX_TEST]);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90556]
	push	ecx
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	call	_soap_set_test_logfile
	add	esp, 8

; 6343 : #endif
; 6344 : #ifdef WITH_ZLIB
; 6345 :     copy->d_stream = (z_stream*)SOAP_MALLOC(copy, sizeof(z_stream));
; 6346 :     copy->d_stream->zalloc = Z_NULL;
; 6347 :     copy->d_stream->zfree = Z_NULL;
; 6348 :     copy->d_stream->opaque = Z_NULL;
; 6349 :     copy->z_buf = NULL;
; 6350 : #endif
; 6351 :     copy->local_namespaces = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+84], 0

; 6352 : #ifndef WITH_NOIDREF
; 6353 :     soap_init_iht(copy);

	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_soap_init_iht
	add	esp, 4

; 6354 :     soap_init_pht(copy);

	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_soap_init_pht
	add	esp, 4

; 6355 : #endif
; 6356 :     copy->header = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12204], 0

; 6357 :     copy->fault = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12208], 0

; 6358 :     copy->action = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+90392], 0

; 6359 : #ifndef WITH_LEAN
; 6360 : #ifdef WITH_COOKIES
; 6361 :     copy->cookies = soap_copy_cookies(copy, soap);
; 6362 : #else
; 6363 :     copy->cookies = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+94676], 0

; 6364 : #endif
; 6365 : #endif
; 6366 :     copy->plugins = NULL;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+12220], 0

; 6367 :     for (p = soap->plugins; p; p = p->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	mov	DWORD PTR _p$85800[ebp], ecx
	jmp	SHORT $LN11@soap_copy_
$LN10@soap_copy_:
	mov	eax, DWORD PTR _p$85800[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$85800[ebp], ecx
$LN11@soap_copy_:
	cmp	DWORD PTR _p$85800[ebp], 0
	je	$LN12@soap_copy_

; 6368 :     { register struct soap_plugin *q = (struct soap_plugin*)SOAP_MALLOC(copy, sizeof(struct soap_plugin));

	push	20					; 00000014H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_copy_context@@9@4JA
	add	eax, 50					; 00000032H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _copy$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _q$85805[ebp], eax

; 6369 :       if (!q)

	cmp	DWORD PTR _q$85805[ebp], 0
	jne	SHORT $LN8@soap_copy_

; 6370 :         return NULL;

	xor	eax, eax
	jmp	$LN15@soap_copy_
$LN8@soap_copy_:

; 6371 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying plugin '%s'\n", p->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_copy_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_copy_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85814[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$85800[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0BF@EIOAOACP@Copying?5plugin?5?8?$CFs?8?6?$AA@
	mov	edx, DWORD PTR _fdebug$85814[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85814[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_copy_:

; 6372 :       *q = *p;

	mov	eax, DWORD PTR _p$85800[ebp]
	mov	ecx, DWORD PTR _q$85805[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax

; 6373 :       if (p->fcopy && p->fcopy(copy, q, p))

	mov	eax, DWORD PTR _p$85800[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN4@soap_copy_
	mov	esi, esp
	mov	eax, DWORD PTR _p$85800[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$85805[ebp]
	push	ecx
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$85800[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN4@soap_copy_

; 6374 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not copy plugin '%s'\n", p->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_copy_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_copy_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_copy_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85821[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$85800[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0BM@PKFIDKCF@Could?5not?5copy?5plugin?5?8?$CFs?8?6?$AA@
	mov	edx, DWORD PTR _fdebug$85821[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85821[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_copy_:

; 6375 :         SOAP_FREE(copy, q);

	mov	eax, DWORD PTR _q$85805[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_copy_context@@9@4JA
	add	ecx, 57					; 00000039H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6376 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_copy_
$LN4@soap_copy_:

; 6377 :       }
; 6378 :       q->next = copy->plugins;

	mov	eax, DWORD PTR _q$85805[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+12220]
	mov	DWORD PTR [eax], edx

; 6379 :       copy->plugins = q;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _q$85805[ebp]
	mov	DWORD PTR [eax+12220], ecx

; 6380 :     }

	jmp	$LN10@soap_copy_
$LN12@soap_copy_:

; 6381 :   }
; 6382 :   return copy;

	mov	eax, DWORD PTR _copy$[ebp]
$LN15@soap_copy_:

; 6383 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_copy_context ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KLNCLHNJ@Initializing?5pointer?5hashtable?6?$AA@ ; `string'
;	COMDAT ??_C@_0CA@KLNCLHNJ@Initializing?5pointer?5hashtable?6?$AA@
CONST	SEGMENT
??_C@_0CA@KLNCLHNJ@Initializing?5pointer?5hashtable?6?$AA@ DB 'Initializi'
	DB	'ng pointer hashtable', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_init_pht
_TEXT	SEGMENT
_fdebug$84591 = -20					; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_init_pht PROC					; COMDAT

; 4683 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4684 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing pointer hashtable\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_init_
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_init_
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_init_:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_init_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84591[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CA@KLNCLHNJ@Initializing?5pointer?5hashtable?6?$AA@
	mov	eax, DWORD PTR _fdebug$84591[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84591[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_init_:

; 4685 :   soap->pblk = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12196], 0

; 4686 :   soap->pidx = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12200], ax

; 4687 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_init_
$LN2@soap_init_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_init_:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN7@soap_init_

; 4688 :     soap->pht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+8100], 0
	jmp	SHORT $LN2@soap_init_
$LN7@soap_init_:

; 4689 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init_pht ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@MBJLJBON@Initializing?5ID?5hashtable?6?$AA@ ; `string'
;	COMDAT ??_C@_0BL@MBJLJBON@Initializing?5ID?5hashtable?6?$AA@
CONST	SEGMENT
??_C@_0BL@MBJLJBON@Initializing?5ID?5hashtable?6?$AA@ DB 'Initializing ID'
	DB	' hashtable', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_init_iht
_TEXT	SEGMENT
_fdebug$84997 = -20					; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_init_iht PROC					; COMDAT

; 5330 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5331 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing ID hashtable\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_init_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_init_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_init_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_init_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$84997[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@MBJLJBON@Initializing?5ID?5hashtable?6?$AA@
	mov	eax, DWORD PTR _fdebug$84997[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$84997[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_init_@2:

; 5332 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_init_@2
$LN2@soap_init_@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_init_@2:
	cmp	DWORD PTR _i$[ebp], 1999		; 000007cfH
	jge	SHORT $LN7@soap_init_@2

; 5333 :     soap->iht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+104], 0
	jmp	SHORT $LN2@soap_init_@2
$LN7@soap_init_@2:

; 5334 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init_iht ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_init_mht
_TEXT	SEGMENT
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_init_mht PROC					; COMDAT

; 5436 : { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5437 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_init_@3
$LN2@soap_init_@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_init_@3:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN4@soap_init_@3

; 5438 :     soap->mht[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90572], 0
	jmp	SHORT $LN2@soap_init_@3
$LN4@soap_init_@3:

; 5439 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init_mht ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_init_logs
_TEXT	SEGMENT
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_init_logs PROC					; COMDAT

; 6212 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6213 :   for (i = 0; i < SOAP_MAXLOGS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@soap_init_@4
$LN2@soap_init_@4:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_init_@4:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN4@soap_init_@4

; 6214 :   { soap->logfile[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90548], 0

; 6215 :     soap->fdebug[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+eax*4+90560], 0
	jmp	SHORT $LN2@soap_init_@4
$LN4@soap_init_@4:

; 6216 :   }
; 6217 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init_logs ENDP
_TEXT	ENDS
PUBLIC	_soap_copy_stream
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_copy_stream
_TEXT	SEGMENT
_copy$ = 8						; size = 4
_soap$ = 12						; size = 4
_soap_copy_stream PROC					; COMDAT

; 6392 : { copy->mode = soap->mode;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 6393 :   copy->imode = soap->imode;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 6394 :   copy->omode = soap->omode;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 6395 :   copy->socket = soap->socket;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR [eax+12408], edx

; 6396 :   copy->recv_timeout = soap->recv_timeout;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 6397 :   copy->send_timeout = soap->send_timeout;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx

; 6398 : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 6399 :   copy->os = soap->os;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12412]
	mov	DWORD PTR [eax+12412], edx

; 6400 :   copy->is = soap->is;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12416]
	mov	DWORD PTR [eax+12416], edx

; 6401 : #endif
; 6402 :   copy->sendfd = soap->sendfd;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12420]
	mov	DWORD PTR [eax+12420], edx

; 6403 :   copy->recvfd = soap->recvfd;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12424]
	mov	DWORD PTR [eax+12424], edx

; 6404 :   copy->bufidx = soap->bufidx;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	DWORD PTR [eax+12428], edx

; 6405 :   copy->buflen = soap->buflen;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+12432], edx

; 6406 :   copy->ahead = soap->ahead;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12436]
	mov	DWORD PTR [eax+12436], edx

; 6407 :   copy->cdata = soap->cdata;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	dx, WORD PTR [ecx+12440]
	mov	WORD PTR [eax+12440], dx

; 6408 :   copy->chunksize = soap->chunksize;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87312]
	mov	DWORD PTR [eax+87312], edx

; 6409 :   copy->chunkbuflen = soap->chunkbuflen;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87316]
	mov	DWORD PTR [eax+87316], edx

; 6410 :   copy->keep_alive = soap->keep_alive;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	dx, WORD PTR [ecx+90412]
	mov	WORD PTR [eax+90412], dx

; 6411 :   copy->tcp_keep_alive = soap->tcp_keep_alive;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	dx, WORD PTR [ecx+90414]
	mov	WORD PTR [eax+90414], dx

; 6412 :   copy->tcp_keep_idle = soap->tcp_keep_idle;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90416]
	mov	DWORD PTR [eax+90416], edx

; 6413 :   copy->tcp_keep_intvl = soap->tcp_keep_intvl;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90420]
	mov	DWORD PTR [eax+90420], edx

; 6414 :   copy->tcp_keep_cnt = soap->tcp_keep_cnt;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90424]
	mov	DWORD PTR [eax+90424], edx

; 6415 :   copy->max_keep_alive = soap->max_keep_alive;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90428]
	mov	DWORD PTR [eax+90428], edx

; 6416 : #ifndef WITH_NOIO
; 6417 :   copy->peer = soap->peer;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 94692				; 000171e4H
	mov	ecx, DWORD PTR _copy$[ebp]
	add	ecx, 94692				; 000171e4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 6418 :   copy->peerlen = soap->peerlen;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+94708]
	mov	DWORD PTR [eax+94708], edx

; 6419 : #endif
; 6420 : #ifdef WITH_OPENSSL
; 6421 :   copy->bio = soap->bio;
; 6422 :   copy->ssl = soap->ssl;
; 6423 :   copy->ctx = soap->ctx;
; 6424 : #endif
; 6425 : #ifdef WITH_ZLIB
; 6426 :   copy->zlib_state = soap->zlib_state;
; 6427 :   copy->zlib_in = soap->zlib_in;
; 6428 :   copy->zlib_out = soap->zlib_out;
; 6429 :   copy->d_stream = (z_stream*)SOAP_MALLOC(copy, sizeof(z_stream));
; 6430 :   memcpy(copy->d_stream, soap->d_stream, sizeof(z_stream));
; 6431 :   copy->z_crc = soap->z_crc;
; 6432 :   copy->z_ratio_in = soap->z_ratio_in;
; 6433 :   copy->z_ratio_out = soap->z_ratio_out;
; 6434 :   copy->z_buf = NULL;
; 6435 :   copy->z_buflen = soap->z_buflen;
; 6436 :   copy->z_level = soap->z_level;
; 6437 :   if (soap->z_buf && soap->zlib_state != SOAP_ZLIB_NONE)
; 6438 :   { copy->z_buf = (char*)SOAP_MALLOC(copy, SOAP_BUFLEN);
; 6439 :     memcpy(copy->z_buf, soap->z_buf, sizeof(soap->z_buf));
; 6440 :   }
; 6441 : #endif
; 6442 :   memcpy(copy->buf, soap->buf, sizeof(soap->buf));

	push	65536					; 00010000H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 12468				; 000030b4H
	push	eax
	mov	ecx, DWORD PTR _copy$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6443 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_copy_stream ENDP
_TEXT	ENDS
PUBLIC	_soap_begin
PUBLIC	??_C@_0BG@LDBBBDML@Initializing?5context?6?$AA@	; `string'
PUBLIC	??_C@_08LECBCGMK@TEST?4log?$AA@			; `string'
PUBLIC	??_C@_08NGEJLGAN@SENT?4log?$AA@			; `string'
PUBLIC	??_C@_08ONCNGCIF@RECV?4log?$AA@			; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40?$AA@			; `string'
PUBLIC	??_C@_03GCKCNDHP@1?41?$AA@			; `string'
PUBLIC	??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@		; `string'
PUBLIC	??_C@_06MNPIOIFE@?$CF?417lG?$AA@		; `string'
PUBLIC	??_C@_04OEJDHHEG@?$CF?49G?$AA@			; `string'
PUBLIC	_soap_init
EXTRN	_namespaces:BYTE
;	COMDAT ??_C@_0BG@LDBBBDML@Initializing?5context?6?$AA@
CONST	SEGMENT
??_C@_0BG@LDBBBDML@Initializing?5context?6?$AA@ DB 'Initializing context', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LECBCGMK@TEST?4log?$AA@
CONST	SEGMENT
??_C@_08LECBCGMK@TEST?4log?$AA@ DB 'TEST.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGEJLGAN@SENT?4log?$AA@
CONST	SEGMENT
??_C@_08NGEJLGAN@SENT?4log?$AA@ DB 'SENT.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONCNGCIF@RECV?4log?$AA@
CONST	SEGMENT
??_C@_08ONCNGCIF@RECV?4log?$AA@ DB 'RECV.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40?$AA@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40?$AA@ DB '1.0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCKCNDHP@1?41?$AA@
CONST	SEGMENT
??_C@_03GCKCNDHP@1?41?$AA@ DB '1.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@
CONST	SEGMENT
??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@ DB 'cid:id%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNPIOIFE@?$CF?417lG?$AA@
CONST	SEGMENT
??_C@_06MNPIOIFE@?$CF?417lG?$AA@ DB '%.17lG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEJDHHEG@?$CF?49G?$AA@
CONST	SEGMENT
??_C@_04OEJDHHEG@?$CF?49G?$AA@ DB '%.9G', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_init
_TEXT	SEGMENT
_fdebug$85844 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_init PROC						; COMDAT

; 6452 : { soap->state = SOAP_INIT;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+4], ax

; 6453 : #ifdef SOAP_MEM_DEBUG
; 6454 :   soap_init_mht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_init_mht
	add	esp, 4

; 6455 : #endif
; 6456 :   soap->version = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax

; 6457 :   soap_imode(soap, SOAP_IO_DEFAULT);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 6458 :   soap_omode(soap, SOAP_IO_DEFAULT);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 6459 :   soap->plugins = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12220], 0

; 6460 :   soap->user = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12216], 0

; 6461 :   soap->userid = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12224], 0

; 6462 :   soap->passwd = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12228], 0

; 6463 : #ifndef WITH_NOHTTP
; 6464 :   soap->fpost = http_post;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12232], OFFSET _http_post

; 6465 :   soap->fget = http_get;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12236], OFFSET _http_get

; 6466 :   soap->fput = http_put;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12240], OFFSET _http_put

; 6467 :   soap->fdel = http_del;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12244], OFFSET _http_del

; 6468 :   soap->fhead = http_head;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12248], OFFSET _http_head

; 6469 :   soap->fform = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12252], 0

; 6470 :   soap->fposthdr = http_post_header;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12256], OFFSET _http_post_header

; 6471 :   soap->fresponse = http_response;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12260], OFFSET _http_response

; 6472 :   soap->fparse = http_parse;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12264], OFFSET _http_parse

; 6473 :   soap->fparsehdr = http_parse_header;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12268], OFFSET _http_parse_header

; 6474 : #endif
; 6475 :   soap->fheader = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12272], 0

; 6476 :   soap->fconnect = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12280], 0

; 6477 :   soap->fdisconnect = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12284], 0

; 6478 : #ifndef WITH_NOIO
; 6479 : #ifndef WITH_IPV6
; 6480 :   soap->fresolve = tcp_gethost;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12276], OFFSET _tcp_gethost

; 6481 : #else
; 6482 :   soap->fresolve = NULL;
; 6483 : #endif
; 6484 :   soap->faccept = tcp_accept;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12300], OFFSET _tcp_accept

; 6485 :   soap->fopen = tcp_connect;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12296], OFFSET _tcp_connect

; 6486 :   soap->fclose = tcp_disconnect;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12304], OFFSET _tcp_disconnect

; 6487 :   soap->fclosesocket = tcp_closesocket;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12288], OFFSET _tcp_closesocket

; 6488 :   soap->fshutdownsocket = tcp_shutdownsocket;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12292], OFFSET _tcp_shutdownsocket

; 6489 :   soap->fsend = fsend;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12308], OFFSET _fsend

; 6490 :   soap->frecv = frecv;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12312], OFFSET _frecv

; 6491 :   soap->fpoll = soap_poll;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12316], OFFSET _soap_poll

; 6492 : #else
; 6493 :   soap->fopen = NULL;
; 6494 :   soap->fclose = NULL;
; 6495 :   soap->fpoll = NULL;
; 6496 : #endif
; 6497 :   soap->fseterror = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12320], 0

; 6498 :   soap->fignore = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12324], 0

; 6499 :   soap->fserveloop = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12328], 0

; 6500 :   soap->fplugin = fplugin;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12332], OFFSET _fplugin

; 6501 :   soap->fmalloc = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12336], 0

; 6502 : #ifndef WITH_LEANER
; 6503 :   soap->fprepareinit = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12340], 0

; 6504 :   soap->fpreparesend = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12344], 0

; 6505 :   soap->fpreparerecv = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12348], 0

; 6506 :   soap->fpreparefinal = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12352], 0

; 6507 :   soap->fdimereadopen = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12356], 0

; 6508 :   soap->fdimewriteopen = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12360], 0

; 6509 :   soap->fdimereadclose = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12364], 0

; 6510 :   soap->fdimewriteclose = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12368], 0

; 6511 :   soap->fdimeread = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12372], 0

; 6512 :   soap->fdimewrite = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12376], 0

; 6513 :   soap->fmimereadopen = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12380], 0

; 6514 :   soap->fmimewriteopen = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12384], 0

; 6515 :   soap->fmimereadclose = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12388], 0

; 6516 :   soap->fmimewriteclose = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12392], 0

; 6517 :   soap->fmimeread = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12396], 0

; 6518 :   soap->fmimewrite = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12400], 0

; 6519 : #endif
; 6520 :   soap->float_format = "%.9G"; /* Alternative: use "%G" */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+20], OFFSET ??_C@_04OEJDHHEG@?$CF?49G?$AA@

; 6521 :   soap->double_format = "%.17lG"; /* Alternative: use "%lG" */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+24], OFFSET ??_C@_06MNPIOIFE@?$CF?417lG?$AA@

; 6522 :   soap->dime_id_format = "cid:id%d"; /* default DIME id format */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+28], OFFSET ??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@

; 6523 :   soap->http_version = "1.1";

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+32], OFFSET ??_C@_03GCKCNDHP@1?41?$AA@

; 6524 :   soap->proxy_http_version = "1.0";

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90432], OFFSET ??_C@_03HLLJOCDO@1?40?$AA@

; 6525 :   soap->http_content = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+36], 0

; 6526 :   soap->actor = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+44], 0

; 6527 :   soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 6528 :   soap->tcp_keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90414], ax

; 6529 :   soap->tcp_keep_idle = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90416], 0

; 6530 :   soap->tcp_keep_intvl = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90420], 0

; 6531 :   soap->tcp_keep_cnt = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90424], 0

; 6532 :   soap->max_keep_alive = SOAP_MAXKEEPALIVE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90428], 100		; 00000064H

; 6533 :   soap->recv_timeout = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+48], 0

; 6534 :   soap->send_timeout = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+52], 0

; 6535 :   soap->connect_timeout = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+56], 0

; 6536 :   soap->accept_timeout = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+60], 0

; 6537 :   soap->socket_flags = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+64], 0

; 6538 :   soap->connect_flags = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+68], 0

; 6539 :   soap->bind_flags = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+72], 0

; 6540 :   soap->accept_flags = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+76], 0

; 6541 :   soap->ip = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90404], 0

; 6542 :   soap->labbuf = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12456], 0

; 6543 :   soap->lablen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12460], 0

; 6544 :   soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0

; 6545 :   soap->encodingStyle = SOAP_STR_EOS;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _soap_padding

; 6546 : #ifndef WITH_NONAMESPACES
; 6547 :   soap->namespaces = namespaces;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+80], OFFSET _namespaces

; 6548 : #else
; 6549 :   soap->namespaces = NULL;
; 6550 : #endif
; 6551 :   soap->local_namespaces = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+84], 0

; 6552 :   soap->nlist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+88], 0

; 6553 :   soap->blist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+92], 0

; 6554 :   soap->clist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+96], 0

; 6555 :   soap->alist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+100], 0

; 6556 :   soap->attributes = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87292], 0

; 6557 :   soap->header = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12204], 0

; 6558 :   soap->fault = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12208], 0

; 6559 :   soap->master = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12404], -1

; 6560 :   soap->socket = SOAP_INVALID_SOCKET;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12408], -1

; 6561 :   soap->os = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12412], 0

; 6562 :   soap->is = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12416], 0

; 6563 : #ifndef WITH_LEANER
; 6564 :   soap->dom = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90472], 0

; 6565 :   soap->dime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90512], 0

; 6566 :   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 6567 :   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 6568 :   soap->mime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90532], 0

; 6569 :   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 6570 :   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 6571 :   soap->mime.boundary = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90524], 0

; 6572 :   soap->mime.start = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90528], 0

; 6573 :   soap->xlist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90544], 0

; 6574 : #endif
; 6575 : #ifndef UNDER_CE
; 6576 :   soap->recvfd = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12424], 0

; 6577 :   soap->sendfd = 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12420], 1

; 6578 : #else
; 6579 :   soap->recvfd = stdin;
; 6580 :   soap->sendfd = stdout;
; 6581 : #endif
; 6582 :   soap->host[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+89368], 0

; 6583 :   soap->port = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90408], 0

; 6584 :   soap->action = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90392], 0

; 6585 :   soap->proxy_host = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90436], 0

; 6586 :   soap->proxy_port = 8080;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90440], 8080		; 00001f90H

; 6587 :   soap->proxy_userid = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90444], 0

; 6588 :   soap->proxy_passwd = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90448], 0

; 6589 :   soap->authrealm = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90396], 0

; 6590 :   soap->prolog = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90400], 0

; 6591 : #ifdef WITH_ZLIB
; 6592 :   soap->zlib_state = SOAP_ZLIB_NONE;
; 6593 :   soap->zlib_in = SOAP_ZLIB_NONE;
; 6594 :   soap->zlib_out = SOAP_ZLIB_NONE;
; 6595 :   soap->d_stream = (z_stream*)SOAP_MALLOC(soap, sizeof(z_stream));
; 6596 :   soap->d_stream->zalloc = Z_NULL;
; 6597 :   soap->d_stream->zfree = Z_NULL;
; 6598 :   soap->d_stream->opaque = Z_NULL;
; 6599 :   soap->z_buf = NULL;
; 6600 :   soap->z_level = 6;
; 6601 : #endif
; 6602 : #ifndef WITH_LEAN
; 6603 :   soap->c14ninclude = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94668], 0

; 6604 :   soap->c14nexclude = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94672], 0

; 6605 :   soap->cookies = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94676], 0

; 6606 :   soap->cookie_domain = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94680], 0

; 6607 :   soap->cookie_path = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94684], 0

; 6608 :   soap->cookie_max = 32;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+94688], 32		; 00000020H

; 6609 : #endif
; 6610 : #ifdef SOAP_DEBUG
; 6611 :   soap_init_logs(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_init_logs
	add	esp, 4

; 6612 : #endif
; 6613 : #ifdef WMW_RPM_IO
; 6614 :   soap->rpmreqid = NULL;
; 6615 : #endif
; 6616 : #ifdef PALM
; 6617 :   palmNetLibOpen();
; 6618 : #endif
; 6619 : #ifndef WITH_NOIDREF
; 6620 :   soap_init_iht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_init_iht
	add	esp, 4

; 6621 :   soap_init_pht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_init_pht
	add	esp, 4

; 6622 : #endif
; 6623 : #ifdef SOAP_DEBUG
; 6624 :   soap_set_recv_logfile(soap, "RECV.log");

	push	OFFSET ??_C@_08ONCNGCIF@RECV?4log?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_recv_logfile
	add	esp, 8

; 6625 :   soap_set_sent_logfile(soap, "SENT.log");

	push	OFFSET ??_C@_08NGEJLGAN@SENT?4log?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_sent_logfile
	add	esp, 8

; 6626 :   soap_set_test_logfile(soap, "TEST.log");

	push	OFFSET ??_C@_08LECBCGMK@TEST?4log?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_test_logfile
	add	esp, 8

; 6627 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing context\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_init
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_init
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_init:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_init
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85844[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BG@LDBBBDML@Initializing?5context?6?$AA@
	mov	eax, DWORD PTR _fdebug$85844[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85844[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_init:

; 6628 : #endif
; 6629 : #ifdef WITH_OPENSSL
; 6630 :   if (!soap_ssl_init_done)
; 6631 :   { soap_ssl_init();
; 6632 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing OpenSSL, version=%ld\n", (long)OPENSSL_VERSION_NUMBER));
; 6633 :   }
; 6634 :   soap->fsslauth = ssl_auth_init;
; 6635 :   soap->fsslverify = ssl_verify_callback;
; 6636 :   soap->bio = NULL;
; 6637 :   soap->ssl = NULL;
; 6638 :   soap->ctx = NULL;
; 6639 :   soap->ssl_flags = SOAP_SSL_DEFAULT;
; 6640 :   soap->keyfile = NULL;
; 6641 :   soap->password = NULL;
; 6642 :   soap->dhfile = NULL;
; 6643 :   soap->cafile = NULL;
; 6644 :   soap->capath = NULL;
; 6645 :   soap->crlfile = NULL;
; 6646 :   soap->randfile = NULL;
; 6647 :   soap->session = NULL;
; 6648 : #endif
; 6649 :   soap_begin(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_begin
	add	esp, 4

; 6650 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init ENDP
_TEXT	ENDS
PUBLIC	_soap_init1
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_init1
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_mode$ = 12						; size = 4
_soap_init1 PROC					; COMDAT

; 6659 : { soap_init2(soap, mode, mode);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_init2
	add	esp, 12					; 0000000cH

; 6660 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init1 ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_init2
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_imode$ = 12						; size = 4
_omode$ = 16						; size = 4
_soap_init2 PROC					; COMDAT

; 6669 : { soap_init(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_init
	add	esp, 4

; 6670 :   soap_imode(soap, imode);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _imode$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR _imode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 6671 :   soap_omode(soap, omode);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _omode$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR _omode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 6672 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_init2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@CMOKONKA@Reinitializing?5context?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@CMOKONKA@Reinitializing?5context?6?$AA@
CONST	SEGMENT
??_C@_0BI@CMOKONKA@Reinitializing?5context?6?$AA@ DB 'Reinitializing cont'
	DB	'ext', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_begin
_TEXT	SEGMENT
_fdebug$85862 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_begin PROC					; COMDAT

; 6681 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reinitializing context\n"));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN4@soap_begin@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_begin@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_begin@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN4@soap_begin@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85862[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@CMOKONKA@Reinitializing?5context?6?$AA@
	mov	eax, DWORD PTR _fdebug$85862[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85862[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_begin@3:

; 6682 :   if (!soap->keep_alive)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jne	SHORT $LN1@soap_begin@3

; 6683 :   { soap->buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], 0

; 6684 :     soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0
$LN1@soap_begin@3:

; 6685 :   }
; 6686 :   soap->keep_alive = (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) != 0);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12]
	or	edx, DWORD PTR [ecx+16]
	and	edx, 16					; 00000010H
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	WORD PTR [eax+90412], dx

; 6687 :   soap->null = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 6688 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 6689 :   soap->encoding = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax

; 6690 :   soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax

; 6691 :   soap->mode = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+8], 0

; 6692 :   soap->ns = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87302], ax

; 6693 :   soap->part = SOAP_END;

	mov	eax, 9
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 6694 :   soap->alloced = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87306], ax

; 6695 :   soap->count = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], 0

; 6696 :   soap->length = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12452], 0

; 6697 :   soap->cdata = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12440], ax

; 6698 :   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 6699 :   soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax

; 6700 :   soap->ahead = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 0

; 6701 :   soap->idnum = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12212], 0

; 6702 :   soap->level = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12444], 0

; 6703 :   soap->endpoint[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+87320], 0

; 6704 : #ifndef WITH_LEANER
; 6705 :   soap->dime.chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90484], 0

; 6706 :   soap->dime.buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90488], 0

; 6707 : #endif
; 6708 :   soap_free_temp(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_temp
	add	esp, 4

; 6709 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_begin ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_end@@9@4JA		; `soap_end'::`2'::__LINE__Var
PUBLIC	_soap_end
;	COMDAT ?__LINE__Var@?1??soap_end@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_end@@9@4JA DD 01a3eH		; `soap_end'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_end
_TEXT	SEGMENT
_cp$85873 = -8						; size = 4
_soap$ = 8						; size = 4
_soap_end PROC						; COMDAT

; 6718 : { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_end
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN4@soap_end
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN4@soap_end
$LN3@soap_end:

; 6719 :     return;

	jmp	SHORT $LN5@soap_end
$LN4@soap_end:

; 6720 :   soap_free_temp(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_temp
	add	esp, 4

; 6721 :   soap_dealloc(soap, NULL);

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_dealloc
	add	esp, 8
$LN2@soap_end:

; 6722 :   while (soap->clist)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN1@soap_end

; 6723 :   { register struct soap_clist *cp = soap->clist->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cp$85873[ebp], edx

; 6724 :     SOAP_FREE(soap, soap->clist);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_end@@9@4JA
	add	edx, 6
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6725 :     soap->clist = cp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _cp$85873[ebp]
	mov	DWORD PTR [eax+96], ecx

; 6726 :   }

	jmp	SHORT $LN2@soap_end
$LN1@soap_end:

; 6727 :   soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 6728 : #ifdef SOAP_DEBUG
; 6729 :   soap_close_logfiles(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_close_logfiles
	add	esp, 4
$LN5@soap_end:

; 6730 : #endif
; 6731 : #ifdef PALM
; 6732 :   palmNetLibClose();
; 6733 : #endif
; 6734 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_end ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_set_namespaces@@9@4JA	; `soap_set_namespaces'::`2'::__LINE__Var
PUBLIC	_soap_set_namespaces
;	COMDAT ?__LINE__Var@?1??soap_set_namespaces@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_set_namespaces@@9@4JA DD 01a57H	; `soap_set_namespaces'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_set_namespaces
_TEXT	SEGMENT
_i$85897 = -80						; size = 4
_s$85891 = -68						; size = 4
_level$ = -56						; size = 4
_nr$ = -44						; size = 4
_nq$ = -32						; size = 4
_np$ = -20						; size = 4
_ns$ = -8						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_set_namespaces PROC				; COMDAT

; 6743 : { register struct Namespace *ns = soap->local_namespaces;

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ns$[ebp], ecx

; 6744 :   register struct soap_nlist *np, *nq, *nr;
; 6745 :   register unsigned int level = soap->level;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	mov	DWORD PTR _level$[ebp], ecx

; 6746 :   soap->namespaces = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 6747 :   soap->local_namespaces = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+84], 0

; 6748 :   soap_set_local_namespaces(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_local_namespaces
	add	esp, 4

; 6749 :   /* reverse the namespace list */
; 6750 :   np = soap->nlist;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx

; 6751 :   soap->nlist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+88], 0

; 6752 :   if (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN10@soap_set_n

; 6753 :   { nq = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nq$[ebp], ecx

; 6754 :     np->next = NULL;

	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax], 0
$LN12@soap_set_n:

; 6755 :     while (nq)

	cmp	DWORD PTR _nq$[ebp], 0
	je	SHORT $LN10@soap_set_n

; 6756 :     { nr = nq->next;

	mov	eax, DWORD PTR _nq$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nr$[ebp], ecx

; 6757 :       nq->next = np;

	mov	eax, DWORD PTR _nq$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax], ecx

; 6758 :       np = nq;

	mov	eax, DWORD PTR _nq$[ebp]
	mov	DWORD PTR _np$[ebp], eax

; 6759 :       nq = nr;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR _nq$[ebp], eax

; 6760 :     }

	jmp	SHORT $LN12@soap_set_n
$LN10@soap_set_n:

; 6761 :   }
; 6762 :   /* then push on new stack */
; 6763 :   while (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	$LN9@soap_set_n

; 6764 :   { register const char *s;
; 6765 :     soap->level = np->level; /* preserve element nesting level */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12444], edx

; 6766 :     s = np->ns;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _s$85891[ebp], ecx

; 6767 :     if (!s && np->index >= 0 && ns)

	cmp	DWORD PTR _s$85891[ebp], 0
	jne	SHORT $LN8@soap_set_n
	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	jl	SHORT $LN8@soap_set_n
	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN8@soap_set_n

; 6768 :     { s = ns[np->index].out;

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _s$85891[ebp], eax

; 6769 :       if (!s)

	cmp	DWORD PTR _s$85891[ebp], 0
	jne	SHORT $LN8@soap_set_n

; 6770 :         s = ns[np->index].ns;

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _s$85891[ebp], eax
$LN8@soap_set_n:

; 6771 :     }
; 6772 :     if (s && soap_push_namespace(soap, np->id, s))

	cmp	DWORD PTR _s$85891[ebp], 0
	je	SHORT $LN6@soap_set_n
	mov	eax, DWORD PTR _s$85891[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_push_namespace
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_set_n

; 6773 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN14@soap_set_n
$LN6@soap_set_n:

; 6774 :     nq = np;

	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR _nq$[ebp], eax

; 6775 :     np = np->next;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx

; 6776 :     SOAP_FREE(soap, nq);

	mov	eax, DWORD PTR _nq$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_namespaces@@9@4JA
	add	ecx, 33					; 00000021H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6777 :   }

	jmp	$LN10@soap_set_n
$LN9@soap_set_n:

; 6778 :   if (ns)

	cmp	DWORD PTR _ns$[ebp], 0
	je	$LN5@soap_set_n

; 6779 :   { register int i;
; 6780 :     for (i = 0; ns[i].id; i++)

	mov	DWORD PTR _i$85897[ebp], 0
	jmp	SHORT $LN4@soap_set_n
$LN3@soap_set_n:
	mov	eax, DWORD PTR _i$85897[ebp]
	add	eax, 1
	mov	DWORD PTR _i$85897[ebp], eax
$LN4@soap_set_n:
	mov	eax, DWORD PTR _i$85897[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $LN2@soap_set_n

; 6781 :     { if (ns[i].out)

	mov	eax, DWORD PTR _i$85897[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+eax+12], 0
	je	SHORT $LN1@soap_set_n

; 6782 :       { SOAP_FREE(soap, ns[i].out);

	mov	eax, DWORD PTR _i$85897[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_set_namespaces@@9@4JA
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 6783 :         ns[i].out = NULL;

	mov	eax, DWORD PTR _i$85897[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [ecx+eax+12], 0
$LN1@soap_set_n:

; 6784 :       }
; 6785 :     }

	jmp	SHORT $LN3@soap_set_n
$LN2@soap_set_n:

; 6786 :     SOAP_FREE(soap, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_namespaces@@9@4JA
	add	ecx, 43					; 0000002bH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN5@soap_set_n:

; 6787 :   }
; 6788 :   soap->level = level; /* restore level */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _level$[ebp]
	mov	DWORD PTR [eax+12444], ecx

; 6789 :   return SOAP_OK;

	xor	eax, eax
$LN14@soap_set_n:

; 6790 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_namespaces ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_set_local_namespaces@@9@4JA ; `soap_set_local_namespaces'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??soap_set_local_namespaces@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_set_local_namespaces@@9@4JA DD 01a8fH ; `soap_set_local_namespaces'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_set_local_namespaces
_TEXT	SEGMENT
_n$85908 = -32						; size = 4
_ns2$85907 = -20					; size = 4
_ns1$85906 = -8						; size = 4
_soap$ = 8						; size = 4
_soap_set_local_namespaces PROC				; COMDAT

; 6799 : { if (soap->namespaces && !soap->local_namespaces)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	$LN9@soap_set_l@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	$LN9@soap_set_l@2

; 6800 :   { register const struct Namespace *ns1;
; 6801 :     register struct Namespace *ns2;
; 6802 :     register size_t n = 1;

	mov	DWORD PTR _n$85908[ebp], 1

; 6803 :     for (ns1 = soap->namespaces; ns1->id; ns1++)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _ns1$85906[ebp], ecx
	jmp	SHORT $LN7@soap_set_l@2
$LN6@soap_set_l@2:
	mov	eax, DWORD PTR _ns1$85906[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _ns1$85906[ebp], eax
$LN7@soap_set_l@2:
	mov	eax, DWORD PTR _ns1$85906[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@soap_set_l@2

; 6804 :       n++;

	mov	eax, DWORD PTR _n$85908[ebp]
	add	eax, 1
	mov	DWORD PTR _n$85908[ebp], eax
	jmp	SHORT $LN6@soap_set_l@2
$LN5@soap_set_l@2:

; 6805 :     n *= sizeof(struct Namespace);

	mov	eax, DWORD PTR _n$85908[ebp]
	shl	eax, 4
	mov	DWORD PTR _n$85908[ebp], eax

; 6806 :     ns2 = (struct Namespace*)SOAP_MALLOC(soap, n);

	mov	eax, DWORD PTR _n$85908[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_local_namespaces@@9@4JA
	add	ecx, 7
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ns2$85907[ebp], eax

; 6807 :     if (ns2)

	cmp	DWORD PTR _ns2$85907[ebp], 0
	je	SHORT $LN9@soap_set_l@2

; 6808 :     { memcpy(ns2, soap->namespaces, n);

	mov	eax, DWORD PTR _n$85908[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _ns2$85907[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6809 :       if (ns2[0].ns)

	mov	eax, DWORD PTR _ns2$85907[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@soap_set_l@2

; 6810 :       { if (!strcmp(ns2[0].ns, soap_env1))

	push	OFFSET _soap_env1
	mov	eax, DWORD PTR _ns2$85907[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_set_l@2

; 6811 :           soap->version = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax

; 6812 :         else

	jmp	SHORT $LN3@soap_set_l@2
$LN2@soap_set_l@2:

; 6813 :           soap->version = 2;

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax
$LN3@soap_set_l@2:

; 6814 :       }
; 6815 :       soap->local_namespaces = ns2;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _ns2$85907[ebp]
	mov	DWORD PTR [eax+84], ecx
$LN9@soap_set_l@2:

; 6816 :     }
; 6817 :   }
; 6818 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_local_namespaces ENDP
_TEXT	ENDS
PUBLIC	_soap_strsearch
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_strsearch
_TEXT	SEGMENT
_s$ = -20						; size = 4
_n$ = -8						; size = 4
_big$ = 8						; size = 4
_little$ = 12						; size = 4
_soap_strsearch PROC					; COMDAT

; 6828 : { size_t n = strlen(little);

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _little$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 6829 :   const char *s = big;

	mov	eax, DWORD PTR _big$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN5@soap_strse:

; 6830 :   while (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_strse

; 6831 :   { if (!strncmp(s, little, n) && (s[n] == '\0' || s[n] == ' '))

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _little$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@soap_strse
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@soap_strse
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@soap_strse
$LN2@soap_strse:

; 6832 :       return s;

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN6@soap_strse
$LN3@soap_strse:

; 6833 :     s = strchr(s, ' ');

	mov	esi, esp
	push	32					; 00000020H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$[ebp], eax

; 6834 :     if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_strse

; 6835 :       s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN1@soap_strse:

; 6836 :   }

	jmp	SHORT $LN5@soap_strse
$LN4@soap_strse:

; 6837 :   return NULL;

	xor	eax, eax
$LN6@soap_strse:

; 6838 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_strsearch ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup_ns
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_lookup_ns
_TEXT	SEGMENT
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_lookup_ns PROC					; COMDAT

; 6849 : { register struct soap_nlist *np;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6850 :   for (np = soap->nlist; np; np = np->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN4@soap_looku@3
$LN3@soap_looku@3:
	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx
$LN4@soap_looku@3:
	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN2@soap_looku@3

; 6851 :   { if (!strncmp(np->id, tag, n) && !np->id[n])

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _np$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_looku@3
	mov	eax, DWORD PTR _np$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	jne	SHORT $LN1@soap_looku@3

; 6852 :       return np;

	mov	eax, DWORD PTR _np$[ebp]
	jmp	SHORT $LN5@soap_looku@3
$LN1@soap_looku@3:

; 6853 :   }

	jmp	SHORT $LN3@soap_looku@3
$LN2@soap_looku@3:

; 6854 :   return NULL;

	xor	eax, eax
$LN5@soap_looku@3:

; 6855 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_lookup_ns ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@ ; `string'
PUBLIC	??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@		; `string'
PUBLIC	??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@		; `string'
PUBLIC	??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@	; `string'
PUBLIC	??_C@_08JNIDGPLJ@xsi?3type?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_03HCMCBFLP@_?$CFd?$AA@			; `string'
PUBLIC	_soap_attribute
PUBLIC	??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@ ; `string'
PUBLIC	??_C@_0CK@PHOLDMEC@Element?5begin?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFd?8?5t@ ; `string'
PUBLIC	_soap_element
;	COMDAT ??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@
CONST	SEGMENT
??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@ DB 'SOAP-ENV:encodingSty'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
CONST	SEGMENT
??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@ DB 'SOAP-ENV:mustUnders'
	DB	'tand', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
CONST	SEGMENT
??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@ DB 'SOAP-ENV:actor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
CONST	SEGMENT
??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@ DB 'SOAP-ENV:role', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
CONST	SEGMENT
??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@ DB 'SOAP-ENC:position', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNIDGPLJ@xsi?3type?$AA@
CONST	SEGMENT
??_C@_08JNIDGPLJ@xsi?3type?$AA@ DB 'xsi:type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HCMCBFLP@_?$CFd?$AA@
CONST	SEGMENT
??_C@_03HCMCBFLP@_?$CFd?$AA@ DB '_%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
CONST	SEGMENT
??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@ DB 'xmlns:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@
CONST	SEGMENT
??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@ DB '<'
	DB	'?xml version="1.0" encoding="UTF-8"?>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PHOLDMEC@Element?5begin?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFd?8?5t@
CONST	SEGMENT
??_C@_0CK@PHOLDMEC@Element?5begin?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFd?8?5t@ DB 'E'
	DB	'lement begin tag=''%s'' id=''%d'' type=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element
_TEXT	SEGMENT
tv302 = -256						; size = 4
tv293 = -256						; size = 4
tv184 = -256						; size = 4
tv144 = -256						; size = 4
tv129 = -256						; size = 4
tv77 = -256						; size = 4
_i$86040 = -56						; size = 4
_t$86037 = -44						; size = 4
_t$86026 = -32						; size = 4
_ns$86017 = -20						; size = 4
_fdebug$86005 = -8					; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_element PROC					; COMDAT

; 6937 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6938 : #ifdef WITH_XMLNS
; 6939 :   register const char *s;
; 6940 : #endif
; 6941 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element begin tag='%s' id='%d' type='%s'\n", tag, id, type?type:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN42@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN41@soap_eleme
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN41@soap_eleme:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN42@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86005[ebp], ecx
	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN45@soap_eleme
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN46@soap_eleme
$LN45@soap_eleme:
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@soap_eleme:
	mov	esi, esp
	mov	ecx, DWORD PTR tv77[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@PHOLDMEC@Element?5begin?5tag?$DN?8?$CFs?8?5id?$DN?8?$CFd?8?5t@
	mov	ecx, DWORD PTR _fdebug$86005[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86005[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN42@soap_eleme:

; 6942 : #ifdef WITH_DOM
; 6943 :   if (soap->part == SOAP_BEGIN_SECURITY && (soap->mode & SOAP_XML_CANONICAL) && !(soap->mode & SOAP_DOM_ASIS))
; 6944 :   { register struct soap_nlist *np;
; 6945 :     /* wsu:Id found: clear xmlns renderings, so re-emit them for exc-c14n */
; 6946 :     for (np = soap->nlist; np; np = np->next)
; 6947 :     { if (np->index == 2)
; 6948 :         np->index = 0;
; 6949 :     }
; 6950 :   }
; 6951 :   if (soap->mode & SOAP_XML_DOM)
; 6952 :   { register struct soap_dom_element *elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
; 6953 :     if (!elt)
; 6954 :       return soap->error = SOAP_EOM;
; 6955 :     elt->soap = soap;
; 6956 :     elt->next = NULL;
; 6957 :     elt->prnt = soap->dom;
; 6958 :     elt->name = soap_strdup(soap, tag);
; 6959 :     elt->elts = NULL;
; 6960 :     elt->atts = NULL;
; 6961 :     elt->nstr = NULL;
; 6962 :     elt->data = NULL;
; 6963 :     elt->wide = NULL;
; 6964 :     elt->node = NULL;
; 6965 :     elt->type = 0;
; 6966 :     elt->head = NULL;
; 6967 :     elt->tail = NULL;
; 6968 :     if (soap->dom)
; 6969 :     { struct soap_dom_element *p = soap->dom->elts;
; 6970 :       if (p)
; 6971 :       { while (p->next)
; 6972 :           p = p->next;
; 6973 :         p->next = elt;
; 6974 :       }
; 6975 :       else
; 6976 :         soap->dom->elts = elt;
; 6977 :     }
; 6978 :     soap->dom = elt;
; 6979 :   }
; 6980 :   else
; 6981 :   {
; 6982 : #endif
; 6983 :     soap->level++;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx

; 6984 : #ifndef WITH_LEAN
; 6985 :     if (!soap->ns)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87302]
	test	ecx, ecx
	jne	SHORT $LN39@soap_eleme

; 6986 :     { if (!(soap->mode & SOAP_XML_CANONICAL)
; 6987 :        && soap_send(soap, soap->prolog ? soap->prolog : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	jne	SHORT $LN38@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90400], 0
	je	SHORT $LN47@soap_eleme
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90400]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN48@soap_eleme
$LN47@soap_eleme:
	mov	DWORD PTR tv129[ebp], OFFSET ??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@
$LN48@soap_eleme:
	mov	eax, DWORD PTR tv129[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@soap_eleme

; 6988 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN38@soap_eleme:

; 6989 :     }

	jmp	SHORT $LN37@soap_eleme
$LN39@soap_eleme:

; 6990 :     else if (soap->mode & SOAP_XML_INDENT)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN37@soap_eleme

; 6991 :     { if (soap->ns == 1 && soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87302]
	cmp	ecx, 1
	jne	SHORT $LN35@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12444], 11		; 0000000bH
	jae	SHORT $LN49@soap_eleme
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN50@soap_eleme
$LN49@soap_eleme:
	mov	DWORD PTR tv144[ebp], 10		; 0000000aH
$LN50@soap_eleme:
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	push	OFFSET _soap_indent
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN35@soap_eleme

; 6992 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN35@soap_eleme:

; 6993 :       soap->body = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12442], ax
$LN37@soap_eleme:

; 6994 :     }
; 6995 : #endif
; 6996 : #ifdef WITH_XMLNS
; 6997 :     s = strchr(tag, ':');
; 6998 :     if (s && strncmp(tag, "SOAP-ENV", s - tag))
; 6999 :     { struct Namespace *ns = soap->local_namespaces;
; 7000 :       size_t n = s - tag;
; 7001 :       if (soap_send_raw(soap, "<", 1)
; 7002 :        || soap_send(soap, s + 1))
; 7003 :         return soap->error;
; 7004 :       if (soap->nlist && !strncmp(soap->nlist->id, tag, n) && !soap->nlist->id[n])
; 7005 :         ns = NULL;
; 7006 :       for (; ns && ns->id; ns++)
; 7007 :       { if (*ns->id && (ns->out || ns->ns) && !strncmp(ns->id, tag, n) && !ns->id[n])
; 7008 :         { soap_push_ns(soap, ns->id, ns->out ? ns->out : ns->ns, 0);
; 7009 :           if (soap_attribute(soap, "xmlns", ns->out ? ns->out : ns->ns))
; 7010 :             return soap->error;
; 7011 :           break;
; 7012 :         }
; 7013 :       }
; 7014 :     }
; 7015 :     else
; 7016 : #endif
; 7017 :     if (soap_send_raw(soap, "<", 1)
; 7018 :      || soap_send(soap, tag))

	push	1
	push	OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@soap_eleme
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@soap_eleme
$LN33@soap_eleme:

; 7019 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN34@soap_eleme:

; 7020 : #ifdef WITH_DOM
; 7021 :   }
; 7022 : #endif
; 7023 :   if (!soap->ns)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87302]
	test	ecx, ecx
	jne	$LN32@soap_eleme

; 7024 :   { struct Namespace *ns;
; 7025 :     for (ns = soap->local_namespaces; ns && ns->id; ns++)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ns$86017[ebp], ecx
	jmp	SHORT $LN31@soap_eleme
$LN30@soap_eleme:
	mov	eax, DWORD PTR _ns$86017[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _ns$86017[ebp], eax
$LN31@soap_eleme:
	cmp	DWORD PTR _ns$86017[ebp], 0
	je	$LN32@soap_eleme
	mov	eax, DWORD PTR _ns$86017[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN32@soap_eleme

; 7026 :     { if (*ns->id && (ns->out || ns->ns))

	mov	eax, DWORD PTR _ns$86017[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN28@soap_eleme
	mov	eax, DWORD PTR _ns$86017[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN27@soap_eleme
	mov	eax, DWORD PTR _ns$86017[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN28@soap_eleme
$LN27@soap_eleme:

; 7027 :       { sprintf(soap->tmpbuf, "xmlns:%s", ns->id);

	mov	esi, esp
	mov	eax, DWORD PTR _ns$86017[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7028 :         if (soap_attribute(soap, soap->tmpbuf, ns->out ? ns->out : ns->ns))

	mov	eax, DWORD PTR _ns$86017[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN51@soap_eleme
	mov	ecx, DWORD PTR _ns$86017[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv184[ebp], edx
	jmp	SHORT $LN52@soap_eleme
$LN51@soap_eleme:
	mov	eax, DWORD PTR _ns$86017[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv184[ebp], ecx
$LN52@soap_eleme:
	mov	edx, DWORD PTR tv184[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN28@soap_eleme

; 7029 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN28@soap_eleme:

; 7030 :       }
; 7031 :     }

	jmp	$LN30@soap_eleme
$LN32@soap_eleme:

; 7032 :   }
; 7033 :   soap->ns = 1; /* start with 0 or 2, but should be one to continue */

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87302], ax

; 7034 : #ifndef WITH_LEAN
; 7035 :   if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN25@soap_eleme

; 7036 :   { const char *t = strchr(tag, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$86026[ebp], eax

; 7037 :     if (t)

	cmp	DWORD PTR _t$86026[ebp], 0
	je	SHORT $LN25@soap_eleme

; 7038 :       soap_utilize_ns(soap, tag, t - tag);

	mov	eax, DWORD PTR _t$86026[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_utilize_ns
	add	esp, 12					; 0000000cH
$LN25@soap_eleme:

; 7039 :   }
; 7040 : #endif
; 7041 :   if (id > 0)

	cmp	DWORD PTR _id$[ebp], 0
	jle	SHORT $LN23@soap_eleme

; 7042 :   { sprintf(soap->tmpbuf, "_%d", id);

	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET ??_C@_03HCMCBFLP@_?$CFd?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7043 :     if (soap_attribute(soap, "id", soap->tmpbuf))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	push	OFFSET ??_C@_02EGCJHIOB@id?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@soap_eleme

; 7044 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN23@soap_eleme:

; 7045 :   }
; 7046 :   if (type && *type && (!(soap->mode & SOAP_XML_SEC) || soap->part == SOAP_IN_BODY))

	cmp	DWORD PTR _type$[ebp], 0
	je	$LN21@soap_eleme
	mov	eax, DWORD PTR _type$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN21@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN20@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 6
	jne	SHORT $LN21@soap_eleme
$LN20@soap_eleme:

; 7047 :   { if (soap_attribute(soap, "xsi:type", type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET ??_C@_08JNIDGPLJ@xsi?3type?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@soap_eleme

; 7048 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN19@soap_eleme:

; 7049 : #ifndef WITH_LEAN
; 7050 :     if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN21@soap_eleme

; 7051 :     { const char *t = strchr(type, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$86037[ebp], eax

; 7052 :       if (t)

	cmp	DWORD PTR _t$86037[ebp], 0
	je	SHORT $LN21@soap_eleme

; 7053 :         soap_utilize_ns(soap, type, t - type);

	mov	eax, DWORD PTR _t$86037[ebp]
	sub	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_utilize_ns
	add	esp, 12					; 0000000cH
$LN21@soap_eleme:

; 7054 :     }
; 7055 : #endif
; 7056 :   }
; 7057 :   if (soap->null && soap->position > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	$LN16@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87222]
	test	ecx, ecx
	jle	$LN16@soap_eleme

; 7058 :   { register int i;
; 7059 :     sprintf(soap->tmpbuf, "[%d", soap->positions[0]);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87224]
	push	ecx
	push	OFFSET ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7060 :     for (i = 1; i < soap->position; i++)

	mov	DWORD PTR _i$86040[ebp], 1
	jmp	SHORT $LN15@soap_eleme
$LN14@soap_eleme:
	mov	eax, DWORD PTR _i$86040[ebp]
	add	eax, 1
	mov	DWORD PTR _i$86040[ebp], eax
$LN15@soap_eleme:
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87222]
	cmp	DWORD PTR _i$86040[ebp], ecx
	jge	SHORT $LN13@soap_eleme

; 7061 :       sprintf(soap->tmpbuf + strlen(soap->tmpbuf), ",%d", soap->positions[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$86040[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+87224]
	push	edx
	push	OFFSET ??_C@_03LEIBKMN@?0?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+79028]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN14@soap_eleme
$LN13@soap_eleme:

; 7062 :     strcat(soap->tmpbuf, "]");

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcat
	add	esp, 8

; 7063 :     if (soap_attribute(soap, "SOAP-ENC:position", soap->tmpbuf))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	push	OFFSET ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@soap_eleme

; 7064 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN16@soap_eleme:

; 7065 :   }
; 7066 :   if (soap->mustUnderstand)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87298]
	test	ecx, ecx
	je	$LN11@soap_eleme

; 7067 :   { if (soap->actor && *soap->actor)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN10@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN10@soap_eleme

; 7068 :     { if (soap_attribute(soap, soap->version == 2 ? "SOAP-ENV:role" : "SOAP-ENV:actor", soap->actor))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN53@soap_eleme
	mov	DWORD PTR tv293[ebp], OFFSET ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
	jmp	SHORT $LN54@soap_eleme
$LN53@soap_eleme:
	mov	DWORD PTR tv293[ebp], OFFSET ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
$LN54@soap_eleme:
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR tv293[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@soap_eleme

; 7069 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN10@soap_eleme:

; 7070 :     }
; 7071 :     if (soap_attribute(soap, "SOAP-ENV:mustUnderstand", soap->version == 2 ? "true" : "1"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN55@soap_eleme
	mov	DWORD PTR tv302[ebp], OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jmp	SHORT $LN56@soap_eleme
$LN55@soap_eleme:
	mov	DWORD PTR tv302[ebp], OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN56@soap_eleme:
	mov	edx, DWORD PTR tv302[ebp]
	push	edx
	push	OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_eleme

; 7072 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_eleme
$LN8@soap_eleme:

; 7073 :     soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax
$LN11@soap_eleme:

; 7074 :   }
; 7075 :   if (soap->encoding)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87296]
	test	ecx, ecx
	je	SHORT $LN7@soap_eleme

; 7076 :   { if (soap->encodingStyle && soap->local_namespaces)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN6@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN6@soap_eleme

; 7077 :     { if (!*soap->encodingStyle)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@soap_eleme

; 7078 :       { if (soap->local_namespaces[1].out)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN4@soap_eleme

; 7079 :           soap->encodingStyle = soap->local_namespaces[1].out;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+40], eax

; 7080 :         else

	jmp	SHORT $LN5@soap_eleme
$LN4@soap_eleme:

; 7081 :           soap->encodingStyle = soap->local_namespaces[1].ns;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+40], eax
$LN5@soap_eleme:

; 7082 :       }
; 7083 :       if (soap_attribute(soap, "SOAP-ENV:encodingStyle", soap->encodingStyle))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET ??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_eleme

; 7084 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN43@soap_eleme
$LN6@soap_eleme:

; 7085 :     }
; 7086 :     soap->encoding = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax
$LN7@soap_eleme:

; 7087 :   }
; 7088 :   soap->null = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 7089 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 7090 :   if (soap->part == SOAP_BEGIN_SECURITY && (soap->mode & SOAP_XML_CANONICAL))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN1@soap_eleme
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN1@soap_eleme

; 7091 :     soap->part = SOAP_IN_SECURITY;

	mov	eax, 11					; 0000000bH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax
$LN1@soap_eleme:

; 7092 :   return SOAP_OK;

	xor	eax, eax
$LN43@soap_eleme:

; 7093 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OGHLBAHI@Utilizing?5namespace?5of?5?8?$CFs?8?6?$AA@ ; `string'
EXTRN	__imp__strncpy:PROC
;	COMDAT ??_C@_0BN@OGHLBAHI@Utilizing?5namespace?5of?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BN@OGHLBAHI@Utilizing?5namespace?5of?5?8?$CFs?8?6?$AA@ DB 'Utilizi'
	DB	'ng namespace of ''%s''', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_utilize_ns
_TEXT	SEGMENT
_fdebug$85986 = -20					; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_utilize_ns PROC					; COMDAT

; 6909 : { register struct soap_nlist *np = soap_lookup_ns(soap, tag, n);

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_lookup_ns
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _np$[ebp], eax

; 6910 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Utilizing namespace of '%s'\n", tag));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_utili
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_utili
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_utili:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_utili
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85986[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@OGHLBAHI@Utilizing?5namespace?5of?5?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$85986[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85986[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_utili:

; 6911 :   if (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN4@soap_utili

; 6912 :   { if (np->index == 0)

	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN3@soap_utili

; 6913 :       soap_push_ns(soap, np->id, np->ns, 1);

	push	1
	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _np$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_push_ns
	add	esp, 16					; 00000010H
$LN3@soap_utili:

; 6914 :   }

	jmp	SHORT $LN8@soap_utili
$LN4@soap_utili:

; 6915 :   else if (strncmp(tag, "xml", 3))

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN8@soap_utili

; 6916 :   { strncpy(soap->tmpbuf, tag, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6917 :     soap->tmpbuf[n] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	BYTE PTR [eax+79028], 0

; 6918 :     soap_push_ns(soap, soap->tmpbuf, NULL, 1);

	push	1
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_push_ns
	add	esp, 16					; 00000010H
$LN8@soap_utili:

; 6919 :   }
; 6920 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_utilize_ns ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_push_ns@@9@4JA@6501541a	; `soap_push_ns'::`2'::__LINE__Var
PUBLIC	??_C@_0DL@IHDNDFAI@Adding?5namespace?5binding?5?$CIlevel?$DN@ ; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@		; `string'
;	COMDAT ?__LINE__Var@?1??soap_push_ns@@9@4JA@6501541a
_DATA	SEGMENT
?__LINE__Var@?1??soap_push_ns@@9@4JA@6501541a DD 01acfH	; `soap_push_ns'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DL@IHDNDFAI@Adding?5namespace?5binding?5?$CIlevel?$DN@
CONST	SEGMENT
??_C@_0DL@IHDNDFAI@Adding?5namespace?5binding?5?$CIlevel?$DN@ DB 'Adding '
	DB	'namespace binding (level=%u) ''%s'' ''%s'' utilized=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ DB '(null)', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_push_ns
_TEXT	SEGMENT
tv141 = -244						; size = 4
_fdebug$85965 = -44					; size = 4
_k$ = -32						; size = 4
_n$ = -20						; size = 4
_np$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_ns$ = 16						; size = 4
_utilized$ = 20						; size = 2
_soap_push_ns PROC					; COMDAT

; 6863 : { register struct soap_nlist *np;

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 6864 :   size_t n, k;
; 6865 :   if (soap_strsearch(soap->c14nexclude, id))

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+94672]
	push	edx
	call	_soap_strsearch
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@soap_push_@3

; 6866 :     return NULL;

	xor	eax, eax
	jmp	$LN20@soap_push_@3
$LN19@soap_push_@3:

; 6867 :   if (!utilized)

	movsx	eax, WORD PTR _utilized$[ebp]
	test	eax, eax
	jne	$LN18@soap_push_@3

; 6868 :   { for (np = soap->nlist; np; np = np->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$[ebp], ecx
	jmp	SHORT $LN17@soap_push_@3
$LN16@soap_push_@3:
	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$[ebp], ecx
$LN17@soap_push_@3:
	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN15@soap_push_@3

; 6869 :     { if (!strcmp(np->id, id) && (!np->ns || !strcmp(np->ns, ns)))

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_push_@3
	mov	eax, DWORD PTR _np$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN13@soap_push_@3
	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_push_@3
$LN13@soap_push_@3:

; 6870 :         break;

	jmp	SHORT $LN15@soap_push_@3
$LN14@soap_push_@3:

; 6871 :     }

	jmp	SHORT $LN16@soap_push_@3
$LN15@soap_push_@3:

; 6872 :     if (np)

	cmp	DWORD PTR _np$[ebp], 0
	je	SHORT $LN18@soap_push_@3

; 6873 :     { if ((np->level < soap->level || !np->ns) && np->index == 1)

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+12444]
	jb	SHORT $LN10@soap_push_@3
	mov	eax, DWORD PTR _np$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN11@soap_push_@3
$LN10@soap_push_@3:
	mov	eax, DWORD PTR _np$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	cmp	ecx, 1
	jne	SHORT $LN11@soap_push_@3

; 6874 :         utilized = 1;

	mov	eax, 1
	mov	WORD PTR _utilized$[ebp], ax

; 6875 :       else

	jmp	SHORT $LN18@soap_push_@3
$LN11@soap_push_@3:

; 6876 :         return NULL;

	xor	eax, eax
	jmp	$LN20@soap_push_@3
$LN18@soap_push_@3:

; 6877 :     }
; 6878 :   }
; 6879 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Adding namespace binding (level=%u) '%s' '%s' utilized=%d\n", soap->level, id, ns?ns:"(null)", utilized));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN8@soap_push_@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_push_@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_push_@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_push_@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$85965[ebp], ecx
	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN22@soap_push_@3
	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN23@soap_push_@3
$LN22@soap_push_@3:
	mov	DWORD PTR tv141[ebp], OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
$LN23@soap_push_@3:
	movsx	ecx, WORD PTR _utilized$[ebp]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR tv141[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	push	edx
	push	OFFSET ??_C@_0DL@IHDNDFAI@Adding?5namespace?5binding?5?$CIlevel?$DN@
	mov	eax, DWORD PTR _fdebug$85965[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$85965[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_push_@3:

; 6880 :   n = strlen(id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 6881 :   if (ns)

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN5@soap_push_@3

; 6882 :     k = strlen(ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _k$[ebp], eax

; 6883 :   else

	jmp	SHORT $LN4@soap_push_@3
$LN5@soap_push_@3:

; 6884 :     k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN4@soap_push_@3:

; 6885 :   np = (struct soap_nlist*)SOAP_MALLOC(soap, sizeof(struct soap_nlist) + n + k + 1);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	lea	edx, DWORD PTR [ecx+eax+21]
	push	edx
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_push_ns@@9@4JA@6501541a
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _np$[ebp], eax

; 6886 :   if (!np)

	cmp	DWORD PTR _np$[ebp], 0
	jne	SHORT $LN3@soap_push_@3

; 6887 :   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 6888 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN20@soap_push_@3
$LN3@soap_push_@3:

; 6889 :   }
; 6890 :   np->next = soap->nlist;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax], edx

; 6891 :   soap->nlist = np;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 6892 :   strcpy(np->id, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_strcpy
	add	esp, 8

; 6893 :   if (ns)

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN2@soap_push_@3

; 6894 :   { np->ns = np->id + n + 1;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _np$[ebp]
	lea	edx, DWORD PTR [ecx+eax+17]
	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+12], edx

; 6895 :     strcpy(np->ns, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_strcpy
	add	esp, 8

; 6896 :   }
; 6897 :   else

	jmp	SHORT $LN1@soap_push_@3
$LN2@soap_push_@3:

; 6898 :     np->ns = NULL;

	mov	eax, DWORD PTR _np$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN1@soap_push_@3:

; 6899 :   np->level = soap->level;

	mov	eax, DWORD PTR _np$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	mov	DWORD PTR [eax+4], edx

; 6900 :   np->index = utilized;

	mov	eax, DWORD PTR _np$[ebp]
	mov	cx, WORD PTR _utilized$[ebp]
	mov	WORD PTR [eax+8], cx

; 6901 :   return np;

	mov	eax, DWORD PTR _np$[ebp]
$LN20@soap_push_@3:

; 6902 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_push_ns ENDP
_TEXT	ENDS
PUBLIC	_soap_element_start_end_out
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_element_begin_out
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_element_begin_out PROC				; COMDAT

; 7102 : { if (*tag == '-')

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN2@soap_eleme@2

; 7103 :     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN3@soap_eleme@2
$LN2@soap_eleme@2:

; 7104 :   if (soap_element(soap, tag, id, type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_eleme@2

; 7105 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_eleme@2
$LN1@soap_eleme@2:

; 7106 :   return soap_element_start_end_out(soap, NULL);

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
$LN3@soap_eleme@2:

; 7107 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_begin_out ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@	; `string'
PUBLIC	??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@	; `string'
PUBLIC	??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@	; `string'
PUBLIC	??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@	; `string'
PUBLIC	??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@		; `string'
PUBLIC	_soap_array_begin_out
EXTRN	__imp__strrchr:PROC
;	COMDAT ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
CONST	SEGMENT
??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@ DB 'SOAP-ENC:arrayType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
CONST	SEGMENT
??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@ DB 'SOAP-ENC:offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@
CONST	SEGMENT
??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@ DB 'SOAP-ENC:arraySize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
CONST	SEGMENT
??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@ DB 'SOAP-ENC:itemType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@
CONST	SEGMENT
??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@ DB 'SOAP-ENC:Array', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_array_begin_out
_TEXT	SEGMENT
_s$86093 = -20						; size = 4
_s$86080 = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
_offset$ = 24						; size = 4
_soap_array_begin_out PROC				; COMDAT

; 7227 : { if (soap_element(soap, tag, id, "SOAP-ENC:Array"))

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@soap_array@3

; 7228 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN11@soap_array@3
$LN10@soap_array@3:

; 7229 :   if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	$LN9@soap_array@3

; 7230 :   { const char *s;
; 7231 :     s = soap_strrchr(type, '[');

	mov	esi, esp
	push	91					; 0000005bH
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$86080[ebp], eax

; 7232 :     if ((size_t)(s - type) < sizeof(soap->tmpbuf))

	mov	eax, DWORD PTR _s$86080[ebp]
	sub	eax, DWORD PTR _type$[ebp]
	cmp	eax, 1024				; 00000400H
	jae	$LN8@soap_array@3

; 7233 :     { strncpy(soap->tmpbuf, type, s - type);

	mov	eax, DWORD PTR _s$86080[ebp]
	sub	eax, DWORD PTR _type$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7234 :       soap->tmpbuf[s - type] = '\0';

	mov	eax, DWORD PTR _s$86080[ebp]
	sub	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+eax+79028], 0

; 7235 :       if (type && *type && (soap_attribute(soap, "SOAP-ENC:itemType", soap->tmpbuf)))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN7@soap_array@3
	mov	eax, DWORD PTR _type$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@soap_array@3
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	push	OFFSET ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@soap_array@3

; 7236 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN11@soap_array@3
$LN7@soap_array@3:

; 7237 :       if (s && (soap_attribute(soap, "SOAP-ENC:arraySize", s + 1)))

	cmp	DWORD PTR _s$86080[ebp], 0
	je	SHORT $LN8@soap_array@3
	mov	eax, DWORD PTR _s$86080[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_array@3

; 7238 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN11@soap_array@3
$LN8@soap_array@3:

; 7239 :     }
; 7240 :   }
; 7241 :   else

	jmp	SHORT $LN5@soap_array@3
$LN9@soap_array@3:

; 7242 :   { if (offset && (soap_attribute(soap, "SOAP-ENC:offset", offset)))

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN4@soap_array@3
	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_array@3

; 7243 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN11@soap_array@3
$LN4@soap_array@3:

; 7244 :     if (type && *type && (soap_attribute(soap, "SOAP-ENC:arrayType", type)))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN5@soap_array@3
	mov	eax, DWORD PTR _type$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@soap_array@3
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_array@3

; 7245 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_array@3
$LN5@soap_array@3:

; 7246 :   }
; 7247 : #ifndef WITH_LEAN
; 7248 :   if (type && *type && (soap->mode & SOAP_XML_CANONICAL))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN2@soap_array@3
	mov	eax, DWORD PTR _type$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@soap_array@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN2@soap_array@3

; 7249 :   { const char *s = strchr(type, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$86093[ebp], eax

; 7250 :     if (s)

	cmp	DWORD PTR _s$86093[ebp], 0
	je	SHORT $LN2@soap_array@3

; 7251 :       soap_utilize_ns(soap, type, s - type);

	mov	eax, DWORD PTR _s$86093[ebp]
	sub	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_utilize_ns
	add	esp, 12					; 0000000cH
$LN2@soap_array@3:

; 7252 :   }
; 7253 : #endif
; 7254 :   return soap_element_start_end_out(soap, NULL);

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
$LN11@soap_array@3:

; 7255 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_array_begin_out ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCGKDMEN@?1?$DO?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	_soap_string_out
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	_soap_set_attr
PUBLIC	??_C@_0CO@LPLOEKHG@Enabling?5utilized?5binding?5?$CIlevel@ ; `string'
;	COMDAT ??_C@_02HCGKDMEN@?1?$DO?$AA@
CONST	SEGMENT
??_C@_02HCGKDMEN@?1?$DO?$AA@ DB '/>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC?$AA@ DB '="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LPLOEKHG@Enabling?5utilized?5binding?5?$CIlevel@
CONST	SEGMENT
??_C@_0CO@LPLOEKHG@Enabling?5utilized?5binding?5?$CIlevel@ DB 'Enabling u'
	DB	'tilized binding (level=%u) %s=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_start_end_out
_TEXT	SEGMENT
_fdebug$86116 = -44					; size = 4
_s$86106 = -32						; size = 4
_np$86101 = -20						; size = 4
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_element_start_end_out PROC			; COMDAT

; 7264 : { register struct soap_attribute *tp;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7265 : #ifndef WITH_LEAN
; 7266 :   if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	$LN27@soap_eleme@3

; 7267 :   { struct soap_nlist *np;
; 7268 :     for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN26@soap_eleme@3
$LN25@soap_eleme@3:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN26@soap_eleme@3:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN24@soap_eleme@3

; 7269 :     { if (tp->visible && tp->name)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN23@soap_eleme@3
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	je	SHORT $LN23@soap_eleme@3

; 7270 :       { const char *s = strchr(tp->name, ':');

	push	58					; 0000003aH
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$86106[ebp], eax

; 7271 :         if (s)

	cmp	DWORD PTR _s$86106[ebp], 0
	je	SHORT $LN23@soap_eleme@3

; 7272 :           soap_utilize_ns(soap, tp->name, s - tp->name);

	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	mov	ecx, DWORD PTR _s$86106[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _tp$[ebp]
	add	edx, 18					; 00000012H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_utilize_ns
	add	esp, 12					; 0000000cH
$LN23@soap_eleme@3:

; 7273 :       }
; 7274 :     }

	jmp	SHORT $LN25@soap_eleme@3
$LN24@soap_eleme@3:

; 7275 :     for (np = soap->nlist; np; np = np->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$86101[ebp], ecx
	jmp	SHORT $LN21@soap_eleme@3
$LN20@soap_eleme@3:
	mov	eax, DWORD PTR _np$86101[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$86101[ebp], ecx
$LN21@soap_eleme@3:
	cmp	DWORD PTR _np$86101[ebp], 0
	je	$LN27@soap_eleme@3

; 7276 :     { if (np->index == 1 && np->ns)

	mov	eax, DWORD PTR _np$86101[ebp]
	movsx	ecx, WORD PTR [eax+8]
	cmp	ecx, 1
	jne	$LN18@soap_eleme@3
	mov	eax, DWORD PTR _np$86101[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN18@soap_eleme@3

; 7277 :       { sprintf(soap->tmpbuf, "xmlns:%s", np->id);

	mov	eax, DWORD PTR _np$86101[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7278 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enabling utilized binding (level=%u) %s='%s'\n", np->level, soap->tmpbuf, np->ns));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN17@soap_eleme@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN16@soap_eleme@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN16@soap_eleme@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN17@soap_eleme@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86116[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _np$86101[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	mov	eax, DWORD PTR _np$86101[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0CO@LPLOEKHG@Enabling?5utilized?5binding?5?$CIlevel@
	mov	edx, DWORD PTR _fdebug$86116[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86116[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@soap_eleme@3:

; 7279 :         soap_set_attr(soap, soap->tmpbuf, np->ns);

	mov	eax, DWORD PTR _np$86101[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_attr
	add	esp, 12					; 0000000cH

; 7280 :         np->index = 2;

	mov	eax, 2
	mov	ecx, DWORD PTR _np$86101[ebp]
	mov	WORD PTR [ecx+8], ax
$LN18@soap_eleme@3:

; 7281 :       }
; 7282 :     }

	jmp	$LN20@soap_eleme@3
$LN27@soap_eleme@3:

; 7283 :   }
; 7284 : #endif
; 7285 : #ifdef WITH_DOM
; 7286 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7287 :   { register struct soap_dom_attribute **att;
; 7288 :     att = &soap->dom->atts;
; 7289 :     for (tp = soap->attributes; tp; tp = tp->next)
; 7290 :     { if (tp->visible)
; 7291 :       { *att = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 7292 :         if (!*att)
; 7293 :           return soap->error = SOAP_EOM;
; 7294 :         (*att)->next = NULL;
; 7295 :         (*att)->nstr = NULL;
; 7296 :         (*att)->name = soap_strdup(soap, tp->name);
; 7297 :         (*att)->data = soap_strdup(soap, tp->value);
; 7298 :         (*att)->wide = NULL;
; 7299 :         (*att)->soap = soap;
; 7300 :         att = &(*att)->next;
; 7301 :         tp->visible = 0;
; 7302 :       }
; 7303 :     }
; 7304 :     return SOAP_OK;
; 7305 :   }
; 7306 : #endif
; 7307 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN14@soap_eleme@3
$LN13@soap_eleme@3:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN14@soap_eleme@3:
	cmp	DWORD PTR _tp$[ebp], 0
	je	$LN12@soap_eleme@3

; 7308 :   { if (tp->visible)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	$LN11@soap_eleme@3

; 7309 :     {
; 7310 : #ifdef WITH_XMLNS
; 7311 :       const char *s = strchr(tp->name, ':');
; 7312 :       if (s)
; 7313 :       { size_t n = s - tp->name;
; 7314 :         if (soap->nlist && !strncmp(soap->nlist->id, tp->name, n) && !soap->nlist->id[n])
; 7315 :           s++;
; 7316 :         else
; 7317 :           s = tp->name;
; 7318 :         if (soap_send(soap, " ") || soap_send(soap, s))
; 7319 :           return soap->error;
; 7320 :       }
; 7321 :       else
; 7322 : #endif
; 7323 :       if (soap_send(soap, " ") || soap_send(soap, tp->name))

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@3
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_eleme@3
$LN9@soap_eleme@3:

; 7324 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN28@soap_eleme@3
$LN10@soap_eleme@3:

; 7325 :       if (tp->visible == 2 && tp->value)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	cmp	ecx, 2
	jne	SHORT $LN8@soap_eleme@3
	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@soap_eleme@3

; 7326 :         if (soap_send_raw(soap, "=\"", 2)
; 7327 :          || soap_string_out(soap, tp->value, 1)
; 7328 :          || soap_send_raw(soap, "\"", 1))

	push	2
	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_eleme@3
	push	1
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_eleme@3
	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_eleme@3
$LN6@soap_eleme@3:

; 7329 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN28@soap_eleme@3
$LN8@soap_eleme@3:

; 7330 :       tp->visible = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax
$LN11@soap_eleme@3:

; 7331 :     }
; 7332 :   }

	jmp	$LN13@soap_eleme@3
$LN12@soap_eleme@3:

; 7333 :   if (tag)

	cmp	DWORD PTR _tag$[ebp], 0
	je	$LN5@soap_eleme@3

; 7334 :   {
; 7335 : #ifndef WITH_LEAN
; 7336 :     if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN4@soap_eleme@3

; 7337 :     { if (soap_send_raw(soap, ">", 1)
; 7338 :        || soap_element_end_out(soap, tag))

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@soap_eleme@3
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@soap_eleme@3
$LN2@soap_eleme@3:

; 7339 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN28@soap_eleme@3
$LN3@soap_eleme@3:

; 7340 :       return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN28@soap_eleme@3
$LN4@soap_eleme@3:

; 7341 :     }
; 7342 : #endif
; 7343 :     soap->level--;	/* decrement level just before /> */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx

; 7344 :     if (soap_send_raw(soap, "/>", 2))

	push	2
	push	OFFSET ??_C@_02HCGKDMEN@?1?$DO?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_eleme@3

; 7345 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN28@soap_eleme@3
$LN1@soap_eleme@3:

; 7346 :     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN28@soap_eleme@3
$LN5@soap_eleme@3:

; 7347 :   }
; 7348 :   return soap_send_raw(soap, ">", 1);

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN28@soap_eleme@3:

; 7349 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_start_end_out ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DPNDACHE@?$DM?1?$AA@			; `string'
PUBLIC	??_C@_0BJ@PIOKNLEA@Element?5ending?5tag?$DN?8?$CFs?8?6?$AA@ ; `string'
;	COMDAT ??_C@_02DPNDACHE@?$DM?1?$AA@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1?$AA@ DB '</', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PIOKNLEA@Element?5ending?5tag?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PIOKNLEA@Element?5ending?5tag?$DN?8?$CFs?8?6?$AA@ DB 'Element e'
	DB	'nding tag=''%s''', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_end_out
_TEXT	SEGMENT
tv95 = -208						; size = 4
_fdebug$86145 = -8					; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_element_end_out PROC				; COMDAT

; 7358 : { if (*tag == '-')

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN10@soap_eleme@4

; 7359 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN11@soap_eleme@4
$LN10@soap_eleme@4:

; 7360 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element ending tag='%s'\n", tag));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_eleme@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_eleme@4
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_eleme@4:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_eleme@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86145[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@PIOKNLEA@Element?5ending?5tag?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$86145[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86145[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_eleme@4:

; 7361 : #ifdef WITH_DOM
; 7362 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7363 :   { if (soap->dom->prnt)
; 7364 :       soap->dom = soap->dom->prnt;
; 7365 :     return SOAP_OK;
; 7366 :   }
; 7367 : #endif
; 7368 : #ifndef WITH_LEAN
; 7369 :   if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN6@soap_eleme@4

; 7370 :     soap_pop_ns(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pop_ns
	add	esp, 4
$LN6@soap_eleme@4:

; 7371 :   if (soap->mode & SOAP_XML_INDENT)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN5@soap_eleme@4

; 7372 :   { if (!soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	jne	SHORT $LN4@soap_eleme@4

; 7373 :     { if (soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12444], 11		; 0000000bH
	jae	SHORT $LN13@soap_eleme@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12444]
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN14@soap_eleme@4
$LN13@soap_eleme@4:
	mov	DWORD PTR tv95[ebp], 10			; 0000000aH
$LN14@soap_eleme@4:
	mov	eax, DWORD PTR tv95[ebp]
	push	eax
	push	OFFSET _soap_indent
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_eleme@4

; 7374 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_eleme@4
$LN4@soap_eleme@4:

; 7375 :     }
; 7376 :     soap->body = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12442], ax
$LN5@soap_eleme@4:

; 7377 :   }
; 7378 : #endif
; 7379 : #ifdef WITH_XMLNS
; 7380 :   { const char *s = strchr(tag, ':');
; 7381 :     if (s && strncmp(tag, "SOAP-ENV", s - tag))
; 7382 :     { soap_pop_ns(soap);
; 7383 :       tag = s + 1;
; 7384 :     }
; 7385 :   }
; 7386 : #endif
; 7387 :   if (soap_send_raw(soap, "</", 2)
; 7388 :    || soap_send(soap, tag))

	push	2
	push	OFFSET ??_C@_02DPNDACHE@?$DM?1?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@4
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_eleme@4
$LN1@soap_eleme@4:

; 7389 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_eleme@4
$LN2@soap_eleme@4:

; 7390 :   soap->level--;	/* decrement level just before > */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx

; 7391 :   return soap_send_raw(soap, ">", 1);

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN11@soap_eleme@4:

; 7392 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_end_out ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_pop_ns
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_pop_ns PROC					; COMDAT

; 6927 : { soap_pop_namespace(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pop_namespace
	add	esp, 4

; 6928 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_pop_ns ENDP
_TEXT	ENDS
PUBLIC	??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@		; `string'
PUBLIC	??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@		; `string'
PUBLIC	_soap_element_ref
;	COMDAT ??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@
CONST	SEGMENT
??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@ DB '#_%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@
CONST	SEGMENT
??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@ DB 'SOAP-ENC:ref', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_ref
_TEXT	SEGMENT
_s$ = -20						; size = 4
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_href$ = 20						; size = 4
_soap_element_ref PROC					; COMDAT

; 7401 : { register int n = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _n$[ebp], 0

; 7402 :   const char *s = "href";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_04CMBCJJJD@href?$AA@

; 7403 :   if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN1@soap_eleme@5

; 7404 :   { s = "SOAP-ENC:ref";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@

; 7405 :     n = 1;

	mov	DWORD PTR _n$[ebp], 1
$LN1@soap_eleme@5:

; 7406 :   }
; 7407 :   sprintf(soap->href, "#_%d", href);

	mov	esi, esp
	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	push	OFFSET ??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 82100				; 000140b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7408 :   return soap_element_href(soap, tag, id, s, soap->href + n);

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+82100]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_href
	add	esp, 20					; 00000014H

; 7409 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_ref ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@LHEEEDA@Element?5?8?$CFs?8?5reference?5?$CFs?$DN?8?$CFs?8?6?$AA@ ; `string'
;	COMDAT ??_C@_0CA@LHEEEDA@Element?5?8?$CFs?8?5reference?5?$CFs?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0CA@LHEEEDA@Element?5?8?$CFs?8?5reference?5?$CFs?$DN?8?$CFs?8?6?$AA@ DB 'E'
	DB	'lement ''%s'' reference %s=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_href
_TEXT	SEGMENT
_fdebug$86176 = -8					; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_ref$ = 20						; size = 4
_val$ = 24						; size = 4
_soap_element_href PROC					; COMDAT

; 7418 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element '%s' reference %s='%s'\n", tag, ref, val));

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_eleme@6
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_eleme@6
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_eleme@6:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_eleme@6
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86176[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@LHEEEDA@Element?5?8?$CFs?8?5reference?5?$CFs?$DN?8?$CFs?8?6?$AA@
	mov	eax, DWORD PTR _fdebug$86176[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86176[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_eleme@6:

; 7419 :   if (soap_element(soap, tag, id, NULL)
; 7420 :    || soap_attribute(soap, ref, val)
; 7421 :    || soap_element_start_end_out(soap, tag))

	push	0
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@6
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@6
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_start_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_eleme@6
$LN1@soap_eleme@6:

; 7422 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN6@soap_eleme@6
$LN2@soap_eleme@6:

; 7423 :   return SOAP_OK;

	xor	eax, eax
$LN6@soap_eleme@6:

; 7424 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_href ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KJDFMKIE@xsi?3nil?$AA@			; `string'
PUBLIC	_soap_element_null
;	COMDAT ??_C@_07KJDFMKIE@xsi?3nil?$AA@
CONST	SEGMENT
??_C@_07KJDFMKIE@xsi?3nil?$AA@ DB 'xsi:nil', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_null
_TEXT	SEGMENT
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_element_null PROC					; COMDAT

; 7433 : { struct soap_attribute *tp;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7434 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN9@soap_eleme@7
$LN8@soap_eleme@7:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN9@soap_eleme@7:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN7@soap_eleme@7

; 7435 :     if (tp->visible)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN6@soap_eleme@7

; 7436 :       break;

	jmp	SHORT $LN7@soap_eleme@7
$LN6@soap_eleme@7:

; 7437 :   if (tp || (soap->version == 2 && soap->position > 0) || id > 0 || (soap->mode & SOAP_XML_NIL))

	jmp	SHORT $LN8@soap_eleme@7
$LN7@soap_eleme@7:
	cmp	DWORD PTR _tp$[ebp], 0
	jne	SHORT $LN4@soap_eleme@7
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN3@soap_eleme@7
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87222]
	test	ecx, ecx
	jg	SHORT $LN4@soap_eleme@7
$LN3@soap_eleme@7:
	cmp	DWORD PTR _id$[ebp], 0
	jg	SHORT $LN4@soap_eleme@7
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN5@soap_eleme@7
$LN4@soap_eleme@7:

; 7438 :   { if (soap_element(soap, tag, id, type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@soap_eleme@7

; 7439 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN10@soap_eleme@7
$LN2@soap_eleme@7:

; 7440 :     if (!tp && soap_attribute(soap, "xsi:nil", "true"))

	cmp	DWORD PTR _tp$[ebp], 0
	jne	SHORT $LN1@soap_eleme@7
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	push	OFFSET ??_C@_07KJDFMKIE@xsi?3nil?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_eleme@7

; 7441 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN10@soap_eleme@7
$LN1@soap_eleme@7:

; 7442 :     return soap_element_start_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_start_end_out
	add	esp, 8
	jmp	SHORT $LN10@soap_eleme@7
$LN5@soap_eleme@7:

; 7443 :   }
; 7444 :   soap->null = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 7445 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 7446 :   soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax

; 7447 :   return SOAP_OK;

	xor	eax, eax
$LN10@soap_eleme@7:

; 7448 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_null ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_element_id
_TEXT	SEGMENT
_pp$86211 = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_a$ = 24						; size = 4
_n$ = 28						; size = 4
_type$ = 32						; size = 4
_t$ = 36						; size = 4
_soap_element_id PROC					; COMDAT

; 7457 : { if (!p || (a && !a->__ptr))

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN8@soap_eleme@8
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN9@soap_eleme@8
	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@soap_eleme@8
$LN8@soap_eleme@8:

; 7458 :   { soap_element_null(soap, tag, id, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_null
	add	esp, 16					; 00000010H

; 7459 :     return -1;

	or	eax, -1
	jmp	$LN10@soap_eleme@8
$LN9@soap_eleme@8:

; 7460 :   }
; 7461 : #ifndef WITH_NOIDREF
; 7462 :   if (soap->mode & SOAP_XML_TREE)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN7@soap_eleme@8

; 7463 :     return 0;

	xor	eax, eax
	jmp	$LN10@soap_eleme@8
$LN7@soap_eleme@8:

; 7464 :   if (id < 0)

	cmp	DWORD PTR _id$[ebp], 0
	jge	$LN6@soap_eleme@8

; 7465 :   { struct soap_plist *pp;
; 7466 :     if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN5@soap_eleme@8

; 7467 :       id = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	eax, DWORD PTR _pp$86211[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_array_pointer_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _id$[ebp], eax

; 7468 :     else

	jmp	SHORT $LN4@soap_eleme@8
$LN5@soap_eleme@8:

; 7469 :       id = soap_pointer_lookup(soap, p, t, &pp);

	lea	eax, DWORD PTR _pp$86211[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pointer_lookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _id$[ebp], eax
$LN4@soap_eleme@8:

; 7470 :     if (id)

	cmp	DWORD PTR _id$[ebp], 0
	je	SHORT $LN6@soap_eleme@8

; 7471 :     { if (soap_is_embedded(soap, pp))

	mov	eax, DWORD PTR _pp$86211[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_is_embedded
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_eleme@8

; 7472 :       { soap_element_ref(soap, tag, 0, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element_ref
	add	esp, 16					; 00000010H

; 7473 :         return -1;

	or	eax, -1
	jmp	SHORT $LN10@soap_eleme@8
$LN2@soap_eleme@8:

; 7474 :       }
; 7475 :       if (soap_is_single(soap, pp))

	mov	eax, DWORD PTR _pp$86211[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_is_single
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_eleme@8

; 7476 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN10@soap_eleme@8
$LN1@soap_eleme@8:

; 7477 :       soap_set_embedded(soap, pp);

	mov	eax, DWORD PTR _pp$86211[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_embedded
	add	esp, 8
$LN6@soap_eleme@8:

; 7478 :     }
; 7479 :   }
; 7480 :   return id;

	mov	eax, DWORD PTR _id$[ebp]
$LN10@soap_eleme@8:

; 7481 : #else
; 7482 :   return 0;
; 7483 : #endif
; 7484 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@soap_eleme@8
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@soap_eleme@8:
	DD	1
	DD	$LN13@soap_eleme@8
$LN13@soap_eleme@8:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN12@soap_eleme@8
$LN12@soap_eleme@8:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
_soap_element_id ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@		; `string'
PUBLIC	??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@	; `string'
PUBLIC	_soap_element_result
;	COMDAT ??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@
CONST	SEGMENT
??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@ DB 'xmlns:SOAP-RPC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
CONST	SEGMENT
??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@ DB 'SOAP-RPC:result', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_result
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_element_result PROC				; COMDAT

; 7493 : { if (soap->version == 2 && soap->encodingStyle)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	$LN3@soap_eleme@9
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN3@soap_eleme@9

; 7494 :   { if (soap_element(soap, "SOAP-RPC:result", 0, NULL)
; 7495 :      || soap_attribute(soap, "xmlns:SOAP-RPC", soap_rpc)
; 7496 :      || soap_element_start_end_out(soap, NULL)
; 7497 :      || soap_string_out(soap, tag, 0)
; 7498 :      || soap_element_end_out(soap, "SOAP-RPC:result"))

	push	0
	push	0
	push	OFFSET ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@9
	push	OFFSET _soap_rpc
	push	OFFSET ??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@9
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@9
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@9
	push	OFFSET ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@soap_eleme@9
$LN1@soap_eleme@9:

; 7499 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN4@soap_eleme@9
$LN3@soap_eleme@9:

; 7500 :   }
; 7501 :   return SOAP_OK;

	xor	eax, eax
$LN4@soap_eleme@9:

; 7502 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_result ENDP
_TEXT	ENDS
PUBLIC	_soap_instring
PUBLIC	??_C@_07EFBDHEMP@?3result?$AA@			; `string'
PUBLIC	_soap_check_result
;	COMDAT ??_C@_07EFBDHEMP@?3result?$AA@
CONST	SEGMENT
??_C@_07EFBDHEMP@?3result?$AA@ DB ':result', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_check_result
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_check_result PROC					; COMDAT

; 7511 : { if (soap->version == 2 && soap->encodingStyle)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN2@soap_check
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN2@soap_check

; 7512 :   { soap_instring(soap, ":result", NULL, NULL, 0, 2, -1, -1);

	push	-1
	push	-1
	push	2
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_07EFBDHEMP@?3result?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_instring
	add	esp, 32					; 00000020H
$LN2@soap_check:

; 7513 :     /* just ignore content for compliance reasons, but should compare tag to element's QName value? */
; 7514 :   }
; 7515 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_check_result ENDP
_TEXT	ENDS
PUBLIC	??_C@_06PNFLLAEF@xmlns?3?$AA@			; `string'
;	COMDAT ??_C@_06PNFLLAEF@xmlns?3?$AA@
CONST	SEGMENT
??_C@_06PNFLLAEF@xmlns?3?$AA@ DB 'xmlns:', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_attribute
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_soap_attribute PROC					; COMDAT

; 7524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7525 : #ifdef WITH_DOM
; 7526 :   if ((soap->mode & SOAP_XML_DOM) && !(soap->mode & SOAP_XML_CANONICAL) && soap->dom)
; 7527 :   { register struct soap_dom_attribute *a = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 7528 :     a->next = soap->dom->atts;
; 7529 :     a->nstr = NULL;
; 7530 :     a->name = soap_strdup(soap, name);
; 7531 :     a->data = soap_strdup(soap, value);
; 7532 :     a->wide = NULL;
; 7533 :     a->soap = soap;
; 7534 :     soap->dom->atts = a;
; 7535 :     return SOAP_OK;
; 7536 :   }
; 7537 : #endif
; 7538 : #ifndef WITH_LEAN
; 7539 :   if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN10@soap_attri

; 7540 :   { /* TODO: consider using this code to handle default namespace bindings
; 7541 :     if (!strncmp(name, "xmlns", 5) && (name[5] == ':' || name[5] == '\0'))
; 7542 :     { if (name[5] == ':')
; 7543 :         soap_push_ns(soap, name + 6, value, 0);
; 7544 :       else
; 7545 :         soap_push_ns(soap, "", value, 0);
; 7546 :     }
; 7547 :     */
; 7548 :     if (!strncmp(name, "xmlns:", 6))

	mov	esi, esp
	push	6
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN9@soap_attri

; 7549 :       soap_push_ns(soap, name + 6, value, 0);

	push	0
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_push_ns
	add	esp, 16					; 00000010H
	jmp	SHORT $LN8@soap_attri
$LN9@soap_attri:

; 7550 :     else if (soap_set_attr(soap, name, value))

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_set_attr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_attri

; 7551 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN11@soap_attri
$LN8@soap_attri:

; 7552 :   }
; 7553 :   else

	jmp	$LN6@soap_attri
$LN10@soap_attri:

; 7554 : #endif
; 7555 :   { if (soap_send(soap, " ") || soap_send(soap, name))

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_attri
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_attri
$LN4@soap_attri:

; 7556 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_attri
$LN5@soap_attri:

; 7557 :     if (value)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN6@soap_attri

; 7558 :       if (soap_send_raw(soap, "=\"", 2)
; 7559 :        || soap_string_out(soap, value, 1)
; 7560 :        || soap_send_raw(soap, "\"", 1))

	push	2
	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_attri
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_attri
	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_attri
$LN1@soap_attri:

; 7561 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_attri
$LN6@soap_attri:

; 7562 :   }
; 7563 :   return SOAP_OK;

	xor	eax, eax
$LN11@soap_attri:

; 7564 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_attribute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@OLLPEIBK@Begin?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8@ ; `string'
;	COMDAT ??_C@_0CK@OLLPEIBK@Begin?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8@
CONST	SEGMENT
??_C@_0CK@OLLPEIBK@Begin?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8@ DB 'B'
	DB	'egin element found (level=%u) ''%s''=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_begin_in
_TEXT	SEGMENT
tv155 = -208						; size = 4
_fdebug$86265 = -8					; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_nillable$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_element_begin_in PROC				; COMDAT

; 7573 : { if (!soap_peek_element(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_peek_element
	add	esp, 4
	test	eax, eax
	jne	$LN12@soap_eleme@10

; 7574 :   { if (soap->other)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87220]
	test	ecx, ecx
	je	SHORT $LN11@soap_eleme@10

; 7575 :       return soap->error = SOAP_TAG_MISMATCH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 3
	mov	eax, 3
	jmp	$LN13@soap_eleme@10
$LN11@soap_eleme@10:

; 7576 :     if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN10@soap_eleme@10
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN10@soap_eleme@10

; 7577 :       return SOAP_OK;

	xor	eax, eax
	jmp	$LN13@soap_eleme@10
$LN10@soap_eleme@10:

; 7578 :     if (!(soap->error = soap_match_tag(soap, soap->tag, tag)))

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 80052				; 000138b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	jne	$LN9@soap_eleme@10

; 7579 :     { soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax

; 7580 :       if (type && *soap->type && soap_match_tag(soap, soap->type, type))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN8@soap_eleme@10
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN8@soap_eleme@10
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_eleme@10

; 7581 :         return soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
	mov	eax, 4
	jmp	$LN13@soap_eleme@10
$LN8@soap_eleme@10:

; 7582 :       if (!nillable && soap->null && (soap->mode & SOAP_XML_STRICT))

	cmp	DWORD PTR _nillable$[ebp], 0
	jne	SHORT $LN7@soap_eleme@10
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	SHORT $LN7@soap_eleme@10
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN7@soap_eleme@10

; 7583 :         return soap->error = SOAP_NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 23		; 00000017H
	mov	eax, 23					; 00000017H
	jmp	$LN13@soap_eleme@10
$LN7@soap_eleme@10:

; 7584 :       if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN6@soap_eleme@10

; 7585 :         soap->level++;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	add	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx
$LN6@soap_eleme@10:

; 7586 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin element found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag?tag:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN9@soap_eleme@10
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_eleme@10
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_eleme@10:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_eleme@10
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86265[ebp], ecx
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN15@soap_eleme@10
	mov	eax, DWORD PTR _tag$[ebp]
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $LN16@soap_eleme@10
$LN15@soap_eleme@10:
	mov	DWORD PTR tv155[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@soap_eleme@10:
	mov	esi, esp
	mov	ecx, DWORD PTR tv155[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 80052				; 000138b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	push	ecx
	push	OFFSET ??_C@_0CK@OLLPEIBK@Begin?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8@
	mov	edx, DWORD PTR _fdebug$86265[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86265[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_eleme@10:

; 7587 :     }
; 7588 :   }

	jmp	SHORT $LN2@soap_eleme@10
$LN12@soap_eleme@10:

; 7589 :   else if (soap->error == SOAP_NO_TAG && tag && *tag == '-')

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	jne	SHORT $LN2@soap_eleme@10
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN2@soap_eleme@10
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN2@soap_eleme@10

; 7590 :     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN2@soap_eleme@10:

; 7591 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN13@soap_eleme@10:

; 7592 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_begin_in ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@DFEGEPIM@End?5element?5tag?5name?5does?5not?5ma@ ; `string'
PUBLIC	??_C@_0CI@DKJDKPLM@End?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8?$CFs@ ; `string'
;	COMDAT ??_C@_0CF@DFEGEPIM@End?5element?5tag?5name?5does?5not?5ma@
CONST	SEGMENT
??_C@_0CF@DFEGEPIM@End?5element?5tag?5name?5does?5not?5ma@ DB 'End elemen'
	DB	't tag name does not match', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DKJDKPLM@End?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8?$CFs@
CONST	SEGMENT
??_C@_0CI@DKJDKPLM@End?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8?$CFs@ DB 'E'
	DB	'nd element found (level=%u) ''%s''=''%s''', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_element_end_in
_TEXT	SEGMENT
tv156 = -256						; size = 4
tv93 = -256						; size = 4
_fdebug$86320 = -56					; size = 4
_fdebug$86312 = -44					; size = 4
_n$ = -32						; size = 4
_s$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_element_end_in PROC				; COMDAT

; 7601 : { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7602 :   register char *s;
; 7603 :   register int n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 7604 :   if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN30@soap_eleme@11
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN30@soap_eleme@11

; 7605 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN31@soap_eleme@11
$LN30@soap_eleme@11:

; 7606 :   if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	jne	SHORT $LN29@soap_eleme@11

; 7607 :     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN29@soap_eleme@11:

; 7608 : #ifdef WITH_DOM
; 7609 :   /* this whitespace or mixed content is not insignificant for DOM */
; 7610 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7611 :   { if (!soap->peeked && !soap_string_in(soap, 3, -1, -1))
; 7612 :       return soap->error;
; 7613 :     if (soap->dom->prnt)
; 7614 :       soap->dom = soap->dom->prnt;
; 7615 :   }
; 7616 : #endif
; 7617 :   if (soap->peeked)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87308]
	test	ecx, ecx
	je	SHORT $LN23@soap_eleme@11

; 7618 :   { if (*soap->tag)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+80052]
	test	ecx, ecx
	je	SHORT $LN27@soap_eleme@11

; 7619 :       n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN27@soap_eleme@11:

; 7620 :     soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax
$LN23@soap_eleme@11:

; 7621 :   }
; 7622 :   do
; 7623 :   { while (((c = soap_get(soap)) != SOAP_TT))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], -3			; fffffffdH
	je	SHORT $LN25@soap_eleme@11

; 7624 :     { if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN21@soap_eleme@11

; 7625 :         return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN31@soap_eleme@11
$LN21@soap_eleme@11:

; 7626 :       if (c == SOAP_LT)

	cmp	DWORD PTR _c$[ebp], -2			; fffffffeH
	jne	SHORT $LN20@soap_eleme@11

; 7627 :         n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN19@soap_eleme@11
$LN20@soap_eleme@11:

; 7628 :       else if (c == '/')

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN19@soap_eleme@11

; 7629 :       { c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 7630 :         if (c == SOAP_GT)

	cmp	DWORD PTR _c$[ebp], -4			; fffffffcH
	jne	SHORT $LN17@soap_eleme@11

; 7631 :           n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 7632 :         else

	jmp	SHORT $LN19@soap_eleme@11
$LN17@soap_eleme@11:

; 7633 :           soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx
$LN19@soap_eleme@11:

; 7634 :       }
; 7635 :     }

	jmp	SHORT $LN23@soap_eleme@11
$LN25@soap_eleme@11:

; 7636 :   } while (n--);

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 0
	jne	$LN23@soap_eleme@11

; 7637 :   s = soap->tag;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	mov	DWORD PTR _s$[ebp], eax

; 7638 :   n = sizeof(soap->tag);

	mov	DWORD PTR _n$[ebp], 1024		; 00000400H
$LN15@soap_eleme@11:

; 7639 :   while (soap_notblank(c = soap_get(soap)))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN14@soap_eleme@11

; 7640 :   { if (--n > 0)

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN13@soap_eleme@11

; 7641 :       *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN13@soap_eleme@11:

; 7642 :   }

	jmp	SHORT $LN15@soap_eleme@11
$LN14@soap_eleme@11:

; 7643 :   *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7644 :   if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN11@soap_eleme@11

; 7645 :     return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN31@soap_eleme@11
$LN11@soap_eleme@11:

; 7646 :   while (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN10@soap_eleme@11
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN10@soap_eleme@11

; 7647 :     c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN11@soap_eleme@11
$LN10@soap_eleme@11:

; 7648 :   if (c != SOAP_GT)

	cmp	DWORD PTR _c$[ebp], -4			; fffffffcH
	je	SHORT $LN9@soap_eleme@11

; 7649 :     return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 5
	mov	eax, 5
	jmp	$LN31@soap_eleme@11
$LN9@soap_eleme@11:

; 7650 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End element found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag?tag:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN8@soap_eleme@11
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_eleme@11
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_eleme@11:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_eleme@11
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86312[ebp], ecx
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN33@soap_eleme@11
	mov	eax, DWORD PTR _tag$[ebp]
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN34@soap_eleme@11
$LN33@soap_eleme@11:
	mov	DWORD PTR tv156[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN34@soap_eleme@11:
	mov	esi, esp
	mov	ecx, DWORD PTR tv156[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 80052				; 000138b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	push	ecx
	push	OFFSET ??_C@_0CI@DKJDKPLM@End?5element?5found?5?$CIlevel?$DN?$CFu?$CJ?5?8?$CFs@
	mov	edx, DWORD PTR _fdebug$86312[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86312[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_eleme@11:

; 7651 : #ifndef WITH_LEAN
; 7652 :   if (tag && (soap->mode & SOAP_XML_STRICT))

	cmp	DWORD PTR _tag$[ebp], 0
	je	$LN5@soap_eleme@11
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	$LN5@soap_eleme@11

; 7653 :   { soap_pop_namespace(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pop_namespace
	add	esp, 4

; 7654 :     if (soap_match_tag(soap, soap->tag, tag))

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 80052				; 000138b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_eleme@11

; 7655 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End element tag name does not match\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_eleme@11
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_eleme@11
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_eleme@11:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_eleme@11
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86320[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CF@DFEGEPIM@End?5element?5tag?5name?5does?5not?5ma@
	mov	eax, DWORD PTR _fdebug$86320[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86320[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_eleme@11:

; 7656 :       return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 5
	mov	eax, 5
	jmp	SHORT $LN31@soap_eleme@11
$LN5@soap_eleme@11:

; 7657 :     }
; 7658 :   }
; 7659 : #endif
; 7660 :   soap->level--;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx

; 7661 :   return SOAP_OK;

	xor	eax, eax
$LN31@soap_eleme@11:

; 7662 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_element_end_in ENDP
_TEXT	ENDS
PUBLIC	_soap_attr_value
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_attr_value
_TEXT	SEGMENT
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_name$ = 12						; size = 4
_flag$ = 16						; size = 4
_soap_attr_value PROC					; COMDAT

; 7671 : { register struct soap_attribute *tp;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7672 :   if (*name == '-')

	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN10@soap_attr_

; 7673 :     return SOAP_STR_EOS;

	mov	eax, OFFSET _soap_padding
	jmp	$LN11@soap_attr_
$LN10@soap_attr_:

; 7674 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN9@soap_attr_
$LN8@soap_attr_:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN9@soap_attr_:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN7@soap_attr_

; 7675 :   { if (tp->visible && !soap_match_tag(soap, tp->name, name))

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN6@soap_attr_
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_attr_

; 7676 :       break;

	jmp	SHORT $LN7@soap_attr_
$LN6@soap_attr_:

; 7677 :   }

	jmp	SHORT $LN8@soap_attr_
$LN7@soap_attr_:

; 7678 :   if (tp)

	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN5@soap_attr_

; 7679 :   { if (flag == 2 && (soap->mode & SOAP_XML_STRICT))

	cmp	DWORD PTR _flag$[ebp], 2
	jne	SHORT $LN4@soap_attr_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN4@soap_attr_

; 7680 :       soap->error = SOAP_PROHIBITED;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 43		; 0000002bH

; 7681 :     else

	jmp	SHORT $LN3@soap_attr_
$LN4@soap_attr_:

; 7682 :       return tp->value;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN11@soap_attr_
$LN3@soap_attr_:
	jmp	SHORT $LN2@soap_attr_
$LN5@soap_attr_:

; 7683 :   }
; 7684 :   else if (flag == 1 && (soap->mode & SOAP_XML_STRICT))

	cmp	DWORD PTR _flag$[ebp], 1
	jne	SHORT $LN2@soap_attr_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN2@soap_attr_

; 7685 :     soap->error = SOAP_REQUIRED;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 42		; 0000002aH
$LN2@soap_attr_:

; 7686 :   return NULL;

	xor	eax, eax
$LN11@soap_attr_:

; 7687 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_attr_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BGJENONN@wsu?3Id?$AA@			; `string'
PUBLIC	??_C@_0CG@HIABGPJ@Allocate?5attribute?5value?5for?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0CG@NCMEJBEJ@Free?5attribute?5value?5of?5?$CFs?5?$CIfree@ ; `string'
PUBLIC	??_C@_0CF@IMICHKNC@Canonicalization?3?5prefix?5?$CFs?$DN?$CFp?5?$CI@ ; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns?$AA@			; `string'
PUBLIC	??_C@_0CB@JAJGPMKB@Inserting?5attribute?5?$CFs?5for?5c14n?6@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_set_attr@@9@4JA		; `soap_set_attr'::`2'::__LINE__Var
PUBLIC	??_C@_0BH@EEGPDING@Allocate?5attribute?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@NOBCNBHD@Set?5attribute?5?$CFs?$DN?8?$CFs?8?6?$AA@ ; `string'
;	COMDAT ??_C@_06BGJENONN@wsu?3Id?$AA@
CONST	SEGMENT
??_C@_06BGJENONN@wsu?3Id?$AA@ DB 'wsu:Id', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HIABGPJ@Allocate?5attribute?5value?5for?5?$CFs?5@
CONST	SEGMENT
??_C@_0CG@HIABGPJ@Allocate?5attribute?5value?5for?5?$CFs?5@ DB 'Allocate '
	DB	'attribute value for %s (%p)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCMEJBEJ@Free?5attribute?5value?5of?5?$CFs?5?$CIfree@
CONST	SEGMENT
??_C@_0CG@NCMEJBEJ@Free?5attribute?5value?5of?5?$CFs?5?$CIfree@ DB 'Free '
	DB	'attribute value of %s (free %p)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IMICHKNC@Canonicalization?3?5prefix?5?$CFs?$DN?$CFp?5?$CI@
CONST	SEGMENT
??_C@_0CF@IMICHKNC@Canonicalization?3?5prefix?5?$CFs?$DN?$CFp?5?$CI@ DB 'C'
	DB	'anonicalization: prefix %s=%p (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns?$AA@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns?$AA@ DB 'xmlns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JAJGPMKB@Inserting?5attribute?5?$CFs?5for?5c14n?6@
CONST	SEGMENT
??_C@_0CB@JAJGPMKB@Inserting?5attribute?5?$CFs?5for?5c14n?6@ DB 'Insertin'
	DB	'g attribute %s for c14n', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_set_attr@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_set_attr@@9@4JA DD 01e10H		; `soap_set_attr'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@EEGPDING@Allocate?5attribute?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@EEGPDING@Allocate?5attribute?5?$CFs?6?$AA@ DB 'Allocate attribu'
	DB	'te %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NOBCNBHD@Set?5attribute?5?$CFs?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BH@NOBCNBHD@Set?5attribute?5?$CFs?$DN?8?$CFs?8?6?$AA@ DB 'Set attr'
	DB	'ibute %s=''%s''', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_set_attr
_TEXT	SEGMENT
tv79 = -316						; size = 4
_fdebug$86424 = -116					; size = 4
_fdebug$86414 = -104					; size = 4
_fdebug$86400 = -92					; size = 4
_k$86390 = -80						; size = 4
_fdebug$86373 = -68					; size = 4
_s$86368 = -56						; size = 4
_tpp$86367 = -44					; size = 4
_fdebug$86360 = -32					; size = 4
_fdebug$86349 = -20					; size = 4
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_soap_set_attr PROC					; COMDAT

; 7696 : { register struct soap_attribute *tp;

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7697 :   if (*name == '-')

	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN59@soap_set_a

; 7698 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN60@soap_set_a
$LN59@soap_set_a:

; 7699 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Set attribute %s='%s'\n", name, value?value:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN58@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN57@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN57@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN58@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86349[ebp], ecx
	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN62@soap_set_a
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN63@soap_set_a
$LN62@soap_set_a:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN63@soap_set_a:
	mov	esi, esp
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@NOBCNBHD@Set?5attribute?5?$CFs?$DN?8?$CFs?8?6?$AA@
	mov	eax, DWORD PTR _fdebug$86349[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86349[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN58@soap_set_a:

; 7700 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN55@soap_set_a
$LN54@soap_set_a:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN55@soap_set_a:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN53@soap_set_a

; 7701 :   { if (!strcmp(tp->name, name))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@soap_set_a

; 7702 :       break;

	jmp	SHORT $LN53@soap_set_a
$LN52@soap_set_a:

; 7703 :   }

	jmp	SHORT $LN54@soap_set_a
$LN53@soap_set_a:

; 7704 :   if (!tp)

	cmp	DWORD PTR _tp$[ebp], 0
	jne	$LN51@soap_set_a

; 7705 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Allocate attribute %s\n", name));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN50@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN49@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN49@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN50@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86360[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@EEGPDING@Allocate?5attribute?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$86360[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86360[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@soap_set_a:

; 7706 :     if (!(tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(name))))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_set_attr@@9@4JA
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tp$[ebp], eax
	cmp	DWORD PTR _tp$[ebp], 0
	jne	SHORT $LN47@soap_set_a

; 7707 :       return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN60@soap_set_a
$LN47@soap_set_a:

; 7708 :     tp->ns = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+12], 0

; 7709 : #ifndef WITH_LEAN
; 7710 :     if (soap->mode & SOAP_XML_CANONICAL)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	$LN46@soap_set_a

; 7711 :     { struct soap_attribute **tpp = &soap->attributes;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87292				; 000154fcH
	mov	DWORD PTR _tpp$86367[ebp], eax

; 7712 :       const char *s = strchr(name, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$86368[ebp], eax

; 7713 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inserting attribute %s for c14n\n", name))

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN45@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN44@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN44@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN45@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86373[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@JAJGPMKB@Inserting?5attribute?5?$CFs?5for?5c14n?6@
	mov	ecx, DWORD PTR _fdebug$86373[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86373[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN45@soap_set_a:

; 7714 :       if (!strncmp(name, "xmlns", 5))

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN42@soap_set_a
	jmp	SHORT $LN41@soap_set_a
$LN40@soap_set_a:

; 7715 :       { for (; *tpp; tpp = &(*tpp)->next)

	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tpp$86367[ebp], ecx
$LN41@soap_set_a:
	mov	eax, DWORD PTR _tpp$86367[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN39@soap_set_a

; 7716 :           if (strncmp((*tpp)->name, "xmlns", 5) || strcmp((*tpp)->name + 5, name + 5) > 0)

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 18					; 00000012H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN37@soap_set_a
	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _tpp$86367[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 23					; 00000017H
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN38@soap_set_a
$LN37@soap_set_a:

; 7717 :             break;

	jmp	SHORT $LN39@soap_set_a
$LN38@soap_set_a:

; 7718 :       }

	jmp	SHORT $LN40@soap_set_a
$LN39@soap_set_a:

; 7719 :       else if (!s)

	jmp	$LN36@soap_set_a
$LN42@soap_set_a:
	cmp	DWORD PTR _s$86368[ebp], 0
	jne	SHORT $LN35@soap_set_a
	jmp	SHORT $LN34@soap_set_a
$LN33@soap_set_a:

; 7720 :       { for (; *tpp; tpp = &(*tpp)->next)

	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tpp$86367[ebp], ecx
$LN34@soap_set_a:
	mov	eax, DWORD PTR _tpp$86367[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN32@soap_set_a

; 7721 :           if (strncmp((*tpp)->name, "xmlns", 5) && ((*tpp)->ns || strcmp((*tpp)->name, name) > 0))

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 18					; 00000012H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN31@soap_set_a
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN30@soap_set_a
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tpp$86367[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 18					; 00000012H
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN31@soap_set_a
$LN30@soap_set_a:

; 7722 :             break;

	jmp	SHORT $LN32@soap_set_a
$LN31@soap_set_a:

; 7723 :       }

	jmp	SHORT $LN33@soap_set_a
$LN32@soap_set_a:

; 7724 :       else

	jmp	$LN36@soap_set_a
$LN35@soap_set_a:

; 7725 :       { int k;
; 7726 :         for (; *tpp; tpp = &(*tpp)->next)

	jmp	SHORT $LN28@soap_set_a
$LN27@soap_set_a:
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tpp$86367[ebp], ecx
$LN28@soap_set_a:
	mov	eax, DWORD PTR _tpp$86367[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN36@soap_set_a

; 7727 :         { if (!strncmp((*tpp)->name, "xmlns:", 6) && !strncmp((*tpp)->name + 6, name, s - name) && !(*tpp)->name[6 + s - name])

	mov	esi, esp
	push	6
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 18					; 00000012H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN25@soap_set_a
	mov	eax, DWORD PTR _s$86368[ebp]
	sub	eax, DWORD PTR _name$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tpp$86367[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 24					; 00000018H
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN25@soap_set_a
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _s$86368[ebp]
	add	edx, 6
	sub	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [ecx+edx+18]
	test	eax, eax
	jne	$LN25@soap_set_a

; 7728 :           { if (!tp->ns)

	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN24@soap_set_a

; 7729 :             { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Canonicalization: prefix %s=%p (%s)\n", name, (*tpp)->ns, (*tpp)->ns));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN23@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN22@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN22@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN23@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86400[ebp], ecx
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@IMICHKNC@Canonicalization?3?5prefix?5?$CFs?$DN?$CFp?5?$CI@
	mov	ecx, DWORD PTR _fdebug$86400[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86400[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@soap_set_a:

; 7730 :               tp->ns = (*tpp)->ns;

	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
$LN24@soap_set_a:

; 7731 :             }
; 7732 :           }

	jmp	SHORT $LN20@soap_set_a
$LN25@soap_set_a:

; 7733 :           else if (strncmp((*tpp)->name, "xmlns", 5) && (*tpp)->ns && tp->ns && ((k = strcmp((*tpp)->ns, tp->ns)) > 0 || (!k && strcmp((*tpp)->name, name) > 0)))

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 18					; 00000012H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN20@soap_set_a
	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN20@soap_set_a
	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN20@soap_set_a
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _tpp$86367[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR _k$86390[ebp], eax
	cmp	DWORD PTR _k$86390[ebp], 0
	jg	SHORT $LN18@soap_set_a
	cmp	DWORD PTR _k$86390[ebp], 0
	jne	SHORT $LN20@soap_set_a
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tpp$86367[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 18					; 00000012H
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN20@soap_set_a
$LN18@soap_set_a:

; 7734 :             break;

	jmp	SHORT $LN36@soap_set_a
$LN20@soap_set_a:

; 7735 :         }

	jmp	$LN27@soap_set_a
$LN36@soap_set_a:

; 7736 :       }
; 7737 :       tp->next = *tpp;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _tpp$86367[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 7738 :       *tpp = tp;

	mov	eax, DWORD PTR _tpp$86367[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax], ecx

; 7739 :     }
; 7740 :     else

	jmp	SHORT $LN17@soap_set_a
$LN46@soap_set_a:

; 7741 : #endif
; 7742 :     { tp->next = soap->attributes;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87292]
	mov	DWORD PTR [eax], edx

; 7743 :       soap->attributes = tp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+87292], ecx
$LN17@soap_set_a:

; 7744 :     }
; 7745 :     strcpy(tp->name, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	call	_strcpy
	add	esp, 8

; 7746 :     tp->value = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN16@soap_set_a
$LN51@soap_set_a:

; 7747 :   }
; 7748 :   else if (tp->visible)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN15@soap_set_a

; 7749 :   { return SOAP_OK;

	xor	eax, eax
	jmp	$LN60@soap_set_a
	jmp	$LN16@soap_set_a
$LN15@soap_set_a:

; 7750 :   }
; 7751 :   else if (value && tp->value && tp->size <= strlen(value))

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN16@soap_set_a
	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN16@soap_set_a
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [ecx+8], eax
	ja	$LN16@soap_set_a

; 7752 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free attribute value of %s (free %p)\n", name, tp->value));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN12@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN12@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86414[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CG@NCMEJBEJ@Free?5attribute?5value?5of?5?$CFs?5?$CIfree@
	mov	eax, DWORD PTR _fdebug$86414[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86414[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@soap_set_a:

; 7753 :     SOAP_FREE(soap, tp->value);

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_set_attr@@9@4JA
	add	edx, 57					; 00000039H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 7754 :     tp->value = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+4], 0

; 7755 :     tp->ns = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN16@soap_set_a:

; 7756 :   }
; 7757 :   if (value)

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN9@soap_set_a

; 7758 :   { if (!tp->value)

	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	$LN8@soap_set_a

; 7759 :     { tp->size = strlen(value) + 1;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 7760 :       if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_set_attr@@9@4JA
	add	edx, 64					; 00000040H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN7@soap_set_a

; 7761 :         return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN60@soap_set_a
$LN7@soap_set_a:

; 7762 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Allocate attribute value for %s (%p)\n", tp->name, tp->value));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_set_a
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_set_a:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_set_a
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86424[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _tp$[ebp]
	add	edx, 18					; 00000012H
	push	edx
	push	OFFSET ??_C@_0CG@HIABGPJ@Allocate?5attribute?5value?5for?5?$CFs?5@
	mov	eax, DWORD PTR _fdebug$86424[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86424[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_set_a:

; 7763 :     }
; 7764 :     strcpy(tp->value, value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_strcpy
	add	esp, 8

; 7765 :     if (!strncmp(tp->name, "xmlns:", 6))

	mov	esi, esp
	push	6
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@soap_set_a

; 7766 :       tp->ns = tp->value;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
$LN3@soap_set_a:

; 7767 :     tp->visible = 2;

	mov	eax, 2
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax

; 7768 : #ifndef WITH_LEAN
; 7769 :     if (!strcmp(name, "wsu:Id"))

	push	OFFSET ??_C@_06BGJENONN@wsu?3Id?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_set_a

; 7770 :     { soap->part = SOAP_BEGIN_SECURITY;

	mov	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 7771 :       strncpy(soap->id, value, sizeof(soap->id));

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 81076				; 00013cb4H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7772 :       soap->id[sizeof(soap->id)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+82099], 0
$LN2@soap_set_a:

; 7773 :     }
; 7774 : #endif
; 7775 :   }
; 7776 :   else

	jmp	SHORT $LN1@soap_set_a
$LN9@soap_set_a:

; 7777 :     tp->visible = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax
$LN1@soap_set_a:

; 7778 :   return SOAP_OK;

	xor	eax, eax
$LN60@soap_set_a:

; 7779 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_attr ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_clr_attr@@9@4JA		; `soap_clr_attr'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??soap_clr_attr@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_clr_attr@@9@4JA DD 01e6cH		; `soap_clr_attr'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_clr_attr
_TEXT	SEGMENT
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_clr_attr PROC					; COMDAT

; 7788 : { register struct soap_attribute *tp;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7789 : #ifndef WITH_LEAN
; 7790 :   if ((soap->mode & SOAP_XML_CANONICAL))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	$LN8@soap_clr_a
$LN7@soap_clr_a:

; 7791 :   { while (soap->attributes)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+87292], 0
	je	SHORT $LN6@soap_clr_a

; 7792 :     { tp = soap->attributes->next;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tp$[ebp], edx

; 7793 :       if (soap->attributes->value)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@soap_clr_a

; 7794 :         SOAP_FREE(soap, soap->attributes->value);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_clr_attr@@9@4JA
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN5@soap_clr_a:

; 7795 :       SOAP_FREE(soap, soap->attributes);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_clr_attr@@9@4JA
	add	edx, 7
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 7796 :       soap->attributes = tp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+87292], ecx

; 7797 :     }

	jmp	$LN7@soap_clr_a
$LN6@soap_clr_a:

; 7798 :   }
; 7799 :   else

	jmp	SHORT $LN9@soap_clr_a
$LN8@soap_clr_a:

; 7800 : #endif
; 7801 :   { for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN3@soap_clr_a
$LN2@soap_clr_a:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN3@soap_clr_a:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN9@soap_clr_a

; 7802 :       tp->visible = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax
	jmp	SHORT $LN2@soap_clr_a
$LN9@soap_clr_a:

; 7803 :   }
; 7804 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_clr_attr ENDP
_TEXT	ENDS
PUBLIC	_soap_store_lab
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_store_lab
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_store_lab PROC					; COMDAT

; 7872 : { soap->labidx = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0

; 7873 :   return soap_append_lab(soap, s, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 7874 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_store_lab ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_append_lab@@9@4JA		; `soap_append_lab'::`2'::__LINE__Var
PUBLIC	??_C@_0BA@MIAICPDK@?0?5new?5size?$DN?$CFlu?6?$AA@ ; `string'
PUBLIC	??_C@_0DJ@HKGHNJBJ@Enlarging?5look?9aside?5buffer?5to?5a@ ; `string'
;	COMDAT ?__LINE__Var@?1??soap_append_lab@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_append_lab@@9@4JA DD 01ecdH	; `soap_append_lab'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@MIAICPDK@?0?5new?5size?$DN?$CFlu?6?$AA@
CONST	SEGMENT
??_C@_0BA@MIAICPDK@?0?5new?5size?$DN?$CFlu?6?$AA@ DB ', new size=%lu', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HKGHNJBJ@Enlarging?5look?9aside?5buffer?5to?5a@
CONST	SEGMENT
??_C@_0DJ@HKGHNJBJ@Enlarging?5look?9aside?5buffer?5to?5a@ DB 'Enlarging l'
	DB	'ook-aside buffer to append data, old size=%lu', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_append_lab
_TEXT	SEGMENT
_fdebug$86505 = -32					; size = 4
_fdebug$86494 = -20					; size = 4
_t$86489 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_append_lab PROC					; COMDAT

; 7885 : { if (soap->labidx + n >= soap->lablen)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12464]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	ecx, DWORD PTR [edx+12460]
	jb	$LN14@soap_appen

; 7886 :   { register char *t = soap->labbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	mov	DWORD PTR _t$86489[ebp], ecx

; 7887 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enlarging look-aside buffer to append data, old size=%lu", (unsigned long)soap->lablen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN13@soap_appen
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN12@soap_appen
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN12@soap_appen:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN13@soap_appen
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86494[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	push	ecx
	push	OFFSET ??_C@_0DJ@HKGHNJBJ@Enlarging?5look?9aside?5buffer?5to?5a@
	mov	edx, DWORD PTR _fdebug$86494[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86494[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@soap_appen:

; 7888 :     if (soap->lablen == 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12460], 0
	jne	SHORT $LN9@soap_appen

; 7889 :       soap->lablen = SOAP_LABLEN;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12460], 256		; 00000100H
$LN9@soap_appen:

; 7890 :     while (soap->labidx + n >= soap->lablen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12464]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	ecx, DWORD PTR [edx+12460]
	jb	SHORT $LN8@soap_appen

; 7891 :       soap->lablen <<= 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	shl	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12460], ecx
	jmp	SHORT $LN9@soap_appen
$LN8@soap_appen:

; 7892 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, ", new size=%lu\n", (unsigned long)soap->lablen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_appen
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_appen
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_appen:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_appen
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86505[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	push	ecx
	push	OFFSET ??_C@_0BA@MIAICPDK@?0?5new?5size?$DN?$CFlu?6?$AA@
	mov	edx, DWORD PTR _fdebug$86505[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86505[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_appen:

; 7893 :     soap->labbuf = (char*)SOAP_MALLOC(soap, soap->lablen);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12460]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_append_lab@@9@4JA
	add	edx, 8
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12456], eax

; 7894 :     if (!soap->labbuf)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12456], 0
	jne	SHORT $LN4@soap_appen

; 7895 :     { if (t)

	cmp	DWORD PTR _t$86489[ebp], 0
	je	SHORT $LN3@soap_appen

; 7896 :         SOAP_FREE(soap, t);

	mov	eax, DWORD PTR _t$86489[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_append_lab@@9@4JA
	add	ecx, 11					; 0000000bH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN3@soap_appen:

; 7897 :       return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN15@soap_appen
$LN4@soap_appen:

; 7898 :     }
; 7899 :     if (t)

	cmp	DWORD PTR _t$86489[ebp], 0
	je	SHORT $LN14@soap_appen

; 7900 :     { memcpy(soap->labbuf, t, soap->labidx);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12464]
	push	ecx
	mov	edx, DWORD PTR _t$86489[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7901 :       SOAP_FREE(soap, t);

	mov	eax, DWORD PTR _t$86489[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_append_lab@@9@4JA
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN14@soap_appen:

; 7902 :     }
; 7903 :   }
; 7904 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_appen

; 7905 :   { memcpy(soap->labbuf + soap->labidx, s, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12456]
	mov	ecx, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR [ecx+12464]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7906 :     soap->labidx += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12464]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12464], ecx
$LN1@soap_appen:

; 7907 :   }
; 7908 :   return SOAP_OK;

	xor	eax, eax
$LN15@soap_appen:

; 7909 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_append_lab ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@ ; `string'
PUBLIC	??_C@_03GCDGINBO@ref?$AA@			; `string'
PUBLIC	??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@		; `string'
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	??_C@_08DJPLLOHP@xsi?3null?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??soap_peek_element@@9@4JA	; `soap_peek_element'::`2'::__LINE__Var
;	COMDAT ??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@
CONST	SEGMENT
??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@ DB 'http://'
	DB	'www.w3.org/2003/05/soap-envelope/role/next', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref?$AA@
CONST	SEGMENT
??_C@_03GCDGINBO@ref?$AA@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/actor/next', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@
CONST	SEGMENT
??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@ DB 'SOAP-ENC:root', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJPLLOHP@xsi?3null?$AA@
CONST	SEGMENT
??_C@_08DJPLLOHP@xsi?3null?$AA@ DB 'xsi:null', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_peek_element@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_peek_element@@9@4JA DD 01eefH	; `soap_peek_element'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_peek_element
_TEXT	SEGMENT
tv426 = -268						; size = 4
tv390 = -268						; size = 4
tv289 = -268						; size = 4
tv220 = -268						; size = 4
tv189 = -268						; size = 4
tv173 = -268						; size = 4
tv149 = -268						; size = 4
tv599 = -266						; size = 2
_i$ = -68						; size = 4
_c$ = -56						; size = 4
_s$ = -44						; size = 4
_t$ = -32						; size = 4
_tq$ = -20						; size = 4
_tp$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_peek_element PROC					; COMDAT

; 7919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7920 : #ifdef WITH_DOM
; 7921 :   register struct soap_dom_attribute **att = NULL;
; 7922 :   register char *lead = NULL;
; 7923 : #endif
; 7924 :   register struct soap_attribute *tp, *tq = NULL;

	mov	DWORD PTR _tq$[ebp], 0

; 7925 :   const char *t;
; 7926 :   register char *s;
; 7927 :   register soap_wchar c;
; 7928 :   register int i;
; 7929 :   if (soap->peeked)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87308]
	test	ecx, ecx
	je	SHORT $LN124@soap_peek_

; 7930 :   { if (!*soap->tag)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+80052]
	test	ecx, ecx
	jne	SHORT $LN123@soap_peek_

; 7931 :       return soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6
	mov	eax, 6
	jmp	$LN125@soap_peek_
$LN123@soap_peek_:

; 7932 :     return SOAP_OK;

	xor	eax, eax
	jmp	$LN125@soap_peek_
$LN124@soap_peek_:

; 7933 :   }
; 7934 :   soap->peeked = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax

; 7935 :   soap->id[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+81076], 0

; 7936 :   soap->href[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+82100], 0

; 7937 :   soap->type[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+83124], 0

; 7938 :   soap->arrayType[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+84148], 0

; 7939 :   soap->arraySize[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+85172], 0

; 7940 :   soap->arrayOffset[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+86196], 0

; 7941 :   soap->other = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87220], ax

; 7942 :   soap->root = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87288], ax

; 7943 :   soap->position = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax

; 7944 :   soap->null = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax

; 7945 :   soap->mustUnderstand = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax

; 7946 :   c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN122@soap_peek_:

; 7947 : #ifdef WITH_DOM
; 7948 :   /* whitespace leading to start tag is not insignificant for DOM */
; 7949 :   if (soap_blank(c))
; 7950 :   { soap->labidx = 0;
; 7951 :     do
; 7952 :     { if (soap_append_lab(soap, NULL, 0))
; 7953 :         return SOAP_EOM;
; 7954 :       s = soap->labbuf + soap->labidx;
; 7955 :       i = soap->lablen - soap->labidx;
; 7956 :       soap->labidx = soap->lablen;
; 7957 :       while (soap_blank(c) && i--)
; 7958 :       { *s++ = c;
; 7959 :         c = soap_getutf8(soap);
; 7960 :       }
; 7961 :     }
; 7962 :     while (soap_blank(c));
; 7963 :     *s = '\0';
; 7964 :     lead = soap_strdup(soap, soap->labbuf);
; 7965 :   }
; 7966 : #else
; 7967 :   while (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN121@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN121@soap_peek_

; 7968 :     c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN122@soap_peek_
$LN121@soap_peek_:

; 7969 : #endif
; 7970 :   if (c != SOAP_LT)

	cmp	DWORD PTR _c$[ebp], -2			; fffffffeH
	je	SHORT $LN120@soap_peek_

; 7971 :   { *soap->tag = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+80052], 0

; 7972 :     if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN119@soap_peek_

; 7973 :       return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN125@soap_peek_
$LN119@soap_peek_:

; 7974 :     soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 7975 : #ifdef WITH_DOM
; 7976 :     /* whitespace leading to end tag is not insignificant for DOM */
; 7977 :     if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7978 :       soap->dom->tail = soap_strdup(soap, lead);
; 7979 : #endif
; 7980 :     return soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6
	mov	eax, 6
	jmp	$LN125@soap_peek_
$LN120@soap_peek_:

; 7981 :   }
; 7982 :   s = soap->tag;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	mov	DWORD PTR _s$[ebp], eax
$LN118@soap_peek_:

; 7983 :   do c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN127@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN127@soap_peek_
	mov	DWORD PTR tv149[ebp], -1
	jmp	SHORT $LN128@soap_peek_
$LN127@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN128@soap_peek_:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 7984 :   while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN116@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN118@soap_peek_
$LN116@soap_peek_:

; 7985 :   i = sizeof(soap->tag);

	mov	DWORD PTR _i$[ebp], 1024		; 00000400H
$LN114@soap_peek_:

; 7986 :   while (c != '>' && c != '/' && soap_notblank(c) && (int)c != EOF)

	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN111@soap_peek_
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN111@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	$LN111@soap_peek_
	cmp	DWORD PTR _c$[ebp], -1
	je	$LN111@soap_peek_

; 7987 :   { if (--i > 0)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN112@soap_peek_

; 7988 :       *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN112@soap_peek_:

; 7989 :     c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN129@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN129@soap_peek_
	mov	DWORD PTR tv173[ebp], -1
	jmp	SHORT $LN130@soap_peek_
$LN129@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN130@soap_peek_:
	mov	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 7990 :   }

	jmp	$LN114@soap_peek_
$LN111@soap_peek_:

; 7991 :   while (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN110@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN110@soap_peek_

; 7992 :     c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN131@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN131@soap_peek_
	mov	DWORD PTR tv189[ebp], -1
	jmp	SHORT $LN132@soap_peek_
$LN131@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv189[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN132@soap_peek_:
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN111@soap_peek_
$LN110@soap_peek_:

; 7993 :   *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7994 : #ifdef WITH_DOM
; 7995 :   if (soap->mode & SOAP_XML_DOM)
; 7996 :   { register struct soap_dom_element *elt;
; 7997 :     elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
; 7998 :     if (!elt)
; 7999 :       return soap->error = SOAP_EOM;
; 8000 :     elt->next = NULL;
; 8001 :     elt->nstr = NULL;
; 8002 :     elt->name = soap_strdup(soap, soap->tag);
; 8003 :     elt->prnt = soap->dom;
; 8004 :     elt->elts = NULL;
; 8005 :     elt->atts = NULL;
; 8006 :     elt->data = NULL;
; 8007 :     elt->wide = NULL;
; 8008 :     elt->type = 0;
; 8009 :     elt->node = NULL;
; 8010 :     elt->head = lead;
; 8011 :     elt->tail = NULL;
; 8012 :     elt->soap = soap;
; 8013 :     if (soap->dom)
; 8014 :     { struct soap_dom_element *p = soap->dom->elts;
; 8015 :       if (p)
; 8016 :       { while (p->next)
; 8017 :           p = p->next;
; 8018 :         p->next = elt;
; 8019 :       }
; 8020 :       else
; 8021 :         soap->dom->elts = elt;
; 8022 :     }
; 8023 :     soap->dom = elt;
; 8024 :     att = &elt->atts;
; 8025 :   }
; 8026 : #endif
; 8027 :   soap_pop_namespace(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_pop_namespace
	add	esp, 4

; 8028 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN109@soap_peek_
$LN108@soap_peek_:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN109@soap_peek_:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN106@soap_peek_

; 8029 :     tp->visible = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax
	jmp	SHORT $LN108@soap_peek_
$LN106@soap_peek_:

; 8030 :   while ((int)c != EOF && c != '>' && c != '/')

	cmp	DWORD PTR _c$[ebp], -1
	je	$LN105@soap_peek_
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN105@soap_peek_
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN105@soap_peek_

; 8031 :   { s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$[ebp], eax

; 8032 :     i = sizeof(soap->tmpbuf);

	mov	DWORD PTR _i$[ebp], 1024		; 00000400H
$LN104@soap_peek_:

; 8033 :     while (c != '=' && c != '>' && c != '/' && soap_notblank(c) && (int)c != EOF)

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	je	$LN103@soap_peek_
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN103@soap_peek_
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN103@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	$LN103@soap_peek_
	cmp	DWORD PTR _c$[ebp], -1
	je	$LN103@soap_peek_

; 8034 :     { if (--i > 0)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN102@soap_peek_

; 8035 :         *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN102@soap_peek_:

; 8036 :       c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN133@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN133@soap_peek_
	mov	DWORD PTR tv220[ebp], -1
	jmp	SHORT $LN134@soap_peek_
$LN133@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv220[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN134@soap_peek_:
	mov	edx, DWORD PTR tv220[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 8037 :     }

	jmp	$LN104@soap_peek_
$LN103@soap_peek_:

; 8038 :     *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 8039 :     if (i == sizeof(soap->tmpbuf))

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN101@soap_peek_

; 8040 :       return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 5
	mov	eax, 5
	jmp	$LN125@soap_peek_
$LN101@soap_peek_:

; 8041 : #ifdef WITH_DOM
; 8042 :     /* add attribute name to dom */
; 8043 :     if (att)
; 8044 :     { *att = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 8045 :        if (!*att)
; 8046 :          return soap->error = SOAP_EOM;
; 8047 :        (*att)->next = NULL;
; 8048 :        (*att)->nstr = NULL;
; 8049 :        (*att)->name = soap_strdup(soap, soap->tmpbuf);
; 8050 :        (*att)->data = NULL;
; 8051 :        (*att)->wide = NULL;
; 8052 :        (*att)->soap = soap;
; 8053 :     }
; 8054 : #endif
; 8055 :     if (!strncmp(soap->tmpbuf, "xmlns", 5))

	mov	esi, esp
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN100@soap_peek_

; 8056 :     { if (soap->tmpbuf[5] == ':')

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+79033]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN99@soap_peek_

; 8057 :         t = soap->tmpbuf + 6;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79034				; 000134baH
	mov	DWORD PTR _t$[ebp], eax
	jmp	SHORT $LN98@soap_peek_
$LN99@soap_peek_:

; 8058 :       else if (soap->tmpbuf[5])

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+79033]
	test	ecx, ecx
	je	SHORT $LN97@soap_peek_

; 8059 :         t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 8060 :       else

	jmp	SHORT $LN98@soap_peek_
$LN97@soap_peek_:

; 8061 :         t = SOAP_STR_EOS;

	mov	DWORD PTR _t$[ebp], OFFSET _soap_padding
$LN98@soap_peek_:

; 8062 :     }
; 8063 :     else

	jmp	SHORT $LN95@soap_peek_
$LN100@soap_peek_:

; 8064 :       t = NULL;

	mov	DWORD PTR _t$[ebp], 0
$LN95@soap_peek_:

; 8065 :     tq = NULL;

	mov	DWORD PTR _tq$[ebp], 0

; 8066 :     for (tp = soap->attributes; tp; tq = tp, tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN94@soap_peek_
$LN93@soap_peek_:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _tq$[ebp], eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tp$[ebp], edx
$LN94@soap_peek_:
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN92@soap_peek_

; 8067 :     { if (!SOAP_STRCMP(tp->name, soap->tmpbuf))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN91@soap_peek_

; 8068 :         break;

	jmp	SHORT $LN92@soap_peek_
$LN91@soap_peek_:

; 8069 :     }

	jmp	SHORT $LN93@soap_peek_
$LN92@soap_peek_:

; 8070 :     if (!tp)

	cmp	DWORD PTR _tp$[ebp], 0
	jne	$LN86@soap_peek_

; 8071 :     { tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(soap->tmpbuf));

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_peek_element@@9@4JA
	add	ecx, 152				; 00000098H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tp$[ebp], eax

; 8072 :       if (!tp)

	cmp	DWORD PTR _tp$[ebp], 0
	jne	SHORT $LN89@soap_peek_

; 8073 :         return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN125@soap_peek_
$LN89@soap_peek_:

; 8074 :       strcpy(tp->name, soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	call	_strcpy
	add	esp, 8

; 8075 :       tp->value = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+4], 0

; 8076 :       tp->size = 0;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+8], 0

; 8077 :       /* if attribute name is qualified, append it to the end of the list */
; 8078 :       if (tq && strchr(soap->tmpbuf, ':'))

	cmp	DWORD PTR _tq$[ebp], 0
	je	SHORT $LN88@soap_peek_
	push	58					; 0000003aH
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN88@soap_peek_

; 8079 :       { tq->next = tp;

	mov	eax, DWORD PTR _tq$[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax], ecx

; 8080 :         tp->next = NULL;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax], 0

; 8081 :       }
; 8082 :       else

	jmp	SHORT $LN86@soap_peek_
$LN88@soap_peek_:

; 8083 :       { tp->next = soap->attributes;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+87292]
	mov	DWORD PTR [eax], edx

; 8084 :         soap->attributes = tp;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+87292], ecx
$LN86@soap_peek_:

; 8085 :       }
; 8086 :     }
; 8087 :     while (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN85@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN85@soap_peek_

; 8088 :       c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN135@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN135@soap_peek_
	mov	DWORD PTR tv289[ebp], -1
	jmp	SHORT $LN136@soap_peek_
$LN135@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv289[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN136@soap_peek_:
	mov	edx, DWORD PTR tv289[ebp]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN86@soap_peek_
$LN85@soap_peek_:

; 8089 :     if (c == '=')

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	jne	$LN84@soap_peek_
$LN83@soap_peek_:

; 8090 :     { do c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 8091 :       while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN81@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN83@soap_peek_
$LN81@soap_peek_:

; 8092 :       if (c != SOAP_QT && c != SOAP_AP)

	cmp	DWORD PTR _c$[ebp], -5			; fffffffbH
	je	SHORT $LN79@soap_peek_
	cmp	DWORD PTR _c$[ebp], -6			; fffffffaH
	je	SHORT $LN79@soap_peek_

; 8093 :       { soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 8094 :         c = ' '; /* blank delimiter */

	mov	DWORD PTR _c$[ebp], 32			; 00000020H
$LN79@soap_peek_:

; 8095 :       }
; 8096 :       if (soap_getattrval(soap, tp->value, tp->size, c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_getattrval
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN64@soap_peek_

; 8097 :       {
; 8098 : #ifdef WITH_FAST
; 8099 :         if (soap->error != SOAP_EOM)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 20		; 00000014H
	je	SHORT $LN77@soap_peek_

; 8100 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN125@soap_peek_
$LN77@soap_peek_:

; 8101 :         soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 8102 :         if (soap_store_lab(soap, tp->value, tp->size))

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_store_lab
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN76@soap_peek_

; 8103 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN125@soap_peek_
$LN76@soap_peek_:

; 8104 :         if (tp->value)

	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN74@soap_peek_

; 8105 :           SOAP_FREE(soap, tp->value);

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_peek_element@@9@4JA
	add	edx, 186				; 000000baH
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN74@soap_peek_:

; 8106 :         for (;;)
; 8107 :         { if (soap_getattrval(soap, soap->labbuf + soap->labidx, soap->lablen - soap->labidx, c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+12460]
	sub	eax, DWORD PTR [edx+12464]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12456]
	mov	eax, DWORD PTR _soap$[ebp]
	add	edx, DWORD PTR [eax+12464]
	push	edx
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getattrval
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN72@soap_peek_

; 8108 :           { if (soap->error != SOAP_EOM)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 20		; 00000014H
	je	SHORT $LN71@soap_peek_

; 8109 :               return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN125@soap_peek_
$LN71@soap_peek_:

; 8110 :             soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 8111 :             soap->labidx = soap->lablen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12460]
	mov	DWORD PTR [eax+12464], edx

; 8112 :             if (soap_append_lab(soap, NULL, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN70@soap_peek_

; 8113 :               return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN125@soap_peek_
$LN70@soap_peek_:

; 8114 :           }
; 8115 :           else

	jmp	SHORT $LN69@soap_peek_
$LN72@soap_peek_:

; 8116 :             break;

	jmp	SHORT $LN73@soap_peek_
$LN69@soap_peek_:

; 8117 :         }

	jmp	$LN74@soap_peek_
$LN73@soap_peek_:

; 8118 :         if (soap->labidx)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12464], 0
	je	SHORT $LN68@soap_peek_

; 8119 :           tp->size = soap->lablen;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12460]
	mov	DWORD PTR [eax+8], edx

; 8120 :         else

	jmp	SHORT $LN67@soap_peek_
$LN68@soap_peek_:

; 8121 :         { tp->size = strlen(soap->labbuf) + 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	edx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [edx+8], eax

; 8122 :           if (tp->size < SOAP_LABLEN)

	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+8], 256			; 00000100H
	jae	SHORT $LN67@soap_peek_

; 8123 :             tp->size = SOAP_LABLEN;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+8], 256			; 00000100H
$LN67@soap_peek_:

; 8124 :         }
; 8125 :         if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_peek_element@@9@4JA
	add	edx, 206				; 000000ceH
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN65@soap_peek_

; 8126 :           return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN125@soap_peek_
$LN65@soap_peek_:

; 8127 :         strcpy(tp->value, soap->labbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	mov	edx, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8
$LN64@soap_peek_:

; 8128 : #else
; 8129 :         size_t n;
; 8130 :         if (soap->error != SOAP_EOM)
; 8131 :           return soap->error;
; 8132 :         soap->error = SOAP_OK;
; 8133 :         if (soap_new_block(soap))
; 8134 :           return soap->error;
; 8135 :         for (;;)
; 8136 :         { if (!(s = (char*)soap_push_block(soap, SOAP_BLKLEN)))
; 8137 :             return soap->error;
; 8138 :           if (soap_getattrval(soap, s, SOAP_BLKLEN, c))
; 8139 :           { if (soap->error != SOAP_EOM)
; 8140 :               return soap->error;
; 8141 :             soap->error = SOAP_OK;
; 8142 :           }
; 8143 :           else
; 8144 :             break;
; 8145 :         }
; 8146 :         n = tp->size + soap->blist->size;
; 8147 :         if (!(s = (char*)SOAP_MALLOC(soap, n)))
; 8148 :           return soap->error = SOAP_EOM;
; 8149 :         if (tp->value)
; 8150 :         { memcpy(s, tp->value, tp->size);
; 8151 :           SOAP_FREE(soap, tp->value);
; 8152 :         }
; 8153 :         soap_save_block(soap, s + tp->size, 0);
; 8154 :         tp->value = s;
; 8155 :         tp->size = n;
; 8156 : #endif
; 8157 :       }
; 8158 :       do c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN137@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN137@soap_peek_
	mov	DWORD PTR tv390[ebp], -1
	jmp	SHORT $LN138@soap_peek_
$LN137@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv390[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN138@soap_peek_:
	mov	edx, DWORD PTR tv390[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 8159 :       while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN62@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN64@soap_peek_
$LN62@soap_peek_:

; 8160 :       tp->visible = 2; /* seen this attribute w/ value */

	mov	eax, 2
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax

; 8161 : #ifdef WITH_DOM
; 8162 :       if (att)
; 8163 :         (*att)->data = soap_strdup(soap, tp->value);
; 8164 : #endif
; 8165 :     }
; 8166 :     else

	jmp	SHORT $LN60@soap_peek_
$LN84@soap_peek_:

; 8167 :       tp->visible = 1; /* seen this attribute w/o value */

	mov	eax, 1
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	WORD PTR [ecx+16], ax
$LN60@soap_peek_:

; 8168 : #ifdef WITH_DOM
; 8169 :     if (att)
; 8170 :       att = &(*att)->next;
; 8171 : #endif
; 8172 :     if (t && tp->value)

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN59@soap_peek_
	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN59@soap_peek_

; 8173 :     { if (soap_push_namespace(soap, t, tp->value))

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_push_namespace
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN59@soap_peek_

; 8174 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN125@soap_peek_
$LN59@soap_peek_:

; 8175 :     }
; 8176 :   }

	jmp	$LN106@soap_peek_
$LN105@soap_peek_:

; 8177 : #ifdef WITH_DOM
; 8178 :   if (att)
; 8179 :   { soap->dom->nstr = soap_current_namespace(soap, soap->tag);
; 8180 :     for (att = &soap->dom->atts; *att; att = &(*att)->next)
; 8181 :       (*att)->nstr = soap_current_namespace(soap, (*att)->name);
; 8182 :   }
; 8183 : #endif
; 8184 :   if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN57@soap_peek_

; 8185 :     return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN125@soap_peek_
$LN57@soap_peek_:

; 8186 :   if (!(soap->body = (c != '/')))

	xor	eax, eax
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	setne	al
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12442], ax
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+12442]
	test	eax, eax
	jne	SHORT $LN56@soap_peek_
$LN55@soap_peek_:

; 8187 :     do c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN139@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN139@soap_peek_
	mov	DWORD PTR tv426[ebp], -1
	jmp	SHORT $LN140@soap_peek_
$LN139@soap_peek_:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv426[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN140@soap_peek_:
	mov	edx, DWORD PTR tv426[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 8188 :     while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN56@soap_peek_
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN55@soap_peek_
$LN56@soap_peek_:

; 8189 : #ifdef WITH_DOM
; 8190 :   if (soap->mode & SOAP_XML_DOM)
; 8191 :   { if (!soap->body && soap->dom->prnt)
; 8192 :       soap->dom = soap->dom->prnt;
; 8193 :   }
; 8194 : #endif
; 8195 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$[ebp], ecx
	jmp	SHORT $LN51@soap_peek_
$LN50@soap_peek_:
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$[ebp], ecx
$LN51@soap_peek_:
	cmp	DWORD PTR _tp$[ebp], 0
	je	$LN49@soap_peek_

; 8196 :   { if (tp->visible && tp->value)

	mov	eax, DWORD PTR _tp$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	$LN48@soap_peek_
	mov	eax, DWORD PTR _tp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN48@soap_peek_

; 8197 :     {
; 8198 : #ifndef WITH_NOIDREF
; 8199 :       if (!strcmp(tp->name, "id"))

	push	OFFSET ??_C@_02EGCJHIOB@id?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@soap_peek_

; 8200 :       { if ((soap->version > 0 && !(soap->mode & SOAP_XML_TREE))
; 8201 :          || (soap->mode & SOAP_XML_GRAPH))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	test	ecx, ecx
	jle	SHORT $LN44@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN45@soap_peek_
$LN44@soap_peek_:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN46@soap_peek_
$LN45@soap_peek_:

; 8202 :         { *soap->id = '#';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+81076], 35		; 00000023H

; 8203 :           strncpy(soap->id + 1, tp->value, sizeof(soap->id) - 2);

	mov	esi, esp
	push	1022					; 000003feH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81077				; 00013cb5H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8204 :           soap->id[sizeof(soap->id)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+82099], 0
$LN46@soap_peek_:

; 8205 :         }
; 8206 :       }

	jmp	$LN48@soap_peek_
$LN47@soap_peek_:

; 8207 :       else if (!strcmp(tp->name, "href"))

	push	OFFSET ??_C@_04CMBCJJJD@href?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@soap_peek_

; 8208 :       { if (soap->version == 1
; 8209 :          || (soap->mode & SOAP_XML_GRAPH)
; 8210 :          || (soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	je	SHORT $LN40@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65536				; 00010000H
	jne	SHORT $LN40@soap_peek_
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN41@soap_peek_
$LN40@soap_peek_:

; 8211 :         { strncpy(soap->href, tp->value, sizeof(soap->href) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8212 :           soap->href[sizeof(soap->href)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+83123], 0
$LN41@soap_peek_:

; 8213 :         }
; 8214 :       }
; 8215 :       else

	jmp	$LN48@soap_peek_
$LN42@soap_peek_:

; 8216 : #endif
; 8217 :       if (!soap_match_tag(soap, tp->name, "xsi:type"))

	push	OFFSET ??_C@_08JNIDGPLJ@xsi?3type?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN38@soap_peek_

; 8218 :       { strncpy(soap->type, tp->value, sizeof(soap->type) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 83124				; 000144b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8219 :         soap->type[sizeof(soap->type)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+84147], 0

; 8220 :       }
; 8221 :       else if ((!soap_match_tag(soap, tp->name, "xsi:null")

	jmp	$LN48@soap_peek_
$LN38@soap_peek_:

; 8222 :              || !soap_match_tag(soap, tp->name, "xsi:nil"))
; 8223 :             && (!strcmp(tp->value, "1")
; 8224 :              || !strcmp(tp->value, "true")))

	push	OFFSET ??_C@_08DJPLLOHP@xsi?3null?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN35@soap_peek_
	push	OFFSET ??_C@_07KJDFMKIE@xsi?3nil?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN36@soap_peek_
$LN35@soap_peek_:
	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@soap_peek_
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@soap_peek_
$LN34@soap_peek_:

; 8225 :       { soap->null = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87300], ax
	jmp	$LN48@soap_peek_
$LN36@soap_peek_:

; 8226 :       }
; 8227 :       else if (soap->version == 1)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	jne	$LN32@soap_peek_

; 8228 :       { if (!soap_match_tag(soap, tp->name, "SOAP-ENC:arrayType"))

	push	OFFSET ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN31@soap_peek_

; 8229 :         { s = soap_strrchr(tp->value, '[');

	push	91					; 0000005bH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 8230 :           if (s && (size_t)(s - tp->value) < sizeof(soap->arrayType))

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN30@soap_peek_
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	cmp	ecx, 1024				; 00000400H
	jae	SHORT $LN30@soap_peek_

; 8231 :           { strncpy(soap->arrayType, tp->value, s - tp->value);

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 84148				; 000148b4H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8232 :             soap->arrayType[s - tp->value] = '\0';

	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [edx+ecx+84148], 0

; 8233 :             strncpy(soap->arraySize, s, sizeof(soap->arraySize) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 85172				; 00014cb4H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8234 :           }
; 8235 :           else

	jmp	SHORT $LN29@soap_peek_
$LN30@soap_peek_:

; 8236 :             strncpy(soap->arrayType, tp->value, sizeof(soap->arrayType) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 84148				; 000148b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@soap_peek_:

; 8237 :           soap->arraySize[sizeof(soap->arrayType)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+86195], 0

; 8238 :           soap->arrayType[sizeof(soap->arrayType)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+85171], 0
	jmp	$LN28@soap_peek_
$LN31@soap_peek_:

; 8239 :         }
; 8240 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:offset"))

	push	OFFSET ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@soap_peek_

; 8241 :           strncpy(soap->arrayOffset, tp->value, sizeof(soap->arrayOffset));

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 86196				; 000150b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN28@soap_peek_
$LN27@soap_peek_:

; 8242 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:position"))

	push	OFFSET ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@soap_peek_

; 8243 :           soap->position = soap_getposition(tp->value, soap->positions);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87224				; 000154b8H
	push	eax
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_soap_getposition
	add	esp, 8
	mov	ecx, eax
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87222], ax
	jmp	$LN28@soap_peek_
$LN25@soap_peek_:

; 8244 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:root"))

	push	OFFSET ??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@soap_peek_

; 8245 :           soap->root = ((!strcmp(tp->value, "1") || !strcmp(tp->value, "true")));

	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN141@soap_peek_
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	edx, DWORD PTR _tp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN141@soap_peek_
	xor	ecx, ecx
	mov	WORD PTR tv599[ebp], cx
	jmp	SHORT $LN142@soap_peek_
$LN141@soap_peek_:
	mov	edx, 1
	mov	WORD PTR tv599[ebp], dx
$LN142@soap_peek_:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	cx, WORD PTR tv599[ebp]
	mov	WORD PTR [eax+87288], cx

; 8246 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand")

	jmp	$LN28@soap_peek_
$LN23@soap_peek_:

; 8247 :               && (!strcmp(tp->value, "1") || !strcmp(tp->value, "true")))

	push	OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@soap_peek_
	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@soap_peek_
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@soap_peek_
$LN20@soap_peek_:

; 8248 :           soap->mustUnderstand = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax
	jmp	SHORT $LN28@soap_peek_
$LN21@soap_peek_:

; 8249 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:actor"))

	push	OFFSET ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@soap_peek_

; 8250 :         { if ((!soap->actor || strcmp(soap->actor, tp->value))
; 8251 :            && strcmp(tp->value, "http://schemas.xmlsoap.org/soap/actor/next"))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN16@soap_peek_
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@soap_peek_
$LN16@soap_peek_:
	push	OFFSET ??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@soap_peek_

; 8252 :             soap->other = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87220], ax
$LN28@soap_peek_:

; 8253 :         }
; 8254 :       }

	jmp	$LN48@soap_peek_
$LN32@soap_peek_:

; 8255 :       else if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	$LN48@soap_peek_

; 8256 :       {
; 8257 : #ifndef WITH_NOIDREF
; 8258 :         if (!strcmp(tp->name, "ref")
; 8259 :          || !soap_match_tag(soap, tp->name, "SOAP-ENC:ref"))

	push	OFFSET ??_C@_03GCDGINBO@ref?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@soap_peek_
	push	OFFSET ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@soap_peek_
$LN12@soap_peek_:

; 8260 :         { *soap->href = '#';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+82100], 35		; 00000023H

; 8261 :           strncpy(soap->href + 1, tp->value, sizeof(soap->href) - 2);

	mov	esi, esp
	push	1022					; 000003feH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82101				; 000140b5H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8262 :           soap->href[sizeof(soap->href)-1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+83123], 0

; 8263 :         }
; 8264 :         else

	jmp	$LN48@soap_peek_
$LN13@soap_peek_:

; 8265 : #endif
; 8266 : 	if (!soap_match_tag(soap, tp->name, "SOAP-ENC:itemType"))

	push	OFFSET ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@soap_peek_

; 8267 :           strncpy(soap->arrayType, tp->value, sizeof(soap->arrayType) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 84148				; 000148b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN48@soap_peek_
$LN10@soap_peek_:

; 8268 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:arraySize"))

	push	OFFSET ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@soap_peek_

; 8269 :           strncpy(soap->arraySize, tp->value, sizeof(soap->arraySize) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 85172				; 00014cb4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8270 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand")

	jmp	$LN48@soap_peek_
$LN8@soap_peek_:

; 8271 :               && (!strcmp(tp->value, "1") || !strcmp(tp->value, "true")))

	push	OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_peek_
	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_peek_
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_peek_
$LN5@soap_peek_:

; 8272 :           soap->mustUnderstand = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87298], ax
	jmp	SHORT $LN48@soap_peek_
$LN6@soap_peek_:

; 8273 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:role"))

	push	OFFSET ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
	mov	eax, DWORD PTR _tp$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN48@soap_peek_

; 8274 :         { if ((!soap->actor || strcmp(soap->actor, tp->value))
; 8275 :            && strcmp(tp->value, "http://www.w3.org/2003/05/soap-envelope/role/next"))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN1@soap_peek_
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@soap_peek_
$LN1@soap_peek_:
	push	OFFSET ??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@
	mov	eax, DWORD PTR _tp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@soap_peek_

; 8276 :             soap->other = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87220], ax
$LN48@soap_peek_:

; 8277 :         }
; 8278 :       }
; 8279 :     }
; 8280 :   }

	jmp	$LN50@soap_peek_
$LN49@soap_peek_:

; 8281 :   return soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
	xor	eax, eax
$LN125@soap_peek_:

; 8282 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_peek_element ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\string.h
_TEXT	ENDS
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 188  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
_TEXT	ENDS
;	COMDAT _soap_getattrval
_TEXT	SEGMENT
tv68 = -220						; size = 4
_c$86454 = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_d$ = 20						; size = 4
_soap_getattrval PROC					; COMDAT

; 7811 : { register size_t i;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 7812 :   for (i = 0; i < n; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@soap_getat
$LN16@soap_getat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@soap_getat:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jae	$LN15@soap_getat

; 7813 :   { register soap_wchar c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$86454[ebp], eax

; 7814 :     switch (c)

	mov	eax, DWORD PTR _c$86454[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	add	ecx, 6
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 53			; 00000035H
	ja	$LN2@soap_getat
	mov	edx, DWORD PTR tv68[ebp]
	movzx	eax, BYTE PTR $LN20@soap_getat[edx]
	jmp	DWORD PTR $LN21@soap_getat[eax*4]
$LN12@soap_getat:

; 7815 :     {
; 7816 :     case SOAP_TT:
; 7817 :       *s++ = '<';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 7818 :       soap_unget(soap, '/');

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 47		; 0000002fH

; 7819 :       break;

	jmp	$LN13@soap_getat
$LN11@soap_getat:

; 7820 :     case SOAP_LT:
; 7821 :       *s++ = '<';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 7822 :       break;

	jmp	$LN13@soap_getat
$LN10@soap_getat:

; 7823 :     case SOAP_GT:
; 7824 :       if (d == ' ')

	cmp	DWORD PTR _d$[ebp], 32			; 00000020H
	jne	SHORT $LN9@soap_getat

; 7825 :       { soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$86454[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 7826 :         *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7827 :         return SOAP_OK;

	xor	eax, eax
	jmp	$LN18@soap_getat
$LN9@soap_getat:

; 7828 :       }
; 7829 :       *s++ = '>';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 62			; 0000003eH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 7830 :       break;

	jmp	$LN13@soap_getat
$LN8@soap_getat:

; 7831 :     case SOAP_QT:
; 7832 :       if (c == d)

	mov	eax, DWORD PTR _c$86454[ebp]
	cmp	eax, DWORD PTR _d$[ebp]
	jne	SHORT $LN7@soap_getat

; 7833 :       { *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7834 :         return SOAP_OK;

	xor	eax, eax
	jmp	$LN18@soap_getat
$LN7@soap_getat:

; 7835 :       }
; 7836 :       *s++ = '"';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 7837 :       break;

	jmp	SHORT $LN13@soap_getat
$LN6@soap_getat:

; 7838 :     case SOAP_AP:
; 7839 :       if (c == d)

	mov	eax, DWORD PTR _c$86454[ebp]
	cmp	eax, DWORD PTR _d$[ebp]
	jne	SHORT $LN5@soap_getat

; 7840 :       { *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7841 :         return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN18@soap_getat
$LN5@soap_getat:

; 7842 :       }
; 7843 :       *s++ = '\'';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 39			; 00000027H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 7844 :       break;

	jmp	SHORT $LN13@soap_getat
$LN4@soap_getat:

; 7845 :     case '\t':
; 7846 :     case '\n':
; 7847 :     case '\r':
; 7848 :     case ' ':
; 7849 :     case '/':
; 7850 :       if (d == ' ')

	cmp	DWORD PTR _d$[ebp], 32			; 00000020H
	jne	SHORT $LN2@soap_getat

; 7851 :       { soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$86454[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 7852 :         *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 7853 :         return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN18@soap_getat
$LN2@soap_getat:

; 7854 :       }
; 7855 :     default:
; 7856 :       if ((int)c == EOF)

	cmp	DWORD PTR _c$86454[ebp], -1
	jne	SHORT $LN1@soap_getat

; 7857 :         return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	SHORT $LN18@soap_getat
$LN1@soap_getat:

; 7858 :       *s++ = (char)c;

	mov	ecx, DWORD PTR _c$86454[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN13@soap_getat:

; 7859 :     }
; 7860 :   }

	jmp	$LN16@soap_getat
$LN15@soap_getat:

; 7861 :   return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
$LN18@soap_getat:

; 7862 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN21@soap_getat:
	DD	$LN6@soap_getat
	DD	$LN8@soap_getat
	DD	$LN10@soap_getat
	DD	$LN12@soap_getat
	DD	$LN11@soap_getat
	DD	$LN4@soap_getat
	DD	$LN2@soap_getat
$LN20@soap_getat:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	5
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_soap_getattrval ENDP
_TEXT	ENDS
PUBLIC	_soap_revert
PUBLIC	_soap_retry
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_retry
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_retry PROC					; COMDAT

; 8291 : { soap->error = SOAP_OK;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 8292 :   soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 8293 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_retry ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FPHNKLL@Reverting?5last?5element?5?$CIlevel?$DN?$CFu@ ; `string'
;	COMDAT ??_C@_0CD@FPHNKLL@Reverting?5last?5element?5?$CIlevel?$DN?$CFu@
CONST	SEGMENT
??_C@_0CD@FPHNKLL@Reverting?5last?5element?5?$CIlevel?$DN?$CFu@ DB 'Rever'
	DB	'ting last element (level=%u)', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_revert
_TEXT	SEGMENT
_fdebug$86693 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_revert PROC					; COMDAT

; 8302 : { if (!soap->peeked)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87308]
	test	ecx, ecx
	jne	SHORT $LN5@soap_rever

; 8303 :   { soap->peeked = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax

; 8304 :     if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN5@soap_rever

; 8305 :       soap->level--;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	sub	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12444], ecx
$LN5@soap_rever:

; 8306 :   }
; 8307 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reverting last element (level=%u)\n", soap->level));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_rever
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_rever
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_rever:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_rever
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86693[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12444]
	push	ecx
	push	OFFSET ??_C@_0CD@FPHNKLL@Reverting?5last?5element?5?$CIlevel?$DN?$CFu@
	mov	edx, DWORD PTR _fdebug$86693[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86693[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_rever:

; 8308 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_revert ENDP
_TEXT	ENDS
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@		; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@		; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@		; `string'
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL?$AA@		; `string'
PUBLIC	??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@		; `string'
PUBLIC	??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@		; `string'
PUBLIC	??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@		; `string'
EXTRN	__imp__mbtowc:PROC
EXTRN	__imp_____mb_cur_max_func:PROC
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@ DB '&quot;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@ DB '&lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL?$AA@ DB '&amp;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@
CONST	SEGMENT
??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@ DB '&#xD;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@
CONST	SEGMENT
??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@ DB '&#xA;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@
CONST	SEGMENT
??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@ DB '&#x9;', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_string_out
_TEXT	SEGMENT
tv71 = -256						; size = 4
tv69 = -256						; size = 4
_m$86747 = -56						; size = 4
_wc$86746 = -44						; size = 2
_mask$ = -32						; size = 4
_c$ = -20						; size = 4
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_flag$ = 16						; size = 4
_soap_string_out PROC					; COMDAT

; 8317 : { register const char *t;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8318 :   register soap_wchar c;
; 8319 :   register soap_wchar mask = 0xFFFFFF80UL;

	mov	DWORD PTR _mask$[ebp], -128		; ffffff80H

; 8320 : #ifdef WITH_DOM
; 8321 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8322 :   { soap->dom->data = soap_strdup(soap, s);
; 8323 :     return SOAP_OK;
; 8324 :   }
; 8325 : #endif
; 8326 :   if (soap->mode & SOAP_C_UTFSTRING)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2097152				; 00200000H
	je	SHORT $LN40@soap_strin

; 8327 :     mask = 0;

	mov	DWORD PTR _mask$[ebp], 0
$LN40@soap_strin:

; 8328 :   t = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _t$[ebp], eax
$LN39@soap_strin:

; 8329 :   while ((c = *t++))

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	$LN38@soap_strin

; 8330 :   { switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR tv71[ebp]
	sub	ecx, 9
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 53			; 00000035H
	ja	$LN9@soap_strin
	mov	edx, DWORD PTR tv71[ebp]
	movzx	eax, BYTE PTR $LN44@soap_strin[edx]
	jmp	DWORD PTR $LN48@soap_strin[eax*4]
$LN35@soap_strin:

; 8331 :     {
; 8332 :     case 0x09:
; 8333 :       if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN34@soap_strin

; 8334 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#x9;", 5))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@soap_strin
	push	5
	push	OFFSET ??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN33@soap_strin
$LN32@soap_strin:

; 8335 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN33@soap_strin:

; 8336 :         s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN34@soap_strin:

; 8337 :       }
; 8338 :       break;

	jmp	$LN36@soap_strin
$LN31@soap_strin:

; 8339 :     case 0x0A:
; 8340 :       if (flag || !(soap->mode & SOAP_XML_CANONICAL))

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $LN29@soap_strin
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	jne	SHORT $LN30@soap_strin
$LN29@soap_strin:

; 8341 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#xA;", 5))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@soap_strin
	push	5
	push	OFFSET ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN28@soap_strin
$LN27@soap_strin:

; 8342 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN28@soap_strin:

; 8343 :         s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN30@soap_strin:

; 8344 :       }
; 8345 :       break;

	jmp	$LN36@soap_strin
$LN26@soap_strin:

; 8346 :     case 0x0D:
; 8347 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#xD;", 5))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@soap_strin
	push	5
	push	OFFSET ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@soap_strin
$LN24@soap_strin:

; 8348 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN25@soap_strin:

; 8349 :       s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 8350 :       break;

	jmp	$LN36@soap_strin
$LN23@soap_strin:

; 8351 :     case '&':
; 8352 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&amp;", 5))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@soap_strin
	push	5
	push	OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN22@soap_strin
$LN21@soap_strin:

; 8353 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN22@soap_strin:

; 8354 :       s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 8355 :       break;

	jmp	$LN36@soap_strin
$LN20@soap_strin:

; 8356 :     case '<':
; 8357 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&lt;", 4))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@soap_strin
	push	4
	push	OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@soap_strin
$LN18@soap_strin:

; 8358 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN19@soap_strin:

; 8359 :       s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 8360 :       break;

	jmp	$LN36@soap_strin
$LN17@soap_strin:

; 8361 :     case '>':
; 8362 :       if (!flag)

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $LN16@soap_strin

; 8363 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&gt;", 4))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@soap_strin
	push	4
	push	OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@soap_strin
$LN14@soap_strin:

; 8364 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN15@soap_strin:

; 8365 :         s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN16@soap_strin:

; 8366 :       }
; 8367 :       break;

	jmp	$LN36@soap_strin
$LN13@soap_strin:

; 8368 :     case '"':
; 8369 :       if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN12@soap_strin

; 8370 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&quot;", 6))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@soap_strin
	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@soap_strin
$LN10@soap_strin:

; 8371 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN11@soap_strin:

; 8372 :         s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN12@soap_strin:

; 8373 :       }
; 8374 :       break;

	jmp	$LN36@soap_strin
$LN9@soap_strin:

; 8375 :     default:
; 8376 : #ifndef WITH_LEANER
; 8377 : #ifdef HAVE_MBTOWC
; 8378 :       if (soap->mode & SOAP_C_MBSTRING)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4194304				; 00400000H
	je	$LN8@soap_strin

; 8379 :       { wchar_t wc;
; 8380 :         register int m = mbtowc(&wc, t - 1, MB_CUR_MAX);

	mov	esi, esp
	call	DWORD PTR __imp_____mb_cur_max_func
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR _wc$86746[ebp]
	push	ecx
	call	DWORD PTR __imp__mbtowc
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _m$86747[ebp], eax

; 8381 :         if (m > 0 && wc != c)

	cmp	DWORD PTR _m$86747[ebp], 0
	jle	SHORT $LN8@soap_strin
	movzx	eax, WORD PTR _wc$86746[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	je	SHORT $LN8@soap_strin

; 8382 :         { if (soap_send_raw(soap, s, t - s - 1) || soap_pututf8(soap, wc))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@soap_strin
	movzx	eax, WORD PTR _wc$86746[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_pututf8
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_strin
$LN5@soap_strin:

; 8383 :             return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN41@soap_strin
$LN6@soap_strin:

; 8384 :           s = t += m - 1;

	mov	eax, DWORD PTR _m$86747[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _t$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 8385 :           continue;

	jmp	$LN39@soap_strin
$LN8@soap_strin:

; 8386 :         }
; 8387 :       }
; 8388 : #endif
; 8389 : #endif
; 8390 : #ifndef WITH_NOSTRINGTOUTF8
; 8391 :       if ((c & mask) || !(c & 0xFFFFFFE0UL))

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	jne	SHORT $LN3@soap_strin
	mov	eax, DWORD PTR _c$[ebp]
	and	eax, -32				; ffffffe0H
	jne	SHORT $LN36@soap_strin
$LN3@soap_strin:

; 8392 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_pututf8(soap, (unsigned char)c))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_strin
	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_pututf8
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_strin
$LN1@soap_strin:

; 8393 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN41@soap_strin
$LN2@soap_strin:

; 8394 :         s = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN36@soap_strin:

; 8395 :       }
; 8396 : #endif
; 8397 :     }
; 8398 :   }

	jmp	$LN39@soap_strin
$LN38@soap_strin:

; 8399 :   return soap_send_raw(soap, s, t - s - 1);

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN41@soap_strin:

; 8400 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN47@soap_strin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN47@soap_strin:
	DD	1
	DD	$LN46@soap_strin
$LN46@soap_strin:
	DD	-44					; ffffffd4H
	DD	2
	DD	$LN45@soap_strin
$LN45@soap_strin:
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	0
	npad	1
$LN48@soap_strin:
	DD	$LN35@soap_strin
	DD	$LN31@soap_strin
	DD	$LN26@soap_strin
	DD	$LN13@soap_strin
	DD	$LN23@soap_strin
	DD	$LN20@soap_strin
	DD	$LN17@soap_strin
	DD	$LN9@soap_strin
$LN44@soap_strin:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	6
_soap_string_out ENDP
_TEXT	ENDS
PUBLIC	_soap_s2QName
PUBLIC	??_C@_0CJ@NGPFFPKN@String?5too?5short?3?5?$CFld?5chars?0?5min@ ; `string'
PUBLIC	??_C@_0BN@MDNBDPGN@String?5too?5long?3?5maxlen?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_05HNAHLMAI@apos?$DL?$AA@			; `string'
PUBLIC	??_C@_05LDHOCHGG@quot?$DL?$AA@			; `string'
PUBLIC	??_C@_04DMIAPOKJ@amp?$DL?$AA@			; `string'
PUBLIC	??_C@_03BHAAMAON@gt?$DL?$AA@			; `string'
PUBLIC	??_C@_03MAABEHOM@lt?$DL?$AA@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0BI@GPIPPNHJ@Reading?5string?5content?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_string_in
EXTRN	__imp__wctomb:PROC
;	COMDAT ??_C@_0CJ@NGPFFPKN@String?5too?5short?3?5?$CFld?5chars?0?5min@
CONST	SEGMENT
??_C@_0CJ@NGPFFPKN@String?5too?5short?3?5?$CFld?5chars?0?5min@ DB 'String'
	DB	' too short: %ld chars, minlen=%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDNBDPGN@String?5too?5long?3?5maxlen?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDNBDPGN@String?5too?5long?3?5maxlen?$DN?$CFld?6?$AA@ DB 'Strin'
	DB	'g too long: maxlen=%ld', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNAHLMAI@apos?$DL?$AA@
CONST	SEGMENT
??_C@_05HNAHLMAI@apos?$DL?$AA@ DB 'apos;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDHOCHGG@quot?$DL?$AA@
CONST	SEGMENT
??_C@_05LDHOCHGG@quot?$DL?$AA@ DB 'quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMIAPOKJ@amp?$DL?$AA@
CONST	SEGMENT
??_C@_04DMIAPOKJ@amp?$DL?$AA@ DB 'amp;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHAAMAON@gt?$DL?$AA@
CONST	SEGMENT
??_C@_03BHAAMAON@gt?$DL?$AA@ DB 'gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAABEHOM@lt?$DL?$AA@
CONST	SEGMENT
??_C@_03MAABEHOM@lt?$DL?$AA@ DB 'lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPIPPNHJ@Reading?5string?5content?6?$AA@
CONST	SEGMENT
??_C@_0BI@GPIPPNHJ@Reading?5string?5content?6?$AA@ DB 'Reading string con'
	DB	'tent', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_string_in
_TEXT	SEGMENT
tv256 = -360						; size = 4
_fdebug$86895 = -160					; size = 4
_fdebug$86888 = -148					; size = 4
_k$86791 = -136						; size = 4
_tp$86779 = -124					; size = 4
_fdebug$86774 = -112					; size = 4
_buf$ = -100						; size = 8
_c$ = -84						; size = 4
_m$ = -72						; size = 4
_n$ = -60						; size = 4
_l$ = -48						; size = 4
_i$ = -36						; size = 4
_t$ = -24						; size = 4
_s$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_flag$ = 12						; size = 4
_minlen$ = 16						; size = 4
_maxlen$ = 20						; size = 4
_soap_string_in PROC					; COMDAT

; 8409 : { register char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-360]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8410 :   char *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 8411 :   register size_t i;
; 8412 :   register long l = 0;

	mov	DWORD PTR _l$[ebp], 0

; 8413 :   register int n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 8414 :   register int m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 8415 :   register soap_wchar c;
; 8416 : #if !defined(WITH_LEANER) && defined(HAVE_WCTOMB)
; 8417 :   char buf[MB_LEN_MAX > 8 ? MB_LEN_MAX : 8];
; 8418 : #else
; 8419 :   char buf[8];
; 8420 : #endif
; 8421 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Reading string content\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN75@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN74@soap_strin@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN74@soap_strin@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN75@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86774[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@GPIPPNHJ@Reading?5string?5content?6?$AA@
	mov	eax, DWORD PTR _fdebug$86774[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86774[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN75@soap_strin@2:

; 8422 :   if (soap->peeked)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87308]
	test	ecx, ecx
	je	$LN72@soap_strin@2

; 8423 :   { if (!soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	jne	SHORT $LN71@soap_strin@2

; 8424 :       return NULL;

	xor	eax, eax
	jmp	$LN76@soap_strin@2
$LN71@soap_strin@2:

; 8425 :     if (*soap->tag)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+80052]
	test	ecx, ecx
	je	$LN72@soap_strin@2

; 8426 :     {
; 8427 : #ifndef WITH_LEAN
; 8428 :       struct soap_attribute *tp;
; 8429 :       t = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _t$[ebp], eax

; 8430 :       *t = '<';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH

; 8431 :       t[sizeof(soap->tmpbuf)-1] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax+1023], 0

; 8432 :       strncpy(t + 1, soap->tag, sizeof(soap->tmpbuf) - 2);

	mov	esi, esp
	push	1022					; 000003feH
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8433 :       t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8434 :       for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$86779[ebp], ecx
	jmp	SHORT $LN69@soap_strin@2
$LN68@soap_strin@2:
	mov	eax, DWORD PTR _tp$86779[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$86779[ebp], ecx
$LN69@soap_strin@2:
	cmp	DWORD PTR _tp$86779[ebp], 0
	je	$LN67@soap_strin@2

; 8435 :       { if (tp->visible)

	mov	eax, DWORD PTR _tp$86779[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	$LN66@soap_strin@2

; 8436 :         { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80050				; 000138b2H
	cmp	DWORD PTR _t$[ebp], eax
	jb	SHORT $LN65@soap_strin@2

; 8437 :             break;

	jmp	$LN67@soap_strin@2
$LN65@soap_strin@2:

; 8438 :           *t++ = ' ';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8439 :           strcpy(t, tp->name);

	mov	eax, DWORD PTR _tp$86779[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8440 :           t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8441 :           if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80050				; 000138b2H
	cmp	DWORD PTR _t$[ebp], eax
	jb	SHORT $LN64@soap_strin@2

; 8442 :             break;

	jmp	SHORT $LN67@soap_strin@2
$LN64@soap_strin@2:

; 8443 :           if (tp->value)

	mov	eax, DWORD PTR _tp$86779[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN66@soap_strin@2

; 8444 :           { *t++ = '=';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8445 :             *t++ = '"';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8446 :             strcpy(t, tp->value);

	mov	eax, DWORD PTR _tp$86779[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 8447 :             t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8448 :             *t++ = '"';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx
$LN66@soap_strin@2:

; 8449 :           }
; 8450 :         }
; 8451 :       }

	jmp	$LN68@soap_strin@2
$LN67@soap_strin@2:

; 8452 :       *t++ = '>';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 62			; 0000003eH
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8453 :       *t = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 8454 :       t = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _t$[ebp], eax

; 8455 :       m = (int)strlen(soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _m$[ebp], eax

; 8456 : #endif
; 8457 :       n = 1;

	mov	DWORD PTR _n$[ebp], 1

; 8458 :       soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax
$LN72@soap_strin@2:

; 8459 :     }
; 8460 :   }
; 8461 : #ifdef WITH_CDATA
; 8462 :   if (!flag)
; 8463 :   { register int state = 0;
; 8464 : #ifdef WITH_FAST
; 8465 :     soap->labidx = 0;			/* use look-aside buffer */
; 8466 : #else
; 8467 :     if (soap_new_block(soap))
; 8468 :       return NULL;
; 8469 : #endif
; 8470 :     for (;;)
; 8471 :     {
; 8472 : #ifdef WITH_FAST
; 8473 :       register size_t k;
; 8474 :       if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */
; 8475 :         return NULL;
; 8476 :       s = soap->labbuf + soap->labidx;	/* space to populate */
; 8477 :       k = soap->lablen - soap->labidx;	/* number of bytes available */
; 8478 :       soap->labidx = soap->lablen;	/* claim this space */
; 8479 : #else
; 8480 :       register size_t k = SOAP_BLKLEN;
; 8481 :       if (!(s = (char*)soap_push_block(soap, k)))
; 8482 :         return NULL;
; 8483 : #endif
; 8484 :       for (i = 0; i < k; i++)
; 8485 :       { if (m > 0)
; 8486 :         { *s++ = *t++;	/* copy multibyte characters */
; 8487 :           m--;
; 8488 :           continue;
; 8489 :         }
; 8490 :         c = soap_getchar(soap);
; 8491 :         if ((int)c == EOF)
; 8492 :           goto end;
; 8493 :         if (c >= 0x80 && state != 1 && !(soap->mode & SOAP_ENC_LATIN))
; 8494 :         { soap_unget(soap, c);
; 8495 :           c = soap_getutf8(soap);
; 8496 :           if (soap->mode & SOAP_C_UTFSTRING)
; 8497 :           { if ((c & 0x80000000) && c >= -0x7FFFFF80 && c < SOAP_AP)
; 8498 :             { c &= 0x7FFFFFFF;
; 8499 :               t = buf;
; 8500 :               if (c < 0x0800)
; 8501 :                 *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));
; 8502 :               else
; 8503 :               { if (c < 0x010000)
; 8504 :                   *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));
; 8505 :                 else
; 8506 :                 { if (c < 0x200000)
; 8507 :                     *t++ = (char)(0xF0 | ((c >> 18) & 0x07));
; 8508 :                   else
; 8509 :                   { if (c < 0x04000000)
; 8510 :                       *t++ = (char)(0xF8 | ((c >> 24) & 0x03));
; 8511 :                     else
; 8512 :                     { *t++ = (char)(0xFC | ((c >> 30) & 0x01));
; 8513 :                       *t++ = (char)(0x80 | ((c >> 24) & 0x3F));
; 8514 :                     }
; 8515 :                     *t++ = (char)(0x80 | ((c >> 18) & 0x3F));
; 8516 :                   }
; 8517 :                   *t++ = (char)(0x80 | ((c >> 12) & 0x3F));
; 8518 :                 }
; 8519 :                 *t++ = (char)(0x80 | ((c >> 6) & 0x3F));
; 8520 :               }
; 8521 :               *t++ = (char)(0x80 | (c & 0x3F));
; 8522 :               m = (int)(t - buf) - 1;
; 8523 :               t = buf;
; 8524 :               *s++ = *t++;
; 8525 :               continue;
; 8526 :             }
; 8527 :           }
; 8528 :         }
; 8529 :         switch (state)
; 8530 :         { case 1:
; 8531 :             if (c == ']')
; 8532 :               state = 4;
; 8533 :             *s++ = c;
; 8534 :             continue;
; 8535 :           case 2:
; 8536 :             if (c == '-')
; 8537 :               state = 6;
; 8538 :             *s++ = c;
; 8539 :             continue;
; 8540 :           case 3:
; 8541 :             if (c == '?')
; 8542 :               state = 8;
; 8543 :             *s++ = c;
; 8544 :             continue;
; 8545 :           /* CDATA */
; 8546 :           case 4:
; 8547 :             if (c == ']')
; 8548 :               state = 5;
; 8549 :             else
; 8550 :               state = 1;
; 8551 :             *s++ = c;
; 8552 :             continue;
; 8553 :           case 5:
; 8554 :             if (c == '>')
; 8555 :               state = 0;
; 8556 :             else
; 8557 :               state = 1;
; 8558 :             *s++ = c;
; 8559 :             continue;
; 8560 :           /* comment */
; 8561 :           case 6:
; 8562 :             if (c == '-')
; 8563 :               state = 7;
; 8564 :             else
; 8565 :               state = 2;
; 8566 :             *s++ = c;
; 8567 :             continue;
; 8568 :           case 7:
; 8569 :             if (c == '>')
; 8570 :               state = 0;
; 8571 :             else
; 8572 :               state = 2;
; 8573 :             *s++ = c;
; 8574 :             continue;
; 8575 :           /* PI */
; 8576 :           case 8:
; 8577 :             if (c == '>')
; 8578 :               state = 0;
; 8579 :             else
; 8580 :               state = 3;
; 8581 :             *s++ = c;
; 8582 :             continue;
; 8583 :         }
; 8584 :         switch (c)
; 8585 :         {
; 8586 :         case '/':
; 8587 :           if (n > 0)
; 8588 :           { c = soap_getchar(soap);
; 8589 :             if (c == '>')
; 8590 :               n--;
; 8591 :             soap_unget(soap, c);
; 8592 :           }
; 8593 :           *s++ = '/';
; 8594 :           break;
; 8595 :         case '<':
; 8596 :           c = soap_getchar(soap);
; 8597 :           if (c == '/')
; 8598 :           { if (n == 0)
; 8599 :             { c = SOAP_TT;
; 8600 :               goto end;
; 8601 :             }
; 8602 :             n--;
; 8603 :           }
; 8604 :           else if (c == '!')
; 8605 :           { c = soap_getchar(soap);
; 8606 :             if (c == '[')
; 8607 :             { do c = soap_getchar(soap);
; 8608 :               while ((int)c != EOF && c != '[');
; 8609 :               if ((int)c == EOF)
; 8610 :                  goto end;
; 8611 :               t = (char*)"![CDATA[";
; 8612 :               m = 8;
; 8613 :               state = 1;
; 8614 :             }
; 8615 :             else if (c == '-')
; 8616 :             { if ((c = soap_getchar(soap)) == '-')
; 8617 :                 state = 2;
; 8618 :               t = (char*)"!-";
; 8619 :               m = 2;
; 8620 :               soap_unget(soap, c);
; 8621 :             }
; 8622 :             else
; 8623 :             { t = (char*)"!";
; 8624 :               m = 1;
; 8625 :               soap_unget(soap, c);
; 8626 :             }
; 8627 :             *s++ = '<';
; 8628 :             break;
; 8629 :           }
; 8630 :           else if (c == '?')
; 8631 :             state = 3;
; 8632 :           else
; 8633 :             n++;
; 8634 :           soap_unget(soap, c);
; 8635 :           *s++ = '<';
; 8636 :           break;
; 8637 :         case '>':
; 8638 :           *s++ = '>';
; 8639 :           break;
; 8640 :         case '"':
; 8641 :           *s++ = '"';
; 8642 :           break;
; 8643 :         default:
; 8644 : #ifndef WITH_LEANER
; 8645 : #ifdef HAVE_WCTOMB
; 8646 :           if (soap->mode & SOAP_C_MBSTRING)
; 8647 :           { m = wctomb(buf, c & 0x7FFFFFFF);
; 8648 :             if (m >= 1 && m <= (int)MB_CUR_MAX)
; 8649 :             { t = buf;
; 8650 :               *s++ = *t++;
; 8651 :               m--;
; 8652 :             }
; 8653 :             else
; 8654 :             { *s++ = SOAP_UNKNOWN_CHAR;
; 8655 :               m = 0;
; 8656 :             }
; 8657 :           }
; 8658 :           else
; 8659 : #endif
; 8660 : #endif
; 8661 :             *s++ = (char)(c & 0xFF);
; 8662 :         }
; 8663 :         l++;
; 8664 :         if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)
; 8665 :         { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));
; 8666 :           soap->error = SOAP_LENGTH;
; 8667 :           return NULL;
; 8668 :         }
; 8669 :       }
; 8670 :     }
; 8671 :   }
; 8672 : #endif
; 8673 : #ifdef WITH_FAST
; 8674 :   soap->labidx = 0;			/* use look-aside buffer */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0
$LN62@soap_strin@2:

; 8675 : #else
; 8676 :   if (soap_new_block(soap))
; 8677 :     return NULL;
; 8678 : #endif
; 8679 :   for (;;)
; 8680 :   {
; 8681 : #ifdef WITH_FAST
; 8682 :     register size_t k;
; 8683 :     if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN60@soap_strin@2

; 8684 :       return NULL;

	xor	eax, eax
	jmp	$LN76@soap_strin@2
$LN60@soap_strin@2:

; 8685 :     s = soap->labbuf + soap->labidx;	/* space to populate */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+12464]
	mov	DWORD PTR _s$[ebp], ecx

; 8686 :     k = soap->lablen - soap->labidx;	/* number of bytes available */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12460]
	sub	edx, DWORD PTR [ecx+12464]
	mov	DWORD PTR _k$86791[ebp], edx

; 8687 :     soap->labidx = soap->lablen;	/* claim this space */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12460]
	mov	DWORD PTR [eax+12464], edx

; 8688 : #else
; 8689 :     register size_t k = SOAP_BLKLEN;
; 8690 :     if (!(s = (char*)soap_push_block(soap, k)))
; 8691 :       return NULL;
; 8692 : #endif
; 8693 :     for (i = 0; i < k; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN59@soap_strin@2
$LN58@soap_strin@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN59@soap_strin@2:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _k$86791[ebp]
	jae	$LN57@soap_strin@2

; 8694 :     { if (m > 0)

	cmp	DWORD PTR _m$[ebp], 0
	jle	SHORT $LN56@soap_strin@2

; 8695 :       { *s++ = *t++;	/* copy multibyte characters */

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8696 :         m--;

	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax

; 8697 :         continue;

	jmp	SHORT $LN58@soap_strin@2
$LN56@soap_strin@2:

; 8698 :       }
; 8699 :       if (soap->mode & SOAP_C_UTFSTRING)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2097152				; 00200000H
	je	$LN55@soap_strin@2

; 8700 :       { if (((c = soap_get(soap)) & 0x80000000) && c >= -0x7FFFFF80 && c < SOAP_AP)

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	$LN54@soap_strin@2
	cmp	DWORD PTR _c$[ebp], -2147483520		; 80000080H
	jl	$LN54@soap_strin@2
	cmp	DWORD PTR _c$[ebp], -6			; fffffffaH
	jge	$LN54@soap_strin@2

; 8701 :         { c &= 0x7FFFFFFF;

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _c$[ebp], eax

; 8702 :           t = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8703 :           if (c < 0x0800)

	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jge	SHORT $LN53@soap_strin@2

; 8704 :             *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8705 :           else

	jmp	$LN52@soap_strin@2
$LN53@soap_strin@2:

; 8706 :           { if (c < 0x010000)

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jge	SHORT $LN51@soap_strin@2

; 8707 :               *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8708 :             else

	jmp	$LN50@soap_strin@2
$LN51@soap_strin@2:

; 8709 :             { if (c < 0x200000)

	cmp	DWORD PTR _c$[ebp], 2097152		; 00200000H
	jge	SHORT $LN49@soap_strin@2

; 8710 :                 *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8711 :               else

	jmp	$LN48@soap_strin@2
$LN49@soap_strin@2:

; 8712 :               { if (c < 0x04000000)

	cmp	DWORD PTR _c$[ebp], 67108864		; 04000000H
	jge	SHORT $LN47@soap_strin@2

; 8713 :                   *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 24					; 00000018H
	and	ecx, 3
	or	ecx, 248				; 000000f8H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8714 :                 else

	jmp	SHORT $LN46@soap_strin@2
$LN47@soap_strin@2:

; 8715 :                 { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 30					; 0000001eH
	and	ecx, 1
	or	ecx, 252				; 000000fcH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8716 :                   *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 24					; 00000018H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN46@soap_strin@2:

; 8717 :                 }
; 8718 :                 *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 18					; 00000012H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN48@soap_strin@2:

; 8719 :               }
; 8720 :               *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 12					; 0000000cH
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN50@soap_strin@2:

; 8721 :             }
; 8722 :             *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 6
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN52@soap_strin@2:

; 8723 :           }
; 8724 :           *t++ = (char)(0x80 | (c & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 8725 :           m = (int)(t - buf) - 1;

	mov	eax, DWORD PTR _t$[ebp]
	lea	ecx, DWORD PTR _buf$[ebp]
	sub	eax, ecx
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax

; 8726 :           t = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8727 :           *s++ = *t++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8728 :           continue;

	jmp	$LN58@soap_strin@2
$LN54@soap_strin@2:

; 8729 :         }
; 8730 :       }
; 8731 :       else

	jmp	SHORT $LN45@soap_strin@2
$LN55@soap_strin@2:

; 8732 :         c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN45@soap_strin@2:

; 8733 :       switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv256[ebp], eax
	cmp	DWORD PTR tv256[ebp], -6		; fffffffaH
	jg	SHORT $LN78@soap_strin@2
	cmp	DWORD PTR tv256[ebp], -6		; fffffffaH
	je	$LN36@soap_strin@2
	mov	ecx, DWORD PTR tv256[ebp]
	add	ecx, 2147483614				; 7fffffdeH
	mov	DWORD PTR tv256[ebp], ecx
	cmp	DWORD PTR tv256[ebp], 28		; 0000001cH
	ja	$LN17@soap_strin@2
	mov	edx, DWORD PTR tv256[ebp]
	movzx	eax, BYTE PTR $LN79@soap_strin@2[edx]
	jmp	DWORD PTR $LN85@soap_strin@2[eax*4]
$LN78@soap_strin@2:
	mov	ecx, DWORD PTR tv256[ebp]
	add	ecx, 5
	mov	DWORD PTR tv256[ebp], ecx
	cmp	DWORD PTR tv256[ebp], 52		; 00000034H
	ja	$LN17@soap_strin@2
	mov	edx, DWORD PTR tv256[ebp]
	movzx	eax, BYTE PTR $LN80@soap_strin@2[edx]
	jmp	DWORD PTR $LN86@soap_strin@2[eax*4]
$LN42@soap_strin@2:

; 8734 :       {
; 8735 :       case SOAP_TT:
; 8736 :         if (n == 0)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN41@soap_strin@2
	jmp	$end$86827

; 8737 :           goto end;

	jmp	$end$86827
$LN41@soap_strin@2:

; 8738 :         n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 8739 :         *s++ = '<';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8740 :         t = (char*)"/";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_01KMDKNFGN@?1?$AA@

; 8741 :         m = 1;

	mov	DWORD PTR _m$[ebp], 1

; 8742 :         break;

	jmp	$LN43@soap_strin@2
$LN39@soap_strin@2:

; 8743 :       case SOAP_LT:
; 8744 :         n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 8745 :         *s++ = '<';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8746 :         break;

	jmp	$LN43@soap_strin@2
$LN38@soap_strin@2:

; 8747 :       case SOAP_GT:
; 8748 :         *s++ = '>';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 62			; 0000003eH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8749 :         break;

	jmp	$LN43@soap_strin@2
$LN37@soap_strin@2:

; 8750 :       case SOAP_QT:
; 8751 :         *s++ = '"';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8752 :         break;

	jmp	$LN43@soap_strin@2
$LN36@soap_strin@2:

; 8753 :       case SOAP_AP:
; 8754 :         *s++ = '\'';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 39			; 00000027H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8755 :         break;

	jmp	$LN43@soap_strin@2
$LN35@soap_strin@2:

; 8756 :       case '/':
; 8757 :         if (n > 0)

	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN34@soap_strin@2

; 8758 :         { c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 8759 :           if (c == SOAP_GT)

	cmp	DWORD PTR _c$[ebp], -4			; fffffffcH
	jne	SHORT $LN33@soap_strin@2

; 8760 :             n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN33@soap_strin@2:

; 8761 :           soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx
$LN34@soap_strin@2:

; 8762 :         }
; 8763 :         *s++ = '/';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 47			; 0000002fH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8764 :         break;

	jmp	$LN43@soap_strin@2
$LN32@soap_strin@2:

; 8765 :       case (soap_wchar)('<' | 0x80000000):
; 8766 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN31@soap_strin@2

; 8767 :           *s++ = '<';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8768 :         else

	jmp	SHORT $LN30@soap_strin@2
$LN31@soap_strin@2:

; 8769 :         { *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8770 :           t = (char*)"lt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_03MAABEHOM@lt?$DL?$AA@

; 8771 :           m = 3;

	mov	DWORD PTR _m$[ebp], 3
$LN30@soap_strin@2:

; 8772 :         }
; 8773 :         break;

	jmp	$LN43@soap_strin@2
$LN29@soap_strin@2:

; 8774 :       case (soap_wchar)('>' | 0x80000000):
; 8775 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN28@soap_strin@2

; 8776 :           *s++ = '>';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 62			; 0000003eH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8777 :         else

	jmp	SHORT $LN27@soap_strin@2
$LN28@soap_strin@2:

; 8778 :         { *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8779 :           t = (char*)"gt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_03BHAAMAON@gt?$DL?$AA@

; 8780 :           m = 3;

	mov	DWORD PTR _m$[ebp], 3
$LN27@soap_strin@2:

; 8781 :         }
; 8782 :         break;

	jmp	$LN43@soap_strin@2
$LN26@soap_strin@2:

; 8783 :       case (soap_wchar)('&' | 0x80000000):
; 8784 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN25@soap_strin@2

; 8785 :           *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8786 :         else

	jmp	SHORT $LN24@soap_strin@2
$LN25@soap_strin@2:

; 8787 :         { *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8788 :           t = (char*)"amp;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_04DMIAPOKJ@amp?$DL?$AA@

; 8789 :           m = 4;

	mov	DWORD PTR _m$[ebp], 4
$LN24@soap_strin@2:

; 8790 :         }
; 8791 :         break;

	jmp	$LN43@soap_strin@2
$LN23@soap_strin@2:

; 8792 :       case (soap_wchar)('"' | 0x80000000):
; 8793 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN22@soap_strin@2

; 8794 :           *s++ = '"';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8795 :         else

	jmp	SHORT $LN21@soap_strin@2
$LN22@soap_strin@2:

; 8796 :         { *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8797 :           t = (char*)"quot;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05LDHOCHGG@quot?$DL?$AA@

; 8798 :           m = 5;

	mov	DWORD PTR _m$[ebp], 5
$LN21@soap_strin@2:

; 8799 :         }
; 8800 :         break;

	jmp	$LN43@soap_strin@2
$LN20@soap_strin@2:

; 8801 :       case (soap_wchar)('\'' | 0x80000000):
; 8802 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN19@soap_strin@2

; 8803 :           *s++ = '\'';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 39			; 00000027H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8804 :         else

	jmp	SHORT $LN18@soap_strin@2
$LN19@soap_strin@2:

; 8805 :         { *s++ = '&';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8806 :           t = (char*)"apos;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05HNAHLMAI@apos?$DL?$AA@

; 8807 :           m = 5;

	mov	DWORD PTR _m$[ebp], 5
$LN18@soap_strin@2:

; 8808 :         }
; 8809 :         break;

	jmp	$LN43@soap_strin@2
$LN17@soap_strin@2:

; 8810 :       default:
; 8811 :         if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN16@soap_strin@2
	jmp	$end$86827

; 8812 :           goto end;

	jmp	$end$86827
$LN16@soap_strin@2:

; 8813 : #ifndef WITH_LEANER
; 8814 : #ifdef HAVE_WCTOMB
; 8815 :         if (soap->mode & SOAP_C_MBSTRING)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4194304				; 00400000H
	je	$LN14@soap_strin@2

; 8816 :         { m = wctomb(buf, c & 0x7FFFFFFF);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 2147483647				; 7fffffffH
	call	@_RTC_Check_4_to_2@4
	mov	esi, esp
	movzx	eax, ax
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wctomb
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _m$[ebp], eax

; 8817 :           if (m >= 1 && m <= (int)MB_CUR_MAX)

	cmp	DWORD PTR _m$[ebp], 1
	jl	SHORT $LN13@soap_strin@2
	mov	esi, esp
	call	DWORD PTR __imp_____mb_cur_max_func
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _m$[ebp], eax
	jg	SHORT $LN13@soap_strin@2

; 8818 :           { t = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8819 :             *s++ = *t++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8820 :             m--;

	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax

; 8821 :           }
; 8822 :           else

	jmp	SHORT $LN12@soap_strin@2
$LN13@soap_strin@2:

; 8823 :           { *s++ = SOAP_UNKNOWN_CHAR;

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 127			; 0000007fH
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 8824 :             m = 0;

	mov	DWORD PTR _m$[ebp], 0
$LN12@soap_strin@2:

; 8825 :           }
; 8826 :         }
; 8827 :         else

	jmp	SHORT $LN43@soap_strin@2
$LN14@soap_strin@2:

; 8828 : #endif
; 8829 : #endif
; 8830 :           *s++ = (char)(c & 0xFF);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN43@soap_strin@2:

; 8831 :       }
; 8832 :       l++;

	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 8833 :       if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	$LN10@soap_strin@2
	cmp	DWORD PTR _maxlen$[ebp], 0
	jl	$LN10@soap_strin@2
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _maxlen$[ebp]
	jle	$LN10@soap_strin@2

; 8834 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_strin@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_strin@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86888[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _maxlen$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@MDNBDPGN@String?5too?5long?3?5maxlen?$DN?$CFld?6?$AA@
	mov	ecx, DWORD PTR _fdebug$86888[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86888[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_strin@2:

; 8835 :         soap->error = SOAP_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 45		; 0000002dH

; 8836 :         return NULL;

	xor	eax, eax
	jmp	$LN76@soap_strin@2
$LN10@soap_strin@2:

; 8837 :       }
; 8838 :     }

	jmp	$LN58@soap_strin@2
$LN57@soap_strin@2:

; 8839 :   }

	jmp	$LN62@soap_strin@2
$end$86827:

; 8840 : end:
; 8841 :   soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 8842 :   *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 8843 : #ifdef WITH_FAST
; 8844 :   t = soap_strdup(soap, soap->labbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 8845 : #else
; 8846 :   soap_size_block(soap, i+1);
; 8847 :   t = soap_save_block(soap, NULL, 0);
; 8848 : #endif
; 8849 :   if ((soap->mode & SOAP_XML_STRICT) && l < minlen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	$LN6@soap_strin@2
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _minlen$[ebp]
	jge	$LN6@soap_strin@2

; 8850 :   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too short: %ld chars, minlen=%ld\n", l, minlen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_strin@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_strin@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_strin@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86895[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _minlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CJ@NGPFFPKN@String?5too?5short?3?5?$CFld?5chars?0?5min@
	mov	edx, DWORD PTR _fdebug$86895[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86895[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_strin@2:

; 8851 :     soap->error = SOAP_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 45		; 0000002dH

; 8852 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN76@soap_strin@2
$LN6@soap_strin@2:

; 8853 :   }
; 8854 : #ifdef WITH_DOM
; 8855 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8856 :   { if (flag == 3)
; 8857 :       soap->dom->tail = t;
; 8858 :     else
; 8859 :       soap->dom->data = t;
; 8860 :   }
; 8861 : #endif
; 8862 :   if (flag == 2)

	cmp	DWORD PTR _flag$[ebp], 2
	jne	SHORT $LN2@soap_strin@2

; 8863 :     if (soap_s2QName(soap, t, &t))

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2QName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_strin@2

; 8864 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN76@soap_strin@2
$LN2@soap_strin@2:

; 8865 :   return t;

	mov	eax, DWORD PTR _t$[ebp]
$LN76@soap_strin@2:

; 8866 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN84@soap_strin@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 360				; 00000168H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN84@soap_strin@2:
	DD	2
	DD	$LN83@soap_strin@2
$LN83@soap_strin@2:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN81@soap_strin@2
	DD	-100					; ffffff9cH
	DD	8
	DD	$LN82@soap_strin@2
$LN82@soap_strin@2:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN81@soap_strin@2:
	DB	116					; 00000074H
	DB	0
	npad	2
$LN85@soap_strin@2:
	DD	$LN23@soap_strin@2
	DD	$LN26@soap_strin@2
	DD	$LN20@soap_strin@2
	DD	$LN32@soap_strin@2
	DD	$LN29@soap_strin@2
	DD	$LN17@soap_strin@2
$LN79@soap_strin@2:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	4
	npad	3
$LN86@soap_strin@2:
	DD	$LN37@soap_strin@2
	DD	$LN38@soap_strin@2
	DD	$LN42@soap_strin@2
	DD	$LN39@soap_strin@2
	DD	$LN35@soap_strin@2
	DD	$LN17@soap_strin@2
$LN80@soap_strin@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_soap_string_in ENDP
_TEXT	ENDS
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	_soap_wstring_out
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_wstring_out
_TEXT	SEGMENT
tv68 = -232						; size = 4
tv66 = -232						; size = 4
_c$ = -32						; size = 4
_tmp$ = -17						; size = 1
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_flag$ = 16						; size = 4
_soap_wstring_out PROC					; COMDAT

; 8876 : { const char *t;

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN26@soap_wstri:

; 8877 :   char tmp;
; 8878 :   register soap_wchar c;
; 8879 : #ifdef WITH_DOM
; 8880 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8881 :   { wchar_t *r = (wchar_t*)s;
; 8882 :     int n = 1;
; 8883 :     while (*r++)
; 8884 :       n++;
; 8885 :     soap->dom->wide = r = (wchar_t*)soap_malloc(soap, n * sizeof(wchar_t));
; 8886 :     while (n--)
; 8887 :       *r++ = *s++;
; 8888 :     return SOAP_OK;
; 8889 :   }
; 8890 : #endif
; 8891 :   while ((c = *s++))

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	$LN25@soap_wstri

; 8892 :   { switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 9
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 53			; 00000035H
	ja	$LN6@soap_wstri
	mov	edx, DWORD PTR tv68[ebp]
	movzx	eax, BYTE PTR $LN30@soap_wstri[edx]
	jmp	DWORD PTR $LN34@soap_wstri[eax*4]
$LN22@soap_wstri:

; 8893 :     {
; 8894 :     case 0x09:
; 8895 :       if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN21@soap_wstri

; 8896 :         t = "&#x9;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@

; 8897 :       else

	jmp	SHORT $LN20@soap_wstri
$LN21@soap_wstri:

; 8898 :         t = "\t";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
$LN20@soap_wstri:

; 8899 :       break;

	jmp	$LN23@soap_wstri
$LN19@soap_wstri:

; 8900 :     case 0x0A:
; 8901 :       if (flag || !(soap->mode & SOAP_XML_CANONICAL))

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $LN17@soap_wstri
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	jne	SHORT $LN18@soap_wstri
$LN17@soap_wstri:

; 8902 :         t = "&#xA;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@

; 8903 :       else

	jmp	SHORT $LN16@soap_wstri
$LN18@soap_wstri:

; 8904 :         t = "\n";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_01EEMJAFIK@?6?$AA@
$LN16@soap_wstri:

; 8905 :       break;

	jmp	$LN23@soap_wstri
$LN15@soap_wstri:

; 8906 :     case 0x0D:
; 8907 :       t = "&#xD;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@

; 8908 :       break;

	jmp	$LN23@soap_wstri
$LN14@soap_wstri:

; 8909 :     case '&':
; 8910 :       t = "&amp;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@

; 8911 :       break;

	jmp	$LN23@soap_wstri
$LN13@soap_wstri:

; 8912 :     case '<':
; 8913 :       t = "&lt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@

; 8914 :       break;

	jmp	$LN23@soap_wstri
$LN12@soap_wstri:

; 8915 :     case '>':
; 8916 :       if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN11@soap_wstri

; 8917 :         t = ">";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_01PPODPGHN@?$DO?$AA@

; 8918 :       else

	jmp	SHORT $LN10@soap_wstri
$LN11@soap_wstri:

; 8919 :         t = "&gt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
$LN10@soap_wstri:

; 8920 :       break;

	jmp	SHORT $LN23@soap_wstri
$LN9@soap_wstri:

; 8921 :     case '"':
; 8922 :       if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN8@soap_wstri

; 8923 :         t = "&quot;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@

; 8924 :       else

	jmp	SHORT $LN7@soap_wstri
$LN8@soap_wstri:

; 8925 :         t = "\"";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
$LN7@soap_wstri:

; 8926 :       break;

	jmp	SHORT $LN23@soap_wstri
$LN6@soap_wstri:

; 8927 :     default:
; 8928 :       if (c >= 0x20 && c < 0x80)

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jl	SHORT $LN5@soap_wstri
	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jge	SHORT $LN5@soap_wstri

; 8929 :       { tmp = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp], al

; 8930 :         if (soap_send_raw(soap, &tmp, 1))

	push	1
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_wstri

; 8931 :           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN27@soap_wstri
$LN4@soap_wstri:

; 8932 :       }

	jmp	SHORT $LN3@soap_wstri
$LN5@soap_wstri:

; 8933 :       else if (soap_pututf8(soap, (unsigned long)c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_pututf8
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@soap_wstri

; 8934 :         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN27@soap_wstri
$LN3@soap_wstri:

; 8935 :       continue;

	jmp	$LN26@soap_wstri
$LN23@soap_wstri:

; 8936 :     }
; 8937 :     if (soap_send(soap, t))

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_wstri

; 8938 :       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN27@soap_wstri
$LN1@soap_wstri:

; 8939 :   }

	jmp	$LN26@soap_wstri
$LN25@soap_wstri:

; 8940 :   return SOAP_OK;

	xor	eax, eax
$LN27@soap_wstri:

; 8941 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@soap_wstri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN33@soap_wstri:
	DD	1
	DD	$LN32@soap_wstri
$LN32@soap_wstri:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN31@soap_wstri
$LN31@soap_wstri:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN34@soap_wstri:
	DD	$LN22@soap_wstri
	DD	$LN19@soap_wstri
	DD	$LN15@soap_wstri
	DD	$LN9@soap_wstri
	DD	$LN14@soap_wstri
	DD	$LN13@soap_wstri
	DD	$LN12@soap_wstri
	DD	$LN6@soap_wstri
$LN30@soap_wstri:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	6
_soap_wstring_out ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@HMGNDIPC@Reading?5wide?5string?5content?6?$AA@ ; `string'
PUBLIC	_soap_wstring_in
;	COMDAT ??_C@_0BN@HMGNDIPC@Reading?5wide?5string?5content?6?$AA@
CONST	SEGMENT
??_C@_0BN@HMGNDIPC@Reading?5wide?5string?5content?6?$AA@ DB 'Reading wide'
	DB	' string content', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_wstring_in
_TEXT	SEGMENT
tv181 = -316						; size = 4
_fdebug$87037 = -116					; size = 4
_fdebug$87030 = -104					; size = 4
_tp$86960 = -92						; size = 4
_fdebug$86955 = -80					; size = 4
_t$ = -68						; size = 4
_c$ = -56						; size = 4
_l$ = -44						; size = 4
_n$ = -32						; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_flag$ = 12						; size = 4
_minlen$ = 16						; size = 4
_maxlen$ = 20						; size = 4
_soap_wstring_in PROC					; COMDAT

; 8952 : { wchar_t *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8953 :   register int i, n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 8954 :   register long l = 0;

	mov	DWORD PTR _l$[ebp], 0

; 8955 :   register soap_wchar c;
; 8956 :   char *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 8957 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Reading wide string content\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN54@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN53@soap_wstri@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN53@soap_wstri@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN54@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$86955[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BN@HMGNDIPC@Reading?5wide?5string?5content?6?$AA@
	mov	eax, DWORD PTR _fdebug$86955[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$86955[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN54@soap_wstri@2:

; 8958 :   if (soap->peeked)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87308]
	test	ecx, ecx
	je	$LN51@soap_wstri@2

; 8959 :   { if (!soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	jne	SHORT $LN50@soap_wstri@2

; 8960 :       return NULL;

	xor	eax, eax
	jmp	$LN55@soap_wstri@2
$LN50@soap_wstri@2:

; 8961 :     if (*soap->tag)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+80052]
	test	ecx, ecx
	je	$LN51@soap_wstri@2

; 8962 :     {
; 8963 : #ifndef WITH_LEAN
; 8964 :       struct soap_attribute *tp;
; 8965 :       t = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _t$[ebp], eax

; 8966 :       *t = '<';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 60			; 0000003cH

; 8967 :       t[sizeof(soap->tmpbuf)-1] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax+1023], 0

; 8968 :       strncpy(t + 1, soap->tag, sizeof(soap->tmpbuf) - 2);

	mov	esi, esp
	push	1022					; 000003feH
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8969 :       t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8970 :       for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+87292]
	mov	DWORD PTR _tp$86960[ebp], ecx
	jmp	SHORT $LN48@soap_wstri@2
$LN47@soap_wstri@2:
	mov	eax, DWORD PTR _tp$86960[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tp$86960[ebp], ecx
$LN48@soap_wstri@2:
	cmp	DWORD PTR _tp$86960[ebp], 0
	je	$LN46@soap_wstri@2

; 8971 :       { if (tp->visible)

	mov	eax, DWORD PTR _tp$86960[ebp]
	movsx	ecx, WORD PTR [eax+16]
	test	ecx, ecx
	je	$LN45@soap_wstri@2

; 8972 :         { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80050				; 000138b2H
	cmp	DWORD PTR _t$[ebp], eax
	jb	SHORT $LN44@soap_wstri@2

; 8973 :             break;

	jmp	$LN46@soap_wstri@2
$LN44@soap_wstri@2:

; 8974 :           *t++ = ' ';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8975 :           strcpy(t, tp->name);

	mov	eax, DWORD PTR _tp$86960[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8976 :           t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8977 :           if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80050				; 000138b2H
	cmp	DWORD PTR _t$[ebp], eax
	jb	SHORT $LN43@soap_wstri@2

; 8978 :             break;

	jmp	SHORT $LN46@soap_wstri@2
$LN43@soap_wstri@2:

; 8979 :           if (tp->value)

	mov	eax, DWORD PTR _tp$86960[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN45@soap_wstri@2

; 8980 :           { *t++ = '=';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8981 :             *t++ = '"';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8982 :             strcpy(t, tp->value);

	mov	eax, DWORD PTR _tp$86960[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 8983 :             t += strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 8984 :             *t++ = '"';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx
$LN45@soap_wstri@2:

; 8985 :           }
; 8986 :         }
; 8987 :       }

	jmp	$LN47@soap_wstri@2
$LN46@soap_wstri@2:

; 8988 :       *t++ = '>';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 62			; 0000003eH
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 8989 :       *t = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 8990 :       t = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _t$[ebp], eax

; 8991 : #endif
; 8992 :       n = 1;

	mov	DWORD PTR _n$[ebp], 1

; 8993 :       soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax
$LN51@soap_wstri@2:

; 8994 :     }
; 8995 :   }
; 8996 :   if (soap_new_block(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_block
	add	esp, 4
	test	eax, eax
	je	SHORT $LN40@soap_wstri@2

; 8997 :     return NULL;

	xor	eax, eax
	jmp	$LN55@soap_wstri@2
$LN40@soap_wstri@2:

; 8998 :   for (;;)
; 8999 :   { if (!(s = (wchar_t*)soap_push_block(soap, sizeof(wchar_t)*SOAP_BLKLEN)))

	push	512					; 00000200H
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_push_block
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN38@soap_wstri@2

; 9000 :       return NULL;

	xor	eax, eax
	jmp	$LN55@soap_wstri@2
$LN38@soap_wstri@2:

; 9001 :     for (i = 0; i < SOAP_BLKLEN; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN37@soap_wstri@2
$LN36@soap_wstri@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN37@soap_wstri@2:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN35@soap_wstri@2

; 9002 :     { if (t)

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN34@soap_wstri@2

; 9003 :       { *s++ = (wchar_t)*t++;

	mov	eax, DWORD PTR _t$[ebp]
	movsx	cx, BYTE PTR [eax]
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 9004 :         if (!*t)

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN33@soap_wstri@2

; 9005 :           t = NULL;

	mov	DWORD PTR _t$[ebp], 0
$LN33@soap_wstri@2:

; 9006 :         continue;

	jmp	SHORT $LN36@soap_wstri@2
$LN34@soap_wstri@2:

; 9007 :       }
; 9008 :       c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 9009 :       switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR tv181[ebp]
	add	ecx, 6
	mov	DWORD PTR tv181[ebp], ecx
	cmp	DWORD PTR tv181[ebp], 68		; 00000044H
	ja	$LN11@soap_wstri@2
	mov	edx, DWORD PTR tv181[ebp]
	movzx	eax, BYTE PTR $LN57@soap_wstri@2[edx]
	jmp	DWORD PTR $LN58@soap_wstri@2[eax*4]
$LN30@soap_wstri@2:

; 9010 :       {
; 9011 :       case SOAP_TT:
; 9012 :         if (n == 0)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN29@soap_wstri@2
	jmp	$end$86988

; 9013 :           goto end;

	jmp	$end$86988
$LN29@soap_wstri@2:

; 9014 :         n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 9015 :         *s++ = '<';

	mov	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9016 :         soap_unget(soap, '/');

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 47		; 0000002fH

; 9017 :         break;

	jmp	$LN31@soap_wstri@2
$LN27@soap_wstri@2:

; 9018 :       case SOAP_LT:
; 9019 :         n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 9020 :         *s++ = '<';

	mov	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9021 :         break;

	jmp	$LN31@soap_wstri@2
$LN26@soap_wstri@2:

; 9022 :       case SOAP_GT:
; 9023 :         *s++ = '>';

	mov	eax, 62					; 0000003eH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9024 :         break;

	jmp	$LN31@soap_wstri@2
$LN25@soap_wstri@2:

; 9025 :       case SOAP_QT:
; 9026 :         *s++ = '"';

	mov	eax, 34					; 00000022H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9027 :         break;

	jmp	$LN31@soap_wstri@2
$LN24@soap_wstri@2:

; 9028 :       case SOAP_AP:
; 9029 :         *s++ = '\'';

	mov	eax, 39					; 00000027H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9030 :         break;

	jmp	$LN31@soap_wstri@2
$LN23@soap_wstri@2:

; 9031 :       case '/':
; 9032 :         if (n > 0)

	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN22@soap_wstri@2

; 9033 :         { c = soap_getutf8(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getutf8
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 9034 :           if (c == SOAP_GT)

	cmp	DWORD PTR _c$[ebp], -4			; fffffffcH
	jne	SHORT $LN21@soap_wstri@2

; 9035 :             n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN21@soap_wstri@2:

; 9036 :           soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx
$LN22@soap_wstri@2:

; 9037 :         }
; 9038 :         *s++ = '/';

	mov	eax, 47					; 0000002fH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9039 :         break;

	jmp	$LN31@soap_wstri@2
$LN20@soap_wstri@2:

; 9040 :       case '<':
; 9041 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN19@soap_wstri@2

; 9042 :           *s++ = (soap_wchar)'<';

	mov	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9043 :         else

	jmp	SHORT $LN18@soap_wstri@2
$LN19@soap_wstri@2:

; 9044 :         { *s++ = (soap_wchar)'&';

	mov	eax, 38					; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9045 :           t = (char *)"lt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_03MAABEHOM@lt?$DL?$AA@
$LN18@soap_wstri@2:

; 9046 :         }
; 9047 :         break;

	jmp	$LN31@soap_wstri@2
$LN17@soap_wstri@2:

; 9048 :       case '>':
; 9049 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN16@soap_wstri@2

; 9050 :           *s++ = (soap_wchar)'>';

	mov	eax, 62					; 0000003eH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9051 :         else

	jmp	SHORT $LN15@soap_wstri@2
$LN16@soap_wstri@2:

; 9052 :         { *s++ = (soap_wchar)'&';

	mov	eax, 38					; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9053 :           t = (char *)"gt;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_03BHAAMAON@gt?$DL?$AA@
$LN15@soap_wstri@2:

; 9054 : 		}
; 9055 :         break;

	jmp	SHORT $LN31@soap_wstri@2
$LN14@soap_wstri@2:

; 9056 :       case '"':
; 9057 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN13@soap_wstri@2

; 9058 :           *s++ = (soap_wchar)'"';

	mov	eax, 34					; 00000022H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9059 :         else

	jmp	SHORT $LN12@soap_wstri@2
$LN13@soap_wstri@2:

; 9060 :         { *s++ = (soap_wchar)'&';

	mov	eax, 38					; 00000026H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 9061 :           t = (char *)"quot;";

	mov	DWORD PTR _t$[ebp], OFFSET ??_C@_05LDHOCHGG@quot?$DL?$AA@
$LN12@soap_wstri@2:

; 9062 :         }
; 9063 :         break;

	jmp	SHORT $LN31@soap_wstri@2
$LN11@soap_wstri@2:

; 9064 :       default:
; 9065 :         if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN10@soap_wstri@2
	jmp	$end$86988

; 9066 :           goto end;

	jmp	$end$86988
$LN10@soap_wstri@2:

; 9067 :         *s++ = (wchar_t)c & 0x7FFFFFFF;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_2@4
	movzx	ecx, ax
	and	ecx, 2147483647				; 7fffffffH
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx
$LN31@soap_wstri@2:

; 9068 :       }
; 9069 :       l++;

	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 9070 :       if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	$LN8@soap_wstri@2
	cmp	DWORD PTR _maxlen$[ebp], 0
	jl	$LN8@soap_wstri@2
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _maxlen$[ebp]
	jle	$LN8@soap_wstri@2

; 9071 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN7@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN6@soap_wstri@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN6@soap_wstri@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN7@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$87030[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _maxlen$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@MDNBDPGN@String?5too?5long?3?5maxlen?$DN?$CFld?6?$AA@
	mov	ecx, DWORD PTR _fdebug$87030[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$87030[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_wstri@2:

; 9072 :         soap->error = SOAP_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 45		; 0000002dH

; 9073 :         return NULL;

	xor	eax, eax
	jmp	$LN55@soap_wstri@2
$LN8@soap_wstri@2:

; 9074 :       }
; 9075 :     }

	jmp	$LN36@soap_wstri@2
$LN35@soap_wstri@2:

; 9076 :   }

	jmp	$LN40@soap_wstri@2
$end$86988:

; 9077 : end:
; 9078 :   soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 9079 :   *s = '\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax

; 9080 :   soap_size_block(soap, sizeof(wchar_t) * (i + 1));

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_size_block
	add	esp, 8

; 9081 :   if ((soap->mode & SOAP_XML_STRICT) && l < minlen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	je	$LN4@soap_wstri@2
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _minlen$[ebp]
	jge	$LN4@soap_wstri@2

; 9082 :   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too short: %ld chars, minlen=%ld\n", l, minlen));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_wstri@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_wstri@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_wstri@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$87037[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _minlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CJ@NGPFFPKN@String?5too?5short?3?5?$CFld?5chars?0?5min@
	mov	edx, DWORD PTR _fdebug$87037[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$87037[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_wstri@2:

; 9083 :     soap->error = SOAP_LENGTH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 45		; 0000002dH

; 9084 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN55@soap_wstri@2
$LN4@soap_wstri@2:

; 9085 :   }
; 9086 :   s = (wchar_t*)soap_save_block(soap, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_save_block
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _s$[ebp], eax

; 9087 : #ifdef WITH_DOM
; 9088 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 9089 :     soap->dom->wide = s;
; 9090 : #endif
; 9091 :   return s;

	mov	eax, DWORD PTR _s$[ebp]
$LN55@soap_wstri@2:

; 9092 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN58@soap_wstri@2:
	DD	$LN24@soap_wstri@2
	DD	$LN25@soap_wstri@2
	DD	$LN26@soap_wstri@2
	DD	$LN30@soap_wstri@2
	DD	$LN27@soap_wstri@2
	DD	$LN14@soap_wstri@2
	DD	$LN23@soap_wstri@2
	DD	$LN20@soap_wstri@2
	DD	$LN17@soap_wstri@2
	DD	$LN11@soap_wstri@2
$LN57@soap_wstri@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	8
_soap_wstring_in ENDP
_TEXT	ENDS
PUBLIC	_soap_long2s
PUBLIC	_soap_int2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_int2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_int2s PROC					; COMDAT

; 9102 : { return soap_long2s(soap, (long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_long2s
	add	esp, 8

; 9103 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_int2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outint
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outint
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outint PROC					; COMDAT

; 9112 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9113 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outin
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_long2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outin
$LN1@soap_outin:

; 9114 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outin
$LN2@soap_outin:

; 9115 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outin:

; 9116 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outint ENDP
_TEXT	ENDS
PUBLIC	_soap_s2int
EXTRN	__imp__SetLastError@4:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2int
_TEXT	SEGMENT
_r$87061 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2int PROC					; COMDAT

; 9125 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_s2int

; 9126 :   { char *r;
; 9127 : #ifndef WITH_NOIO
; 9128 : #ifndef WITH_LEAN
; 9129 :     soap_reset_errno;

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9130 : #endif
; 9131 : #endif
; 9132 :     *p = (int)soap_strtol(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87061[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 9133 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9134 : #ifndef WITH_NOIO
; 9135 : #ifndef WITH_LEAN
; 9136 :      || soap_errno == SOAP_ERANGE
; 9137 : #endif
; 9138 : #endif
; 9139 :    )

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87061[ebp]
	jne	SHORT $LN1@soap_s2int
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN2@soap_s2int
$LN1@soap_s2int:
	mov	eax, DWORD PTR _r$87061[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@soap_s2int
	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN4@soap_s2int
$LN2@soap_s2int:

; 9140 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN4@soap_s2int:

; 9141 :   }
; 9142 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9143 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_s2int
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@soap_s2int:
	DD	1
	DD	$LN8@soap_s2int
$LN8@soap_s2int:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN7@soap_s2int
$LN7@soap_s2int:
	DB	114					; 00000072H
	DB	0
_soap_s2int ENDP
_TEXT	ENDS
PUBLIC	_soap_value
PUBLIC	??_C@_05FFGLOOMC@?3byte?$AA@			; `string'
PUBLIC	??_C@_06DFBHHOOH@?3short?$AA@			; `string'
PUBLIC	??_C@_04JNHIEKJE@?3int?$AA@			; `string'
PUBLIC	_soap_inint
;	COMDAT ??_C@_05FFGLOOMC@?3byte?$AA@
CONST	SEGMENT
??_C@_05FFGLOOMC@?3byte?$AA@ DB ':byte', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFBHHOOH@?3short?$AA@
CONST	SEGMENT
??_C@_06DFBHHOOH@?3short?$AA@ DB ':short', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNHIEKJE@?3int?$AA@
CONST	SEGMENT
??_C@_04JNHIEKJE@?3int?$AA@ DB ':int', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_inint
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inint PROC					; COMDAT

; 9152 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inint

; 9153 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inint
$LN7@soap_inint:

; 9154 : #ifndef WITH_LEAN
; 9155 :   if (*soap->type
; 9156 :    && soap_match_tag(soap, soap->type, type)
; 9157 :    && soap_match_tag(soap, soap->type, ":int")
; 9158 :    && soap_match_tag(soap, soap->type, ":short")
; 9159 :    && soap_match_tag(soap, soap->type, ":byte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inint
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inint

; 9160 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9161 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9162 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inint
$LN6@soap_inint:

; 9163 :   }
; 9164 : #endif
; 9165 :   p = (int*)soap_id_enter(soap, soap->id, p, t, sizeof(int), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9166 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inint

; 9167 :     p = (int*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(int), 0, NULL);

	push	0
	push	0
	push	4
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inint
$LN5@soap_inint:

; 9168 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inint

; 9169 :   { if (soap_s2int(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2int
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inint

; 9170 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inint
$LN4@soap_inint:

; 9171 :   }
; 9172 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inint
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inint

; 9173 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inint
$LN1@soap_inint:

; 9174 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inint:

; 9175 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inint ENDP
_TEXT	ENDS
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_long2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_long2s PROC					; COMDAT

; 9184 : { sprintf(soap->tmpbuf, "%ld", n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9185 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 9186 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_long2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outlong
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outlong
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outlong PROC					; COMDAT

; 9195 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9196 :    || soap_string_out(soap, soap_long2s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outlo
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_long2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outlo
$LN1@soap_outlo:

; 9197 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outlo
$LN2@soap_outlo:

; 9198 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outlo:

; 9199 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outlong ENDP
_TEXT	ENDS
PUBLIC	_soap_s2long
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2long
_TEXT	SEGMENT
_r$87108 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2long PROC					; COMDAT

; 9208 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_s2lon

; 9209 :   { char *r;
; 9210 : #ifndef WITH_NOIO
; 9211 : #ifndef WITH_LEAN
; 9212 :     soap_reset_errno;

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9213 : #endif
; 9214 : #endif
; 9215 :     *p = soap_strtol(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87108[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 9216 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9217 : #ifndef WITH_NOIO
; 9218 : #ifndef WITH_LEAN
; 9219 :      || soap_errno == SOAP_ERANGE
; 9220 : #endif
; 9221 : #endif
; 9222 :    )

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87108[ebp]
	jne	SHORT $LN1@soap_s2lon
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN2@soap_s2lon
$LN1@soap_s2lon:
	mov	eax, DWORD PTR _r$87108[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@soap_s2lon
	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN4@soap_s2lon
$LN2@soap_s2lon:

; 9223 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN4@soap_s2lon:

; 9224 :   }
; 9225 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9226 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_s2lon
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@soap_s2lon:
	DD	1
	DD	$LN8@soap_s2lon
$LN8@soap_s2lon:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN7@soap_s2lon
$LN7@soap_s2lon:
	DB	114					; 00000072H
	DB	0
_soap_s2long ENDP
_TEXT	ENDS
PUBLIC	_soap_inlong
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inlong
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inlong PROC					; COMDAT

; 9235 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inlon

; 9236 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inlon
$LN7@soap_inlon:

; 9237 : #ifndef WITH_LEAN
; 9238 :   if (*soap->type
; 9239 :    && soap_match_tag(soap, soap->type, type)
; 9240 :    && soap_match_tag(soap, soap->type, ":int")
; 9241 :    && soap_match_tag(soap, soap->type, ":short")
; 9242 :    && soap_match_tag(soap, soap->type, ":byte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inlon
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inlon

; 9243 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9244 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9245 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inlon
$LN6@soap_inlon:

; 9246 :   }
; 9247 : #endif
; 9248 :   p = (long*)soap_id_enter(soap, soap->id, p, t, sizeof(long), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9249 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inlon

; 9250 :     p = (long*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(long), 0, NULL);

	push	0
	push	0
	push	4
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inlon
$LN5@soap_inlon:

; 9251 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inlon

; 9252 :   { if (soap_s2long(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2long
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inlon

; 9253 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inlon
$LN4@soap_inlon:

; 9254 :   }
; 9255 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inlon
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inlon

; 9256 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inlon
$LN1@soap_inlon:

; 9257 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inlon:

; 9258 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inlong ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d?$AA@			; `string'
PUBLIC	_soap_LONG642s
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d?$AA@ DB '%I64d', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_LONG642s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 8
_soap_LONG642s PROC					; COMDAT

; 9267 : { sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9268 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 9269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_LONG642s ENDP
_TEXT	ENDS
PUBLIC	_soap_outLONG64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outLONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outLONG64 PROC					; COMDAT

; 9278 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9279 :    || soap_string_out(soap, soap_LONG642s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outLO
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_LONG642s
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outLO
$LN1@soap_outLO:

; 9280 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outLO
$LN2@soap_outLO:

; 9281 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outLO:

; 9282 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outLONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_s2LONG64
EXTRN	__imp__sscanf:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2LONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2LONG64 PROC					; COMDAT

; 9291 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN2@soap_s2LON

; 9292 :   {
; 9293 : #ifdef HAVE_STRTOLL
; 9294 :     char *r;
; 9295 : #ifndef WITH_NOIO
; 9296 : #ifndef WITH_LEAN
; 9297 :     soap_reset_errno;
; 9298 : #endif
; 9299 : #endif
; 9300 :     *p = strtoll(s, &r, 10);
; 9301 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9302 : #ifndef WITH_NOIO
; 9303 : #ifndef WITH_LEAN
; 9304 :        || soap_errno == SOAP_ERANGE
; 9305 : #endif
; 9306 : #endif
; 9307 :      )
; 9308 : #else
; 9309 : # ifdef HAVE_SSCANF
; 9310 :     if (sscanf(s, SOAP_LONG_FORMAT, p) != 1)

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	je	SHORT $LN2@soap_s2LON

; 9311 : # endif
; 9312 : #endif
; 9313 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2LON:

; 9314 :   }
; 9315 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9316 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2LONG64 ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LMKOBMME@?3long?$AA@			; `string'
PUBLIC	??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@	; `string'
PUBLIC	??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@	; `string'
PUBLIC	??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@	; `string'
PUBLIC	??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@	; `string'
PUBLIC	??_C@_08ICEBEHNK@?3integer?$AA@			; `string'
PUBLIC	_soap_inLONG64
;	COMDAT ??_C@_05LMKOBMME@?3long?$AA@
CONST	SEGMENT
??_C@_05LMKOBMME@?3long?$AA@ DB ':long', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
CONST	SEGMENT
??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@ DB ':nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
CONST	SEGMENT
??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@ DB ':nonPositiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
CONST	SEGMENT
??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@ DB ':negativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
CONST	SEGMENT
??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@ DB ':positiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICEBEHNK@?3integer?$AA@
CONST	SEGMENT
??_C@_08ICEBEHNK@?3integer?$AA@ DB ':integer', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_inLONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inLONG64 PROC					; COMDAT

; 9325 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inLON@3

; 9326 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inLON@3
$LN7@soap_inLON@3:

; 9327 : #ifndef WITH_LEAN
; 9328 :   if (*soap->type
; 9329 :    && soap_match_tag(soap, soap->type, type)
; 9330 :    && soap_match_tag(soap, soap->type, ":integer")
; 9331 :    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 9332 :    && soap_match_tag(soap, soap->type, ":negativeInteger")
; 9333 :    && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
; 9334 :    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 9335 :    && soap_match_tag(soap, soap->type, ":long")
; 9336 :    && soap_match_tag(soap, soap->type, ":int")
; 9337 :    && soap_match_tag(soap, soap->type, ":short")
; 9338 :    && soap_match_tag(soap, soap->type, ":byte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inLON@3
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_08ICEBEHNK@?3integer?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inLON@3
	push	OFFSET ??_C@_05LMKOBMME@?3long?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inLON@3
	push	OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inLON@3
	push	OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inLON@3
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inLON@3

; 9339 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9340 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9341 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inLON@3
$LN6@soap_inLON@3:

; 9342 :   }
; 9343 : #endif
; 9344 :   p = (LONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(LONG64), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	8
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9345 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inLON@3

; 9346 :     p = (LONG64*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(LONG64), 0, NULL);

	push	0
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inLON@3
$LN5@soap_inLON@3:

; 9347 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inLON@3

; 9348 :   { if (soap_s2LONG64(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2LONG64
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inLON@3

; 9349 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inLON@3
$LN4@soap_inLON@3:

; 9350 :   }
; 9351 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inLON@3
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inLON@3

; 9352 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inLON@3
$LN1@soap_inLON@3:

; 9353 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inLON@3:

; 9354 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inLONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_byte2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_byte2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 1
_soap_byte2s PROC					; COMDAT

; 9363 : { return soap_long2s(soap, (long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movsx	eax, BYTE PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_long2s
	add	esp, 8

; 9364 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_byte2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outbyte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outbyte
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outbyte PROC					; COMDAT

; 9373 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9374 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outby
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_long2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outby
$LN1@soap_outby:

; 9375 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outby
$LN2@soap_outby:

; 9376 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outby:

; 9377 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outbyte ENDP
_TEXT	ENDS
PUBLIC	_soap_s2byte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2byte
_TEXT	SEGMENT
_r$87199 = -20						; size = 4
_n$87198 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2byte PROC					; COMDAT

; 9386 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_s2byt

; 9387 :   { long n;
; 9388 :     char *r;
; 9389 :     n = soap_strtol(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87199[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$87198[ebp], eax

; 9390 :     if (s == r || *r || n < -128 || n > 127)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87199[ebp]
	je	SHORT $LN1@soap_s2byt
	mov	eax, DWORD PTR _r$87199[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@soap_s2byt
	cmp	DWORD PTR _n$87198[ebp], -128		; ffffff80H
	jl	SHORT $LN1@soap_s2byt
	cmp	DWORD PTR _n$87198[ebp], 127		; 0000007fH
	jle	SHORT $LN2@soap_s2byt
$LN1@soap_s2byt:

; 9391 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2byt:

; 9392 :     *p = (char)n;

	mov	ecx, DWORD PTR _n$87198[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx], al
$LN3@soap_s2byt:

; 9393 :   }
; 9394 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9395 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_s2byt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@soap_s2byt:
	DD	1
	DD	$LN7@soap_s2byt
$LN7@soap_s2byt:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@soap_s2byt
$LN6@soap_s2byt:
	DB	114					; 00000072H
	DB	0
_soap_s2byte ENDP
_TEXT	ENDS
PUBLIC	_soap_inbyte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inbyte
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inbyte PROC					; COMDAT

; 9404 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inbyt

; 9405 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inbyt
$LN7@soap_inbyt:

; 9406 : #ifndef WITH_LEAN
; 9407 :   if (*soap->type
; 9408 :    && soap_match_tag(soap, soap->type, type)
; 9409 :    && soap_match_tag(soap, soap->type, ":byte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_inbyt
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inbyt
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inbyt

; 9410 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9411 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9412 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inbyt
$LN6@soap_inbyt:

; 9413 :   }
; 9414 : #endif
; 9415 :   p = (char*)soap_id_enter(soap, soap->id, p, t, sizeof(char), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9416 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inbyt

; 9417 :     p = (char*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(char), 0, NULL);

	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inbyt
$LN5@soap_inbyt:

; 9418 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inbyt

; 9419 :   { if (soap_s2byte(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2byte
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inbyt

; 9420 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inbyt
$LN4@soap_inbyt:

; 9421 :   }
; 9422 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inbyt
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inbyt

; 9423 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inbyt
$LN1@soap_inbyt:

; 9424 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inbyt:

; 9425 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inbyte ENDP
_TEXT	ENDS
PUBLIC	_soap_short2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_short2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 2
_soap_short2s PROC					; COMDAT

; 9434 : { return soap_long2s(soap, (long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movsx	eax, WORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_long2s
	add	esp, 8

; 9435 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_short2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outshort
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outshort
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outshort PROC					; COMDAT

; 9444 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9445 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outsh
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_long2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outsh
$LN1@soap_outsh:

; 9446 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outsh
$LN2@soap_outsh:

; 9447 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outsh:

; 9448 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outshort ENDP
_TEXT	ENDS
PUBLIC	_soap_s2short
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2short
_TEXT	SEGMENT
_r$87244 = -20						; size = 4
_n$87243 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2short PROC					; COMDAT

; 9457 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_s2sho

; 9458 :   { long n;
; 9459 :     char *r;
; 9460 :     n = soap_strtol(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87244[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$87243[ebp], eax

; 9461 :     if (s == r || *r || n < -32768 || n > 32767)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87244[ebp]
	je	SHORT $LN1@soap_s2sho
	mov	eax, DWORD PTR _r$87244[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@soap_s2sho
	cmp	DWORD PTR _n$87243[ebp], -32768		; ffff8000H
	jl	SHORT $LN1@soap_s2sho
	cmp	DWORD PTR _n$87243[ebp], 32767		; 00007fffH
	jle	SHORT $LN2@soap_s2sho
$LN1@soap_s2sho:

; 9462 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2sho:

; 9463 :     *p = (short)n;

	mov	ecx, DWORD PTR _n$87243[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	WORD PTR [ecx], ax
$LN3@soap_s2sho:

; 9464 :   }
; 9465 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9466 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_s2sho
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@soap_s2sho:
	DD	1
	DD	$LN7@soap_s2sho
$LN7@soap_s2sho:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@soap_s2sho
$LN6@soap_s2sho:
	DB	114					; 00000072H
	DB	0
_soap_s2short ENDP
_TEXT	ENDS
PUBLIC	_soap_inshort
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inshort
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inshort PROC					; COMDAT

; 9475 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_insho

; 9476 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_insho
$LN7@soap_insho:

; 9477 : #ifndef WITH_LEAN
; 9478 :   if (*soap->type
; 9479 :    && soap_match_tag(soap, soap->type, type)
; 9480 :    && soap_match_tag(soap, soap->type, ":short")
; 9481 :    && soap_match_tag(soap, soap->type, ":byte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_insho
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_insho
	push	OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_insho
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_insho

; 9482 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9483 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9484 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_insho
$LN6@soap_insho:

; 9485 :   }
; 9486 : #endif
; 9487 :   p = (short*)soap_id_enter(soap, soap->id, p, t, sizeof(short), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9488 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_insho

; 9489 :     p = (short*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(short), 0, NULL);

	push	0
	push	0
	push	2
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_insho
$LN5@soap_insho:

; 9490 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_insho

; 9491 :   { if (soap_s2short(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2short
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_insho

; 9492 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_insho
$LN4@soap_insho:

; 9493 :   }
; 9494 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_insho
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_insho

; 9495 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_insho
$LN1@soap_insho:

; 9496 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_insho:

; 9497 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inshort ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DKLHLMKJ@?9INF?$AA@			; `string'
PUBLIC	__real@c7efffffe0000000
PUBLIC	??_C@_03OEIAHPBN@INF?$AA@			; `string'
PUBLIC	__real@47efffffe0000000
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	_soap_float2s
EXTRN	__imp___isnan:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_04DKLHLMKJ@?9INF?$AA@
CONST	SEGMENT
??_C@_04DKLHLMKJ@?9INF?$AA@ DB '-INF', 00H		; `string'
CONST	ENDS
;	COMDAT __real@c7efffffe0000000
CONST	SEGMENT
__real@c7efffffe0000000 DQ 0c7efffffe0000000r	; -3.40282e+038
CONST	ENDS
;	COMDAT ??_C@_03OEIAHPBN@INF?$AA@
CONST	SEGMENT
??_C@_03OEIAHPBN@INF?$AA@ DB 'INF', 00H			; `string'
CONST	ENDS
;	COMDAT __real@47efffffe0000000
CONST	SEGMENT
__real@47efffffe0000000 DQ 047efffffe0000000r	; 3.40282e+038
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_float2s
_TEXT	SEGMENT
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_float2s PROC					; COMDAT

; 9506 : { char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9507 :   if (soap_isnan((double)n))

	fld	DWORD PTR _n$[ebp]
	mov	esi, esp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp___isnan
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN4@soap_float

; 9508 :     return "NaN";

	mov	eax, OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	jmp	$LN5@soap_float
$LN4@soap_float:

; 9509 :   if (soap_ispinff(n))

	fld	DWORD PTR _n$[ebp]
	fcomp	QWORD PTR __real@47efffffe0000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3@soap_float

; 9510 :     return "INF";

	mov	eax, OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	jmp	SHORT $LN5@soap_float
$LN3@soap_float:

; 9511 :   if (soap_isninff(n))

	fld	DWORD PTR _n$[ebp]
	fcomp	QWORD PTR __real@c7efffffe0000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN2@soap_float

; 9512 :     return "-INF";

	mov	eax, OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	jmp	SHORT $LN5@soap_float
$LN2@soap_float:

; 9513 :   s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$[ebp], eax

; 9514 : #if defined(HAVE_SPRINTF_L)
; 9515 :   sprintf_l(s, NULL, soap->float_format, n);
; 9516 : #else
; 9517 :   sprintf(s, soap->float_format, n);

	fld	DWORD PTR _n$[ebp]
	mov	esi, esp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9518 :   s = strchr(s, ',');	/* convert decimal comma to DP */

	push	44					; 0000002cH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 9519 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_float

; 9520 :     *s = '.';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
$LN1@soap_float:

; 9521 : #endif
; 9522 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
$LN5@soap_float:

; 9523 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_float2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outfloat
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outfloat
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outfloat PROC					; COMDAT

; 9532 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9533 :    || soap_string_out(soap, soap_float2s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outfl
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_float2s
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outfl
$LN1@soap_outfl:

; 9534 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outfl
$LN2@soap_outfl:

; 9535 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outfl:

; 9536 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outfloat ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BEIEFPIG@?$CFg?$AA@			; `string'
PUBLIC	__real@ff7fffff
PUBLIC	??_C@_04LFPHEJAJ@?$CLINF?$AA@			; `string'
PUBLIC	__real@7f7fffff
PUBLIC	_soap_s2float
EXTRN	__imp__strtod:PROC
;	COMDAT ??_C@_02BEIEFPIG@?$CFg?$AA@
CONST	SEGMENT
??_C@_02BEIEFPIG@?$CFg?$AA@ DB '%g', 00H		; `string'
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
CONST	ENDS
;	COMDAT ??_C@_04LFPHEJAJ@?$CLINF?$AA@
CONST	SEGMENT
??_C@_04LFPHEJAJ@?$CLINF?$AA@ DB '+INF', 00H		; `string'
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_s2float
_TEXT	SEGMENT
_r$87307 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2float PROC					; COMDAT

; 9545 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN1@soap_s2flo

; 9546 :   { if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@soap_s2flo

; 9547 :       return soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
	mov	eax, 4
	jmp	$LN13@soap_s2flo
$LN11@soap_s2flo:

; 9548 :     if (!soap_tag_cmp(s, "INF"))

	push	OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_s2flo

; 9549 :       *p = FLT_PINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __real@7f7fffff
	fstp	DWORD PTR [eax]
	jmp	$LN1@soap_s2flo
$LN10@soap_s2flo:

; 9550 :     else if (!soap_tag_cmp(s, "+INF"))

	push	OFFSET ??_C@_04LFPHEJAJ@?$CLINF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_s2flo

; 9551 :       *p = FLT_PINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __real@7f7fffff
	fstp	DWORD PTR [eax]
	jmp	$LN1@soap_s2flo
$LN8@soap_s2flo:

; 9552 :     else if (!soap_tag_cmp(s, "-INF"))

	push	OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_s2flo

; 9553 :       *p = FLT_NINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __real@ff7fffff
	fstp	DWORD PTR [eax]
	jmp	SHORT $LN1@soap_s2flo
$LN6@soap_s2flo:

; 9554 :     else if (!soap_tag_cmp(s, "NaN"))

	push	OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_s2flo

; 9555 :       *p = FLT_NAN;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _soap_double_nan
	fstp	DWORD PTR [eax]

; 9556 :     else

	jmp	SHORT $LN1@soap_s2flo
$LN4@soap_s2flo:

; 9557 :     {
; 9558 : /* On some systems, strtof appears to be broken or doesn't link: use with caution */
; 9559 : #if defined(HAVE_STRTOF_L)
; 9560 :       char *r;
; 9561 :       *p = strtof_l((char*)s, &r, NULL);
; 9562 :       if (*r)
; 9563 : #elif defined(HAVE_STRTOD_L)
; 9564 :       char *r;
; 9565 :       *p = (float)strtod_l(s, &r, NULL);
; 9566 :       if (*r)
; 9567 : #elif defined(HAVE_STRTOF)
; 9568 :       char *r;
; 9569 :       *p = strtof((char*)s, &r);
; 9570 :       if (*r)
; 9571 : #elif defined(HAVE_STRTOD)
; 9572 :       char *r;
; 9573 :       *p = (float)strtod(s, &r);

	mov	esi, esp
	lea	eax, DWORD PTR _r$87307[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtod
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [edx]

; 9574 :       if (*r)

	mov	eax, DWORD PTR _r$87307[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@soap_s2flo

; 9575 : #endif
; 9576 : #if defined(HAVE_SSCANF_L)
; 9577 :         if (sscanf_l(s, NULL, "%g", p) != 1)
; 9578 :           soap->error = SOAP_TYPE;
; 9579 : #elif defined(HAVE_SSCANF)
; 9580 :         if (sscanf(s, "%g", p) != 1)

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_02BEIEFPIG@?$CFg?$AA@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	je	SHORT $LN1@soap_s2flo

; 9581 :           soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN1@soap_s2flo:

; 9582 : #else
; 9583 :         soap->error = SOAP_TYPE;
; 9584 : #endif
; 9585 :     }
; 9586 :   }
; 9587 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN13@soap_s2flo:

; 9588 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@soap_s2flo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@soap_s2flo:
	DD	1
	DD	$LN16@soap_s2flo
$LN16@soap_s2flo:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN15@soap_s2flo
$LN15@soap_s2flo:
	DB	114					; 00000072H
	DB	0
_soap_s2float ENDP
_TEXT	ENDS
PUBLIC	_soap_infloat
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_infloat
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_infloat PROC					; COMDAT

; 9625 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inflo

; 9626 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inflo
$LN7@soap_inflo:

; 9627 : #ifndef WITH_LEAN
; 9628 :   if (*soap->type != '\0' && soap_isnumeric(soap, type))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_inflo
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_isnumeric
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inflo

; 9629 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inflo
$LN6@soap_inflo:

; 9630 : #endif
; 9631 :   p = (float*)soap_id_enter(soap, soap->id, p, t, sizeof(float), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9632 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inflo

; 9633 :     p = (float*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(float), 0, NULL);

	push	0
	push	0
	push	4
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inflo
$LN5@soap_inflo:

; 9634 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inflo

; 9635 :   { if (soap_s2float(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2float
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inflo

; 9636 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inflo
$LN4@soap_inflo:

; 9637 :   }
; 9638 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inflo
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inflo

; 9639 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inflo
$LN1@soap_inflo:

; 9640 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inflo:

; 9641 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_infloat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@		; `string'
PUBLIC	??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@		; `string'
PUBLIC	??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@		; `string'
PUBLIC	??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@		; `string'
PUBLIC	??_C@_08HMJFKOLE@?3decimal?$AA@			; `string'
PUBLIC	??_C@_07PBNBEHML@?3double?$AA@			; `string'
PUBLIC	??_C@_06INOMFGCG@?3float?$AA@			; `string'
;	COMDAT ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
CONST	SEGMENT
??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@ DB ':unsignedByte', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
CONST	SEGMENT
??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@ DB ':unsignedShort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
CONST	SEGMENT
??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@ DB ':unsignedInt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
CONST	SEGMENT
??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@ DB ':unsignedLong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMJFKOLE@?3decimal?$AA@
CONST	SEGMENT
??_C@_08HMJFKOLE@?3decimal?$AA@ DB ':decimal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBNBEHML@?3double?$AA@
CONST	SEGMENT
??_C@_07PBNBEHML@?3double?$AA@ DB ':double', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06INOMFGCG@?3float?$AA@
CONST	SEGMENT
??_C@_06INOMFGCG@?3float?$AA@ DB ':float', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_isnumeric
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_soap_isnumeric PROC					; COMDAT

; 9594 : { if (soap_match_tag(soap, soap->type, type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9595 :    && soap_match_tag(soap, soap->type, ":float")
; 9596 :    && soap_match_tag(soap, soap->type, ":double")
; 9597 :    && soap_match_tag(soap, soap->type, ":decimal")
; 9598 :    && soap_match_tag(soap, soap->type, ":integer")
; 9599 :    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 9600 :    && soap_match_tag(soap, soap->type, ":negativeInteger")
; 9601 :    && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
; 9602 :    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 9603 :    && soap_match_tag(soap, soap->type, ":long")
; 9604 :    && soap_match_tag(soap, soap->type, ":int")
; 9605 :    && soap_match_tag(soap, soap->type, ":short")
; 9606 :    && soap_match_tag(soap, soap->type, ":byte")
; 9607 :    && soap_match_tag(soap, soap->type, ":unsignedLong")
; 9608 :    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 9609 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9610 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_06INOMFGCG@?3float?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_07PBNBEHML@?3double?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_08HMJFKOLE@?3decimal?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_08ICEBEHNK@?3integer?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_05LMKOBMME@?3long?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@soap_isnum
	push	OFFSET ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_isnum

; 9611 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9612 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9613 :     return SOAP_ERR;

	or	eax, -1
	jmp	SHORT $LN2@soap_isnum
$LN1@soap_isnum:

; 9614 :   }
; 9615 :   return SOAP_OK;

	xor	eax, eax
$LN2@soap_isnum:

; 9616 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_isnumeric ENDP
_TEXT	ENDS
PUBLIC	__real@ffefffffffffffff
PUBLIC	__real@7fefffffffffffff
PUBLIC	_soap_double2s
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_double2s
_TEXT	SEGMENT
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 8
_soap_double2s PROC					; COMDAT

; 9650 : { char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9651 :   if (soap_isnan(n))

	mov	esi, esp
	sub	esp, 8
	fld	QWORD PTR _n$[ebp]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp___isnan
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN4@soap_doubl

; 9652 :     return "NaN";

	mov	eax, OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	jmp	$LN5@soap_doubl
$LN4@soap_doubl:

; 9653 :   if (soap_ispinfd(n))

	fld	QWORD PTR __real@7fefffffffffffff
	fcomp	QWORD PTR _n$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN3@soap_doubl

; 9654 :     return "INF";

	mov	eax, OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	jmp	SHORT $LN5@soap_doubl
$LN3@soap_doubl:

; 9655 :   if (soap_isninfd(n))

	fld	QWORD PTR __real@ffefffffffffffff
	fcomp	QWORD PTR _n$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN2@soap_doubl

; 9656 :     return "-INF";

	mov	eax, OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	jmp	SHORT $LN5@soap_doubl
$LN2@soap_doubl:

; 9657 :   s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$[ebp], eax

; 9658 : #if defined(HAVE_SPRINTF_L)
; 9659 :   sprintf_l(s, NULL, soap->double_format, n);
; 9660 : #else
; 9661 :   sprintf(s, soap->double_format, n);

	mov	esi, esp
	sub	esp, 8
	fld	QWORD PTR _n$[ebp]
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9662 :   s = strchr(s, ',');	/* convert decimal comma to DP */

	push	44					; 0000002cH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 9663 :   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN1@soap_doubl

; 9664 :     *s = '.';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
$LN1@soap_doubl:

; 9665 : #endif
; 9666 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
$LN5@soap_doubl:

; 9667 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_double2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outdouble
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outdouble
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outdouble PROC					; COMDAT

; 9676 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9677 :    || soap_string_out(soap, soap_double2s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outdo
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	sub	esp, 8
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_double2s
	add	esp, 12					; 0000000cH
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outdo
$LN1@soap_outdo:

; 9678 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outdo
$LN2@soap_outdo:

; 9679 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outdo:

; 9680 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outdouble ENDP
_TEXT	ENDS
PUBLIC	??_C@_03CCCGLAML@?$CFlg?$AA@			; `string'
PUBLIC	_soap_s2double
;	COMDAT ??_C@_03CCCGLAML@?$CFlg?$AA@
CONST	SEGMENT
??_C@_03CCCGLAML@?$CFlg?$AA@ DB '%lg', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_s2double
_TEXT	SEGMENT
_r$87378 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2double PROC					; COMDAT

; 9689 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN1@soap_s2dou

; 9690 :   { if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@soap_s2dou

; 9691 :       return soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
	mov	eax, 4
	jmp	$LN13@soap_s2dou
$LN11@soap_s2dou:

; 9692 :     if (!soap_tag_cmp(s, "INF"))

	push	OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_s2dou

; 9693 :       *p = DBL_PINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	QWORD PTR __real@7fefffffffffffff
	fstp	QWORD PTR [eax]
	jmp	$LN1@soap_s2dou
$LN10@soap_s2dou:

; 9694 :     else if (!soap_tag_cmp(s, "+INF"))

	push	OFFSET ??_C@_04LFPHEJAJ@?$CLINF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_s2dou

; 9695 :       *p = DBL_PINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	QWORD PTR __real@7fefffffffffffff
	fstp	QWORD PTR [eax]
	jmp	$LN1@soap_s2dou
$LN8@soap_s2dou:

; 9696 :     else if (!soap_tag_cmp(s, "-INF"))

	push	OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_s2dou

; 9697 :       *p = DBL_NINFTY;

	mov	eax, DWORD PTR _p$[ebp]
	fld	QWORD PTR __real@ffefffffffffffff
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN1@soap_s2dou
$LN6@soap_s2dou:

; 9698 :     else if (!soap_tag_cmp(s, "NaN"))

	push	OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_s2dou

; 9699 :       *p = DBL_NAN;

	mov	eax, DWORD PTR _p$[ebp]
	fld	QWORD PTR _soap_double_nan
	fstp	QWORD PTR [eax]

; 9700 :     else

	jmp	SHORT $LN1@soap_s2dou
$LN4@soap_s2dou:

; 9701 :     {
; 9702 : #if defined(HAVE_STRTOD_L)
; 9703 :       char *r;
; 9704 :       *p = strtod_l(s, &r, NULL);
; 9705 :       if (*r)
; 9706 : #elif defined(HAVE_STRTOD)
; 9707 :       char *r;
; 9708 :       *p = strtod(s, &r);

	mov	esi, esp
	lea	eax, DWORD PTR _r$87378[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtod
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	fstp	QWORD PTR [edx]

; 9709 :       if (*r)

	mov	eax, DWORD PTR _r$87378[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@soap_s2dou

; 9710 : #endif
; 9711 : #if defined(HAVE_SSCANF_L)
; 9712 :         if (sscanf_l(s, NULL, "%lg", p) != 1)
; 9713 :           soap->error = SOAP_TYPE;
; 9714 : #elif defined(HAVE_SSCANF)
; 9715 :         if (sscanf(s, "%lg", p) != 1)

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_03CCCGLAML@?$CFlg?$AA@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	je	SHORT $LN1@soap_s2dou

; 9716 :           soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN1@soap_s2dou:

; 9717 : #else
; 9718 :         soap->error = SOAP_TYPE;
; 9719 : #endif
; 9720 :     }
; 9721 :   }
; 9722 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN13@soap_s2dou:

; 9723 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@soap_s2dou
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@soap_s2dou:
	DD	1
	DD	$LN16@soap_s2dou
$LN16@soap_s2dou:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN15@soap_s2dou
$LN15@soap_s2dou:
	DB	114					; 00000072H
	DB	0
_soap_s2double ENDP
_TEXT	ENDS
PUBLIC	_soap_indouble
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_indouble
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_indouble PROC					; COMDAT

; 9732 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_indou

; 9733 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_indou
$LN7@soap_indou:

; 9734 : #ifndef WITH_LEAN
; 9735 :   if (*soap->type != '\0' && soap_isnumeric(soap, type))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_indou
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_isnumeric
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_indou

; 9736 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_indou
$LN6@soap_indou:

; 9737 : #endif
; 9738 :   p = (double*)soap_id_enter(soap, soap->id, p, t, sizeof(double), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	8
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9739 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_indou

; 9740 :     p = (double*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(double), 0, NULL);

	push	0
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_indou
$LN5@soap_indou:

; 9741 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_indou

; 9742 :   { if (soap_s2double(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2double
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_indou

; 9743 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_indou
$LN4@soap_indou:

; 9744 :   }
; 9745 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_indou
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_indou

; 9746 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_indou
$LN1@soap_indou:

; 9747 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_indou:

; 9748 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_indouble ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedLong2s
PUBLIC	_soap_unsignedByte2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_unsignedByte2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 1
_soap_unsignedByte2s PROC				; COMDAT

; 9757 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	eax, BYTE PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_unsignedLong2s
	add	esp, 8

; 9758 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_unsignedByte2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedByte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outunsignedByte
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outunsignedByte PROC				; COMDAT

; 9767 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9768 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outun
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_unsignedLong2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outun
$LN1@soap_outun:

; 9769 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outun
$LN2@soap_outun:

; 9770 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outun:

; 9771 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outunsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedByte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2unsignedByte
_TEXT	SEGMENT
_r$87423 = -20						; size = 4
_n$87422 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2unsignedByte PROC				; COMDAT

; 9780 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_s2uns

; 9781 :   { unsigned long n;
; 9782 :     char *r;
; 9783 :     n = soap_strtoul(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87423[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$87422[ebp], eax

; 9784 :     if (s == r || *r || n > 255)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87423[ebp]
	je	SHORT $LN1@soap_s2uns
	mov	eax, DWORD PTR _r$87423[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@soap_s2uns
	cmp	DWORD PTR _n$87422[ebp], 255		; 000000ffH
	jbe	SHORT $LN2@soap_s2uns
$LN1@soap_s2uns:

; 9785 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2uns:

; 9786 :     *p = (unsigned char)n;

	mov	ecx, DWORD PTR _n$87422[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx], al
$LN3@soap_s2uns:

; 9787 :   }
; 9788 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9789 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_s2uns
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@soap_s2uns:
	DD	1
	DD	$LN7@soap_s2uns
$LN7@soap_s2uns:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@soap_s2uns
$LN6@soap_s2uns:
	DB	114					; 00000072H
	DB	0
_soap_s2unsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedByte
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inunsignedByte
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedByte PROC				; COMDAT

; 9798 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inuns

; 9799 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns
$LN7@soap_inuns:

; 9800 : #ifndef WITH_LEAN
; 9801 :   if (*soap->type
; 9802 :    && soap_match_tag(soap, soap->type, type)
; 9803 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_inuns
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns

; 9804 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9805 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9806 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns
$LN6@soap_inuns:

; 9807 :   }
; 9808 : #endif
; 9809 :   p = (unsigned char*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned char), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9810 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inuns

; 9811 :     p = (unsigned char*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned char), 0, NULL);

	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inuns
$LN5@soap_inuns:

; 9812 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inuns

; 9813 :   { if (soap_s2unsignedByte(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2unsignedByte
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inuns

; 9814 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns
$LN4@soap_inuns:

; 9815 :   }
; 9816 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inuns
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inuns

; 9817 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns
$LN1@soap_inuns:

; 9818 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inuns:

; 9819 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inunsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedShort2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_unsignedShort2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 2
_soap_unsignedShort2s PROC				; COMDAT

; 9828 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_unsignedLong2s
	add	esp, 8

; 9829 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_unsignedShort2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedShort
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outunsignedShort
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outunsignedShort PROC				; COMDAT

; 9838 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9839 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outun@2
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_unsignedLong2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outun@2
$LN1@soap_outun@2:

; 9840 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outun@2
$LN2@soap_outun@2:

; 9841 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outun@2:

; 9842 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outunsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedShort
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2unsignedShort
_TEXT	SEGMENT
_r$87468 = -20						; size = 4
_n$87467 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2unsignedShort PROC				; COMDAT

; 9851 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_s2uns@2

; 9852 :   { unsigned long n;
; 9853 :     char *r;
; 9854 :     n = soap_strtoul(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87468[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$87467[ebp], eax

; 9855 :     if (s == r || *r || n > 65535)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87468[ebp]
	je	SHORT $LN1@soap_s2uns@2
	mov	eax, DWORD PTR _r$87468[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@soap_s2uns@2
	cmp	DWORD PTR _n$87467[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN2@soap_s2uns@2
$LN1@soap_s2uns@2:

; 9856 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2uns@2:

; 9857 :     *p = (unsigned short)n;

	mov	ecx, DWORD PTR _n$87467[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	WORD PTR [ecx], ax
$LN3@soap_s2uns@2:

; 9858 :   }
; 9859 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9860 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_s2uns@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@soap_s2uns@2:
	DD	1
	DD	$LN7@soap_s2uns@2
$LN7@soap_s2uns@2:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@soap_s2uns@2
$LN6@soap_s2uns@2:
	DB	114					; 00000072H
	DB	0
_soap_s2unsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedShort
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inunsignedShort
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedShort PROC				; COMDAT

; 9869 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inuns@2

; 9870 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@2
$LN7@soap_inuns@2:

; 9871 : #ifndef WITH_LEAN
; 9872 :   if (*soap->type
; 9873 :    && soap_match_tag(soap, soap->type, type)
; 9874 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9875 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_inuns@2
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2
	push	OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2

; 9876 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9877 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9878 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@2
$LN6@soap_inuns@2:

; 9879 :   }
; 9880 : #endif
; 9881 :   p = (unsigned short*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned short), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9882 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inuns@2

; 9883 :     p = (unsigned short*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned short), 0, NULL);

	push	0
	push	0
	push	2
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inuns@2
$LN5@soap_inuns@2:

; 9884 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inuns@2

; 9885 :   { if (soap_s2unsignedShort(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2unsignedShort
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inuns@2

; 9886 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@2
$LN4@soap_inuns@2:

; 9887 :   }
; 9888 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inuns@2
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inuns@2

; 9889 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@2
$LN1@soap_inuns@2:

; 9890 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inuns@2:

; 9891 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inunsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedInt2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_unsignedInt2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_unsignedInt2s PROC				; COMDAT

; 9900 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_unsignedLong2s
	add	esp, 8

; 9901 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_unsignedInt2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedInt
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outunsignedInt
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outunsignedInt PROC				; COMDAT

; 9910 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9911 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outun@3
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_unsignedLong2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outun@3
$LN1@soap_outun@3:

; 9912 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outun@3
$LN2@soap_outun@3:

; 9913 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outun@3:

; 9914 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outunsignedInt ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedInt
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2unsignedInt
_TEXT	SEGMENT
_r$87512 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2unsignedInt PROC				; COMDAT

; 9923 : { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_s2uns@3

; 9924 :   { char *r;
; 9925 : #ifndef WITH_NOIO
; 9926 : #ifndef WITH_LEAN
; 9927 :     soap_reset_errno;

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9928 : #endif
; 9929 : #endif
; 9930 :     *p = (unsigned int)soap_strtoul(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87512[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 9931 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9932 : #ifndef WITH_NOIO
; 9933 : #ifndef WITH_LEAN
; 9934 :      || soap_errno == SOAP_ERANGE
; 9935 : #endif
; 9936 : #endif
; 9937 :    )

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87512[ebp]
	jne	SHORT $LN1@soap_s2uns@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN2@soap_s2uns@3
$LN1@soap_s2uns@3:
	mov	eax, DWORD PTR _r$87512[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@soap_s2uns@3
	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN4@soap_s2uns@3
$LN2@soap_s2uns@3:

; 9938 :       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN4@soap_s2uns@3:

; 9939 :   }
; 9940 :   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 9941 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_s2uns@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@soap_s2uns@3:
	DD	1
	DD	$LN8@soap_s2uns@3
$LN8@soap_s2uns@3:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN7@soap_s2uns@3
$LN7@soap_s2uns@3:
	DB	114					; 00000072H
	DB	0
_soap_s2unsignedInt ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedInt
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inunsignedInt
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedInt PROC				; COMDAT

; 9950 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inuns@3

; 9951 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@3
$LN7@soap_inuns@3:

; 9952 : #ifndef WITH_LEAN
; 9953 :   if (*soap->type
; 9954 :    && soap_match_tag(soap, soap->type, type)
; 9955 :    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 9956 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9957 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inuns@3
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3
	push	OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3
	push	OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3

; 9958 :   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 9959 :     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 9960 :     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@3
$LN6@soap_inuns@3:

; 9961 :   }
; 9962 : #endif
; 9963 :   p = (unsigned int*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned int), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 9964 :   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inuns@3

; 9965 :     p = (unsigned int*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned int), 0, NULL);

	push	0
	push	0
	push	4
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inuns@3
$LN5@soap_inuns@3:

; 9966 :   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inuns@3

; 9967 :   { if (soap_s2unsignedInt(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2unsignedInt
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inuns@3

; 9968 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@3
$LN4@soap_inuns@3:

; 9969 :   }
; 9970 :   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inuns@3
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inuns@3

; 9971 :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@3
$LN1@soap_inuns@3:

; 9972 :   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inuns@3:

; 9973 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inunsignedInt ENDP
_TEXT	ENDS
PUBLIC	??_C@_03FKNCMABI@?$CFlu?$AA@			; `string'
;	COMDAT ??_C@_03FKNCMABI@?$CFlu?$AA@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu?$AA@ DB '%lu', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_unsignedLong2s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_unsignedLong2s PROC				; COMDAT

; 9982 : { sprintf(soap->tmpbuf, "%lu", n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9983 :   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 9984 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_unsignedLong2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedLong
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outunsignedLong
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outunsignedLong PROC				; COMDAT

; 9993 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9994 :    || soap_string_out(soap, soap_unsignedLong2s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outun@4
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_unsignedLong2s
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outun@4
$LN1@soap_outun@4:

; 9995 :     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outun@4
$LN2@soap_outun@4:

; 9996 :   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outun@4:

; 9997 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outunsignedLong ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedLong
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2unsignedLong
_TEXT	SEGMENT
_r$87556 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2unsignedLong PROC				; COMDAT

; 10006: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_s2uns@4

; 10007:   { char *r;
; 10008: #ifndef WITH_NOIO
; 10009: #ifndef WITH_LEAN
; 10010:     soap_reset_errno;

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10011: #endif
; 10012: #endif
; 10013:     *p = soap_strtoul(s, &r, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$87556[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 10014:     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 10015: #ifndef WITH_NOIO
; 10016: #ifndef WITH_LEAN
; 10017:      || soap_errno == SOAP_ERANGE
; 10018: #endif
; 10019: #endif
; 10020:    )

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _r$87556[ebp]
	jne	SHORT $LN1@soap_s2uns@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN2@soap_s2uns@4
$LN1@soap_s2uns@4:
	mov	eax, DWORD PTR _r$87556[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@soap_s2uns@4
	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN4@soap_s2uns@4
$LN2@soap_s2uns@4:

; 10021:       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN4@soap_s2uns@4:

; 10022:   }
; 10023:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 10024: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@soap_s2uns@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@soap_s2uns@4:
	DD	1
	DD	$LN8@soap_s2uns@4
$LN8@soap_s2uns@4:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN7@soap_s2uns@4
$LN7@soap_s2uns@4:
	DB	114					; 00000072H
	DB	0
_soap_s2unsignedLong ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedLong
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inunsignedLong
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedLong PROC				; COMDAT

; 10033: { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inuns@4

; 10034:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@4
$LN7@soap_inuns@4:

; 10035: #ifndef WITH_LEAN
; 10036:   if (*soap->type
; 10037:    && soap_match_tag(soap, soap->type, type)
; 10038:    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 10039:    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 10040:    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inuns@4
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4
	push	OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4
	push	OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4

; 10041:   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 10042:     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 10043:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inuns@4
$LN6@soap_inuns@4:

; 10044:   }
; 10045: #endif
; 10046:   p = (unsigned long*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned long), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 10047:   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inuns@4

; 10048:     p = (unsigned long*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned long), 0, NULL);

	push	0
	push	0
	push	4
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inuns@4
$LN5@soap_inuns@4:

; 10049:   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inuns@4

; 10050:   { if (soap_s2unsignedLong(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2unsignedLong
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inuns@4

; 10051:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@4
$LN4@soap_inuns@4:

; 10052:   }
; 10053:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inuns@4
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inuns@4

; 10054:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inuns@4
$LN1@soap_inuns@4:

; 10055:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inuns@4:

; 10056: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inunsignedLong ENDP
_TEXT	ENDS
PUBLIC	??_C@_05OINFJHGD@?$CFI64u?$AA@			; `string'
PUBLIC	_soap_ULONG642s
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u?$AA@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u?$AA@ DB '%I64u', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_ULONG642s
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_n$ = 12						; size = 8
_soap_ULONG642s PROC					; COMDAT

; 10065: { sprintf(soap->tmpbuf, SOAP_ULONG_FORMAT, n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10066:   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 10067: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_ULONG642s ENDP
_TEXT	ENDS
PUBLIC	_soap_outULONG64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outULONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outULONG64 PROC					; COMDAT

; 10076: { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10077:    || soap_string_out(soap, soap_ULONG642s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outUL
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_ULONG642s
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outUL
$LN1@soap_outUL:

; 10078:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outUL
$LN2@soap_outUL:

; 10079:   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outUL:

; 10080: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_s2ULONG64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2ULONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2ULONG64 PROC					; COMDAT

; 10089: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN2@soap_s2ULO

; 10090:   {
; 10091: #ifdef HAVE_STRTOULL
; 10092:     char *r;
; 10093: #ifndef WITH_NOIO
; 10094: #ifndef WITH_LEAN
; 10095:     soap_reset_errno;
; 10096: #endif
; 10097: #endif
; 10098:     *p = strtoull(s, &r, 10);
; 10099:     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 10100: #ifndef WITH_NOIO
; 10101: #ifndef WITH_LEAN
; 10102:        || soap_errno == SOAP_ERANGE
; 10103: #endif
; 10104: #endif
; 10105:      )
; 10106: #else
; 10107: #ifdef HAVE_SSCANF
; 10108:     if (sscanf(s, SOAP_ULONG_FORMAT, p) != 1)

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	je	SHORT $LN2@soap_s2ULO

; 10109: #endif
; 10110: #endif
; 10111:       soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4
$LN2@soap_s2ULO:

; 10112:   }
; 10113:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 10114: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2ULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_inULONG64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inULONG64
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inULONG64 PROC					; COMDAT

; 10123: { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_inULO

; 10124:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inULO
$LN7@soap_inULO:

; 10125:   if (*soap->type
; 10126:    && soap_match_tag(soap, soap->type, type)
; 10127:    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 10128:    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 10129:    && soap_match_tag(soap, soap->type, ":unsignedLong")
; 10130:    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 10131:    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 10132:    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	$LN6@soap_inULO
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inULO
	push	OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inULO
	push	OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@soap_inULO
	push	OFFSET ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inULO
	push	OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inULO
	push	OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inULO
	push	OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_inULO

; 10133:   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 10134:     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 10135:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_inULO
$LN6@soap_inULO:

; 10136:   }
; 10137:   p = (ULONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(ULONG64), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	8
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 10138:   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_inULO

; 10139:     p = (ULONG64*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(ULONG64), 0, NULL);

	push	0
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_inULO
$LN5@soap_inULO:

; 10140:   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_inULO

; 10141:   { if (soap_s2ULONG64(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2ULONG64
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_inULO

; 10142:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inULO
$LN4@soap_inULO:

; 10143:   }
; 10144:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inULO
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inULO

; 10145:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_inULO
$LN1@soap_inULO:

; 10146:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_inULO:

; 10147: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_s2string
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2string
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_s2string PROC					; COMDAT

; 10156: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@soap_s2str

; 10157:   { if (!(*t = soap_strdup(soap, s)))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@soap_s2str

; 10158:       return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	SHORT $LN4@soap_s2str
$LN3@soap_s2str:

; 10159:     if (!(soap->mode & (SOAP_ENC_LATIN | SOAP_C_UTFSTRING)))
; 10160:     { /* TODO: consider truncating UTF8 to ASCII for regular XML attribute strings? */
; 10161:     }
; 10162:   }
; 10163:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN4@soap_s2str:

; 10164: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@LOHKEFCD@?5into?5?8?$CFs?8?6?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_02JMMFPCED@?$CC?$CC?$AA@			; `string'
PUBLIC	??_C@_0DK@BPPGDDFN@?6Namespace?5prefix?5of?5?8?$CFs?8?5not?5de@ ; `string'
PUBLIC	??_C@_04FNFHGAAP@xml?3?$AA@			; `string'
PUBLIC	??_C@_0CH@CBEOGFEI@Normalized?5namespace?$CIs?$CJ?5of?5QName@ ; `string'
;	COMDAT ??_C@_0M@LOHKEFCD@?5into?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0M@LOHKEFCD@?5into?5?8?$CFs?8?6?$AA@ DB ' into ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFPCED@?$CC?$CC?$AA@
CONST	SEGMENT
??_C@_02JMMFPCED@?$CC?$CC?$AA@ DB '""', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BPPGDDFN@?6Namespace?5prefix?5of?5?8?$CFs?8?5not?5de@
CONST	SEGMENT
??_C@_0DK@BPPGDDFN@?6Namespace?5prefix?5of?5?8?$CFs?8?5not?5de@ DB 0aH, 'N'
	DB	'amespace prefix of ''%s'' not defined (index=%d, URI=%s)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNFHGAAP@xml?3?$AA@
CONST	SEGMENT
??_C@_04FNFHGAAP@xml?3?$AA@ DB 'xml:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CBEOGFEI@Normalized?5namespace?$CIs?$CJ?5of?5QName@
CONST	SEGMENT
??_C@_0CH@CBEOGFEI@Normalized?5namespace?$CIs?$CJ?5of?5QName@ DB 'Normali'
	DB	'zed namespace(s) of QNames ''%s''', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_s2QName
_TEXT	SEGMENT
tv211 = -292						; size = 4
_fdebug$87687 = -92					; size = 4
_fdebug$87677 = -80					; size = 4
_q$87668 = -68						; size = 4
_k$87657 = -56						; size = 4
_p$87643 = -44						; size = 4
_np$87642 = -32						; size = 4
_n$87641 = -20						; size = 4
_fdebug$87636 = -8					; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_s2QName PROC					; COMDAT

; 10173: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN36@soap_s2QNa

; 10174:   { soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0

; 10175:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Normalized namespace(s) of QNames '%s'", s));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN30@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN34@soap_s2QNa
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN34@soap_s2QNa:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN30@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$87636[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@CBEOGFEI@Normalized?5namespace?$CIs?$CJ?5of?5QName@
	mov	ecx, DWORD PTR _fdebug$87636[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$87636[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@soap_s2QNa:

; 10176:     /* convert (by prefix normalize prefix) all QNames in s */
; 10177:     for (;;)
; 10178:     { size_t n;
; 10179:       struct soap_nlist *np;
; 10180:       register const char *p;
; 10181:       /* skip blanks */
; 10182:       while (*s && soap_blank(*s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN29@soap_s2QNa
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN29@soap_s2QNa
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN29@soap_s2QNa

; 10183:         s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN30@soap_s2QNa
$LN29@soap_s2QNa:

; 10184:       if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN28@soap_s2QNa

; 10185:         break;

	jmp	$LN31@soap_s2QNa
$LN28@soap_s2QNa:

; 10186:       /* find next QName */
; 10187:       n = 1;

	mov	DWORD PTR _n$87641[ebp], 1
$LN27@soap_s2QNa:

; 10188:       while (s[n] && !soap_blank(s[n]))

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87641[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN26@soap_s2QNa
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87641[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN25@soap_s2QNa
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87641[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN26@soap_s2QNa
$LN25@soap_s2QNa:

; 10189:         n++;

	mov	eax, DWORD PTR _n$87641[ebp]
	add	eax, 1
	mov	DWORD PTR _n$87641[ebp], eax
	jmp	SHORT $LN27@soap_s2QNa
$LN26@soap_s2QNa:

; 10190:       np = soap->nlist;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _np$87642[ebp], ecx

; 10191:       /* if there is no namespace stack, or prefix is "xml" then copy string */
; 10192:       if (!np || !strncmp(s, "xml:", 4))

	cmp	DWORD PTR _np$87642[ebp], 0
	je	SHORT $LN23@soap_s2QNa
	mov	esi, esp
	push	4
	push	OFFSET ??_C@_04FNFHGAAP@xml?3?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN24@soap_s2QNa
$LN23@soap_s2QNa:

; 10193:       { soap_append_lab(soap, s, n);

	mov	eax, DWORD PTR _n$87641[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10194:       }
; 10195:       else /* we normalize the QName by replacing its prefix */

	jmp	$LN22@soap_s2QNa
$LN24@soap_s2QNa:

; 10196:       { p = strchr(s, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _p$87643[ebp], eax

; 10197:         if (p)

	cmp	DWORD PTR _p$87643[ebp], 0
	je	SHORT $LN16@soap_s2QNa

; 10198:         { size_t k = p - s;

	mov	eax, DWORD PTR _p$87643[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _k$87657[ebp], eax
$LN20@soap_s2QNa:

; 10199:           while (np && (strncmp(np->id, s, k) || np->id[k]))

	cmp	DWORD PTR _np$87642[ebp], 0
	je	SHORT $LN19@soap_s2QNa
	mov	esi, esp
	mov	eax, DWORD PTR _k$87657[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _np$87642[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN18@soap_s2QNa
	mov	eax, DWORD PTR _np$87642[ebp]
	add	eax, DWORD PTR _k$87657[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN19@soap_s2QNa
$LN18@soap_s2QNa:

; 10200:             np = np->next;

	mov	eax, DWORD PTR _np$87642[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$87642[ebp], ecx
	jmp	SHORT $LN20@soap_s2QNa
$LN19@soap_s2QNa:

; 10201:           p++;

	mov	eax, DWORD PTR _p$87643[ebp]
	add	eax, 1
	mov	DWORD PTR _p$87643[ebp], eax

; 10202:         }
; 10203:         else

	jmp	SHORT $LN17@soap_s2QNa
$LN16@soap_s2QNa:

; 10204:         { while (np && *np->id)

	cmp	DWORD PTR _np$87642[ebp], 0
	je	SHORT $LN15@soap_s2QNa
	mov	eax, DWORD PTR _np$87642[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN15@soap_s2QNa

; 10205:             np = np->next;

	mov	eax, DWORD PTR _np$87642[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _np$87642[ebp], ecx
	jmp	SHORT $LN16@soap_s2QNa
$LN15@soap_s2QNa:

; 10206:           p = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$87643[ebp], eax
$LN17@soap_s2QNa:

; 10207:         }
; 10208:         /* replace prefix */
; 10209:         if (np)

	cmp	DWORD PTR _np$87642[ebp], 0
	je	$LN14@soap_s2QNa

; 10210:         { if (np->index >= 0 && soap->local_namespaces)

	mov	eax, DWORD PTR _np$87642[ebp]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	jl	SHORT $LN13@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN13@soap_s2QNa

; 10211:           { const char *q = soap->local_namespaces[np->index].id;

	mov	eax, DWORD PTR _np$87642[ebp]
	movsx	ecx, WORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _q$87668[ebp], ecx

; 10212:             if (q)

	cmp	DWORD PTR _q$87668[ebp], 0
	je	SHORT $LN12@soap_s2QNa

; 10213:               soap_append_lab(soap, q, strlen(q));

	mov	eax, DWORD PTR _q$87668[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _q$87668[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN12@soap_s2QNa:

; 10214:           }

	jmp	$LN11@soap_s2QNa
$LN13@soap_s2QNa:

; 10215:           else if (np->ns)

	mov	eax, DWORD PTR _np$87642[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN10@soap_s2QNa

; 10216:           { soap_append_lab(soap, "\"", 1);

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10217:             soap_append_lab(soap, np->ns, strlen(np->ns));

	mov	eax, DWORD PTR _np$87642[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _np$87642[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10218:             soap_append_lab(soap, "\"", 1);

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10219:           }
; 10220:           else

	jmp	$LN11@soap_s2QNa
$LN10@soap_s2QNa:

; 10221:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\nNamespace prefix of '%s' not defined (index=%d, URI=%s)\n", s, np->index, np->ns?np->ns:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN8@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_s2QNa
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_s2QNa:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$87677[ebp], ecx
	mov	eax, DWORD PTR _np$87642[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN39@soap_s2QNa
	mov	ecx, DWORD PTR _np$87642[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv211[ebp], edx
	jmp	SHORT $LN40@soap_s2QNa
$LN39@soap_s2QNa:
	mov	DWORD PTR tv211[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN40@soap_s2QNa:
	mov	esi, esp
	mov	eax, DWORD PTR tv211[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$87642[ebp]
	movsx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@BPPGDDFN@?6Namespace?5prefix?5of?5?8?$CFs?8?5not?5de@
	mov	ecx, DWORD PTR _fdebug$87677[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$87677[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_s2QNa:

; 10222:             return soap->error = SOAP_NAMESPACE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 9
	mov	eax, 9
	jmp	$LN37@soap_s2QNa
$LN11@soap_s2QNa:

; 10223:           }
; 10224:         }
; 10225:         else /* no namespace: assume default "" namespace */

	jmp	SHORT $LN5@soap_s2QNa
$LN14@soap_s2QNa:

; 10226:         { soap_append_lab(soap, "\"\"", 2);

	push	2
	push	OFFSET ??_C@_02JMMFPCED@?$CC?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN5@soap_s2QNa:

; 10227:         }
; 10228:         soap_append_lab(soap, ":", 1);

	push	1
	push	OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10229:         soap_append_lab(soap, p, n - (p-s));

	mov	eax, DWORD PTR _p$87643[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _n$87641[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _p$87643[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN22@soap_s2QNa:

; 10230:       }
; 10231:       /* advance to next and add spacing */
; 10232:       s += n;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87641[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 10233:       if (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@soap_s2QNa

; 10234:         soap_append_lab(soap, " ", 1);

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN4@soap_s2QNa:

; 10235:     }

	jmp	$LN30@soap_s2QNa
$LN31@soap_s2QNa:

; 10236:     soap_append_lab(soap, SOAP_STR_EOS, 1);

	push	1
	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10237:     *t = soap_strdup(soap, soap->labbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx], eax

; 10238:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, " into '%s'\n", *t));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN36@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_s2QNa
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_s2QNa:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN36@soap_s2QNa
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$87687[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0M@LOHKEFCD@?5into?5?8?$CFs?8?6?$AA@
	mov	edx, DWORD PTR _fdebug$87687[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$87687[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@soap_s2QNa:

; 10239:   }
; 10240:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
$LN37@soap_s2QNa:

; 10241: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2QName ENDP
_TEXT	ENDS
PUBLIC	??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@		; `string'
PUBLIC	_soap_QName2s
;	COMDAT ??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@
CONST	SEGMENT
??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@ DB 'xmlns:_%d', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_QName2s
_TEXT	SEGMENT
tv173 = -268						; size = 4
_r$87725 = -68						; size = 4
_p$87714 = -56						; size = 4
_q$87712 = -44						; size = 4
_r$87709 = -32						; size = 4
_n$87698 = -20						; size = 4
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_QName2s PROC					; COMDAT

; 10250: { const char *t = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _t$[ebp], 0

; 10251:   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN25@soap_QName

; 10252:   { soap->labidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12464], 0
$LN22@soap_QName:

; 10253:     for (;;)
; 10254:     { size_t n;
; 10255:       /* skip blanks */
; 10256:       while (*s && soap_blank(*s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN21@soap_QName
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN21@soap_QName
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN21@soap_QName

; 10257:         s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN22@soap_QName
$LN21@soap_QName:

; 10258:       if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN20@soap_QName

; 10259:         break;

	jmp	$LN23@soap_QName
$LN20@soap_QName:

; 10260:       /* find next QName */
; 10261:       n = 1;

	mov	DWORD PTR _n$87698[ebp], 1
$LN19@soap_QName:

; 10262:       while (s[n] && !soap_blank(s[n]))

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87698[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN18@soap_QName
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87698[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN17@soap_QName
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87698[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN18@soap_QName
$LN17@soap_QName:

; 10263:         n++;

	mov	eax, DWORD PTR _n$87698[ebp]
	add	eax, 1
	mov	DWORD PTR _n$87698[ebp], eax
	jmp	SHORT $LN19@soap_QName
$LN18@soap_QName:

; 10264:       /* normal prefix: pass string as is */
; 10265:       if (*s != '"')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN16@soap_QName

; 10266:       { soap_append_lab(soap, s, n);

	mov	eax, DWORD PTR _n$87698[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10267: #ifndef WITH_LEAN
; 10268:         if ((soap->mode & SOAP_XML_CANONICAL))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN15@soap_QName

; 10269:         { const char *r = strchr(s, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _r$87709[ebp], eax

; 10270:           if (r)

	cmp	DWORD PTR _r$87709[ebp], 0
	je	SHORT $LN15@soap_QName

; 10271:             soap_utilize_ns(soap, s, r - s);

	mov	eax, DWORD PTR _r$87709[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_utilize_ns
	add	esp, 12					; 0000000cH
$LN15@soap_QName:

; 10272:         }
; 10273: #endif
; 10274:       }
; 10275:       else /* URL-based string prefix */

	jmp	$LN13@soap_QName
$LN16@soap_QName:

; 10276:       { const char *q;
; 10277:         s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 10278:         q = strchr(s, '"');

	mov	esi, esp
	push	34					; 00000022H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _q$87712[ebp], eax

; 10279:         if (q)

	cmp	DWORD PTR _q$87712[ebp], 0
	je	$LN13@soap_QName

; 10280:         { struct Namespace *p = soap->local_namespaces;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _p$87714[ebp], ecx

; 10281:           if (p)

	cmp	DWORD PTR _p$87714[ebp], 0
	je	SHORT $LN11@soap_QName
	jmp	SHORT $LN10@soap_QName
$LN9@soap_QName:

; 10282:           { for (; p->id; p++)

	mov	eax, DWORD PTR _p$87714[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _p$87714[ebp], eax
$LN10@soap_QName:
	mov	eax, DWORD PTR _p$87714[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@soap_QName

; 10283:             { if (p->ns)

	mov	eax, DWORD PTR _p$87714[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN7@soap_QName

; 10284:                 if (!soap_tag_cmp(s, p->ns))

	mov	eax, DWORD PTR _p$87714[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@soap_QName

; 10285:                   break;

	jmp	SHORT $LN11@soap_QName
$LN7@soap_QName:

; 10286:               if (p->in)

	mov	eax, DWORD PTR _p$87714[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@soap_QName

; 10287:                 if (!soap_tag_cmp(s, p->in))

	mov	eax, DWORD PTR _p$87714[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@soap_QName

; 10288:                   break;

	jmp	SHORT $LN11@soap_QName
$LN5@soap_QName:

; 10289:             }

	jmp	SHORT $LN9@soap_QName
$LN11@soap_QName:

; 10290:           }
; 10291:           /* URL is in the namespace table? */
; 10292:           if (p && p->id)

	cmp	DWORD PTR _p$87714[ebp], 0
	je	SHORT $LN3@soap_QName
	mov	eax, DWORD PTR _p$87714[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@soap_QName

; 10293:           { soap_append_lab(soap, p->id, strlen(p->id));

	mov	eax, DWORD PTR _p$87714[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _p$87714[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10294:           }
; 10295:           else /* not in namespace table: create xmlns binding */

	jmp	$LN2@soap_QName
$LN3@soap_QName:

; 10296:           { char *r = soap_strdup(soap, s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _r$87725[ebp], eax

; 10297:             r[q-s] = '\0';

	mov	eax, DWORD PTR _q$87712[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _r$87725[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 10298:             sprintf(soap->tmpbuf, "xmlns:_%d", soap->idnum++);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12212]
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12212]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12212], eax
	mov	esi, esp
	mov	edx, DWORD PTR tv173[ebp]
	push	edx
	push	OFFSET ??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10299:             soap_set_attr(soap, soap->tmpbuf, r);

	mov	eax, DWORD PTR _r$87725[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_set_attr
	add	esp, 12					; 0000000cH

; 10300:             soap_append_lab(soap, soap->tmpbuf + 6, strlen(soap->tmpbuf + 6));

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79034				; 000134baH
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79034				; 000134baH
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN2@soap_QName:

; 10301:           }
; 10302:           soap_append_lab(soap, q + 1, n - (q-s) - 1);

	mov	eax, DWORD PTR _q$87712[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _n$87698[ebp]
	sub	ecx, eax
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _q$87712[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN13@soap_QName:

; 10303:         }
; 10304:       }
; 10305:       /* advance to next and add spacing */
; 10306:       s += n;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$87698[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 10307:       if (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@soap_QName

; 10308:         soap_append_lab(soap, " ", 1);

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH
$LN1@soap_QName:

; 10309:     }

	jmp	$LN22@soap_QName
$LN23@soap_QName:

; 10310:     soap_append_lab(soap, SOAP_STR_EOS, 1);

	push	1
	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_append_lab
	add	esp, 12					; 0000000cH

; 10311:     t = soap_strdup(soap, soap->labbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12456]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN25@soap_QName:

; 10312:   }
; 10313:   return t;

	mov	eax, DWORD PTR _t$[ebp]

; 10314: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_QName2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2wchar
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2wchar
_TEXT	SEGMENT
_c4$87751 = -68						; size = 4
_c3$87750 = -56						; size = 4
_c2$87749 = -44						; size = 4
_c1$87748 = -32						; size = 4
_c$87747 = -20						; size = 4
_r$87734 = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_s2wchar PROC					; COMDAT

; 10323: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN18@soap_s2wch

; 10324:   { wchar_t *r;
; 10325:     *t = r = (wchar_t*)soap_malloc(soap, sizeof(wchar_t) * (strlen(s) + 1));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _r$87734[ebp], eax
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	DWORD PTR [eax], ecx

; 10326:     if (!r)

	cmp	DWORD PTR _r$87734[ebp], 0
	jne	SHORT $LN17@soap_s2wch

; 10327:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN19@soap_s2wch
$LN17@soap_s2wch:

; 10328:     if (soap->mode & SOAP_ENC_LATIN)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN12@soap_s2wch
$LN15@soap_s2wch:

; 10329:     { while (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN14@soap_s2wch

; 10330:         *r++ = (wchar_t)*s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	cx, BYTE PTR [eax]
	mov	edx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _r$87734[ebp]
	add	eax, 2
	mov	DWORD PTR _r$87734[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	jmp	SHORT $LN15@soap_s2wch
$LN14@soap_s2wch:

; 10331:     }
; 10332:     else

	jmp	$LN13@soap_s2wch
$LN12@soap_s2wch:

; 10333:     { /* Convert UTF8 to wchar */
; 10334:       while (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN13@soap_s2wch

; 10335:       { register soap_wchar c, c1, c2, c3, c4;
; 10336:         c = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$87747[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10337:         if (c < 0x80)

	cmp	DWORD PTR _c$87747[ebp], 128		; 00000080H
	jge	SHORT $LN10@soap_s2wch

; 10338:           *r++ = (wchar_t)c;

	mov	ecx, DWORD PTR _c$87747[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx

; 10339:         else

	jmp	$LN9@soap_s2wch
$LN10@soap_s2wch:

; 10340:         { c1 = (soap_wchar)*s++ & 0x3F;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _c1$87748[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10341:           if (c < 0xE0)

	cmp	DWORD PTR _c$87747[ebp], 224		; 000000e0H
	jge	SHORT $LN8@soap_s2wch

; 10342:             *r++ = (wchar_t)(((soap_wchar)(c & 0x1F) << 6) | c1);

	mov	ecx, DWORD PTR _c$87747[ebp]
	and	ecx, 31					; 0000001fH
	shl	ecx, 6
	or	ecx, DWORD PTR _c1$87748[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx

; 10343:           else

	jmp	$LN9@soap_s2wch
$LN8@soap_s2wch:

; 10344:           { c2 = (soap_wchar)*s++ & 0x3F;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _c2$87749[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10345:             if (c < 0xF0)

	cmp	DWORD PTR _c$87747[ebp], 240		; 000000f0H
	jge	SHORT $LN6@soap_s2wch

; 10346:               *r++ = (wchar_t)(((soap_wchar)(c & 0x0F) << 12) | (c1 << 6) | c2);

	mov	ecx, DWORD PTR _c$87747[ebp]
	and	ecx, 15					; 0000000fH
	shl	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _c1$87748[ebp]
	shl	eax, 6
	or	ecx, eax
	or	ecx, DWORD PTR _c2$87749[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx

; 10347:             else

	jmp	$LN9@soap_s2wch
$LN6@soap_s2wch:

; 10348:             { c3 = (soap_wchar)*s++ & 0x3F;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _c3$87750[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10349:               if (c < 0xF8)

	cmp	DWORD PTR _c$87747[ebp], 248		; 000000f8H
	jge	SHORT $LN4@soap_s2wch

; 10350:                 *r++ = (wchar_t)(((soap_wchar)(c & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3);

	mov	ecx, DWORD PTR _c$87747[ebp]
	and	ecx, 7
	shl	ecx, 18					; 00000012H
	mov	eax, DWORD PTR _c1$87748[ebp]
	shl	eax, 12					; 0000000cH
	or	ecx, eax
	mov	edx, DWORD PTR _c2$87749[ebp]
	shl	edx, 6
	or	ecx, edx
	or	ecx, DWORD PTR _c3$87750[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx

; 10351:               else

	jmp	$LN9@soap_s2wch
$LN4@soap_s2wch:

; 10352:               { c4 = (soap_wchar)*s++ & 0x3F;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _c4$87751[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10353:                 if (c < 0xFC)

	cmp	DWORD PTR _c$87747[ebp], 252		; 000000fcH
	jge	SHORT $LN2@soap_s2wch

; 10354:                   *r++ = (wchar_t)(((soap_wchar)(c & 0x03) << 24) | (c1 << 18) | (c2 << 12) | (c3 << 6) | c4);

	mov	ecx, DWORD PTR _c$87747[ebp]
	and	ecx, 3
	shl	ecx, 24					; 00000018H
	mov	eax, DWORD PTR _c1$87748[ebp]
	shl	eax, 18					; 00000012H
	or	ecx, eax
	mov	edx, DWORD PTR _c2$87749[ebp]
	shl	edx, 12					; 0000000cH
	or	ecx, edx
	mov	eax, DWORD PTR _c3$87750[ebp]
	shl	eax, 6
	or	ecx, eax
	or	ecx, DWORD PTR _c4$87751[ebp]
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx

; 10355:                 else

	jmp	SHORT $LN9@soap_s2wch
$LN2@soap_s2wch:

; 10356:                   *r++ = (wchar_t)(((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(*s++ & 0x3F));

	mov	ecx, DWORD PTR _c$87747[ebp]
	and	ecx, 1
	shl	ecx, 30					; 0000001eH
	mov	eax, DWORD PTR _c1$87748[ebp]
	shl	eax, 24					; 00000018H
	or	ecx, eax
	mov	edx, DWORD PTR _c2$87749[ebp]
	shl	edx, 18					; 00000012H
	or	ecx, edx
	mov	eax, DWORD PTR _c3$87750[ebp]
	shl	eax, 12					; 0000000cH
	or	ecx, eax
	mov	edx, DWORD PTR _c4$87751[ebp]
	shl	edx, 6
	or	ecx, edx
	mov	eax, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [eax]
	and	edx, 63					; 0000003fH
	or	ecx, edx
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _r$87734[ebp]
	add	edx, 2
	mov	DWORD PTR _r$87734[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN9@soap_s2wch:

; 10357:               }
; 10358:             }
; 10359:           }
; 10360:         }
; 10361:       }

	jmp	$LN12@soap_s2wch
$LN13@soap_s2wch:

; 10362:     }
; 10363:     *r = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _r$87734[ebp]
	mov	WORD PTR [ecx], ax
$LN18@soap_s2wch:

; 10364:   }
; 10365:   return SOAP_OK;

	xor	eax, eax
$LN19@soap_s2wch:

; 10366: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2wchar ENDP
_TEXT	ENDS
PUBLIC	_soap_wchar2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_wchar2s
_TEXT	SEGMENT
tv79 = -256						; size = 4
tv66 = -256						; size = 4
_n$ = -56						; size = 4
_q$ = -44						; size = 4
_t$ = -32						; size = 4
_r$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_wchar2s PROC					; COMDAT

; 10375: { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10376:   register char *r, *t;
; 10377:   const wchar_t *q = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _q$[ebp], eax

; 10378:   size_t n = 0;

	mov	DWORD PTR _n$[ebp], 0
$LN17@soap_wchar:

; 10379:   while ((c = *q++))

	mov	eax, DWORD PTR _q$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR _q$[ebp]
	add	eax, 2
	mov	DWORD PTR _q$[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN16@soap_wchar

; 10380:   { if (c > 0 && c < 0x80)

	cmp	DWORD PTR _c$[ebp], 0
	jle	SHORT $LN15@soap_wchar
	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jge	SHORT $LN15@soap_wchar

; 10381:       n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 10382:     else

	jmp	SHORT $LN14@soap_wchar
$LN15@soap_wchar:

; 10383:       n += 6;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 6
	mov	DWORD PTR _n$[ebp], eax
$LN14@soap_wchar:

; 10384:   }

	jmp	SHORT $LN17@soap_wchar
$LN16@soap_wchar:

; 10385:   r = t = (char*)soap_malloc(soap, n + 1);

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 10386:   if (r)

	cmp	DWORD PTR _r$[ebp], 0
	je	$LN13@soap_wchar
$LN12@soap_wchar:

; 10387:   { /* Convert wchar to UTF8 */
; 10388:     while ((c = *s++))

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR tv79[ebp], 0
	je	$LN11@soap_wchar

; 10389:     { if (c > 0 && c < 0x80)

	cmp	DWORD PTR _c$[ebp], 0
	jle	SHORT $LN10@soap_wchar
	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jge	SHORT $LN10@soap_wchar

; 10390:         *t++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10391:       else

	jmp	$LN9@soap_wchar
$LN10@soap_wchar:

; 10392:       { if (c < 0x0800)

	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jge	SHORT $LN8@soap_wchar

; 10393:           *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10394:         else

	jmp	$LN7@soap_wchar
$LN8@soap_wchar:

; 10395:         { if (c < 0x010000)

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jge	SHORT $LN6@soap_wchar

; 10396:             *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10397:           else

	jmp	$LN5@soap_wchar
$LN6@soap_wchar:

; 10398:           { if (c < 0x200000)

	cmp	DWORD PTR _c$[ebp], 2097152		; 00200000H
	jge	SHORT $LN4@soap_wchar

; 10399:               *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10400:             else

	jmp	$LN3@soap_wchar
$LN4@soap_wchar:

; 10401:             { if (c < 0x04000000)

	cmp	DWORD PTR _c$[ebp], 67108864		; 04000000H
	jge	SHORT $LN2@soap_wchar

; 10402:                 *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 24					; 00000018H
	and	ecx, 3
	or	ecx, 248				; 000000f8H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10403:               else

	jmp	SHORT $LN1@soap_wchar
$LN2@soap_wchar:

; 10404:               { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 30					; 0000001eH
	and	ecx, 1
	or	ecx, 252				; 000000fcH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 10405:                 *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 24					; 00000018H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN1@soap_wchar:

; 10406:               }
; 10407:               *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 18					; 00000012H
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN3@soap_wchar:

; 10408:             }
; 10409:             *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 12					; 0000000cH
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN5@soap_wchar:

; 10410:           }
; 10411:           *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	sar	ecx, 6
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN7@soap_wchar:

; 10412:         }
; 10413:         *t++ = (char)(0x80 | (c & 0x3F));

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN9@soap_wchar:

; 10414:       }
; 10415:     }

	jmp	$LN12@soap_wchar
$LN11@soap_wchar:

; 10416:     *t = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0
$LN13@soap_wchar:

; 10417:   }
; 10418:   return r;

	mov	eax, DWORD PTR _r$[ebp]

; 10419: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_wchar2s ENDP
_TEXT	ENDS
PUBLIC	_soap_outstring
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outstring
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outstring PROC					; COMDAT

; 10428: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_id
	add	esp, 32					; 00000020H
	mov	DWORD PTR _id$[ebp], eax

; 10429:   if (id < 0)

	cmp	DWORD PTR _id$[ebp], 0
	jge	SHORT $LN4@soap_outst

; 10430:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN5@soap_outst
$LN4@soap_outst:

; 10431:   if (!**p && (soap->mode & SOAP_C_NILSTRING))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN3@soap_outst
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN3@soap_outst

; 10432:     return soap_element_null(soap, tag, id, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_null
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@soap_outst
$LN3@soap_outst:

; 10433:   if (soap_element_begin_out(soap, tag, id, type)
; 10434:    || soap_string_out(soap, *p, 0)
; 10435:    || soap_element_end_out(soap, tag))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outst
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_outst
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_outst
$LN1@soap_outst:

; 10436:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@soap_outst
$LN2@soap_outst:

; 10437:   return SOAP_OK;

	xor	eax, eax
$LN5@soap_outst:

; 10438: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outstring ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_instring
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_flag$ = 28						; size = 4
_minlen$ = 32						; size = 4
_maxlen$ = 36						; size = 4
_soap_instring PROC					; COMDAT

; 10447: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	1
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN16@soap_instr

; 10448:   { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN14@soap_instr
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN14@soap_instr
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	je	SHORT $LN15@soap_instr
$LN14@soap_instr:

; 10449:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_instr
$LN15@soap_instr:

; 10450:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN16@soap_instr:

; 10451:   }
; 10452:   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN13@soap_instr

; 10453:   { if (!(p = (char**)soap_malloc(soap, sizeof(char*))))

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN13@soap_instr

; 10454:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_instr
$LN13@soap_instr:

; 10455:   }
; 10456:   if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	$LN11@soap_instr

; 10457:   { *p = soap_string_in(soap, flag, minlen, maxlen);

	mov	eax, DWORD PTR _maxlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_in
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 10458:     if (!*p || !(char*)soap_id_enter(soap, soap->id, *p, t, sizeof(char*), 0, NULL, NULL, NULL))

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@soap_instr
	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	test	eax, eax
	jne	SHORT $LN10@soap_instr
$LN9@soap_instr:

; 10459:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_instr
$LN10@soap_instr:

; 10460:     if (!**p && tag && *tag == '-')

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@soap_instr
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN8@soap_instr
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN8@soap_instr

; 10461:     { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10462:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_instr
$LN8@soap_instr:

; 10463:     }
; 10464:   }

	jmp	SHORT $LN7@soap_instr
$LN11@soap_instr:

; 10465:   else if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN6@soap_instr
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN6@soap_instr

; 10466:   { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10467:     return NULL;

	xor	eax, eax
	jmp	$LN17@soap_instr
	jmp	SHORT $LN7@soap_instr
$LN6@soap_instr:

; 10468:   }
; 10469:   else if (soap->null)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	SHORT $LN4@soap_instr

; 10470:     *p = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0

; 10471:   else

	jmp	SHORT $LN7@soap_instr
$LN4@soap_instr:

; 10472:     *p = soap_strdup(soap, SOAP_STR_EOS);

	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@soap_instr:

; 10473:   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN2@soap_instr

; 10474:     p = (char**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(char**), 0);

	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax
$LN2@soap_instr:

; 10475:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_instr
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_instr

; 10476:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN17@soap_instr
$LN1@soap_instr:

; 10477:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN17@soap_instr:

; 10478: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_instring ENDP
_TEXT	ENDS
PUBLIC	_soap_outwstring
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outwstring
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outwstring PROC					; COMDAT

; 10488: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_id
	add	esp, 32					; 00000020H
	mov	DWORD PTR _id$[ebp], eax

; 10489:   if (id < 0)

	cmp	DWORD PTR _id$[ebp], 0
	jge	SHORT $LN4@soap_outws

; 10490:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN5@soap_outws
$LN4@soap_outws:

; 10491:   if (!**p && (soap->mode & SOAP_C_NILSTRING))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN3@soap_outws
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN3@soap_outws

; 10492:     return soap_element_null(soap, tag, id, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_null
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@soap_outws
$LN3@soap_outws:

; 10493:   if (soap_element_begin_out(soap, tag, id, type)
; 10494:    || soap_wstring_out(soap, *p, 0)
; 10495:    || soap_element_end_out(soap, tag))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outws
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_wstring_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_outws
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_outws
$LN1@soap_outws:

; 10496:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@soap_outws
$LN2@soap_outws:

; 10497:   return SOAP_OK;

	xor	eax, eax
$LN5@soap_outws:

; 10498: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outwstring ENDP
_TEXT	ENDS
PUBLIC	_soap_inwstring
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inwstring
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_minlen$ = 28						; size = 4
_maxlen$ = 32						; size = 4
_soap_inwstring PROC					; COMDAT

; 10509: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	1
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN16@soap_inwst

; 10510:   { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN14@soap_inwst
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN14@soap_inwst
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	je	SHORT $LN15@soap_inwst
$LN14@soap_inwst:

; 10511:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_inwst
$LN15@soap_inwst:

; 10512:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN16@soap_inwst:

; 10513:   }
; 10514:   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN13@soap_inwst

; 10515:   { if (!(p = (wchar_t**)soap_malloc(soap, sizeof(wchar_t*))))

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN13@soap_inwst

; 10516:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_inwst
$LN13@soap_inwst:

; 10517:   }
; 10518:   if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	$LN11@soap_inwst

; 10519:   { *p = soap_wstring_in(soap, 1, minlen, maxlen);

	mov	eax, DWORD PTR _maxlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minlen$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_wstring_in
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 10520:     if (!*p || !(wchar_t*)soap_id_enter(soap, soap->id, *p, t, sizeof(wchar_t*), 0, NULL, NULL, NULL))

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@soap_inwst
	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	test	eax, eax
	jne	SHORT $LN10@soap_inwst
$LN9@soap_inwst:

; 10521:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_inwst
$LN10@soap_inwst:

; 10522:     if (!**p && tag && *tag == '-')

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@soap_inwst
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN8@soap_inwst
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN8@soap_inwst

; 10523:     { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10524:       return NULL;

	xor	eax, eax
	jmp	$LN17@soap_inwst
$LN8@soap_inwst:

; 10525:     }
; 10526:   }

	jmp	SHORT $LN7@soap_inwst
$LN11@soap_inwst:

; 10527:   else if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN6@soap_inwst
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN6@soap_inwst

; 10528:   { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10529:     return NULL;

	xor	eax, eax
	jmp	$LN17@soap_inwst
	jmp	SHORT $LN7@soap_inwst
$LN6@soap_inwst:

; 10530:   }
; 10531:   else if (soap->null)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	SHORT $LN4@soap_inwst

; 10532:     *p = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0

; 10533:   else

	jmp	SHORT $LN7@soap_inwst
$LN4@soap_inwst:

; 10534:     *p = soap_wstrdup(soap, (wchar_t*)SOAP_STR_EOS);

	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_wstrdup
	add	esp, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@soap_inwst:

; 10535:   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN2@soap_inwst

; 10536:     p = (wchar_t**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(wchar_t**), 0);

	push	0
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_lookup
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax
$LN2@soap_inwst:

; 10537:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inwst
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inwst

; 10538:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN17@soap_inwst
$LN1@soap_inwst:

; 10539:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN17@soap_inwst:

; 10540: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inwstring ENDP
_TEXT	ENDS
PUBLIC	_soap_timegm
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_timegm
_TEXT	SEGMENT
_tm$ = -88						; size = 36
_z$ = -44						; size = 8
_g$ = -28						; size = 8
_t$ = -12						; size = 8
_T$ = 8							; size = 4
_soap_timegm PROC					; COMDAT

; 10550: {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10551: #if defined(HAVE_TIMEGM)
; 10552:   return timegm(T);
; 10553: #else
; 10554:   time_t t, g, z;
; 10555:   struct tm tm;
; 10556:   t = mktime(T);

	mov	eax, DWORD PTR _T$[ebp]
	push	eax
	call	_mktime
	add	esp, 4
	mov	DWORD PTR _t$[ebp], eax
	mov	DWORD PTR _t$[ebp+4], edx

; 10557:   if (t == (time_t)-1)

	mov	eax, DWORD PTR _t$[ebp]
	and	eax, DWORD PTR _t$[ebp+4]
	cmp	eax, -1
	jne	SHORT $LN2@soap_timeg

; 10558:     return (time_t)-1;

	or	eax, -1
	or	edx, -1
	jmp	SHORT $LN3@soap_timeg
$LN2@soap_timeg:

; 10559: #ifdef HAVE_GMTIME_R
; 10560:   gmtime_r(&t, &tm);
; 10561: #else
; 10562:   tm = *gmtime(&t);

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_gmtime
	add	esp, 4
	mov	ecx, 9
	mov	esi, eax
	lea	edi, DWORD PTR _tm$[ebp]
	rep movsd

; 10563: #endif
; 10564:   tm.tm_isdst = 0;

	mov	DWORD PTR _tm$[ebp+32], 0

; 10565:   g = mktime(&tm);

	lea	eax, DWORD PTR _tm$[ebp]
	push	eax
	call	_mktime
	add	esp, 4
	mov	DWORD PTR _g$[ebp], eax
	mov	DWORD PTR _g$[ebp+4], edx

; 10566:   if (g == (time_t)-1)

	mov	eax, DWORD PTR _g$[ebp]
	and	eax, DWORD PTR _g$[ebp+4]
	cmp	eax, -1
	jne	SHORT $LN1@soap_timeg

; 10567:     return (time_t)-1;

	or	eax, -1
	or	edx, -1
	jmp	SHORT $LN3@soap_timeg
$LN1@soap_timeg:

; 10568:   z = g - t;

	mov	eax, DWORD PTR _g$[ebp]
	sub	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _g$[ebp+4]
	sbb	ecx, DWORD PTR _t$[ebp+4]
	mov	DWORD PTR _z$[ebp], eax
	mov	DWORD PTR _z$[ebp+4], ecx

; 10569:   return t - z;

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _t$[ebp+4]
	sbb	edx, DWORD PTR _z$[ebp+4]
$LN3@soap_timeg:

; 10570: #endif
; 10571: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_timeg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@soap_timeg:
	DD	2
	DD	$LN7@soap_timeg
$LN7@soap_timeg:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN5@soap_timeg
	DD	-88					; ffffffa8H
	DD	36					; 00000024H
	DD	$LN6@soap_timeg
$LN6@soap_timeg:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	0
$LN5@soap_timeg:
	DB	116					; 00000074H
	DB	0
_soap_timegm ENDP
_TEXT	ENDS
EXTRN	__imp___gmtime64:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\time.inl
;	COMDAT _gmtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_gmtime	PROC						; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 103  : #pragma warning( push )
; 104  : #pragma warning( disable : 4996 )
; 105  :     return _gmtime64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___gmtime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 106  : #pragma warning( pop )
; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_gmtime	ENDP
_TEXT	ENDS
EXTRN	__imp___mktime64:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _mktime
_TEXT	SEGMENT
__Tm$ = 8						; size = 4
_mktime	PROC						; COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 127  :     return _mktime64(_Tm);

	mov	esi, esp
	mov	eax, DWORD PTR __Tm$[ebp]
	push	eax
	call	DWORD PTR __imp___mktime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mktime	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@ ; `string'
PUBLIC	??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@ ; `string'
PUBLIC	_soap_dateTime2s
EXTRN	_abs:PROC
EXTRN	__imp__strftime:PROC
;	COMDAT ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
CONST	SEGMENT
??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@ DB '1969-12-31T23:59:59Z'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@ DB '%+03d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@
CONST	SEGMENT
??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@ DB '%Y-%m'
	DB	'-%dT%H:%M:%S', 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_dateTime2s
_TEXT	SEGMENT
_t$ = -76						; size = 16
_pT$ = -52						; size = 4
_T$ = -40						; size = 36
_soap$ = 8						; size = 4
_n$ = 12						; size = 8
_soap_dateTime2s PROC					; COMDAT

; 10580: { struct tm T, *pT = &T;

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	eax, DWORD PTR _T$[ebp]
	mov	DWORD PTR _pT$[ebp], eax

; 10581: #if defined(HAVE_GMTIME_R)
; 10582:   if (gmtime_r(&n, pT))
; 10583:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
; 10584: #elif defined(HAVE_GMTIME)
; 10585:   if ((pT = gmtime(&n)))
; 10586:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
; 10587: #elif defined(HAVE_GETTIMEOFDAY)
; 10588:   struct timezone tz;
; 10589:   memset((void*)&tz, 0, sizeof(tz));
; 10590: #if defined(HAVE_LOCALTIME_R)
; 10591:   if (localtime_r(&n, pT))
; 10592:   { struct timeval tv;
; 10593:     gettimeofday(&tv, &tz);
; 10594:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10595:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
; 10596:   }
; 10597: #else
; 10598:   if ((pT = localtime(&n)))
; 10599:   { struct timeval tv;
; 10600:     gettimeofday(&tv, &tz);
; 10601:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10602:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
; 10603:   }
; 10604: #endif
; 10605: #elif defined(HAVE_FTIME)
; 10606:   struct timeb t;
; 10607:   memset((void*)&t, 0, sizeof(t));

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 10608: #if defined(HAVE_LOCALTIME_R)
; 10609:   if (localtime_r(&n, pT))
; 10610:   {
; 10611: #ifdef __BORLANDC__
; 10612:     ::ftime(&t);
; 10613: #else
; 10614:     ftime(&t);
; 10615: #endif
; 10616:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10617:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);
; 10618:   }
; 10619: #else
; 10620:   if ((pT = localtime(&n)))

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _pT$[ebp], eax
	cmp	DWORD PTR _pT$[ebp], 0
	je	$LN2@soap_dateT

; 10621:   {
; 10622: #ifdef __BORLANDC__
; 10623:     ::ftime(&t);
; 10624: #else
; 10625:     ftime(&t);

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_ftime
	add	esp, 4

; 10626: #endif
; 10627:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);

	mov	esi, esp
	mov	eax, DWORD PTR _pT$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10628:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);

	movsx	eax, WORD PTR _t$[ebp+10]
	push	eax
	call	_abs
	add	esp, 4
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	esi, esp
	push	edx
	movsx	eax, WORD PTR _t$[ebp+10]
	neg	eax
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	edx, DWORD PTR _pT$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [edx+32], 0
	setne	cl
	add	eax, ecx
	push	eax
	push	OFFSET ??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+79028]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10629:   }
; 10630: #endif
; 10631: #elif defined(HAVE_LOCALTIME_R)
; 10632:   if (localtime_r(&n, pT))
; 10633:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10634: #else
; 10635:   if ((pT = localtime(&n)))
; 10636:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10637: #endif
; 10638:   else

	jmp	SHORT $LN1@soap_dateT
$LN2@soap_dateT:

; 10639:     strcpy(soap->tmpbuf, "1969-12-31T23:59:59Z");

	push	OFFSET ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcpy
	add	esp, 8
$LN1@soap_dateT:

; 10640:   return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H

; 10641: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@soap_dateT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@soap_dateT:
	DD	2
	DD	$LN7@soap_dateT
$LN7@soap_dateT:
	DD	-40					; ffffffd8H
	DD	36					; 00000024H
	DD	$LN5@soap_dateT
	DD	-76					; ffffffb4H
	DD	16					; 00000010H
	DD	$LN6@soap_dateT
$LN6@soap_dateT:
	DB	116					; 00000074H
	DB	0
$LN5@soap_dateT:
	DB	84					; 00000054H
	DB	0
_soap_dateTime2s ENDP
_TEXT	ENDS
EXTRN	__imp___ftime64:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\sys\timeb.inl
;	COMDAT _ftime
_TEXT	SEGMENT
__Tmb$ = 8						; size = 4
_ftime	PROC						; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 52   :     _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb64) );
; 53   :     _ftime64((struct __timeb64 *)_Tmb);

	mov	esi, esp
	mov	eax, DWORD PTR __Tmb$[ebp]
	push	eax
	call	DWORD PTR __imp___ftime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 54   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ftime	ENDP
_TEXT	ENDS
EXTRN	__imp___localtime64:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 116  : #pragma warning( push )
; 117  : #pragma warning( disable : 4996 )
; 118  :     return _localtime64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 119  : #pragma warning( pop )
; 120  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
PUBLIC	_soap_outdateTime
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
;	COMDAT _soap_outdateTime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_p$ = 20						; size = 4
_type$ = 24						; size = 4
_n$ = 28						; size = 4
_soap_outdateTime PROC					; COMDAT

; 10650: { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10651:    || soap_string_out(soap, soap_dateTime2s(soap, *p), 0))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN1@soap_outda
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_dateTime2s
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_string_out
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_outda
$LN1@soap_outda:

; 10652:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_outda
$LN2@soap_outda:

; 10653:   return soap_element_end_out(soap, tag);

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
$LN3@soap_outda:

; 10654: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outdateTime ENDP
_TEXT	ENDS
PUBLIC	??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@ ; `string'
PUBLIC	??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ ; `string'
PUBLIC	??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_s2dateTime
;	COMDAT ??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@
CONST	SEGMENT
??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@ DB '%d:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@ DB '%'
	DB	'4d%2d%2dT%2d%2d%2d%31s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ DB '%'
	DB	'4d%2d%2dT%d:%d:%d%31s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ DB '%'
	DB	'd-%d-%dT%d:%d:%d%31s', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_s2dateTime
_TEXT	SEGMENT
_m$87974 = -120						; size = 4
_h$87973 = -108						; size = 4
_t$87952 = -96						; size = 4
_zone$87951 = -84					; size = 32
_T$87950 = -44						; size = 36
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_s2dateTime PROC					; COMDAT

; 10663: { if (s)

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN21@soap_s2dat

; 10664:   { struct tm T;
; 10665:     char zone[32];
; 10666:     const char *t;
; 10667:     memset((void*)&T, 0, sizeof(T));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _T$87950[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 10668:     zone[sizeof(zone)-1] = '\0';

	mov	BYTE PTR _zone$87951[ebp+31], 0

; 10669:     if (strchr(s, '-'))

	mov	esi, esp
	push	45					; 0000002dH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN20@soap_s2dat

; 10670:       t = "%d-%d-%dT%d:%d:%d%31s";

	mov	DWORD PTR _t$87952[ebp], OFFSET ??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
	jmp	SHORT $LN19@soap_s2dat
$LN20@soap_s2dat:

; 10671:     else if (strchr(s, ':'))

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN18@soap_s2dat

; 10672:       t = "%4d%2d%2dT%d:%d:%d%31s";

	mov	DWORD PTR _t$87952[ebp], OFFSET ??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@

; 10673:     else /* parse non-XSD-standard alternative ISO 8601 format */

	jmp	SHORT $LN19@soap_s2dat
$LN18@soap_s2dat:

; 10674:       t = "%4d%2d%2dT%2d%2d%2d%31s";

	mov	DWORD PTR _t$87952[ebp], OFFSET ??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@
$LN19@soap_s2dat:

; 10675:     sscanf(s, t, &T.tm_year, &T.tm_mon, &T.tm_mday, &T.tm_hour, &T.tm_min, &T.tm_sec, zone);

	mov	esi, esp
	lea	eax, DWORD PTR _zone$87951[ebp]
	push	eax
	lea	ecx, DWORD PTR _T$87950[ebp]
	push	ecx
	lea	edx, DWORD PTR _T$87950[ebp+4]
	push	edx
	lea	eax, DWORD PTR _T$87950[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _T$87950[ebp+12]
	push	ecx
	lea	edx, DWORD PTR _T$87950[ebp+16]
	push	edx
	lea	eax, DWORD PTR _T$87950[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _t$87952[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__sscanf
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10676:     if (T.tm_year == 1)

	cmp	DWORD PTR _T$87950[ebp+20], 1
	jne	SHORT $LN16@soap_s2dat

; 10677:       T.tm_year = 70;

	mov	DWORD PTR _T$87950[ebp+20], 70		; 00000046H

; 10678:     else

	jmp	SHORT $LN15@soap_s2dat
$LN16@soap_s2dat:

; 10679:       T.tm_year -= 1900;

	mov	eax, DWORD PTR _T$87950[ebp+20]
	sub	eax, 1900				; 0000076cH
	mov	DWORD PTR _T$87950[ebp+20], eax
$LN15@soap_s2dat:

; 10680:     T.tm_mon--;

	mov	eax, DWORD PTR _T$87950[ebp+16]
	sub	eax, 1
	mov	DWORD PTR _T$87950[ebp+16], eax

; 10681:     if (*zone)

	movsx	eax, BYTE PTR _zone$87951[ebp]
	test	eax, eax
	je	$LN14@soap_s2dat

; 10682:     { if (*zone == '.')

	movsx	eax, BYTE PTR _zone$87951[ebp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN13@soap_s2dat

; 10683:       { for (s = zone + 1; *s; s++)

	lea	eax, DWORD PTR _zone$87951[ebp+1]
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN12@soap_s2dat
$LN11@soap_s2dat:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN12@soap_s2dat:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN10@soap_s2dat

; 10684:           if (*s < '0' || *s > '9')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN8@soap_s2dat
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN9@soap_s2dat
$LN8@soap_s2dat:

; 10685:             break;

	jmp	SHORT $LN10@soap_s2dat
$LN9@soap_s2dat:

; 10686:       }

	jmp	SHORT $LN11@soap_s2dat
$LN10@soap_s2dat:

; 10687:       else

	jmp	SHORT $LN7@soap_s2dat
$LN13@soap_s2dat:

; 10688:         s = zone;

	lea	eax, DWORD PTR _zone$87951[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN7@soap_s2dat:

; 10689:       if (*s == '+' || *s == '-')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN5@soap_s2dat
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	$LN6@soap_s2dat
$LN5@soap_s2dat:

; 10690:       { int h = 0, m = 0;

	mov	DWORD PTR _h$87973[ebp], 0
	mov	DWORD PTR _m$87974[ebp], 0

; 10691:         if (s[3] == ':')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN4@soap_s2dat

; 10692:         { sscanf(s, "%d:%d", &h, &m);

	mov	esi, esp
	lea	eax, DWORD PTR _m$87974[ebp]
	push	eax
	lea	ecx, DWORD PTR _h$87973[ebp]
	push	ecx
	push	OFFSET ??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__sscanf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10693:           if (h < 0)

	cmp	DWORD PTR _h$87973[ebp], 0
	jge	SHORT $LN3@soap_s2dat

; 10694:             m = -m;

	mov	eax, DWORD PTR _m$87974[ebp]
	neg	eax
	mov	DWORD PTR _m$87974[ebp], eax
$LN3@soap_s2dat:

; 10695:         }
; 10696:         else

	jmp	SHORT $LN2@soap_s2dat
$LN4@soap_s2dat:

; 10697:         { m = (int)atol(s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _m$87974[ebp], eax

; 10698:           h = m / 100;

	mov	eax, DWORD PTR _m$87974[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _h$87973[ebp], eax

; 10699:           m = m % 100;

	mov	eax, DWORD PTR _m$87974[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _m$87974[ebp], edx
$LN2@soap_s2dat:

; 10700:         }
; 10701:         T.tm_hour -= h;

	mov	eax, DWORD PTR _T$87950[ebp+8]
	sub	eax, DWORD PTR _h$87973[ebp]
	mov	DWORD PTR _T$87950[ebp+8], eax

; 10702:         T.tm_min -= m;

	mov	eax, DWORD PTR _T$87950[ebp+4]
	sub	eax, DWORD PTR _m$87974[ebp]
	mov	DWORD PTR _T$87950[ebp+4], eax
$LN6@soap_s2dat:

; 10703:       }
; 10704:       T.tm_isdst = 0;

	mov	DWORD PTR _T$87950[ebp+32], 0

; 10705:       *p = soap_timegm(&T);

	lea	eax, DWORD PTR _T$87950[ebp]
	push	eax
	call	_soap_timegm
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 10706:     }
; 10707:     else

	jmp	SHORT $LN21@soap_s2dat
$LN14@soap_s2dat:

; 10708:     { T.tm_isdst = -1;

	mov	DWORD PTR _T$87950[ebp+32], -1

; 10709:       *p = mktime(&T); /* no time zone: suppose it is localtime? */

	lea	eax, DWORD PTR _T$87950[ebp]
	push	eax
	call	_mktime
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN21@soap_s2dat:

; 10710:     }
; 10711:   }
; 10712:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 10713: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@soap_s2dat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@soap_s2dat:
	DD	4
	DD	$LN28@soap_s2dat
$LN28@soap_s2dat:
	DD	-44					; ffffffd4H
	DD	36					; 00000024H
	DD	$LN24@soap_s2dat
	DD	-84					; ffffffacH
	DD	32					; 00000020H
	DD	$LN25@soap_s2dat
	DD	-108					; ffffff94H
	DD	4
	DD	$LN26@soap_s2dat
	DD	-120					; ffffff88H
	DD	4
	DD	$LN27@soap_s2dat
$LN27@soap_s2dat:
	DB	109					; 0000006dH
	DB	0
$LN26@soap_s2dat:
	DB	104					; 00000068H
	DB	0
$LN25@soap_s2dat:
	DB	122					; 0000007aH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN24@soap_s2dat:
	DB	84					; 00000054H
	DB	0
_soap_s2dateTime ENDP
_TEXT	ENDS
PUBLIC	??_C@_09ONEMIJDH@?3dateTime?$AA@		; `string'
PUBLIC	_soap_indateTime
;	COMDAT ??_C@_09ONEMIJDH@?3dateTime?$AA@
CONST	SEGMENT
??_C@_09ONEMIJDH@?3dateTime?$AA@ DB ':dateTime', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_indateTime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_indateTime PROC					; COMDAT

; 10722: { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	0
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@soap_indat

; 10723:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_indat
$LN7@soap_indat:

; 10724:   if (*soap->type
; 10725:    && soap_match_tag(soap, soap->type, type)
; 10726:    && soap_match_tag(soap, soap->type, ":dateTime"))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+83124]
	test	ecx, ecx
	je	SHORT $LN6@soap_indat
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 83124				; 000144b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_indat
	push	OFFSET ??_C@_09ONEMIJDH@?3dateTime?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_indat

; 10727:   { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 10728:     soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 10729:     return NULL;

	xor	eax, eax
	jmp	$LN8@soap_indat
$LN6@soap_indat:

; 10730:   }
; 10731:   p = (time_t*)soap_id_enter(soap, soap->id, p, t, sizeof(time_t), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	8
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_enter
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax

; 10732:   if (*soap->href)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+82100]
	test	ecx, ecx
	je	SHORT $LN5@soap_indat

; 10733:     p = (time_t*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(time_t), 0, NULL);

	push	0
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 82100				; 000140b4H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_id_forward
	add	esp, 36					; 00000024H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@soap_indat
$LN5@soap_indat:

; 10734:   else if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@soap_indat

; 10735:   { if (soap_s2dateTime(soap, soap_value(soap), p))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_value
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_s2dateTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_indat

; 10736:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_indat
$LN4@soap_indat:

; 10737:   }
; 10738:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_indat
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_indat

; 10739:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN8@soap_indat
$LN1@soap_indat:

; 10740:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN8@soap_indat:

; 10741: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_indateTime ENDP
_TEXT	ENDS
PUBLIC	_soap_outliteral
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outliteral
_TEXT	SEGMENT
tv143 = -220						; size = 4
_t$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_outliteral PROC					; COMDAT

; 10750: { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10751:   const char *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 10752:   if (tag && *tag != '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	$LN13@soap_outli
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	$LN13@soap_outli

; 10753:   { if (soap->local_namespaces && (t = strchr(tag, ':')))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	$LN12@soap_outli
	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	je	$LN12@soap_outli

; 10754:     { strncpy(soap->tmpbuf, tag, t-tag);

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10755:       soap->tmpbuf[t-tag] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+eax+79028], 0

; 10756:       for (i = 0; soap->local_namespaces[i].id; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@soap_outli
$LN10@soap_outli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@soap_outli:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	DWORD PTR [eax+edx], 0
	je	SHORT $LN9@soap_outli

; 10757:         if (!strcmp(soap->tmpbuf, soap->local_namespaces[i].id))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_outli

; 10758:           break;

	jmp	SHORT $LN9@soap_outli
$LN8@soap_outli:

; 10759:       t++;

	jmp	SHORT $LN10@soap_outli
$LN9@soap_outli:
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax

; 10760:       if (soap_element(soap, t, 0, type)
; 10761:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10762:        || soap_element_start_end_out(soap, NULL))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN6@soap_outli
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	DWORD PTR [edx+eax+4], 0
	je	SHORT $LN16@soap_outli
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN17@soap_outli
$LN16@soap_outli:
	mov	DWORD PTR tv143[ebp], OFFSET _soap_padding
$LN17@soap_outli:
	mov	ecx, DWORD PTR tv143[ebp]
	push	ecx
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_outli
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_outli
$LN6@soap_outli:

; 10763:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN14@soap_outli
$LN7@soap_outli:

; 10764:     }
; 10765:     else

	jmp	SHORT $LN13@soap_outli
$LN12@soap_outli:

; 10766:     { t = tag;

	mov	eax, DWORD PTR _tag$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 10767:       if (soap_element_begin_out(soap, t, 0, type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN13@soap_outli

; 10768:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN14@soap_outli
$LN13@soap_outli:

; 10769:     }
; 10770:   }
; 10771:   if (p && *p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@soap_outli
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@soap_outli

; 10772:   { if (soap_send(soap, *p))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@soap_outli

; 10773:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN14@soap_outli
$LN3@soap_outli:

; 10774:   }
; 10775:   if (t)

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN1@soap_outli

; 10776:     return soap_element_end_out(soap, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	jmp	SHORT $LN14@soap_outli
$LN1@soap_outli:

; 10777:   return SOAP_OK;

	xor	eax, eax
$LN14@soap_outli:

; 10778: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_inliteral
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inliteral
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_inliteral PROC					; COMDAT

; 10787: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	1
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@soap_inlit

; 10788:   { if (soap->error != SOAP_NO_TAG || soap_unget(soap, soap_get(soap)) == SOAP_TT)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	jne	SHORT $LN12@soap_inlit
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12436], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+12436], -3		; fffffffdH
	jne	SHORT $LN13@soap_inlit
$LN12@soap_inlit:

; 10789:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inlit
$LN13@soap_inlit:

; 10790:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN14@soap_inlit:

; 10791:   }
; 10792:   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN11@soap_inlit

; 10793:   { if (!(p = (char**)soap_malloc(soap, sizeof(char*))))

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN11@soap_inlit

; 10794:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inlit
$LN11@soap_inlit:

; 10795:   }
; 10796:   if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN9@soap_inlit

; 10797:   { *p = soap_string_in(soap, 0, -1, -1);

	push	-1
	push	-1
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_in
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 10798:     if (!*p)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@soap_inlit

; 10799:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inlit
$LN8@soap_inlit:

; 10800:     if (!**p && tag && *tag == '-')

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@soap_inlit
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN7@soap_inlit
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN7@soap_inlit

; 10801:     { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10802:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inlit
$LN7@soap_inlit:

; 10803:     }
; 10804:   }

	jmp	SHORT $LN6@soap_inlit
$LN9@soap_inlit:

; 10805:   else if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN5@soap_inlit
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN5@soap_inlit

; 10806:   { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10807:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inlit
	jmp	SHORT $LN6@soap_inlit
$LN5@soap_inlit:

; 10808:   }
; 10809:   else if (soap->null)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	SHORT $LN3@soap_inlit

; 10810:     *p = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0

; 10811:   else

	jmp	SHORT $LN6@soap_inlit
$LN3@soap_inlit:

; 10812:     *p = soap_strdup(soap, SOAP_STR_EOS);

	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@soap_inlit:

; 10813:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inlit
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inlit

; 10814:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inlit
$LN1@soap_inlit:

; 10815:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN15@soap_inlit:

; 10816: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_outwliteral
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_outwliteral
_TEXT	SEGMENT
tv143 = -244						; size = 4
tv168 = -242						; size = 2
_s$88064 = -44						; size = 4
_c$88063 = -32						; size = 2
_t$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_outwliteral PROC					; COMDAT

; 10826: { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10827:   const char *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 10828:   if (tag && *tag != '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	$LN16@soap_outwl
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	$LN16@soap_outwl

; 10829:   { if (soap->local_namespaces && (t = strchr(tag, ':')))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	$LN15@soap_outwl
	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	je	$LN15@soap_outwl

; 10830:     { strncpy(soap->tmpbuf, tag, t-tag);

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10831:       soap->tmpbuf[t-tag] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _tag$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+eax+79028], 0

; 10832:       for (i = 0; soap->local_namespaces[i].id; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@soap_outwl
$LN13@soap_outwl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@soap_outwl:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	DWORD PTR [eax+edx], 0
	je	SHORT $LN12@soap_outwl

; 10833:         if (!strcmp(soap->tmpbuf, soap->local_namespaces[i].id))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@soap_outwl

; 10834:           break;

	jmp	SHORT $LN12@soap_outwl
$LN11@soap_outwl:

; 10835:       t++;

	jmp	SHORT $LN13@soap_outwl
$LN12@soap_outwl:
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax

; 10836:       if (soap_element(soap, t, 0, type)
; 10837:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10838:        || soap_element_start_end_out(soap, NULL))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN9@soap_outwl
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	DWORD PTR [edx+eax+4], 0
	je	SHORT $LN19@soap_outwl
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN20@soap_outwl
$LN19@soap_outwl:
	mov	DWORD PTR tv143[ebp], OFFSET _soap_padding
$LN20@soap_outwl:
	mov	ecx, DWORD PTR tv143[ebp]
	push	ecx
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@soap_outwl
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_outwl
$LN9@soap_outwl:

; 10839:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN17@soap_outwl
$LN10@soap_outwl:

; 10840:     }
; 10841:     else

	jmp	SHORT $LN8@soap_outwl
$LN15@soap_outwl:

; 10842:     { t = tag;

	mov	eax, DWORD PTR _tag$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 10843:       if (soap_element_begin_out(soap, t, 0, type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN8@soap_outwl

; 10844:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN17@soap_outwl
$LN8@soap_outwl:

; 10845:     }
; 10846:     if (soap_send(soap, soap->tmpbuf))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_outwl

; 10847:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN17@soap_outwl
$LN16@soap_outwl:

; 10848:   }
; 10849:   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN5@soap_outwl

; 10850:   { wchar_t c;
; 10851:     const wchar_t *s = *p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$88064[ebp], ecx
$LN4@soap_outwl:

; 10852:     while ((c = *s++))

	mov	eax, DWORD PTR _s$88064[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _c$88063[ebp], cx
	mov	dx, WORD PTR _c$88063[ebp]
	mov	WORD PTR tv168[ebp], dx
	mov	eax, DWORD PTR _s$88064[ebp]
	add	eax, 2
	mov	DWORD PTR _s$88064[ebp], eax
	movzx	ecx, WORD PTR tv168[ebp]
	test	ecx, ecx
	je	SHORT $LN5@soap_outwl

; 10853:     { if (soap_pututf8(soap, (unsigned long)c))

	movzx	eax, WORD PTR _c$88063[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_pututf8
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_outwl

; 10854:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN17@soap_outwl
$LN2@soap_outwl:

; 10855:     }

	jmp	SHORT $LN4@soap_outwl
$LN5@soap_outwl:

; 10856:   }
; 10857:   if (t)

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN1@soap_outwl

; 10858:     return soap_element_end_out(soap, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_out
	add	esp, 8
	jmp	SHORT $LN17@soap_outwl
$LN1@soap_outwl:

; 10859:   return SOAP_OK;

	xor	eax, eax
$LN17@soap_outwl:

; 10860: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outwliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_inwliteral
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_inwliteral
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_soap_inwliteral PROC					; COMDAT

; 10871: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	0
	push	1
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@soap_inwli

; 10872:   { if (soap->error != SOAP_NO_TAG || soap_unget(soap, soap_get(soap)) == SOAP_TT)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 6
	jne	SHORT $LN12@soap_inwli
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12436], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+12436], -3		; fffffffdH
	jne	SHORT $LN13@soap_inwli
$LN12@soap_inwli:

; 10873:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inwli
$LN13@soap_inwli:

; 10874:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN14@soap_inwli:

; 10875:   }
; 10876:   if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN11@soap_inwli

; 10877:   { if (!(p = (wchar_t**)soap_malloc(soap, sizeof(wchar_t*))))

	push	4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN11@soap_inwli

; 10878:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inwli
$LN11@soap_inwli:

; 10879:   }
; 10880:   if (soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN9@soap_inwli

; 10881:   { *p = soap_wstring_in(soap, 0, -1, -1);

	push	-1
	push	-1
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_wstring_in
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 10882:     if (!*p)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@soap_inwli

; 10883:       return NULL;

	xor	eax, eax
	jmp	$LN15@soap_inwli
$LN8@soap_inwli:

; 10884:     if (!**p && tag && *tag == '-')

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@soap_inwli
	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN7@soap_inwli
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN7@soap_inwli

; 10885:     { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10886:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inwli
$LN7@soap_inwli:

; 10887:     }
; 10888:   }

	jmp	SHORT $LN6@soap_inwli
$LN9@soap_inwli:

; 10889:   else if (tag && *tag == '-')

	cmp	DWORD PTR _tag$[ebp], 0
	je	SHORT $LN5@soap_inwli
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN5@soap_inwli

; 10890:   { soap->error = SOAP_NO_TAG;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 6

; 10891:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inwli
	jmp	SHORT $LN6@soap_inwli
$LN5@soap_inwli:

; 10892:   }
; 10893:   else if (soap->null)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87300]
	test	ecx, ecx
	je	SHORT $LN3@soap_inwli

; 10894:     *p = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0

; 10895:   else

	jmp	SHORT $LN6@soap_inwli
$LN3@soap_inwli:

; 10896:     *p = soap_wstrdup(soap, (wchar_t*)SOAP_STR_EOS);

	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_wstrdup
	add	esp, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@soap_inwli:

; 10897:   if (soap->body && soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	je	SHORT $LN1@soap_inwli
	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_inwli

; 10898:     return NULL;

	xor	eax, eax
	jmp	SHORT $LN15@soap_inwli
$LN1@soap_inwli:

; 10899:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN15@soap_inwli:

; 10900: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_inwliteral ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@JHAHNEGD@Element?5content?5value?$DN?8?$CFs?8?6?$AA@ ; `string'
;	COMDAT ??_C@_0BM@JHAHNEGD@Element?5content?5value?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BM@JHAHNEGD@Element?5content?5value?$DN?8?$CFs?8?6?$AA@ DB 'Elemen'
	DB	't content value=''%s''', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_value
_TEXT	SEGMENT
_fdebug$88126 = -44					; size = 4
_s$ = -32						; size = 4
_c$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_value PROC					; COMDAT

; 10910: { register size_t i;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10911:   register soap_wchar c = 0;

	mov	DWORD PTR _c$[ebp], 0

; 10912:   register char *s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$[ebp], eax

; 10913:   if (!soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	jne	SHORT $LN19@soap_value

; 10914:     return SOAP_STR_EOS;

	mov	eax, OFFSET _soap_padding
	jmp	$LN21@soap_value
$LN19@soap_value:

; 10915:   do c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 10916:   while (soap_blank(c));

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN17@soap_value
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN19@soap_value
$LN17@soap_value:

; 10917:   for (i = 0; i < sizeof(soap->tmpbuf) - 1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@soap_value
$LN14@soap_value:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@soap_value:
	cmp	DWORD PTR _i$[ebp], 1023		; 000003ffH
	jae	SHORT $LN13@soap_value

; 10918:   { if (c == SOAP_TT || (int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -3			; fffffffdH
	je	SHORT $LN11@soap_value
	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN12@soap_value
$LN11@soap_value:

; 10919:       break;

	jmp	SHORT $LN13@soap_value
$LN12@soap_value:

; 10920:     *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10921:     c = soap_get(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 10922:   }

	jmp	SHORT $LN14@soap_value
$LN13@soap_value:

; 10923:   for (s--; i > 0; i--, s--)

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN10@soap_value
$LN9@soap_value:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN10@soap_value:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	SHORT $LN8@soap_value

; 10924:   { if (!soap_blank(*s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN6@soap_value
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN7@soap_value
$LN6@soap_value:

; 10925:       break;

	jmp	SHORT $LN8@soap_value
$LN7@soap_value:

; 10926:   }

	jmp	SHORT $LN9@soap_value
$LN8@soap_value:

; 10927:   s[1] = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax+1], 0

; 10928:   if ((int)c == EOF || c == SOAP_TT)

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN4@soap_value
	cmp	DWORD PTR _c$[ebp], -3			; fffffffdH
	jne	SHORT $LN5@soap_value
$LN4@soap_value:

; 10929:     soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx
$LN5@soap_value:

; 10930:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element content value='%s'\n", soap->tmpbuf));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_value
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_value
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_value:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_value
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88126[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BM@JHAHNEGD@Element?5content?5value?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88126[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88126[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_value:

; 10931: #ifdef WITH_DOM
; 10932:   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 10933:     soap->dom->data = soap_strdup(soap, soap->tmpbuf);
; 10934: #endif
; 10935:   return soap->tmpbuf; /* return non-null pointer */

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
$LN21@soap_value:

; 10936: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_value ENDP
_TEXT	ENDS
PUBLIC	_soap_getline
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getline
_TEXT	SEGMENT
tv90 = -220						; size = 4
_c$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_len$ = 16						; size = 4
_soap_getline PROC					; COMDAT

; 10946: { int i = len;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 10947:   soap_wchar c = 0;

	mov	DWORD PTR _c$[ebp], 0
$LN12@soap_getli:

; 10948:   for (;;)
; 10949:   { while (--i > 0)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN11@soap_getli

; 10950:     { c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 10951:       if (c == '\r' || c == '\n')

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN9@soap_getli
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN10@soap_getli
$LN9@soap_getli:

; 10952:         break;

	jmp	SHORT $LN11@soap_getli
$LN10@soap_getli:

; 10953:       if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN8@soap_getli

; 10954:         return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN15@soap_getli
$LN8@soap_getli:

; 10955:       *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 10956:     }

	jmp	SHORT $LN12@soap_getli
$LN11@soap_getli:

; 10957:     if (c != '\n')

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN7@soap_getli

; 10958:       c = soap_getchar(soap); /* got \r or something else, now get \n */

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
$LN7@soap_getli:

; 10959:     if (c == '\n')

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN6@soap_getli

; 10960:     { *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 10961:       if (i+1 == len) /* empty line: end of HTTP/MIME header */

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _len$[ebp]
	jne	SHORT $LN5@soap_getli

; 10962:         break;

	jmp	$LN13@soap_getli
$LN5@soap_getli:

; 10963:       c = soap_get0(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN17@soap_getli
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@soap_getli
	mov	DWORD PTR tv90[ebp], -1
	jmp	SHORT $LN18@soap_getli
$LN17@soap_getli:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv90[ebp], ecx
$LN18@soap_getli:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 10964:       if (c != ' ' && c != '\t') /* HTTP line continuation? */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $LN4@soap_getli
	cmp	DWORD PTR _c$[ebp], 9
	je	SHORT $LN4@soap_getli

; 10965:         break;

	jmp	SHORT $LN13@soap_getli
$LN4@soap_getli:

; 10966:     }

	jmp	SHORT $LN3@soap_getli
$LN6@soap_getli:

; 10967:     else if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN3@soap_getli

; 10968:       return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	SHORT $LN15@soap_getli
$LN3@soap_getli:

; 10969:   }

	jmp	$LN12@soap_getli
$LN13@soap_getli:

; 10970:   if (i < 0)

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN1@soap_getli

; 10971:     return soap->error = SOAP_HDR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 22		; 00000016H
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN15@soap_getli
$LN1@soap_getli:

; 10972:   return SOAP_OK;

	xor	eax, eax
$LN15@soap_getli:

; 10973: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getline ENDP
_TEXT	ENDS
PUBLIC	_soap_dime_option
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_dime_option
_TEXT	SEGMENT
_s$ = -20						; size = 4
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_optype$ = 12						; size = 2
_option$ = 16						; size = 4
_soap_dime_option PROC					; COMDAT

; 11056: { size_t n;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11057:   char *s = NULL;

	mov	DWORD PTR _s$[ebp], 0

; 11058:   if (option)

	cmp	DWORD PTR _option$[ebp], 0
	je	$LN2@soap_dime_@2

; 11059:   { n = strlen(option);

	mov	eax, DWORD PTR _option$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 11060:     s = (char*)soap_malloc(soap, n + 5);

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 11061:     if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN2@soap_dime_@2

; 11062:     { s[0] = (char)(optype >> 8);

	movzx	ecx, WORD PTR _optype$[ebp]
	sar	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al

; 11063:       s[1] = (char)(optype & 0xFF);

	movzx	ecx, WORD PTR _optype$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx+1], al

; 11064:       s[2] = (char)(n >> 8);

	mov	ecx, DWORD PTR _n$[ebp]
	shr	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx+2], al

; 11065:       s[3] = (char)(n & 0xFF);

	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx+3], al

; 11066:       strcpy(s + 4, option);

	mov	eax, DWORD PTR _option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 4
	push	ecx
	call	_strcpy
	add	esp, 8
$LN2@soap_dime_@2:

; 11067:     }
; 11068:   }
; 11069:   return s;

	mov	eax, DWORD PTR _s$[ebp]

; 11070: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_dime_option ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GINGINJN@Put?5DIME?5header?5id?$DN?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_putdimehdr
;	COMDAT ??_C@_0BJ@GINGINJN@Put?5DIME?5header?5id?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GINGINJN@Put?5DIME?5header?5id?$DN?8?$CFs?8?6?$AA@ DB 'Put DIME'
	DB	' header id=''%s''', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putdimehdr
_TEXT	SEGMENT
tv81 = -268						; size = 4
_fdebug$88252 = -68					; size = 4
_typelen$ = -56						; size = 4
_idlen$ = -44						; size = 4
_optlen$ = -32						; size = 4
_tmp$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_putdimehdr PROC					; COMDAT

; 11081: { unsigned char tmp[12];

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 11082:   size_t optlen = 0, idlen = 0, typelen = 0;

	mov	DWORD PTR _optlen$[ebp], 0
	mov	DWORD PTR _idlen$[ebp], 0
	mov	DWORD PTR _typelen$[ebp], 0

; 11083:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Put DIME header id='%s'\n", soap->dime.id?soap->dime.id:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN10@soap_putdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_putdi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_putdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_putdi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88252[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90500], 0
	je	SHORT $LN13@soap_putdi
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90500]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN14@soap_putdi
$LN13@soap_putdi:
	mov	DWORD PTR tv81[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN14@soap_putdi:
	mov	esi, esp
	mov	eax, DWORD PTR tv81[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@GINGINJN@Put?5DIME?5header?5id?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88252[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88252[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_putdi:

; 11084:   if (soap->dime.options)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90508], 0
	je	SHORT $LN7@soap_putdi

; 11085:     optlen = (((unsigned char)soap->dime.options[2] << 8) | ((unsigned char)soap->dime.options[3])) + 4;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90508]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 8
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90508]
	movzx	eax, BYTE PTR [ecx+3]
	or	edx, eax
	add	edx, 4
	mov	DWORD PTR _optlen$[ebp], edx
$LN7@soap_putdi:

; 11086:   if (soap->dime.id)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90500], 0
	je	SHORT $LN6@soap_putdi

; 11087:   { idlen = strlen(soap->dime.id);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90500]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _idlen$[ebp], eax

; 11088:     if (idlen > 0x0000FFFF)

	cmp	DWORD PTR _idlen$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN6@soap_putdi

; 11089:       idlen = 0x0000FFFF;

	mov	DWORD PTR _idlen$[ebp], 65535		; 0000ffffH
$LN6@soap_putdi:

; 11090:   }
; 11091:   if (soap->dime.type)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90504], 0
	je	SHORT $LN4@soap_putdi

; 11092:   { typelen = strlen(soap->dime.type);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90504]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _typelen$[ebp], eax

; 11093:     if (typelen > 0x0000FFFF)

	cmp	DWORD PTR _typelen$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN4@soap_putdi

; 11094:       typelen = 0x0000FFFF;

	mov	DWORD PTR _typelen$[ebp], 65535		; 0000ffffH
$LN4@soap_putdi:

; 11095:   }
; 11096:   tmp[0] = SOAP_DIME_VERSION | (soap->dime.flags & 0x7);

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 7
	or	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp], al

; 11097:   tmp[1] = soap->dime.flags & 0xF0;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 240				; 000000f0H
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+1], al

; 11098:   tmp[2] = (char)(optlen >> 8);

	mov	ecx, DWORD PTR _optlen$[ebp]
	shr	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+2], al

; 11099:   tmp[3] = (char)(optlen & 0xFF);

	mov	ecx, DWORD PTR _optlen$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+3], al

; 11100:   tmp[4] = (char)(idlen >> 8);

	mov	ecx, DWORD PTR _idlen$[ebp]
	shr	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+4], al

; 11101:   tmp[5] = (char)(idlen & 0xFF);

	mov	ecx, DWORD PTR _idlen$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+5], al

; 11102:   tmp[6] = (char)(typelen >> 8);

	mov	ecx, DWORD PTR _typelen$[ebp]
	shr	ecx, 8
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+6], al

; 11103:   tmp[7] = (char)(typelen & 0xFF);

	mov	ecx, DWORD PTR _typelen$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+7], al

; 11104:   tmp[8] = (char)(soap->dime.size >> 24);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	shr	ecx, 24					; 00000018H
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+8], al

; 11105:   tmp[9] = (char)((soap->dime.size >> 16) & 0xFF);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+9], al

; 11106:   tmp[10] = (char)((soap->dime.size >> 8) & 0xFF);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+10], al

; 11107:   tmp[11] = (char)(soap->dime.size & 0xFF);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	BYTE PTR _tmp$[ebp+11], al

; 11108:   if (soap_send_raw(soap, (char*)tmp, 12)
; 11109:    || soap_putdimefield(soap, soap->dime.options, optlen)
; 11110:    || soap_putdimefield(soap, soap->dime.id, idlen)
; 11111:    || soap_putdimefield(soap, soap->dime.type, typelen))

	push	12					; 0000000cH
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_putdi
	mov	eax, DWORD PTR _optlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90508]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimefield
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_putdi
	mov	eax, DWORD PTR _idlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90500]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimefield
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_putdi
	mov	eax, DWORD PTR _typelen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90504]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimefield
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_putdi
$LN1@soap_putdi:

; 11112:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN11@soap_putdi
$LN2@soap_putdi:

; 11113:   return SOAP_OK;

	xor	eax, eax
$LN11@soap_putdi:

; 11114: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@soap_putdi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@soap_putdi:
	DD	1
	DD	$LN16@soap_putdi
$LN16@soap_putdi:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN15@soap_putdi
$LN15@soap_putdi:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_soap_putdimehdr ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_putdimefield
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_putdimefield PROC					; COMDAT

; 11042: { if (soap_send_raw(soap, s, n))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_putdi@2

; 11043:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN2@soap_putdi@2
$LN1@soap_putdi@2:

; 11044:   return soap_send_raw(soap, SOAP_STR_PADDING, -(long)n&3);

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	and	eax, 3
	push	eax
	push	OFFSET _soap_padding
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN2@soap_putdi@2:

; 11045: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putdimefield ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@PHDJCJEO@fdimereadclose?6?$AA@	; `string'
PUBLIC	??_C@_0EK@LIIELHNN@fdimeread?5failed?3?5insufficient?5d@ ; `string'
PUBLIC	??_C@_0BO@FEIDJMEA@fdimeread?5returned?5?$CFlu?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@HNFNOEPH@Chunked?5streaming?5DIME?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@JDAMEDDJ@fdimereadopen?5failed?6?$AA@	; `string'
;	COMDAT ??_C@_0BA@PHDJCJEO@fdimereadclose?6?$AA@
CONST	SEGMENT
??_C@_0BA@PHDJCJEO@fdimereadclose?6?$AA@ DB 'fdimereadclose', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@LIIELHNN@fdimeread?5failed?3?5insufficient?5d@
CONST	SEGMENT
??_C@_0EK@LIIELHNN@fdimeread?5failed?3?5insufficient?5d@ DB 'fdimeread fa'
	DB	'iled: insufficient data (%lu bytes remaining from %lu bytes)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FEIDJMEA@fdimeread?5returned?5?$CFlu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BO@FEIDJMEA@fdimeread?5returned?5?$CFlu?5bytes?6?$AA@ DB 'fdimerea'
	DB	'd returned %lu bytes', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNFNOEPH@Chunked?5streaming?5DIME?6?$AA@
CONST	SEGMENT
??_C@_0BI@HNFNOEPH@Chunked?5streaming?5DIME?6?$AA@ DB 'Chunked streaming '
	DB	'DIME', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JDAMEDDJ@fdimereadopen?5failed?6?$AA@
CONST	SEGMENT
??_C@_0BG@JDAMEDDJ@fdimereadopen?5failed?6?$AA@ DB 'fdimereadopen failed', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putdime
_TEXT	SEGMENT
_fdebug$88349 = -128					; size = 4
_fdebug$88342 = -116					; size = 4
_fdebug$88333 = -104					; size = 4
_bufsize$88325 = -92					; size = 4
_fdebug$88310 = -80					; size = 4
_fdebug$88301 = -68					; size = 4
_chunksize$88296 = -56					; size = 4
_fdebug$88292 = -44					; size = 4
_size$88286 = -32					; size = 4
_handle$88282 = -20					; size = 4
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_putdime PROC					; COMDAT

; 11125: { struct soap_multipart *content;

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11126:   if (!(soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN51@soap_putdi@3

; 11127:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN52@soap_putdi@3
$LN51@soap_putdi@3:

; 11128:   for (content = soap->dime.first; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90516]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	SHORT $LN50@soap_putdi@3
$LN49@soap_putdi@3:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$[ebp], ecx
$LN50@soap_putdi@3:
	cmp	DWORD PTR _content$[ebp], 0
	je	$LN48@soap_putdi@3

; 11129:   { void *handle;
; 11130:     soap->dime.size = content->size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+90480], edx

; 11131:     soap->dime.id = content->id;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+90500], edx

; 11132:     soap->dime.type = content->type;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+90504], edx

; 11133:     soap->dime.options = content->options;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+90508], edx

; 11134:     soap->dime.flags = SOAP_DIME_VERSION | SOAP_DIME_MEDIA;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+90492], 24		; 00000018H

; 11135:     if (soap->fdimereadopen && ((handle = soap->fdimereadopen(soap, (void*)content->ptr, content->id, content->type, content->options)) || soap->error))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12356], 0
	je	$LN47@soap_putdi@3
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12356]
	call	ecx
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _handle$88282[ebp], eax
	cmp	DWORD PTR _handle$88282[ebp], 0
	jne	SHORT $LN46@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN47@soap_putdi@3
$LN46@soap_putdi@3:

; 11136:     { size_t size = content->size;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _size$88286[ebp], ecx

; 11137:       if (!handle)

	cmp	DWORD PTR _handle$88282[ebp], 0
	jne	SHORT $LN45@soap_putdi@3

; 11138:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadopen failed\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN44@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN43@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN43@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN44@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88292[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BG@JDAMEDDJ@fdimereadopen?5failed?6?$AA@
	mov	eax, DWORD PTR _fdebug$88292[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88292[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN44@soap_putdi@3:

; 11139:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN52@soap_putdi@3
$LN45@soap_putdi@3:

; 11140:       }
; 11141:       if (!size && ((soap->mode & SOAP_ENC_XML) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE))

	cmp	DWORD PTR _size$88286[ebp], 0
	jne	$LN41@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN40@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	je	SHORT $LN40@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	$LN41@soap_putdi@3
$LN40@soap_putdi@3:

; 11142:       { size_t chunksize = sizeof(soap->tmpbuf);

	mov	DWORD PTR _chunksize$88296[ebp], 1024	; 00000400H

; 11143:         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked streaming DIME\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN36@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN38@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN38@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN36@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88301[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@HNFNOEPH@Chunked?5streaming?5DIME?6?$AA@
	mov	eax, DWORD PTR _fdebug$88301[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88301[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@soap_putdi@3:

; 11144:         do
; 11145:         { size = soap->fdimeread(soap, handle, soap->tmpbuf, chunksize);

	mov	esi, esp
	mov	eax, DWORD PTR _chunksize$88296[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _handle$88282[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12372]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _size$88286[ebp], eax

; 11146:           DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimeread returned %lu bytes\n", (unsigned long)size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN33@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN32@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN32@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN33@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88310[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _size$88286[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@FEIDJMEA@fdimeread?5returned?5?$CFlu?5bytes?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88310[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88310[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN33@soap_putdi@3:

; 11147:           if (size < chunksize)

	mov	eax, DWORD PTR _size$88286[ebp]
	cmp	eax, DWORD PTR _chunksize$88296[ebp]
	jae	SHORT $LN30@soap_putdi@3

; 11148:           { soap->dime.flags &= ~SOAP_DIME_CF;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, -2					; fffffffeH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al

; 11149:             if (!content->next)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN29@soap_putdi@3

; 11150:               soap->dime.flags |= SOAP_DIME_ME;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	or	ecx, 2
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al
$LN29@soap_putdi@3:

; 11151:           }
; 11152:           else

	jmp	SHORT $LN28@soap_putdi@3
$LN30@soap_putdi@3:

; 11153:             soap->dime.flags |= SOAP_DIME_CF;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	or	ecx, 1
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al
$LN28@soap_putdi@3:

; 11154:           soap->dime.size = size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _size$88286[ebp]
	mov	DWORD PTR [eax+90480], ecx

; 11155:           if (soap_putdimehdr(soap)
; 11156:            || soap_putdimefield(soap, soap->tmpbuf, size))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimehdr
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@soap_putdi@3
	mov	eax, DWORD PTR _size$88286[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_putdimefield
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@soap_putdi@3
$LN26@soap_putdi@3:

; 11157:             break;

	jmp	SHORT $LN34@soap_putdi@3
$LN27@soap_putdi@3:

; 11158:           if (soap->dime.id)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90500], 0
	je	SHORT $LN35@soap_putdi@3

; 11159:           { soap->dime.flags &= ~(SOAP_DIME_MB | SOAP_DIME_MEDIA);

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, -21				; ffffffebH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al

; 11160:             soap->dime.id = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90500], 0

; 11161:             soap->dime.type = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90504], 0

; 11162:             soap->dime.options = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90508], 0
$LN35@soap_putdi@3:

; 11163:           }
; 11164:         } while (size >= chunksize);

	mov	eax, DWORD PTR _size$88286[ebp]
	cmp	eax, DWORD PTR _chunksize$88296[ebp]
	jae	$LN36@soap_putdi@3
$LN34@soap_putdi@3:

; 11165:       }
; 11166:       else

	jmp	$LN24@soap_putdi@3
$LN41@soap_putdi@3:

; 11167:       { if (!content->next)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN23@soap_putdi@3

; 11168:           soap->dime.flags |= SOAP_DIME_ME;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	or	ecx, 2
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al
$LN23@soap_putdi@3:

; 11169:         if (soap_putdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@soap_putdi@3

; 11170:           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN52@soap_putdi@3
$LN21@soap_putdi@3:

; 11171:         do
; 11172:         { size_t bufsize;
; 11173:           if (size < sizeof(soap->tmpbuf))

	cmp	DWORD PTR _size$88286[ebp], 1024	; 00000400H
	jae	SHORT $LN18@soap_putdi@3

; 11174:             bufsize = size;

	mov	eax, DWORD PTR _size$88286[ebp]
	mov	DWORD PTR _bufsize$88325[ebp], eax

; 11175:           else

	jmp	SHORT $LN17@soap_putdi@3
$LN18@soap_putdi@3:

; 11176:             bufsize = sizeof(soap->tmpbuf);

	mov	DWORD PTR _bufsize$88325[ebp], 1024	; 00000400H
$LN17@soap_putdi@3:

; 11177:           if (!(bufsize = soap->fdimeread(soap, handle, soap->tmpbuf, bufsize)))

	mov	esi, esp
	mov	eax, DWORD PTR _bufsize$88325[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _handle$88282[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12372]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bufsize$88325[ebp], eax
	cmp	DWORD PTR _bufsize$88325[ebp], 0
	jne	$LN16@soap_putdi@3

; 11178:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimeread failed: insufficient data (%lu bytes remaining from %lu bytes)\n", (unsigned long)size, (unsigned long)content->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN15@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN14@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN14@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN15@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88333[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _size$88286[ebp]
	push	edx
	push	OFFSET ??_C@_0EK@LIIELHNN@fdimeread?5failed?3?5insufficient?5d@
	mov	eax, DWORD PTR _fdebug$88333[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88333[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@soap_putdi@3:

; 11179:             soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11180:             break;

	jmp	SHORT $LN19@soap_putdi@3
$LN16@soap_putdi@3:

; 11181:           }
; 11182:           if (soap_send_raw(soap, soap->tmpbuf, bufsize))

	mov	eax, DWORD PTR _bufsize$88325[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@soap_putdi@3

; 11183:             break;

	jmp	SHORT $LN19@soap_putdi@3
$LN12@soap_putdi@3:

; 11184:           size -= bufsize;

	mov	eax, DWORD PTR _size$88286[ebp]
	sub	eax, DWORD PTR _bufsize$88325[ebp]
	mov	DWORD PTR _size$88286[ebp], eax

; 11185:         } while (size);

	jne	$LN21@soap_putdi@3
$LN19@soap_putdi@3:

; 11186:         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadclose\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN11@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN10@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN10@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN11@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88342[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BA@PHDJCJEO@fdimereadclose?6?$AA@
	mov	eax, DWORD PTR _fdebug$88342[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88342[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@soap_putdi@3:

; 11187:         soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	push	ecx
	push	OFFSET _soap_padding
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN24@soap_putdi@3:

; 11188:       }
; 11189:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadclose\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_putdi@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_putdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_putdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88349[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BA@PHDJCJEO@fdimereadclose?6?$AA@
	mov	eax, DWORD PTR _fdebug$88349[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88349[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_putdi@3:

; 11190:       if (soap->fdimereadclose)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12364], 0
	je	SHORT $LN5@soap_putdi@3

; 11191:         soap->fdimereadclose(soap, handle);

	mov	esi, esp
	mov	eax, DWORD PTR _handle$88282[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12364]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_putdi@3:

; 11192:     }
; 11193:     else

	jmp	SHORT $LN4@soap_putdi@3
$LN47@soap_putdi@3:

; 11194:     { if (!content->next)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@soap_putdi@3

; 11195:         soap->dime.flags |= SOAP_DIME_ME;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	or	ecx, 2
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al
$LN3@soap_putdi@3:

; 11196:       if (soap_putdimehdr(soap)
; 11197:        || soap_putdimefield(soap, (char*)content->ptr, content->size))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimehdr
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_putdi@3
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_putdimefield
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_putdi@3
$LN1@soap_putdi@3:

; 11198:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN52@soap_putdi@3
$LN4@soap_putdi@3:

; 11199:     }
; 11200:   }

	jmp	$LN49@soap_putdi@3
$LN48@soap_putdi@3:

; 11201:   return SOAP_OK;

	xor	eax, eax
$LN52@soap_putdi@3:

; 11202: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putdime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@ENJJDNGC@DIME?5id?$DN?$CFs?0?5type?$DN?$CFs?0?5options?$DN?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@CKDDIPFB@DIME?5size?$DN?$CFlu?5flags?$DN0x?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@FMBNOAOD@?4?4?4?5From?5chunked?6?$AA@	; `string'
PUBLIC	??_C@_0BB@KKCAGKDD@Get?5DIME?5header?6?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_soap_getdimehdr
;	COMDAT ??_C@_0CB@ENJJDNGC@DIME?5id?$DN?$CFs?0?5type?$DN?$CFs?0?5options?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0CB@ENJJDNGC@DIME?5id?$DN?$CFs?0?5type?$DN?$CFs?0?5options?$DN?$CFs?6@ DB 'D'
	DB	'IME id=%s, type=%s, options=%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CKDDIPFB@DIME?5size?$DN?$CFlu?5flags?$DN0x?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BK@CKDDIPFB@DIME?5size?$DN?$CFlu?5flags?$DN0x?$CFX?6?$AA@ DB 'DIME'
	DB	' size=%lu flags=0x%X', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMBNOAOD@?4?4?4?5From?5chunked?6?$AA@
CONST	SEGMENT
??_C@_0BC@FMBNOAOD@?4?4?4?5From?5chunked?6?$AA@ DB '... From chunked', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KKCAGKDD@Get?5DIME?5header?6?$AA@
CONST	SEGMENT
??_C@_0BB@KKCAGKDD@Get?5DIME?5header?6?$AA@ DB 'Get DIME header', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_getdimehdr
_TEXT	SEGMENT
tv285 = -348						; size = 4
tv278 = -344						; size = 4
tv271 = -340						; size = 4
_fdebug$88426 = -140					; size = 4
_fdebug$88416 = -128					; size = 4
_fdebug$88402 = -116					; size = 4
_fdebug$88392 = -104					; size = 4
_typelen$ = -92						; size = 4
_idlen$ = -80						; size = 4
_optlen$ = -68						; size = 4
_tmp$ = -56						; size = 12
_i$ = -36						; size = 4
_s$ = -24						; size = 4
_c$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_getdimehdr PROC					; COMDAT

; 11245: { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 11246:   register char *s;
; 11247:   register int i;
; 11248:   unsigned char tmp[12];
; 11249:   size_t optlen, idlen, typelen;
; 11250:   if (!(soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN25@soap_getdi

; 11251:     return soap->error = SOAP_DIME_END;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 35		; 00000023H
	mov	eax, 35					; 00000023H
	jmp	$LN26@soap_getdi
$LN25@soap_getdi:

; 11252:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME header\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN24@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN23@soap_getdi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN23@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN24@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88392[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BB@KKCAGKDD@Get?5DIME?5header?6?$AA@
	mov	eax, DWORD PTR _fdebug$88392[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88392[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@soap_getdi:

; 11253:   if (soap->dime.buflen || soap->dime.chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90488], 0
	jne	SHORT $LN20@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90484], 0
	je	$LN21@soap_getdi
$LN20@soap_getdi:

; 11254:   { if (soap_move(soap, (long)(soap->dime.size - soap_tell(soap))))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_tell
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90480]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_move
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@soap_getdi

; 11255:       return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN26@soap_getdi
$LN19@soap_getdi:

; 11256:     soap_unget(soap, soap_getchar(soap)); /* skip padding and get hdr */

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12436], eax

; 11257:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "... From chunked\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN18@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN17@soap_getdi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN17@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN18@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88402[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BC@FMBNOAOD@?4?4?4?5From?5chunked?6?$AA@
	mov	eax, DWORD PTR _fdebug$88402[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88402[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@soap_getdi:

; 11258:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN26@soap_getdi
$LN21@soap_getdi:

; 11259:   }
; 11260:   s = (char*)tmp;

	lea	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 11261:   for (i = 12; i > 0; i--)

	mov	DWORD PTR _i$[ebp], 12			; 0000000cH
	jmp	SHORT $LN15@soap_getdi
$LN14@soap_getdi:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@soap_getdi:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN13@soap_getdi

; 11262:   { if ((int)(c = soap_getchar(soap)) == EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN12@soap_getdi

; 11263:       return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN26@soap_getdi
$LN12@soap_getdi:

; 11264:     *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 11265:   }

	jmp	SHORT $LN14@soap_getdi
$LN13@soap_getdi:

; 11266:   if ((tmp[0] & 0xF8) != SOAP_DIME_VERSION)

	movzx	eax, BYTE PTR _tmp$[ebp]
	and	eax, 248				; 000000f8H
	cmp	eax, 8
	je	SHORT $LN11@soap_getdi

; 11267:     return soap->error = SOAP_DIME_MISMATCH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 34		; 00000022H
	mov	eax, 34					; 00000022H
	jmp	$LN26@soap_getdi
$LN11@soap_getdi:

; 11268:   soap->dime.flags = (tmp[0] & 0x7) | (tmp[1] & 0xF0);

	movzx	ecx, BYTE PTR _tmp$[ebp]
	and	ecx, 7
	movzx	eax, BYTE PTR _tmp$[ebp+1]
	and	eax, 240				; 000000f0H
	or	ecx, eax
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al

; 11269:   optlen = (tmp[2] << 8) | tmp[3];

	movzx	eax, BYTE PTR _tmp$[ebp+2]
	shl	eax, 8
	movzx	ecx, BYTE PTR _tmp$[ebp+3]
	or	eax, ecx
	mov	DWORD PTR _optlen$[ebp], eax

; 11270:   idlen = (tmp[4] << 8) | tmp[5];

	movzx	eax, BYTE PTR _tmp$[ebp+4]
	shl	eax, 8
	movzx	ecx, BYTE PTR _tmp$[ebp+5]
	or	eax, ecx
	mov	DWORD PTR _idlen$[ebp], eax

; 11271:   typelen = (tmp[6] << 8) | tmp[7];

	movzx	eax, BYTE PTR _tmp$[ebp+6]
	shl	eax, 8
	movzx	ecx, BYTE PTR _tmp$[ebp+7]
	or	eax, ecx
	mov	DWORD PTR _typelen$[ebp], eax

; 11272:   soap->dime.size = (tmp[8] << 24) | (tmp[9] << 16) | (tmp[10] << 8) | tmp[11];

	movzx	eax, BYTE PTR _tmp$[ebp+8]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _tmp$[ebp+9]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _tmp$[ebp+10]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _tmp$[ebp+11]
	or	eax, ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90480], eax

; 11273:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME size=%lu flags=0x%X\n", (unsigned long)soap->dime.size, soap->dime.flags));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@soap_getdi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88416[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90480]
	push	eax
	push	OFFSET ??_C@_0BK@CKDDIPFB@DIME?5size?$DN?$CFlu?5flags?$DN0x?$CFX?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88416[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88416[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@soap_getdi:

; 11274:   if (!(soap->dime.options = soap_getdimefield(soap, optlen)) && soap->error)

	mov	eax, DWORD PTR _optlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getdimefield
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90508], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90508], 0
	jne	SHORT $LN7@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN7@soap_getdi

; 11275:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN26@soap_getdi
$LN7@soap_getdi:

; 11276:   if (!(soap->dime.id = soap_getdimefield(soap, idlen)) && soap->error)

	mov	eax, DWORD PTR _idlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getdimefield
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90500], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90500], 0
	jne	SHORT $LN6@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN6@soap_getdi

; 11277:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN26@soap_getdi
$LN6@soap_getdi:

; 11278:   if (!(soap->dime.type = soap_getdimefield(soap, typelen)) && soap->error)

	mov	eax, DWORD PTR _typelen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getdimefield
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90504], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90504], 0
	jne	SHORT $LN5@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN5@soap_getdi

; 11279:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN26@soap_getdi
$LN5@soap_getdi:

; 11280:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME id=%s, type=%s, options=%s\n", soap->dime.id?soap->dime.id:"", soap->dime.type?soap->dime.type:"", soap->dime.options?soap->dime.options+4:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN4@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN3@soap_getdi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN3@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN4@soap_getdi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88426[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90508], 0
	je	SHORT $LN28@soap_getdi
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90508]
	add	edx, 4
	mov	DWORD PTR tv271[ebp], edx
	jmp	SHORT $LN29@soap_getdi
$LN28@soap_getdi:
	mov	DWORD PTR tv271[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN29@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90504], 0
	je	SHORT $LN30@soap_getdi
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90504]
	mov	DWORD PTR tv278[ebp], edx
	jmp	SHORT $LN31@soap_getdi
$LN30@soap_getdi:
	mov	DWORD PTR tv278[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@soap_getdi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90500], 0
	je	SHORT $LN32@soap_getdi
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90500]
	mov	DWORD PTR tv285[ebp], edx
	jmp	SHORT $LN33@soap_getdi
$LN32@soap_getdi:
	mov	DWORD PTR tv285[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN33@soap_getdi:
	mov	esi, esp
	mov	eax, DWORD PTR tv271[ebp]
	push	eax
	mov	ecx, DWORD PTR tv278[ebp]
	push	ecx
	mov	edx, DWORD PTR tv285[ebp]
	push	edx
	push	OFFSET ??_C@_0CB@ENJJDNGC@DIME?5id?$DN?$CFs?0?5type?$DN?$CFs?0?5options?$DN?$CFs?6@
	mov	eax, DWORD PTR _fdebug$88426[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88426[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_getdi:

; 11281:   if (soap->dime.flags & SOAP_DIME_ME)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 2
	je	SHORT $LN1@soap_getdi

; 11282:     soap->mode &= ~SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@soap_getdi:

; 11283:   return SOAP_OK;

	xor	eax, eax
$LN26@soap_getdi:

; 11284: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN36@soap_getdi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN36@soap_getdi:
	DD	1
	DD	$LN35@soap_getdi
$LN35@soap_getdi:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN34@soap_getdi
$LN34@soap_getdi:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_soap_getdimehdr ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_getdimefield
_TEXT	SEGMENT
tv85 = -244						; size = 4
_p$ = -44						; size = 4
_s$ = -32						; size = 4
_i$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_n$ = 12						; size = 4
_soap_getdimefield PROC					; COMDAT

; 11211: { register soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11212:   register size_t i;
; 11213:   register char *s;
; 11214:   register char *p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 11215:   if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	$LN8@soap_getdi@2

; 11216:   { p = (char*)soap_malloc(soap, n + 1);

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 11217:     if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN7@soap_getdi@2

; 11218:     { s = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 11219:       for (i = n; i > 0; i--)

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN6@soap_getdi@2
$LN5@soap_getdi@2:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@soap_getdi@2:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	$LN4@soap_getdi@2

; 11220:       { if ((int)(c = soap_get1(soap)) == EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN11@soap_getdi@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@soap_getdi@2
	mov	DWORD PTR tv85[ebp], -1
	jmp	SHORT $LN12@soap_getdi@2
$LN11@soap_getdi@2:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv85[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN12@soap_getdi@2:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _c$[ebp], edx
	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN3@soap_getdi@2

; 11221:         { soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11222:           return NULL;

	xor	eax, eax
	jmp	SHORT $LN9@soap_getdi@2
$LN3@soap_getdi@2:

; 11223:         }
; 11224:         *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 11225:       }

	jmp	$LN5@soap_getdi@2
$LN4@soap_getdi@2:

; 11226:       *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 11227:       if ((soap->error = soap_move(soap, -(long)n&3)))

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	and	eax, 3
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_move
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN2@soap_getdi@2

; 11228:         return NULL;

	xor	eax, eax
	jmp	SHORT $LN9@soap_getdi@2
$LN2@soap_getdi@2:

; 11229:     }
; 11230:     else

	jmp	SHORT $LN8@soap_getdi@2
$LN7@soap_getdi@2:

; 11231:       soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
$LN8@soap_getdi@2:

; 11232:   }
; 11233:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN9@soap_getdi@2:

; 11234: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getdimefield ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_getdime
_TEXT	SEGMENT
tv256 = -340						; size = 4
_s$88484 = -140						; size = 4
_i$88483 = -128						; size = 4
_c$88482 = -116						; size = 4
_options$88477 = -104					; size = 4
_type$88476 = -92					; size = 4
_id$88475 = -80						; size = 4
_n$88452 = -68						; size = 4
_size$88451 = -56					; size = 4
_options$88450 = -44					; size = 4
_type$88449 = -32					; size = 4
_id$88448 = -20						; size = 4
_content$88443 = -8					; size = 4
_soap$ = 8						; size = 4
_soap_getdime PROC					; COMDAT

; 11295: { while (soap->dime.flags & SOAP_DIME_CF)

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN42@soap_getdi@3:
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	je	SHORT $LN41@soap_getdi@3

; 11296:   { if (soap_getdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN40@soap_getdi@3

; 11297:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_getdi@3
$LN40@soap_getdi@3:

; 11298:     if (soap_move(soap, (long)soap->dime.size))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_move
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@soap_getdi@3

; 11299:       return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN43@soap_getdi@3
$LN39@soap_getdi@3:

; 11300:   }

	jmp	SHORT $LN42@soap_getdi@3
$LN41@soap_getdi@3:

; 11301:   if (soap_move(soap, (long)(((soap->dime.size+3)&(~3))-soap_tell(soap))))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	esi, DWORD PTR [eax+90480]
	add	esi, 3
	and	esi, -4					; fffffffcH
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_tell
	add	esp, 4
	sub	esi, eax
	push	esi
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_move
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@soap_getdi@3

; 11302:     return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN43@soap_getdi@3
$LN37@soap_getdi@3:

; 11303:   for (;;)
; 11304:   { register struct soap_multipart *content;
; 11305:     if (soap_getdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN35@soap_getdi@3

; 11306:       break;

	jmp	$LN36@soap_getdi@3
$LN35@soap_getdi@3:

; 11307:     if (soap->fdimewriteopen && ((soap->dime.ptr = (char*)soap->fdimewriteopen(soap, soap->dime.id, soap->dime.type, soap->dime.options)) || soap->error))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12360], 0
	je	$LN34@soap_getdi@3
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90508]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90504]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90500]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12360]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90496], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90496], 0
	jne	SHORT $LN33@soap_getdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN34@soap_getdi@3
$LN33@soap_getdi@3:

; 11308:     { const char *id, *type, *options;
; 11309:       size_t size, n;
; 11310:       if (!soap->dime.ptr)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90496], 0
	jne	SHORT $LN32@soap_getdi@3

; 11311:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_getdi@3
$LN32@soap_getdi@3:

; 11312:       id = soap->dime.id;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90500]
	mov	DWORD PTR _id$88448[ebp], ecx

; 11313:       type = soap->dime.type;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90504]
	mov	DWORD PTR _type$88449[ebp], ecx

; 11314:       options = soap->dime.options;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90508]
	mov	DWORD PTR _options$88450[ebp], ecx
$LN31@soap_getdi@3:

; 11315:       for (;;)
; 11316:       { size = soap->dime.size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	mov	DWORD PTR _size$88451[ebp], ecx
$LN29@soap_getdi@3:

; 11317:         for (;;)
; 11318:         { n = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	DWORD PTR _n$88452[ebp], edx

; 11319:           if (size < n)

	mov	eax, DWORD PTR _size$88451[ebp]
	cmp	eax, DWORD PTR _n$88452[ebp]
	jae	SHORT $LN27@soap_getdi@3

; 11320:             n = size;

	mov	eax, DWORD PTR _size$88451[ebp]
	mov	DWORD PTR _n$88452[ebp], eax
$LN27@soap_getdi@3:

; 11321:           if ((soap->error = soap->fdimewrite(soap, (void*)soap->dime.ptr, soap->buf + soap->bufidx, n)))

	mov	esi, esp
	mov	eax, DWORD PTR _n$88452[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12468]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90496]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12376]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN26@soap_getdi@3

; 11322:             break;

	jmp	SHORT $LN28@soap_getdi@3
$LN26@soap_getdi@3:

; 11323:           size -= n;

	mov	eax, DWORD PTR _size$88451[ebp]
	sub	eax, DWORD PTR _n$88452[ebp]
	mov	DWORD PTR _size$88451[ebp], eax

; 11324:           if (!size)

	jne	SHORT $LN25@soap_getdi@3

; 11325:           { soap->bufidx += n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	add	ecx, DWORD PTR _n$88452[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12428], ecx

; 11326:             break;

	jmp	SHORT $LN28@soap_getdi@3
$LN25@soap_getdi@3:

; 11327:           }
; 11328:           if (soap_recv(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@soap_getdi@3

; 11329:           { soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	jmp	SHORT $end$88465

; 11330:             goto end;

	jmp	SHORT $end$88465
$LN24@soap_getdi@3:

; 11331:           }
; 11332:         }

	jmp	$LN29@soap_getdi@3
$LN28@soap_getdi@3:

; 11333:         if (soap_move(soap, -(long)soap->dime.size&3))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_move
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@soap_getdi@3

; 11334:         { soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11335:           break;

	jmp	SHORT $end$88465
$LN22@soap_getdi@3:

; 11336:         }
; 11337:         if (!(soap->dime.flags & SOAP_DIME_CF))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	jne	SHORT $LN21@soap_getdi@3

; 11338:           break;

	jmp	SHORT $end$88465
$LN21@soap_getdi@3:

; 11339:         if (soap_getdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@soap_getdi@3

; 11340:           break;

	jmp	SHORT $end$88465
$LN20@soap_getdi@3:

; 11341:       }

	jmp	$LN31@soap_getdi@3
$end$88465:

; 11342: end:
; 11343:       if (soap->fdimewriteclose)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12368], 0
	je	SHORT $LN19@soap_getdi@3

; 11344:         soap->fdimewriteclose(soap, (void*)soap->dime.ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90496]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12368]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_getdi@3:

; 11345:       soap->dime.size = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90480], 0

; 11346:       soap->dime.id = id;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _id$88448[ebp]
	mov	DWORD PTR [eax+90500], ecx

; 11347:       soap->dime.type = type;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _type$88449[ebp]
	mov	DWORD PTR [eax+90504], ecx

; 11348:       soap->dime.options = options;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _options$88450[ebp]
	mov	DWORD PTR [eax+90508], ecx
	jmp	$LN18@soap_getdi@3
$LN34@soap_getdi@3:

; 11349:     }
; 11350:     else if (soap->dime.flags & SOAP_DIME_CF)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	je	$LN17@soap_getdi@3

; 11351:     { const char *id, *type, *options;
; 11352:       id = soap->dime.id;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90500]
	mov	DWORD PTR _id$88475[ebp], ecx

; 11353:       type = soap->dime.type;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90504]
	mov	DWORD PTR _type$88476[ebp], ecx

; 11354:       options = soap->dime.options;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90508]
	mov	DWORD PTR _options$88477[ebp], ecx

; 11355:       if (soap_new_block(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_block
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@soap_getdi@3

; 11356:         return SOAP_EOM;

	mov	eax, 20					; 00000014H
	jmp	$LN43@soap_getdi@3
$LN15@soap_getdi@3:

; 11357:       for (;;)
; 11358:       { register soap_wchar c;
; 11359:         register size_t i;
; 11360:         register char *s;
; 11361:         s = (char*)soap_push_block(soap, soap->dime.size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_push_block
	add	esp, 8
	mov	DWORD PTR _s$88484[ebp], eax

; 11362:         if (!s)

	cmp	DWORD PTR _s$88484[ebp], 0
	jne	SHORT $LN13@soap_getdi@3

; 11363:           return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN43@soap_getdi@3
$LN13@soap_getdi@3:

; 11364:         for (i = soap->dime.size; i > 0; i--)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	mov	DWORD PTR _i$88483[ebp], ecx
	jmp	SHORT $LN12@soap_getdi@3
$LN11@soap_getdi@3:
	mov	eax, DWORD PTR _i$88483[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$88483[ebp], eax
$LN12@soap_getdi@3:
	cmp	DWORD PTR _i$88483[ebp], 0
	jbe	$LN10@soap_getdi@3

; 11365:         { if ((int)(c = soap_get1(soap)) == EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN45@soap_getdi@3
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN45@soap_getdi@3
	mov	DWORD PTR tv256[ebp], -1
	jmp	SHORT $LN46@soap_getdi@3
$LN45@soap_getdi@3:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv256[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN46@soap_getdi@3:
	mov	edx, DWORD PTR tv256[ebp]
	mov	DWORD PTR _c$88482[ebp], edx
	cmp	DWORD PTR _c$88482[ebp], -1
	jne	SHORT $LN9@soap_getdi@3

; 11366:             return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN43@soap_getdi@3
$LN9@soap_getdi@3:

; 11367:           *s++ = (char)c;

	mov	ecx, DWORD PTR _c$88482[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$88484[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$88484[ebp]
	add	edx, 1
	mov	DWORD PTR _s$88484[ebp], edx

; 11368:         }

	jmp	$LN11@soap_getdi@3
$LN10@soap_getdi@3:

; 11369:         if (soap_move(soap, -(long)soap->dime.size&3))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_move
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@soap_getdi@3

; 11370:           return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN43@soap_getdi@3
$LN8@soap_getdi@3:

; 11371:         if (!(soap->dime.flags & SOAP_DIME_CF))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	jne	SHORT $LN7@soap_getdi@3

; 11372:           break;

	jmp	SHORT $LN14@soap_getdi@3
$LN7@soap_getdi@3:

; 11373:         if (soap_getdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_getdi@3

; 11374:           return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_getdi@3
$LN6@soap_getdi@3:

; 11375:       }

	jmp	$LN15@soap_getdi@3
$LN14@soap_getdi@3:

; 11376:       soap->dime.size = soap->blist->size++; /* allocate one more for '\0' */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+90480], eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [edx+8], eax

; 11377:       if (!(soap->dime.ptr = soap_save_block(soap, NULL, 0)))

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_save_block
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90496], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90496], 0
	jne	SHORT $LN5@soap_getdi@3

; 11378:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN43@soap_getdi@3
$LN5@soap_getdi@3:

; 11379:       soap->dime.ptr[soap->dime.size] = '\0'; /* force 0-terminated */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90496]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90480]
	mov	BYTE PTR [ecx+eax], 0

; 11380:       soap->dime.id = id;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _id$88475[ebp]
	mov	DWORD PTR [eax+90500], ecx

; 11381:       soap->dime.type = type;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _type$88476[ebp]
	mov	DWORD PTR [eax+90504], ecx

; 11382:       soap->dime.options = options;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _options$88477[ebp]
	mov	DWORD PTR [eax+90508], ecx

; 11383:     }
; 11384:     else

	jmp	SHORT $LN18@soap_getdi@3
$LN17@soap_getdi@3:

; 11385:       soap->dime.ptr = soap_getdimefield(soap, soap->dime.size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_getdimefield
	add	esp, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90496], eax
$LN18@soap_getdi@3:

; 11386:     content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, soap->dime.ptr, soap->dime.size);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90496]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 90520				; 00016198H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 90516				; 00016194H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_multipart
	add	esp, 20					; 00000014H
	mov	DWORD PTR _content$88443[ebp], eax

; 11387:     if (!content)

	cmp	DWORD PTR _content$88443[ebp], 0
	jne	SHORT $LN3@soap_getdi@3

; 11388:       return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	SHORT $LN43@soap_getdi@3
$LN3@soap_getdi@3:

; 11389:     content->id = soap->dime.id;

	mov	eax, DWORD PTR _content$88443[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90500]
	mov	DWORD PTR [eax+12], edx

; 11390:     content->type = soap->dime.type;

	mov	eax, DWORD PTR _content$88443[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90504]
	mov	DWORD PTR [eax+16], edx

; 11391:     content->options = soap->dime.options;

	mov	eax, DWORD PTR _content$88443[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90508]
	mov	DWORD PTR [eax+20], edx

; 11392:     if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN2@soap_getdi@3

; 11393:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN43@soap_getdi@3
$LN2@soap_getdi@3:

; 11394:     soap_resolve_attachment(soap, content);

	mov	eax, DWORD PTR _content$88443[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_resolve_attachment
	add	esp, 8

; 11395:   }

	jmp	$LN37@soap_getdi@3
$LN36@soap_getdi@3:

; 11396:   if (soap->error != SOAP_DIME_END)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 35		; 00000023H
	je	SHORT $LN1@soap_getdi@3

; 11397:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN43@soap_getdi@3
$LN1@soap_getdi@3:

; 11398:   return soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
	xor	eax, eax
$LN43@soap_getdi@3:

; 11399: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getdime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@ ; `string'
PUBLIC	??_C@_0BE@CDHADPEM@Content?9Description?$AA@	; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type?$AA@		; `string'
PUBLIC	_soap_get_header_attribute
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@	; `string'
PUBLIC	??_C@_0BB@EPBMDIDM@Content?9Location?$AA@	; `string'
PUBLIC	??_C@_0L@BJKBKLJG@Content?9ID?$AA@		; `string'
PUBLIC	??_C@_0BB@EGGDHBGP@MIME?5header?3?5?$CFs?6?$AA@	; `string'
PUBLIC	_soap_set_mime_attachment
PUBLIC	_soap_getmimehdr
;	COMDAT ??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@ DB 'Content-Transfer-'
	DB	'Encoding', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDHADPEM@Content?9Description?$AA@
CONST	SEGMENT
??_C@_0BE@CDHADPEM@Content?9Description?$AA@ DB 'Content-Description', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type?$AA@ DB 'Content-Type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@
CONST	SEGMENT
??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@ DB 'Content-Disposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPBMDIDM@Content?9Location?$AA@
CONST	SEGMENT
??_C@_0BB@EPBMDIDM@Content?9Location?$AA@ DB 'Content-Location', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJKBKLJG@Content?9ID?$AA@
CONST	SEGMENT
??_C@_0L@BJKBKLJG@Content?9ID?$AA@ DB 'Content-ID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EGGDHBGP@MIME?5header?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@EGGDHBGP@MIME?5header?3?5?$CFs?6?$AA@ DB 'MIME header: %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_getmimehdr
_TEXT	SEGMENT
_fdebug$88531 = -56					; size = 4
_val$88525 = -44					; size = 4
_key$88524 = -32					; size = 4
_s$88512 = -20						; size = 4
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_getmimehdr PROC					; COMDAT

; 11410: { struct soap_multipart *content;

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN35@soap_getmi:

; 11411:   do
; 11412:   { if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getline
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@soap_getmi

; 11413:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN36@soap_getmi
$LN34@soap_getmi:

; 11414:   }
; 11415:   while (!*soap->msgbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+78004]
	test	ecx, ecx
	je	SHORT $LN35@soap_getmi

; 11416:   if (soap->msgbuf[0] == '-' && soap->msgbuf[1] == '-')

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+78004]
	cmp	ecx, 45					; 0000002dH
	jne	$LN31@soap_getmi
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+78005]
	cmp	ecx, 45					; 0000002dH
	jne	$LN31@soap_getmi

; 11417:   { char *s = soap->msgbuf + strlen(soap->msgbuf) - 1;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _soap$[ebp]
	lea	edx, DWORD PTR [ecx+eax+78003]
	mov	DWORD PTR _s$88512[ebp], edx
$LN30@soap_getmi:

; 11418:     /* remove white space */
; 11419:     while (soap_blank(*s))

	mov	eax, DWORD PTR _s$88512[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN29@soap_getmi
	mov	eax, DWORD PTR _s$88512[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN29@soap_getmi

; 11420:       s--;

	mov	eax, DWORD PTR _s$88512[ebp]
	sub	eax, 1
	mov	DWORD PTR _s$88512[ebp], eax
	jmp	SHORT $LN30@soap_getmi
$LN29@soap_getmi:

; 11421:     s[1] = '\0';

	mov	eax, DWORD PTR _s$88512[ebp]
	mov	BYTE PTR [eax+1], 0

; 11422:     if (soap->mime.boundary)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	SHORT $LN28@soap_getmi

; 11423:     { if (strcmp(soap->msgbuf + 2, soap->mime.boundary))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78006				; 000130b6H
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@soap_getmi

; 11424:         return soap->error = SOAP_MIME_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 36		; 00000024H
	mov	eax, 36					; 00000024H
	jmp	$LN36@soap_getmi
$LN27@soap_getmi:

; 11425:     }
; 11426:     else

	jmp	SHORT $LN26@soap_getmi
$LN28@soap_getmi:

; 11427:       soap->mime.boundary = soap_strdup(soap, soap->msgbuf + 2);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78006				; 000130b6H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90524], eax
$LN26@soap_getmi:

; 11428:     if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getline
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN31@soap_getmi

; 11429:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN36@soap_getmi
$LN31@soap_getmi:

; 11430:   }
; 11431:   if (soap_set_mime_attachment(soap, NULL, 0, SOAP_MIME_NONE, NULL, NULL, NULL, NULL))

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_mime_attachment
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN24@soap_getmi

; 11432:     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN36@soap_getmi
$LN24@soap_getmi:

; 11433:   content = soap->mime.last;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90540]
	mov	DWORD PTR _content$[ebp], ecx
$LN23@soap_getmi:

; 11434:   for (;;)
; 11435:   { register char *key = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	DWORD PTR _key$88524[ebp], eax

; 11436:     register char *val;
; 11437:     if (!*key)

	mov	eax, DWORD PTR _key$88524[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN21@soap_getmi

; 11438:       break;

	jmp	$LN22@soap_getmi
$LN21@soap_getmi:

; 11439:     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "MIME header: %s\n", key));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN20@soap_getmi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN19@soap_getmi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN19@soap_getmi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN20@soap_getmi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88531[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@EGGDHBGP@MIME?5header?3?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88531[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88531[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@soap_getmi:

; 11440:     val = strchr(soap->msgbuf, ':');

	push	58					; 0000003aH
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _val$88525[ebp], eax

; 11441:     if (val)

	cmp	DWORD PTR _val$88525[ebp], 0
	je	$LN17@soap_getmi

; 11442:     { *val = '\0';

	mov	eax, DWORD PTR _val$88525[ebp]
	mov	BYTE PTR [eax], 0
$LN16@soap_getmi:

; 11443:       do val++;

	mov	eax, DWORD PTR _val$88525[ebp]
	add	eax, 1
	mov	DWORD PTR _val$88525[ebp], eax

; 11444:       while (*val && *val <= 32);

	mov	eax, DWORD PTR _val$88525[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN14@soap_getmi
	mov	eax, DWORD PTR _val$88525[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN16@soap_getmi
$LN14@soap_getmi:

; 11445:       if (!soap_tag_cmp(key, "Content-ID"))

	push	OFFSET ??_C@_0L@BJKBKLJG@Content?9ID?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@soap_getmi

; 11446:         content->id = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN17@soap_getmi
$LN12@soap_getmi:

; 11447:       else if (!soap_tag_cmp(key, "Content-Location"))

	push	OFFSET ??_C@_0BB@EPBMDIDM@Content?9Location?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_getmi

; 11448:         content->location = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+28], eax
	jmp	$LN17@soap_getmi
$LN10@soap_getmi:

; 11449:       else if (!soap_tag_cmp(key, "Content-Disposition"))

	push	OFFSET ??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_getmi

; 11450:         content->id = soap_strdup(soap, soap_get_header_attribute(soap, val, "name"));

	push	OFFSET ??_C@_04MEMAJGDJ@name?$AA@
	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	$LN17@soap_getmi
$LN8@soap_getmi:

; 11451:       else if (!soap_tag_cmp(key, "Content-Type"))

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_getmi

; 11452:         content->type = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN17@soap_getmi
$LN6@soap_getmi:

; 11453:       else if (!soap_tag_cmp(key, "Content-Description"))

	push	OFFSET ??_C@_0BE@CDHADPEM@Content?9Description?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_getmi

; 11454:         content->description = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $LN17@soap_getmi
$LN4@soap_getmi:

; 11455:       else if (!soap_tag_cmp(key, "Content-Transfer-Encoding"))

	push	OFFSET ??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@soap_getmi

; 11456:         content->encoding = (enum soap_mime_encoding)soap_code_int(mime_codes, val, (long)SOAP_MIME_NONE);

	push	0
	mov	eax, DWORD PTR _val$88525[ebp]
	push	eax
	push	OFFSET _mime_codes
	call	_soap_code_int
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN17@soap_getmi:

; 11457:     }
; 11458:     if (soap_getline(soap, key, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _key$88524[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getline
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_getmi

; 11459:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN36@soap_getmi
$LN1@soap_getmi:

; 11460:   }

	jmp	$LN23@soap_getmi
$LN22@soap_getmi:

; 11461:   return SOAP_OK;

	xor	eax, eax
$LN36@soap_getmi:

; 11462: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getmimehdr ENDP
_TEXT	ENDS
PUBLIC	_soap_get_mime_attachment
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_getmime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_getmime PROC					; COMDAT

; 11473: { while (soap_get_mime_attachment(soap, NULL))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@soap_getmi@2:
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get_mime_attachment
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_getmi@2

; 11474:     ;

	jmp	SHORT $LN2@soap_getmi@2
$LN1@soap_getmi@2:

; 11475:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 11476: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_getmime ENDP
_TEXT	ENDS
PUBLIC	_soap_post_check_mime_attachments
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_post_check_mime_attachments
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_post_check_mime_attachments PROC			; COMDAT

; 11487: { soap->imode |= SOAP_MIME_POSTCHECK;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 268435456				; 10000000H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 11488: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_post_check_mime_attachments ENDP
_TEXT	ENDS
PUBLIC	_soap_check_mime_attachments
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_check_mime_attachments
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_check_mime_attachments PROC			; COMDAT

; 11499: { if (soap->mode & SOAP_MIME_POSTCHECK)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN1@soap_check@2

; 11500:     return soap_get_mime_attachment(soap, NULL) != NULL;

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get_mime_attachment
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@soap_check@2
$LN1@soap_check@2:

; 11501:   return 0;

	xor	eax, eax
$LN2@soap_check@2:

; 11502: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_check_mime_attachments ENDP
_TEXT	ENDS
PUBLIC	??_C@_03KBLJEPNL@?6?9?9?$AA@			; `string'
PUBLIC	??_C@_0CE@DNDHAFDE@Parsing?5MIME?5content?5id?$DN?$CFs?5type?$DN@ ; `string'
EXTRN	__imp__strncat:PROC
;	COMDAT ??_C@_03KBLJEPNL@?6?9?9?$AA@
CONST	SEGMENT
??_C@_03KBLJEPNL@?6?9?9?$AA@ DB 0aH, '--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DNDHAFDE@Parsing?5MIME?5content?5id?$DN?$CFs?5type?$DN@
CONST	SEGMENT
??_C@_0CE@DNDHAFDE@Parsing?5MIME?5content?5id?$DN?$CFs?5type?$DN@ DB 'Par'
	DB	'sing MIME content id=%s type=%s', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_get_mime_attachment
_TEXT	SEGMENT
tv151 = -296						; size = 4
tv215 = -292						; size = 4
tv190 = -292						; size = 4
tv146 = -292						; size = 4
_fdebug$88597 = -92					; size = 4
_flag$ = -80						; size = 2
_content$ = -68						; size = 4
_t$ = -56						; size = 4
_s$ = -44						; size = 4
_m$ = -32						; size = 4
_i$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_handle$ = 12						; size = 4
_soap_get_mime_attachment PROC				; COMDAT

; 11513: { register soap_wchar c = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _c$[ebp], 0

; 11514:   register size_t i, m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 11515:   register char *s, *t = NULL;

	mov	DWORD PTR _t$[ebp], 0

; 11516:   register struct soap_multipart *content;
; 11517:   register short flag = 0;

	xor	eax, eax
	mov	WORD PTR _flag$[ebp], ax

; 11518:   if (!(soap->mode & SOAP_ENC_MIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	jne	SHORT $LN48@soap_get_m

; 11519:     return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN48@soap_get_m:

; 11520:   content = soap->mime.last;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90540]
	mov	DWORD PTR _content$[ebp], ecx

; 11521:   if (!content)

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN47@soap_get_m

; 11522:   { if (soap_getmimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getmimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@soap_get_m

; 11523:       return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN46@soap_get_m:

; 11524:     content = soap->mime.last;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90540]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	$LN45@soap_get_m
$LN47@soap_get_m:

; 11525:   }
; 11526:   else if (content != soap->mime.first)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	cmp	ecx, DWORD PTR [eax+90536]
	je	SHORT $LN45@soap_get_m

; 11527:   { if (soap->fmimewriteopen && ((content->ptr = (char*)soap->fmimewriteopen(soap, (void*)handle, content->id, content->type, content->description, content->encoding)) || soap->error))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12384], 0
	je	SHORT $LN45@soap_get_m
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12384]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN42@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN45@soap_get_m
$LN42@soap_get_m:

; 11528:     { if (!content->ptr)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN45@soap_get_m

; 11529:         return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN45@soap_get_m:

; 11530:     }
; 11531:   }
; 11532:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Parsing MIME content id=%s type=%s\n", content->id?content->id:"", content->type?content->type:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN40@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN39@soap_get_m
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN39@soap_get_m:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	$LN40@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88597[ebp], ecx
	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN51@soap_get_m
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN52@soap_get_m
$LN51@soap_get_m:
	mov	DWORD PTR tv146[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN52@soap_get_m:
	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN53@soap_get_m
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv151[ebp], edx
	jmp	SHORT $LN54@soap_get_m
$LN53@soap_get_m:
	mov	DWORD PTR tv151[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN54@soap_get_m:
	mov	esi, esp
	mov	eax, DWORD PTR tv146[ebp]
	push	eax
	mov	ecx, DWORD PTR tv151[ebp]
	push	ecx
	push	OFFSET ??_C@_0CE@DNDHAFDE@Parsing?5MIME?5content?5id?$DN?$CFs?5type?$DN@
	mov	edx, DWORD PTR _fdebug$88597[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88597[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@soap_get_m:

; 11533:   if (!content->ptr && soap_new_block(soap))

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN36@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_new_block
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@soap_get_m

; 11534:   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 11535:     return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN36@soap_get_m:

; 11536:   }
; 11537:   for (;;)
; 11538:   { if (content->ptr)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN34@soap_get_m

; 11539:       s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN33@soap_get_m
$LN34@soap_get_m:

; 11540:     else if (!(s = (char*)soap_push_block(soap, sizeof(soap->tmpbuf))))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_push_block
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN33@soap_get_m

; 11541:     { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 11542:       return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN33@soap_get_m:

; 11543:     }
; 11544:     for (i = 0; i < sizeof(soap->tmpbuf); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@soap_get_m
$LN30@soap_get_m:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN31@soap_get_m:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jae	$LN29@soap_get_m

; 11545:     { if (m > 0)

	cmp	DWORD PTR _m$[ebp], 0
	jbe	SHORT $LN28@soap_get_m

; 11546:       { *s++ = *t++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 11547:         m--;

	mov	eax, DWORD PTR _m$[ebp]
	sub	eax, 1
	mov	DWORD PTR _m$[ebp], eax

; 11548:       }
; 11549:       else

	jmp	$LN27@soap_get_m
$LN28@soap_get_m:

; 11550:       { if (!flag)

	movsx	eax, WORD PTR _flag$[ebp]
	test	eax, eax
	jne	$LN26@soap_get_m

; 11551:         { c = soap_get1(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN55@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN55@soap_get_m
	mov	DWORD PTR tv190[ebp], -1
	jmp	SHORT $LN56@soap_get_m
$LN55@soap_get_m:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv190[ebp], ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12428]
	add	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12428], eax
$LN56@soap_get_m:
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 11552:           if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN26@soap_get_m

; 11553:           { soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11554:             return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN26@soap_get_m:

; 11555:           }
; 11556:         }
; 11557:         if (flag || c == '\r')

	movsx	eax, WORD PTR _flag$[ebp]
	test	eax, eax
	jne	SHORT $LN23@soap_get_m
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jne	$LN24@soap_get_m
$LN23@soap_get_m:

; 11558:         { t = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	DWORD PTR _t$[ebp], eax

; 11559:           memset(t, 0, sizeof(soap->msgbuf));

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 11560:           strcpy(t, "\n--");

	push	OFFSET ??_C@_03KBLJEPNL@?6?9?9?$AA@
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 11561:           if (soap->mime.boundary)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	SHORT $LN21@soap_get_m

; 11562:             strncat(t, soap->mime.boundary, sizeof(soap->msgbuf)-4);

	mov	esi, esp
	push	1020					; 000003fcH
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_get_m:

; 11563:           do c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 11564:           while (c == *t++);

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	cmp	edx, ecx
	jne	SHORT $LN57@soap_get_m
	mov	DWORD PTR tv215[ebp], 1
	jmp	SHORT $LN58@soap_get_m
$LN57@soap_get_m:
	mov	DWORD PTR tv215[ebp], 0
$LN58@soap_get_m:
	cmp	DWORD PTR tv215[ebp], 0
	jne	SHORT $LN21@soap_get_m

; 11565:           if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN18@soap_get_m

; 11566:           { soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11567:             return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN18@soap_get_m:

; 11568:           }
; 11569:           if (!*--t)

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN17@soap_get_m
	jmp	$end$88626

; 11570:             goto end;

	jmp	$end$88626
$LN17@soap_get_m:

; 11571:           *t = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al

; 11572:           flag = (c == '\r');

	xor	eax, eax
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	sete	al
	mov	WORD PTR _flag$[ebp], ax

; 11573:           m = t - soap->msgbuf + 1 - flag;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _t$[ebp]
	sub	ecx, eax
	add	ecx, 1
	movsx	edx, WORD PTR _flag$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _m$[ebp], ecx

; 11574:           t = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	DWORD PTR _t$[ebp], eax

; 11575:           c = '\r';

	mov	DWORD PTR _c$[ebp], 13			; 0000000dH
$LN24@soap_get_m:

; 11576:         }
; 11577:         *s++ = (char)c;

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN27@soap_get_m:

; 11578:       }
; 11579:     }

	jmp	$LN30@soap_get_m
$LN29@soap_get_m:

; 11580:     if (content->ptr && soap->fmimewrite)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN15@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12400], 0
	je	SHORT $LN15@soap_get_m

; 11581:     { if ((soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i)))

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12400]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN15@soap_get_m

; 11582:         break;

	jmp	SHORT $end$88626
$LN15@soap_get_m:

; 11583:     }

	jmp	$LN36@soap_get_m
$end$88626:

; 11584:   }
; 11585: end:
; 11586:   *s = '\0'; /* force 0-terminated */

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 11587:   if (content->ptr)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN13@soap_get_m

; 11588:   { if (!soap->error && soap->fmimewrite)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	jne	SHORT $LN12@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12400], 0
	je	SHORT $LN12@soap_get_m

; 11589:       soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12400]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
$LN12@soap_get_m:

; 11590:     if (soap->fmimewriteclose)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12392], 0
	je	SHORT $LN11@soap_get_m

; 11591:       soap->fmimewriteclose(soap, (void*)content->ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12392]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@soap_get_m:

; 11592:     if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN10@soap_get_m

; 11593:       return NULL;

	xor	eax, eax
	jmp	$LN49@soap_get_m
$LN10@soap_get_m:

; 11594:   }
; 11595:   else

	jmp	SHORT $LN9@soap_get_m
$LN13@soap_get_m:

; 11596:   { content->size = soap_size_block(soap, i+1)-1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_size_block
	add	esp, 8
	sub	eax, 1
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+8], eax

; 11597:     content->ptr = soap_save_block(soap, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_save_block
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN9@soap_get_m:

; 11598:   }
; 11599:   soap_resolve_attachment(soap, content);

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_resolve_attachment
	add	esp, 8

; 11600:   if (c == '-' && soap_getchar(soap) == '-')

	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	SHORT $LN5@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN5@soap_get_m

; 11601:   { soap->mode &= ~SOAP_ENC_MIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 11602:     if ((soap->mode & SOAP_MIME_POSTCHECK) && soap_end_recv(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN7@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@soap_get_m

; 11603:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN49@soap_get_m
$LN7@soap_get_m:

; 11604:   }
; 11605:   else

	jmp	SHORT $LN6@soap_get_m
$LN5@soap_get_m:

; 11606:   { while (c != '\r' && (int)c != EOF && soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN4@soap_get_m
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN4@soap_get_m
	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN4@soap_get_m
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN4@soap_get_m

; 11607:       c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN5@soap_get_m
$LN4@soap_get_m:

; 11608:     if (c != '\r' || soap_getchar(soap) != '\n')

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jne	SHORT $LN2@soap_get_m
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@soap_get_m
$LN2@soap_get_m:

; 11609:     { soap->error = SOAP_MIME_ERROR;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 36		; 00000024H

; 11610:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN49@soap_get_m
$LN3@soap_get_m:

; 11611:     }
; 11612:     if (soap_getmimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getmimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_get_m

; 11613:       return NULL;

	xor	eax, eax
	jmp	SHORT $LN49@soap_get_m
$LN6@soap_get_m:

; 11614:   }
; 11615:   return content;

	mov	eax, DWORD PTR _content$[ebp]
$LN49@soap_get_m:

; 11616: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_get_mime_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_match_cid
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_match_cid
_TEXT	SEGMENT
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_match_cid PROC					; COMDAT

; 11627: { register size_t n;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11628:   if (!s)

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN6@soap_match@4

; 11629:     return 1;

	mov	eax, 1
	jmp	$LN7@soap_match@4
$LN6@soap_match@4:

; 11630:   if (!strcmp(s, t))

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@soap_match@4

; 11631:     return 0;

	xor	eax, eax
	jmp	$LN7@soap_match@4
$LN5@soap_match@4:

; 11632:   if (!strncmp(s, "cid:", 4))

	mov	esi, esp
	push	4
	push	OFFSET ??_C@_04MLBGAAHD@cid?3?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN4@soap_match@4

; 11633:     s += 4;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 4
	mov	DWORD PTR _s$[ebp], eax
$LN4@soap_match@4:

; 11634:   n = strlen(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 11635:   if (*t == '<')

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN3@soap_match@4

; 11636:   { t++;

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax

; 11637:     n -= 2;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 2
	mov	DWORD PTR _n$[ebp], eax
$LN3@soap_match@4:

; 11638:   }
; 11639:   if (!strncmp(s, t, n) && !s[n])

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@soap_match@4
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@soap_match@4

; 11640:     return 0;

	xor	eax, eax
	jmp	SHORT $LN7@soap_match@4
$LN2@soap_match@4:

; 11641:   soap_decode(soap->tmpbuf, sizeof(soap->tmpbuf), s, SOAP_STR_EOS);

	push	OFFSET _soap_padding
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_soap_decode
	add	esp, 16					; 00000010H

; 11642:   if (!strncmp(soap->tmpbuf, t, n) && !soap->tmpbuf[n])

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_match@4
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax+79028]
	test	ecx, ecx
	jne	SHORT $LN1@soap_match@4

; 11643:     return 0;

	xor	eax, eax
	jmp	SHORT $LN7@soap_match@4
$LN1@soap_match@4:

; 11644:   return 1;

	mov	eax, 1
$LN7@soap_match@4:

; 11645: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_match_cid ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_resolve_attachment@@9@4JA@6501541a ; `soap_resolve_attachment'::`2'::__LINE__Var
PUBLIC	??_C@_0DA@PJFPGBOI@Found?5matching?5attachment?5?$CFs?5for@ ; `string'
PUBLIC	??_C@_0CF@PPPDAIHK@Resolving?5attachment?5data?5for?5id@ ; `string'
;	COMDAT ?__LINE__Var@?1??soap_resolve_attachment@@9@4JA@6501541a
_DATA	SEGMENT
?__LINE__Var@?1??soap_resolve_attachment@@9@4JA@6501541a DD 02d86H ; `soap_resolve_attachment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DA@PJFPGBOI@Found?5matching?5attachment?5?$CFs?5for@
CONST	SEGMENT
??_C@_0DA@PJFPGBOI@Found?5matching?5attachment?5?$CFs?5for@ DB 'Found mat'
	DB	'ching attachment %s for content id=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PPPDAIHK@Resolving?5attachment?5data?5for?5id@
CONST	SEGMENT
??_C@_0CF@PPPDAIHK@Resolving?5attachment?5data?5for?5id@ DB 'Resolving at'
	DB	'tachment data for id=%s', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_resolve_attachment
_TEXT	SEGMENT
_fdebug$88683 = -44					; size = 4
_xq$88677 = -32						; size = 4
_fdebug$88672 = -20					; size = 4
_xp$88667 = -8						; size = 4
_soap$ = 8						; size = 4
_content$ = 12						; size = 4
_soap_resolve_attachment PROC				; COMDAT

; 11654: { if (content->id)

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN14@soap_resol@2

; 11655:   { register struct soap_xlist **xp = &soap->xlist;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 90544				; 000161b0H
	mov	DWORD PTR _xp$88667[ebp], eax

; 11656:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving attachment data for id=%s\n", content->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN9@soap_resol@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN11@soap_resol@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN11@soap_resol@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_resol@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88672[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0CF@PPPDAIHK@Resolving?5attachment?5data?5for?5id@
	mov	edx, DWORD PTR _fdebug$88672[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88672[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_resol@2:

; 11657:     while (*xp)

	mov	eax, DWORD PTR _xp$88667[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN14@soap_resol@2

; 11658:     { register struct soap_xlist *xq = *xp;

	mov	eax, DWORD PTR _xp$88667[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xq$88677[ebp], ecx

; 11659:       if (!soap_match_cid(soap, xq->id, content->id))

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _xq$88677[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_cid
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@soap_resol@2

; 11660:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Found matching attachment %s for content id=%s\n", xq->id, content->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_resol@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_resol@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_resol@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_resol@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88683[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _xq$88677[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_0DA@PJFPGBOI@Found?5matching?5attachment?5?$CFs?5for@
	mov	ecx, DWORD PTR _fdebug$88683[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88683[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_resol@2:

; 11661:         *xp = xq->next;

	mov	eax, DWORD PTR _xp$88667[ebp]
	mov	ecx, DWORD PTR _xq$88677[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 11662:         *xq->ptr = (unsigned char*)content->ptr;

	mov	eax, DWORD PTR _xq$88677[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 11663:         *xq->size = (int)content->size;

	mov	eax, DWORD PTR _xq$88677[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 11664:         *xq->type = (char*)content->type;

	mov	eax, DWORD PTR _xq$88677[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx], eax

; 11665:         if (content->options)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@soap_resol@2

; 11666:           *xq->options = (char*)content->options;

	mov	eax, DWORD PTR _xq$88677[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax

; 11667:         else

	jmp	SHORT $LN2@soap_resol@2
$LN3@soap_resol@2:

; 11668:           *xq->options = (char*)content->description;

	mov	eax, DWORD PTR _xq$88677[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax
$LN2@soap_resol@2:

; 11669:         SOAP_FREE(soap, xq);

	mov	eax, DWORD PTR _xq$88677[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_resolve_attachment@@9@4JA@6501541a
	add	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 11670:       }
; 11671:       else

	jmp	SHORT $LN1@soap_resol@2
$LN7@soap_resol@2:

; 11672:         xp = &(*xp)->next;

	mov	eax, DWORD PTR _xp$88667[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xp$88667[ebp], ecx
$LN1@soap_resol@2:

; 11673:     }

	jmp	$LN9@soap_resol@2
$LN14@soap_resol@2:

; 11674:   }
; 11675: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_resolve_attachment ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@	; `string'
PUBLIC	??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@		; `string'
PUBLIC	??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@ ; `string'
PUBLIC	??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@	; `string'
PUBLIC	??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@		; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_0BJ@HCMFCIGE@MIME?5attachment?5type?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	_soap_putmimehdr
;	COMDAT ??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@ DB 'Content-Description:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@ DB 'Content-Location: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@
CONST	SEGMENT
??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@ DB 'Content-ID: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@
CONST	SEGMENT
??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@ DB 'Content-Trans'
	DB	'fer-Encoding: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@
CONST	SEGMENT
??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@ DB 'Content-Type: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
CONST	SEGMENT
??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@ DB 0dH, 0aH, '--', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HCMFCIGE@MIME?5attachment?5type?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@HCMFCIGE@MIME?5attachment?5type?$DN?$CFs?6?$AA@ DB 'MIME attach'
	DB	'ment type=%s', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putmimehdr
_TEXT	SEGMENT
tv79 = -220						; size = 4
_fdebug$88703 = -20					; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_content$ = 12						; size = 4
_soap_putmimehdr PROC					; COMDAT

; 11686: { const char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11687:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "MIME attachment type=%s\n", content->type?content->type:""));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN9@soap_putmi
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN8@soap_putmi
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN8@soap_putmi:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN9@soap_putmi
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88703[ebp], ecx
	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN12@soap_putmi
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN13@soap_putmi
$LN12@soap_putmi:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN13@soap_putmi:
	mov	esi, esp
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@HCMFCIGE@MIME?5attachment?5type?$DN?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88703[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88703[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@soap_putmi:

; 11688:   if (soap_send3(soap, "\r\n--", soap->mime.boundary, "\r\n"))

	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	push	OFFSET ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@soap_putmi

; 11689:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN10@soap_putmi
$LN6@soap_putmi:

; 11690:   if (content->type && soap_send3(soap, "Content-Type: ", content->type, "\r\n"))

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@soap_putmi

; 11691:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN10@soap_putmi
$LN5@soap_putmi:

; 11692:   s = soap_code_str(mime_codes, content->encoding);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET _mime_codes
	call	_soap_code_str
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 11693:   if (s && soap_send3(soap, "Content-Transfer-Encoding: ", s, "\r\n"))

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@soap_putmi

; 11694:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN10@soap_putmi
$LN4@soap_putmi:

; 11695:   if (content->id && soap_send3(soap, "Content-ID: ", content->id, "\r\n"))

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN3@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@soap_putmi

; 11696:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN10@soap_putmi
$LN3@soap_putmi:

; 11697:   if (content->location && soap_send3(soap, "Content-Location: ", content->location, "\r\n"))

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@soap_putmi

; 11698:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN10@soap_putmi
$LN2@soap_putmi:

; 11699:   if (content->description && soap_send3(soap, "Content-Description: ", content->description, "\r\n"))

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN1@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	OFFSET ??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_putmi

; 11700:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN10@soap_putmi
$LN1@soap_putmi:

; 11701:   return soap_send_raw(soap, "\r\n", 2);

	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN10@soap_putmi:

; 11702: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putmimehdr ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BAABKJLB@?9?9?$AA@			; `string'
PUBLIC	??_C@_0EK@JMOOBCKH@fmimeread?5failed?3?5insufficient?5d@ ; `string'
PUBLIC	??_C@_0DH@CBIOBCEI@Error?3?5cannot?5chunk?5streaming?5MI@ ; `string'
PUBLIC	??_C@_0BO@JJFIIAMG@fmimeread?5returned?5?$CFlu?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@FKFCLFDP@Chunked?5streaming?5MIME?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@CJCEMJNB@fmimereadopen?5failed?6?$AA@	; `string'
PUBLIC	??_C@_0BK@MIJKCDOE@Sending?5MIME?5attachments?6?$AA@ ; `string'
;	COMDAT ??_C@_02BAABKJLB@?9?9?$AA@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9?$AA@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@JMOOBCKH@fmimeread?5failed?3?5insufficient?5d@
CONST	SEGMENT
??_C@_0EK@JMOOBCKH@fmimeread?5failed?3?5insufficient?5d@ DB 'fmimeread fa'
	DB	'iled: insufficient data (%lu bytes remaining from %lu bytes)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CBIOBCEI@Error?3?5cannot?5chunk?5streaming?5MI@
CONST	SEGMENT
??_C@_0DH@CBIOBCEI@Error?3?5cannot?5chunk?5streaming?5MI@ DB 'Error: cann'
	DB	'ot chunk streaming MIME (no HTTP chunking)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JJFIIAMG@fmimeread?5returned?5?$CFlu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BO@JJFIIAMG@fmimeread?5returned?5?$CFlu?5bytes?6?$AA@ DB 'fmimerea'
	DB	'd returned %lu bytes', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FKFCLFDP@Chunked?5streaming?5MIME?6?$AA@
CONST	SEGMENT
??_C@_0BI@FKFCLFDP@Chunked?5streaming?5MIME?6?$AA@ DB 'Chunked streaming '
	DB	'MIME', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CJCEMJNB@fmimereadopen?5failed?6?$AA@
CONST	SEGMENT
??_C@_0BG@CJCEMJNB@fmimereadopen?5failed?6?$AA@ DB 'fmimereadopen failed', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MIJKCDOE@Sending?5MIME?5attachments?6?$AA@
CONST	SEGMENT
??_C@_0BK@MIJKCDOE@Sending?5MIME?5attachments?6?$AA@ DB 'Sending MIME att'
	DB	'achments', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_putmime
_TEXT	SEGMENT
_fdebug$88785 = -116					; size = 4
_bufsize$88777 = -104					; size = 4
_fdebug$88771 = -92					; size = 4
_fdebug$88762 = -80					; size = 4
_fdebug$88753 = -68					; size = 4
_fdebug$88743 = -56					; size = 4
_size$88737 = -44					; size = 4
_handle$88733 = -32					; size = 4
_fdebug$88728 = -20					; size = 4
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_putmime PROC					; COMDAT

; 11713: { struct soap_multipart *content;

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11714:   if (!(soap->mode & SOAP_ENC_MIME) || !soap->mime.boundary)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN46@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	jne	SHORT $LN47@soap_putmi@2
$LN46@soap_putmi@2:

; 11715:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN48@soap_putmi@2
$LN47@soap_putmi@2:

; 11716:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending MIME attachments\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN45@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN44@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN44@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN45@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88728[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BK@MIJKCDOE@Sending?5MIME?5attachments?6?$AA@
	mov	eax, DWORD PTR _fdebug$88728[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88728[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN45@soap_putmi@2:

; 11717:   for (content = soap->mime.first; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90536]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	SHORT $LN42@soap_putmi@2
$LN41@soap_putmi@2:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$[ebp], ecx
$LN42@soap_putmi@2:
	cmp	DWORD PTR _content$[ebp], 0
	je	$LN40@soap_putmi@2

; 11718:   { void *handle;
; 11719:     if (soap->fmimereadopen && ((handle = soap->fmimereadopen(soap, (void*)content->ptr, content->id, content->type, content->description)) || soap->error))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12380], 0
	je	$LN39@soap_putmi@2
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12380]
	call	ecx
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _handle$88733[ebp], eax
	cmp	DWORD PTR _handle$88733[ebp], 0
	jne	SHORT $LN38@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN39@soap_putmi@2
$LN38@soap_putmi@2:

; 11720:     { size_t size = content->size;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _size$88737[ebp], ecx

; 11721:       if (!handle)

	cmp	DWORD PTR _handle$88733[ebp], 0
	jne	SHORT $LN37@soap_putmi@2

; 11722:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimereadopen failed\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN36@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN35@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN35@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN36@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88743[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BG@CJCEMJNB@fmimereadopen?5failed?6?$AA@
	mov	eax, DWORD PTR _fdebug$88743[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88743[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@soap_putmi@2:

; 11723:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN48@soap_putmi@2
$LN37@soap_putmi@2:

; 11724:       }
; 11725:       if (soap_putmimehdr(soap, content))

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_putmimehdr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@soap_putmi@2

; 11726:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN48@soap_putmi@2
$LN33@soap_putmi@2:

; 11727:       if (!size)

	cmp	DWORD PTR _size$88737[ebp], 0
	jne	$LN14@soap_putmi@2

; 11728:       { if ((soap->mode & SOAP_ENC_XML) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN30@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	je	SHORT $LN30@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	jne	$LN31@soap_putmi@2
$LN30@soap_putmi@2:

; 11729:         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked streaming MIME\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN26@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN28@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN28@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN26@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88753[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@FKFCLFDP@Chunked?5streaming?5MIME?6?$AA@
	mov	eax, DWORD PTR _fdebug$88753[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88753[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@soap_putmi@2:

; 11730:           do
; 11731:           { size = soap->fmimeread(soap, handle, soap->tmpbuf, sizeof(soap->tmpbuf));

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _handle$88733[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12396]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _size$88737[ebp], eax

; 11732:             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimeread returned %lu bytes\n", (unsigned long)size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN23@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN22@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN22@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN23@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88762[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _size$88737[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@JJFIIAMG@fmimeread?5returned?5?$CFlu?5bytes?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88762[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88762[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@soap_putmi@2:

; 11733:             if (soap_send_raw(soap, soap->tmpbuf, size))

	mov	eax, DWORD PTR _size$88737[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@soap_putmi@2

; 11734:               break;

	jmp	SHORT $LN24@soap_putmi@2
$LN25@soap_putmi@2:

; 11735:           } while (size);

	cmp	DWORD PTR _size$88737[ebp], 0
	jne	$LN26@soap_putmi@2
$LN24@soap_putmi@2:

; 11736:         }
; 11737:         else

	jmp	SHORT $LN19@soap_putmi@2
$LN31@soap_putmi@2:

; 11738:         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error: cannot chunk streaming MIME (no HTTP chunking)\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN17@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN17@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88771[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0DH@CBIOBCEI@Error?3?5cannot?5chunk?5streaming?5MI@
	mov	eax, DWORD PTR _fdebug$88771[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88771[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_putmi@2:

; 11739:         }
; 11740:       }
; 11741:       else

	jmp	$LN15@soap_putmi@2
$LN14@soap_putmi@2:

; 11742:       { do
; 11743:         { size_t bufsize;
; 11744:           if (size < sizeof(soap->tmpbuf))

	cmp	DWORD PTR _size$88737[ebp], 1024	; 00000400H
	jae	SHORT $LN11@soap_putmi@2

; 11745:             bufsize = size;

	mov	eax, DWORD PTR _size$88737[ebp]
	mov	DWORD PTR _bufsize$88777[ebp], eax

; 11746:           else

	jmp	SHORT $LN10@soap_putmi@2
$LN11@soap_putmi@2:

; 11747:             bufsize = sizeof(soap->tmpbuf);

	mov	DWORD PTR _bufsize$88777[ebp], 1024	; 00000400H
$LN10@soap_putmi@2:

; 11748:           if (!(bufsize = soap->fmimeread(soap, handle, soap->tmpbuf, bufsize)))

	mov	esi, esp
	mov	eax, DWORD PTR _bufsize$88777[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _handle$88733[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12396]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bufsize$88777[ebp], eax
	cmp	DWORD PTR _bufsize$88777[ebp], 0
	jne	$LN9@soap_putmi@2

; 11749:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimeread failed: insufficient data (%lu bytes remaining from %lu bytes)\n", (unsigned long)size, (unsigned long)content->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN8@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN7@soap_putmi@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN7@soap_putmi@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN8@soap_putmi@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88785[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _size$88737[ebp]
	push	edx
	push	OFFSET ??_C@_0EK@JMOOBCKH@fmimeread?5failed?3?5insufficient?5d@
	mov	eax, DWORD PTR _fdebug$88785[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88785[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@soap_putmi@2:

; 11750:             soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1

; 11751:             break;

	jmp	SHORT $LN15@soap_putmi@2
$LN9@soap_putmi@2:

; 11752:           }
; 11753:           if (soap_send_raw(soap, soap->tmpbuf, bufsize))

	mov	eax, DWORD PTR _bufsize$88777[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_putmi@2

; 11754:             break;

	jmp	SHORT $LN15@soap_putmi@2
$LN5@soap_putmi@2:

; 11755:           size -= bufsize;

	mov	eax, DWORD PTR _size$88737[ebp]
	sub	eax, DWORD PTR _bufsize$88777[ebp]
	mov	DWORD PTR _size$88737[ebp], eax

; 11756:         } while (size);

	jne	$LN14@soap_putmi@2
$LN15@soap_putmi@2:

; 11757:       }
; 11758:       if (soap->fmimereadclose)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12388], 0
	je	SHORT $LN4@soap_putmi@2

; 11759:         soap->fmimereadclose(soap, handle);

	mov	esi, esp
	mov	eax, DWORD PTR _handle$88733[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12388]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_putmi@2:

; 11760:     }
; 11761:     else

	jmp	SHORT $LN3@soap_putmi@2
$LN39@soap_putmi@2:

; 11762:     { if (soap_putmimehdr(soap, content)
; 11763:        || soap_send_raw(soap, content->ptr, content->size))

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_putmimehdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_putmi@2
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@soap_putmi@2
$LN1@soap_putmi@2:

; 11764:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN48@soap_putmi@2
$LN3@soap_putmi@2:

; 11765:     }
; 11766:   }

	jmp	$LN41@soap_putmi@2
$LN40@soap_putmi@2:

; 11767:   return soap_send3(soap, "\r\n--", soap->mime.boundary, "--");

	push	OFFSET ??_C@_02BAABKJLB@?9?9?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	push	OFFSET ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send3
	add	esp, 16					; 00000010H
$LN48@soap_putmi@2:

; 11768: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_putmime ENDP
_TEXT	ENDS
PUBLIC	_soap_set_dime
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_dime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_set_dime PROC					; COMDAT

; 11779: { soap->omode |= SOAP_ENC_DIME;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 11780:   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 11781:   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 11782: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_dime ENDP
_TEXT	ENDS
PUBLIC	_soap_set_mime
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_mime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_boundary$ = 12						; size = 4
_start$ = 16						; size = 4
_soap_set_mime PROC					; COMDAT

; 11793: { soap->omode |= SOAP_ENC_MIME;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 11794:   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 11795:   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 11796:   soap->mime.boundary = soap_strdup(soap, boundary);

	mov	eax, DWORD PTR _boundary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90524], eax

; 11797:   soap->mime.start = soap_strdup(soap, start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90528], eax

; 11798: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_mime ENDP
_TEXT	ENDS
PUBLIC	_soap_clr_dime
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_clr_dime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_clr_dime PROC					; COMDAT

; 11809: { soap->omode &= ~SOAP_ENC_DIME;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 11810:   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 11811:   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 11812: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_clr_dime ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_clr_mime
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_clr_mime PROC					; COMDAT

; 11823: { soap->omode &= ~SOAP_ENC_MIME;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 11824:   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 11825:   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 11826:   soap->mime.boundary = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90524], 0

; 11827:   soap->mime.start = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90528], 0

; 11828: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_clr_mime ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_new_multipart
_TEXT	SEGMENT
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_first$ = 12						; size = 4
_last$ = 16						; size = 4
_ptr$ = 20						; size = 4
_size$ = 24						; size = 4
_soap_new_multipart PROC				; COMDAT

; 11837: { struct soap_multipart *content;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11838:   content = (struct soap_multipart*)soap_malloc(soap, sizeof(struct soap_multipart));

	push	36					; 00000024H
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _content$[ebp], eax

; 11839:   if (content)

	cmp	DWORD PTR _content$[ebp], 0
	je	$LN3@soap_new_m

; 11840:   { content->next = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax], 0

; 11841:     content->ptr = ptr;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 11842:     content->size = size;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 11843:     content->id = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+12], 0

; 11844:     content->type = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+16], 0

; 11845:     content->options = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+20], 0

; 11846:     content->encoding = SOAP_MIME_NONE;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+24], 0

; 11847:     content->location = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+28], 0

; 11848:     content->description = NULL;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+32], 0

; 11849:     if (!*first)

	mov	eax, DWORD PTR _first$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@soap_new_m

; 11850:       *first = content;

	mov	eax, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@soap_new_m:

; 11851:     if (*last)

	mov	eax, DWORD PTR _last$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@soap_new_m

; 11852:       (*last)->next = content;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@soap_new_m:

; 11853:     *last = content;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@soap_new_m:

; 11854:   }
; 11855:   return content;

	mov	eax, DWORD PTR _content$[ebp]

; 11856: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_new_multipart ENDP
_TEXT	ENDS
PUBLIC	_soap_set_dime_attachment
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_dime_attachment
_TEXT	SEGMENT
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_type$ = 20						; size = 4
_id$ = 24						; size = 4
_optype$ = 28						; size = 2
_option$ = 32						; size = 4
_soap_set_dime_attachment PROC				; COMDAT

; 11867: { struct soap_multipart *content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, ptr, size);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 90520				; 00016198H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 90516				; 00016194H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_new_multipart
	add	esp, 20					; 00000014H
	mov	DWORD PTR _content$[ebp], eax

; 11868:   if (!content)

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN1@soap_set_d

; 11869:     return SOAP_EOM;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN2@soap_set_d
$LN1@soap_set_d:

; 11870:   content->id = soap_strdup(soap, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+12], eax

; 11871:   content->type = soap_strdup(soap, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+16], eax

; 11872:   content->options = soap_dime_option(soap, optype, option);

	mov	eax, DWORD PTR _option$[ebp]
	push	eax
	movzx	ecx, WORD PTR _optype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_dime_option
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 11873:   return SOAP_OK;

	xor	eax, eax
$LN2@soap_set_d:

; 11874: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_dime_attachment ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_set_mime_attachment
_TEXT	SEGMENT
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_encoding$ = 20						; size = 4
_type$ = 24						; size = 4
_id$ = 28						; size = 4
_location$ = 32						; size = 4
_description$ = 36					; size = 4
_soap_set_mime_attachment PROC				; COMDAT

; 11885: { struct soap_multipart *content = soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, ptr, size);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 90540				; 000161acH
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 90536				; 000161a8H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_new_multipart
	add	esp, 20					; 00000014H
	mov	DWORD PTR _content$[ebp], eax

; 11886:   if (!content)

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $LN1@soap_set_m

; 11887:     return SOAP_EOM;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN2@soap_set_m
$LN1@soap_set_m:

; 11888:   content->id = soap_strdup(soap, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+12], eax

; 11889:   content->type = soap_strdup(soap, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+16], eax

; 11890:   content->encoding = encoding;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 11891:   content->location = soap_strdup(soap, location);

	mov	eax, DWORD PTR _location$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+28], eax

; 11892:   content->description = soap_strdup(soap, description);

	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+32], eax

; 11893:   return SOAP_OK;

	xor	eax, eax
$LN2@soap_set_m:

; 11894: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_mime_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_next_multipart
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_next_multipart
_TEXT	SEGMENT
_content$ = 8						; size = 4
_soap_next_multipart PROC				; COMDAT

; 11905: { if (content)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN1@soap_next_@2

; 11906:     return content->next;

	mov	eax, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN2@soap_next_@2
$LN1@soap_next_@2:

; 11907:   return NULL;

	xor	eax, eax
$LN2@soap_next_@2:

; 11908: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_next_multipart ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@ ; `string'
PUBLIC	??_C@_02EGOFBIJA@?$DN?$DN?$AA@			; `string'
;	COMDAT ??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@
CONST	SEGMENT
??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@ DB '<SOAP-ENV:Envelop'
	DB	'e>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
CONST	SEGMENT
??_C@_02EGOFBIJA@?$DN?$DN?$AA@ DB '==', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_select_mime_boundary
_TEXT	SEGMENT
_n$88857 = -20						; size = 4
_s$88856 = -8						; size = 4
_soap$ = 8						; size = 4
_soap_select_mime_boundary PROC				; COMDAT

; 11917: { while (!soap->mime.boundary || soap_valid_mime_boundary(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN9@soap_selec:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	SHORT $LN7@soap_selec
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_valid_mime_boundary
	add	esp, 4
	test	eax, eax
	je	$LN8@soap_selec
$LN7@soap_selec:

; 11918:   { register char *s = soap->mime.boundary;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	mov	DWORD PTR _s$88856[ebp], ecx

; 11919:     register size_t n = 0;

	mov	DWORD PTR _n$88857[ebp], 0

; 11920:     if (s)

	cmp	DWORD PTR _s$88856[ebp], 0
	je	SHORT $LN6@soap_selec

; 11921:       n = strlen(s);

	mov	eax, DWORD PTR _s$88856[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$88857[ebp], eax
$LN6@soap_selec:

; 11922:     if (n < 16)

	cmp	DWORD PTR _n$88857[ebp], 16		; 00000010H
	jae	SHORT $LN5@soap_selec

; 11923:     { n = 64;

	mov	DWORD PTR _n$88857[ebp], 64		; 00000040H

; 11924:       s = soap->mime.boundary = (char*)soap_malloc(soap, n + 1);

	mov	eax, DWORD PTR _n$88857[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90524], eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	mov	DWORD PTR _s$88856[ebp], ecx

; 11925:       if (!s)

	cmp	DWORD PTR _s$88856[ebp], 0
	jne	SHORT $LN5@soap_selec

; 11926:         return;

	jmp	$LN10@soap_selec
$LN5@soap_selec:

; 11927:     }
; 11928:     strcpy(s, "==");

	push	OFFSET ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
	mov	eax, DWORD PTR _s$88856[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 11929:     s += 2;

	mov	eax, DWORD PTR _s$88856[ebp]
	add	eax, 2
	mov	DWORD PTR _s$88856[ebp], eax

; 11930:     n -= 4;

	mov	eax, DWORD PTR _n$88857[ebp]
	sub	eax, 4
	mov	DWORD PTR _n$88857[ebp], eax
$LN3@soap_selec:

; 11931:     while (n)

	cmp	DWORD PTR _n$88857[ebp], 0
	je	SHORT $LN2@soap_selec

; 11932:     { *s++ = soap_base64o[soap_random & 0x3F];

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR _s$88856[ebp]
	mov	dl, BYTE PTR _soap_base64o[eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _s$88856[ebp]
	add	eax, 1
	mov	DWORD PTR _s$88856[ebp], eax

; 11933:       n--;

	mov	eax, DWORD PTR _n$88857[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$88857[ebp], eax

; 11934:     }

	jmp	SHORT $LN3@soap_selec
$LN2@soap_selec:

; 11935:     strcpy(s, "==");

	push	OFFSET ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
	mov	eax, DWORD PTR _s$88856[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 11936:   }

	jmp	$LN9@soap_selec
$LN8@soap_selec:

; 11937:   if (!soap->mime.start)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90528], 0
	jne	SHORT $LN10@soap_selec

; 11938:     soap->mime.start = "<SOAP-ENV:Envelope>";

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90528], OFFSET ??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@
$LN10@soap_selec:

; 11939: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_select_mime_boundary ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_valid_mime_boundary
_TEXT	SEGMENT
_i$88880 = -44						; size = 4
_p$88878 = -32						; size = 4
_k$ = -20						; size = 4
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_valid_mime_boundary PROC				; COMDAT

; 11948: { register struct soap_multipart *content;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11949:   register size_t k;
; 11950:   if (soap->fmimeread)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12396], 0
	je	SHORT $LN9@soap_valid

; 11951:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN10@soap_valid
$LN9@soap_valid:

; 11952:   k = strlen(soap->mime.boundary);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _k$[ebp], eax

; 11953:   for (content = soap->mime.first; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90536]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	SHORT $LN8@soap_valid
$LN7@soap_valid:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$[ebp], ecx
$LN8@soap_valid:
	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN6@soap_valid

; 11954:   { if (content->ptr && content->size >= k)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@soap_valid
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _k$[ebp]
	jb	SHORT $LN5@soap_valid

; 11955:     { register const char *p = (const char*)content->ptr;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$88878[ebp], ecx

; 11956:       register size_t i;
; 11957:       for (i = 0; i < content->size - k; i++, p++)

	mov	DWORD PTR _i$88880[ebp], 0
	jmp	SHORT $LN4@soap_valid
$LN3@soap_valid:
	mov	eax, DWORD PTR _i$88880[ebp]
	add	eax, 1
	mov	DWORD PTR _i$88880[ebp], eax
	mov	ecx, DWORD PTR _p$88878[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$88878[ebp], ecx
$LN4@soap_valid:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _i$88880[ebp], ecx
	jae	SHORT $LN5@soap_valid

; 11958:       { if (!strncmp(p, soap->mime.boundary, k))

	mov	esi, esp
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90524]
	push	edx
	mov	eax, DWORD PTR _p$88878[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_valid

; 11959:           return SOAP_ERR;

	or	eax, -1
	jmp	SHORT $LN10@soap_valid
$LN1@soap_valid:

; 11960:       }

	jmp	SHORT $LN3@soap_valid
$LN5@soap_valid:

; 11961:     }
; 11962:   }

	jmp	$LN7@soap_valid
$LN6@soap_valid:

; 11963:   return SOAP_OK;

	xor	eax, eax
$LN10@soap_valid:

; 11964: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_valid_mime_boundary ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@LFIMFOFG@Chunked?5DIME?5SOAP?5message?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@KDHCEMMM@application?1dime?$AA@	; `string'
PUBLIC	??_C@_0BI@DLJLKJKP@Initializing?5for?5input?6?$AA@ ; `string'
PUBLIC	_soap_begin_recv
;	COMDAT ??_C@_0BL@LFIMFOFG@Chunked?5DIME?5SOAP?5message?6?$AA@
CONST	SEGMENT
??_C@_0BL@LFIMFOFG@Chunked?5DIME?5SOAP?5message?6?$AA@ DB 'Chunked DIME S'
	DB	'OAP message', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
CONST	SEGMENT
??_C@_0BB@KDHCEMMM@application?1dime?$AA@ DB 'application/dime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DLJLKJKP@Initializing?5for?5input?6?$AA@
CONST	SEGMENT
??_C@_0BI@DLJLKJKP@Initializing?5for?5input?6?$AA@ DB 'Initializing for i'
	DB	'nput', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_begin_recv
_TEXT	SEGMENT
tv277 = -232						; size = 4
tv210 = -232						; size = 4
tv193 = -232						; size = 4
_fdebug$88942 = -32					; size = 4
_fdebug$88893 = -20					; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_begin_recv PROC					; COMDAT

; 12684: { soap_wchar c;

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 12685:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for input\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN43@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN42@soap_begin@4
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN42@soap_begin@4:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN43@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88893[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BI@DLJLKJKP@Initializing?5for?5input?6?$AA@
	mov	eax, DWORD PTR _fdebug$88893[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88893[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN43@soap_begin@4:

; 12686:   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 12687:   soap_free_temp(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_temp
	add	esp, 4

; 12688:   soap_set_local_namespaces(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_local_namespaces
	add	esp, 4

; 12689:   soap->version = 0;	/* don't assume we're parsing SOAP content by default */

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax

; 12690: #ifndef WITH_NOIDREF
; 12691:   soap_free_iht(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_free_iht
	add	esp, 4

; 12692: #endif
; 12693:   if ((soap->imode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN40@soap_begin@4

; 12694:     soap->omode |= SOAP_IO_CHUNK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 3
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN40@soap_begin@4:

; 12695:   soap->imode &= ~SOAP_IO;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 12696:   soap->mode = soap->imode;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 12697:   if (!soap->keep_alive)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jne	SHORT $LN39@soap_begin@4

; 12698:   { soap->buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], 0

; 12699:     soap->bufidx = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12428], 0
$LN39@soap_begin@4:

; 12700:   }
; 12701:   if (!(soap->mode & SOAP_IO_KEEPALIVE))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN38@soap_begin@4

; 12702:     soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN38@soap_begin@4:

; 12703:   soap->ahead = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12436], 0

; 12704:   soap->peeked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87308], ax

; 12705:   soap->level = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12444], 0

; 12706:   soap->part = SOAP_BEGIN;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 12707:   soap->alloced = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87306], ax

; 12708:   soap->count = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], 0

; 12709:   soap->length = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12452], 0

; 12710:   soap->cdata = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+12440], ax

; 12711:   *soap->endpoint = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+87320], 0

; 12712:   soap->action = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90392], 0

; 12713:   soap->header = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12204], 0

; 12714:   soap->fault = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12208], 0

; 12715:   soap->status = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90456], 0

; 12716: #ifndef WITH_LEANER
; 12717:   soap->dom = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90472], 0

; 12718:   soap->dime.chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90484], 0

; 12719:   soap->dime.buflen = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90488], 0

; 12720:   soap->dime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90512], 0

; 12721:   soap->dime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90516], 0

; 12722:   soap->dime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90520], 0

; 12723:   soap->mime.list = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90532], 0

; 12724:   soap->mime.first = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90536], 0

; 12725:   soap->mime.last = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90540], 0

; 12726:   soap->mime.boundary = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90524], 0

; 12727:   soap->mime.start = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90528], 0

; 12728:   soap->xlist = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90544], 0

; 12729: #endif
; 12730: #ifdef WIN32
; 12731: #ifndef UNDER_CE
; 12732: #ifndef WITH_FASTCGI
; 12733:   if (!soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	jne	SHORT $LN37@soap_begin@4

; 12734: #ifdef __BORLANDC__
; 12735:     setmode(soap->recvfd, O_BINARY);
; 12736: #else
; 12737:     _setmode(soap->recvfd, _O_BINARY);

	mov	esi, esp
	push	32768					; 00008000H
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12424]
	push	ecx
	call	DWORD PTR __imp___setmode
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN37@soap_begin@4:

; 12738: #endif
; 12739: #endif
; 12740: #endif
; 12741: #endif
; 12742: #ifdef WITH_ZLIB
; 12743:   soap->mode &= ~SOAP_ENC_ZLIB;
; 12744:   soap->zlib_in = SOAP_ZLIB_NONE;
; 12745:   soap->zlib_out = SOAP_ZLIB_NONE;
; 12746:   soap->d_stream->next_in = Z_NULL;
; 12747:   soap->d_stream->avail_in = 0;
; 12748:   soap->d_stream->next_out = (Byte*)soap->buf;
; 12749:   soap->d_stream->avail_out = SOAP_BUFLEN;
; 12750:   soap->z_ratio_in = 1.0;
; 12751: #endif
; 12752: #ifndef WITH_LEANER
; 12753:   if (soap->fprepareinit)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12340], 0
	je	SHORT $LN36@soap_begin@4

; 12754:     soap->fprepareinit(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12340]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@soap_begin@4:

; 12755: #endif
; 12756:   c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 12757: #ifdef WITH_GZIP
; 12758:   if (c == 0x1F)
; 12759:   { if (soap_getgziphdr(soap))
; 12760:       return soap->error;
; 12761:     if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
; 12762:       return soap->error = SOAP_ZLIB_ERROR;
; 12763:     soap->zlib_state = SOAP_ZLIB_INFLATE;
; 12764:     soap->mode |= SOAP_ENC_ZLIB;
; 12765:     soap->zlib_in = SOAP_ZLIB_GZIP;
; 12766:     soap->z_crc = crc32(0L, NULL, 0);
; 12767:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip initialized\n"));
; 12768:     if (!soap->z_buf)
; 12769:       soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 12770:     memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 12771:     /* should not chunk over plain transport, so why bother to check? */
; 12772:     /* if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) */
; 12773:     /*   soap->z_buflen = soap->bufidx; */
; 12774:     /* else */
; 12775:     soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 12776:     soap->d_stream->avail_in = soap->buflen - soap->bufidx;
; 12777:     soap->z_buflen = soap->buflen;
; 12778:     soap->buflen = soap->bufidx;
; 12779:     c = soap_getchar(soap);
; 12780:   }
; 12781: #endif
; 12782: #ifndef WITH_LEANER
; 12783:   if (c == '-' && soap_get0(soap) == '-')

	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	jne	SHORT $LN35@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN46@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@soap_begin@4
	mov	DWORD PTR tv193[ebp], -1
	jmp	SHORT $LN47@soap_begin@4
$LN46@soap_begin@4:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv193[ebp], ecx
$LN47@soap_begin@4:
	cmp	DWORD PTR tv193[ebp], 45		; 0000002dH
	jne	SHORT $LN35@soap_begin@4

; 12784:     soap->mode |= SOAP_ENC_MIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN34@soap_begin@4
$LN35@soap_begin@4:

; 12785:   else if ((c & 0xFFFC) == (SOAP_DIME_VERSION | SOAP_DIME_MB) && (soap_get0(soap) & 0xFFF0) == 0x20)

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 65532				; 0000fffcH
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN31@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN48@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN48@soap_begin@4
	mov	DWORD PTR tv210[ebp], -1
	jmp	SHORT $LN49@soap_begin@4
$LN48@soap_begin@4:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv210[ebp], ecx
$LN49@soap_begin@4:
	mov	edx, DWORD PTR tv210[ebp]
	and	edx, 65520				; 0000fff0H
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN31@soap_begin@4

; 12786:     soap->mode |= SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 12787:   else

	jmp	SHORT $LN34@soap_begin@4
$LN31@soap_begin@4:

; 12788: #endif
; 12789:   { while (soap_blank(c))

	cmp	DWORD PTR _c$[ebp], 0
	jl	SHORT $LN34@soap_begin@4
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN34@soap_begin@4

; 12790:       c = soap_getchar(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getchar
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN31@soap_begin@4
$LN34@soap_begin@4:

; 12791:   }
; 12792:   if ((int)c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN29@soap_begin@4

; 12793:     return soap->error = SOAP_EOF;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], -1
	or	eax, -1
	jmp	$LN44@soap_begin@4
$LN29@soap_begin@4:

; 12794:   soap_unget(soap, c);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+12436], ecx

; 12795: #ifndef WITH_NOHTTP
; 12796:   /* if not XML or (start of)BOM or MIME/DIME/ZLIB, assume HTTP header */
; 12797:   if (c != '<' && c != 0xEF && !(soap->mode & (SOAP_ENC_MIME | SOAP_ENC_DIME | SOAP_ENC_ZLIB)))

	cmp	DWORD PTR _c$[ebp], 60			; 0000003cH
	je	$LN28@soap_begin@4
	cmp	DWORD PTR _c$[ebp], 239			; 000000efH
	je	$LN28@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1408				; 00000580H
	jne	$LN28@soap_begin@4

; 12798:   { soap->mode &= ~SOAP_IO;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 12799:     soap->error = soap->fparse(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12264]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax

; 12800:     if (soap->error && soap->error < SOAP_STOP)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN27@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 1000		; 000003e8H
	jge	SHORT $LN27@soap_begin@4

; 12801:     { soap->keep_alive = 0; /* force close later */

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 12802:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN27@soap_begin@4:

; 12803:     }
; 12804:     if (soap->error == SOAP_STOP)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 1000		; 000003e8H
	jne	SHORT $LN26@soap_begin@4

; 12805:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN26@soap_begin@4:

; 12806:     if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN25@soap_begin@4

; 12807:     { soap->chunkbuflen = soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+87316], edx

; 12808:       soap->buflen = soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	DWORD PTR [eax+12432], edx

; 12809:       soap->chunksize = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+87312], 0
	jmp	SHORT $LN24@soap_begin@4
$LN25@soap_begin@4:

; 12810:     }
; 12811: #ifndef WITH_LEANER
; 12812:     else if (soap->fpreparerecv && soap->buflen != soap->bufidx)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12348], 0
	je	SHORT $LN24@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	cmp	edx, DWORD PTR [ecx+12428]
	je	SHORT $LN24@soap_begin@4

; 12813:       soap->fpreparerecv(soap, soap->buf + soap->bufidx, soap->buflen - soap->bufidx);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12468]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12348]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@soap_begin@4:

; 12814: #endif
; 12815:     /* Note: fparse should not use soap_unget to push back last char */
; 12816:     if (soap_get0(soap) == (int)EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jb	SHORT $LN50@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN50@soap_begin@4
	mov	DWORD PTR tv277[ebp], -1
	jmp	SHORT $LN51@soap_begin@4
$LN50@soap_begin@4:
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+12468]
	mov	DWORD PTR tv277[ebp], ecx
$LN51@soap_begin@4:
	cmp	DWORD PTR tv277[ebp], -1
	jne	SHORT $LN22@soap_begin@4

; 12817:     { if (soap->status == 200)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 200		; 000000c8H
	jne	SHORT $LN21@soap_begin@4

; 12818:         return soap->error = SOAP_NO_DATA;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 14		; 0000000eH
	mov	eax, 14					; 0000000eH
	jmp	$LN44@soap_begin@4
$LN21@soap_begin@4:

; 12819:       return soap->error = soap->status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90456]
	mov	DWORD PTR [eax+90460], edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN22@soap_begin@4:

; 12820:     }
; 12821: #ifdef WITH_ZLIB
; 12822:     if (soap->zlib_in != SOAP_ZLIB_NONE)
; 12823:     {
; 12824: #ifdef WITH_GZIP
; 12825:       if (soap->zlib_in != SOAP_ZLIB_DEFLATE)
; 12826:       { c = soap_get1(soap);
; 12827:         if (c == 0x1F)
; 12828:         { if (soap_getgziphdr(soap))
; 12829:             return soap->error;
; 12830:           if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
; 12831:             return soap->error = SOAP_ZLIB_ERROR;
; 12832:           soap->z_crc = crc32(0L, NULL, 0);
; 12833:           DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip initialized\n"));
; 12834:         }
; 12835:         else
; 12836:         { soap_revget1(soap);
; 12837:           if (inflateInit(soap->d_stream) != Z_OK)
; 12838:             return soap->error = SOAP_ZLIB_ERROR;
; 12839:           soap->zlib_in = SOAP_ZLIB_DEFLATE;
; 12840:         }
; 12841:       }
; 12842:       else
; 12843: #endif
; 12844:       if (inflateInit(soap->d_stream) != Z_OK)
; 12845:         return soap->error = SOAP_ZLIB_ERROR;
; 12846:       soap->zlib_state = SOAP_ZLIB_INFLATE;
; 12847:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflate initialized\n"));
; 12848:       soap->mode |= SOAP_ENC_ZLIB;
; 12849:       if (!soap->z_buf)
; 12850:         soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 12851:       memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 12852:       soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 12853:       soap->d_stream->avail_in = soap->buflen - soap->bufidx;
; 12854:       soap->z_buflen = soap->buflen;
; 12855:       soap->buflen = soap->bufidx;
; 12856:     }
; 12857: #endif
; 12858:     if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN28@soap_begin@4

; 12859:     { if (soap->error == SOAP_FORM && soap->fform)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 1001		; 000003e9H
	jne	SHORT $LN19@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12252], 0
	je	SHORT $LN19@soap_begin@4

; 12860:       { soap->error = soap->fform(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12252]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax

; 12861:         if (soap->error == SOAP_OK)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	jne	SHORT $LN19@soap_begin@4

; 12862:           soap->error = SOAP_STOP; /* prevents further processing */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 1000		; 000003e8H
$LN19@soap_begin@4:

; 12863:       }
; 12864:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN28@soap_begin@4:

; 12865:     }
; 12866:   }
; 12867: #endif
; 12868: #ifndef WITH_LEANER
; 12869:   if (soap->mode & SOAP_ENC_MIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	$LN17@soap_begin@4

; 12870:   { if (soap_getmimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getmimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@soap_begin@4

; 12871:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN16@soap_begin@4:

; 12872:     if (soap->mime.start)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90528], 0
	je	SHORT $LN15@soap_begin@4
$LN14@soap_begin@4:

; 12873:     { do
; 12874:       { if (!soap->mime.last->id)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90540]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN11@soap_begin@4

; 12875:           break;

	jmp	SHORT $LN15@soap_begin@4
$LN11@soap_begin@4:

; 12876:         if (!soap_match_cid(soap, soap->mime.start, soap->mime.last->id))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90540]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90528]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_match_cid
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@soap_begin@4

; 12877:           break;

	jmp	SHORT $LN15@soap_begin@4
$LN13@soap_begin@4:

; 12878:       } while (soap_get_mime_attachment(soap, NULL));

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get_mime_attachment
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_begin@4
$LN15@soap_begin@4:

; 12879:     }
; 12880:     if (soap_get_header_attribute(soap, soap->mime.first->type, "application/dime"))

	push	OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90536]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@soap_begin@4

; 12881:       soap->mode |= SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN17@soap_begin@4:

; 12882:   }
; 12883:   if (soap->mode & SOAP_ENC_DIME)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	$LN8@soap_begin@4

; 12884:   { if (soap_getdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@soap_begin@4

; 12885:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN44@soap_begin@4
$LN7@soap_begin@4:

; 12886:     if (soap->dime.flags & SOAP_DIME_CF)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	and	ecx, 1
	je	$LN6@soap_begin@4

; 12887:     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked DIME SOAP message\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_begin@4
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_begin@4:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_begin@4
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88942[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BL@LFIMFOFG@Chunked?5DIME?5SOAP?5message?6?$AA@
	mov	eax, DWORD PTR _fdebug$88942[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88942[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_begin@4:

; 12888:       soap->dime.chunksize = soap->dime.size;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90480]
	mov	DWORD PTR [eax+90484], edx

; 12889:       if (soap->buflen - soap->bufidx >= soap->dime.chunksize)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	edx, DWORD PTR [eax+90484]
	jb	SHORT $LN2@soap_begin@4

; 12890:       { soap->dime.buflen = soap->buflen;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12432]
	mov	DWORD PTR [eax+90488], edx

; 12891:         soap->buflen = soap->bufidx + soap->dime.chunksize;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR [edx+90484]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12432], ecx

; 12892:       }
; 12893:       else

	jmp	SHORT $LN6@soap_begin@4
$LN2@soap_begin@4:

; 12894:         soap->dime.chunksize -= soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90484]
	sub	ecx, edx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90484], ecx
$LN6@soap_begin@4:

; 12895:     }
; 12896:     soap->count = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12432]
	sub	edx, DWORD PTR [ecx+12428]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], edx
$LN8@soap_begin@4:

; 12897:   }
; 12898: #endif
; 12899:   return SOAP_OK;

	xor	eax, eax
$LN44@soap_begin@4:

; 12900: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_begin_recv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@		; `string'
PUBLIC	??_C@_0P@LPMLFOGK@HTTP?5error?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BG@FJPACGIL@Target?5endpoint?$DN?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_05PMJKDPIC@HEAD?5?$AA@			; `string'
PUBLIC	??_C@_07GOAKFIAN@DELETE?5?$AA@			; `string'
PUBLIC	??_C@_04DCMJKHH@PUT?5?$AA@			; `string'
PUBLIC	??_C@_04IBPFIGHK@GET?5?$AA@			; `string'
PUBLIC	??_C@_05LPJJJLLB@POST?5?$AA@			; `string'
PUBLIC	??_C@_0BM@ELFKEDB@Keep?5alive?5connection?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_05FKGKDBHO@HTTP?1?$AA@			; `string'
PUBLIC	??_C@_0CL@FEONOLBF@Finished?5HTTP?5header?5parsing?0?5st@ ; `string'
PUBLIC	??_C@_0BB@INKBDLAF@HTTP?5header?3?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0CF@EBOFKDKD@EOF?5in?5HTTP?5header?0?5continue?5any@ ; `string'
PUBLIC	??_C@_0BB@OJFPBBBC@HTTP?5status?3?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0CG@CKLNIGDL@Waiting?5for?5HTTP?5request?1respons@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
CONST	SEGMENT
??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@ DB 'HTTP Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPMLFOGK@HTTP?5error?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0P@LPMLFOGK@HTTP?5error?5?$CFd?6?$AA@ DB 'HTTP error %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FJPACGIL@Target?5endpoint?$DN?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BG@FJPACGIL@Target?5endpoint?$DN?8?$CFs?8?6?$AA@ DB 'Target endpoi'
	DB	'nt=''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMJKDPIC@HEAD?5?$AA@
CONST	SEGMENT
??_C@_05PMJKDPIC@HEAD?5?$AA@ DB 'HEAD ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOAKFIAN@DELETE?5?$AA@
CONST	SEGMENT
??_C@_07GOAKFIAN@DELETE?5?$AA@ DB 'DELETE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DCMJKHH@PUT?5?$AA@
CONST	SEGMENT
??_C@_04DCMJKHH@PUT?5?$AA@ DB 'PUT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBPFIGHK@GET?5?$AA@
CONST	SEGMENT
??_C@_04IBPFIGHK@GET?5?$AA@ DB 'GET ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LPJJJLLB@POST?5?$AA@
CONST	SEGMENT
??_C@_05LPJJJLLB@POST?5?$AA@ DB 'POST ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ELFKEDB@Keep?5alive?5connection?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@ELFKEDB@Keep?5alive?5connection?5?$DN?5?$CFd?6?$AA@ DB 'Keep al'
	DB	'ive connection = %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKGKDBHO@HTTP?1?$AA@
CONST	SEGMENT
??_C@_05FKGKDBHO@HTTP?1?$AA@ DB 'HTTP/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FEONOLBF@Finished?5HTTP?5header?5parsing?0?5st@
CONST	SEGMENT
??_C@_0CL@FEONOLBF@Finished?5HTTP?5header?5parsing?0?5st@ DB 'Finished HT'
	DB	'TP header parsing, status = %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@INKBDLAF@HTTP?5header?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@INKBDLAF@HTTP?5header?3?5?$CFs?6?$AA@ DB 'HTTP header: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EBOFKDKD@EOF?5in?5HTTP?5header?0?5continue?5any@
CONST	SEGMENT
??_C@_0CF@EBOFKDKD@EOF?5in?5HTTP?5header?0?5continue?5any@ DB 'EOF in HTT'
	DB	'P header, continue anyway', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OJFPBBBC@HTTP?5status?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@OJFPBBBC@HTTP?5status?3?5?$CFs?6?$AA@ DB 'HTTP status: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKLNIGDL@Waiting?5for?5HTTP?5request?1respons@
CONST	SEGMENT
??_C@_0CG@CKLNIGDL@Waiting?5for?5HTTP?5request?1respons@ DB 'Waiting for '
	DB	'HTTP request/response...', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _http_parse
_TEXT	SEGMENT
tv380 = -8592						; size = 4
_fdebug$89081 = -8392					; size = 4
_fdebug$89050 = -8380					; size = 4
_n$89043 = -8368					; size = 4
_m$89042 = -8356					; size = 4
_l$89025 = -8344					; size = 4
_fdebug$89022 = -8332					; size = 4
_fdebug$89011 = -8320					; size = 4
_t$88990 = -8308					; size = 4
_fdebug$88987 = -8296					; size = 4
_fdebug$88980 = -8284					; size = 4
_fdebug$88969 = -8272					; size = 4
_fdebug$88958 = -8260					; size = 4
_k$ = -8248						; size = 2
_status$ = -8236					; size = 2
_httpcmd$ = -8224					; size = 2
_s$ = -8212						; size = 4
_header$ = -8200					; size = 8192
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_http_parse PROC					; COMDAT

; 12908: { char header[SOAP_HDRLEN], *s;

	push	ebp
	mov	ebp, esp
	mov	eax, 8592				; 00002190H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-8592]
	mov	ecx, 2148				; 00000864H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 12909:   unsigned short httpcmd = 0, status = 0, k = 0;

	xor	eax, eax
	mov	WORD PTR _httpcmd$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _status$[ebp], ax
	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax

; 12910:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Waiting for HTTP request/response...\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN90@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN89@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN89@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN90@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88958[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CG@CKLNIGDL@Waiting?5for?5HTTP?5request?1respons@
	mov	eax, DWORD PTR _fdebug$88958[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88958[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN90@http_parse:

; 12911:   *soap->endpoint = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+87320], 0

; 12912:   soap->length = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12452], 0

; 12913:   soap->userid = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12224], 0

; 12914:   soap->passwd = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12228], 0

; 12915:   soap->action = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90392], 0

; 12916:   soap->authrealm = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90396], 0

; 12917:   soap->proxy_from = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90452], 0

; 12918:   soap->http_content = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+36], 0

; 12919:   soap->status = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90456], 0
$LN87@http_parse:

; 12920:   do
; 12921:   { if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getline
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN84@http_parse

; 12922:     { if (soap->error == SOAP_EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], -1
	jne	SHORT $LN83@http_parse

; 12923:         return SOAP_EOF;

	or	eax, -1
	jmp	$LN91@http_parse
$LN83@http_parse:

; 12924:       return soap->error = 414;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 414		; 0000019eH
	mov	eax, 414				; 0000019eH
	jmp	$LN91@http_parse
$LN84@http_parse:

; 12925:     }
; 12926:     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP status: %s\n", soap->msgbuf));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN79@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN81@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN81@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN79@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88969[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BB@OJFPBBBC@HTTP?5status?3?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88969[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88969[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN79@http_parse:

; 12927:     for (;;)
; 12928:     { if (soap_getline(soap, header, SOAP_HDRLEN))

	push	8192					; 00002000H
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_getline
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN77@http_parse

; 12929:       { if (soap->error == SOAP_EOF)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], -1
	jne	$LN76@http_parse

; 12930:         { soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 12931:           DBGLOG(TEST,SOAP_MESSAGE(fdebug, "EOF in HTTP header, continue anyway\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN75@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN74@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN74@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN75@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88980[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CF@EBOFKDKD@EOF?5in?5HTTP?5header?0?5continue?5any@
	mov	eax, DWORD PTR _fdebug$88980[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88980[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN75@http_parse:

; 12932:           break;

	jmp	$LN78@http_parse
$LN76@http_parse:

; 12933:         }
; 12934:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN91@http_parse
$LN77@http_parse:

; 12935:       }
; 12936:       if (!*header)

	movsx	eax, BYTE PTR _header$[ebp]
	test	eax, eax
	jne	SHORT $LN72@http_parse

; 12937:         break;

	jmp	$LN78@http_parse
$LN72@http_parse:

; 12938:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP header: %s\n", header));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN71@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN70@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN70@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN71@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88987[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@INKBDLAF@HTTP?5header?3?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88987[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88987[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN71@http_parse:

; 12939:       s = strchr(header, ':');

	push	58					; 0000003aH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 12940:       if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN68@http_parse

; 12941:       { char *t;
; 12942:         *s = '\0';

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0
$LN67@http_parse:

; 12943:         do s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 12944:         while (*s && *s <= 32);

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN65@http_parse
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN67@http_parse
$LN65@http_parse:

; 12945:         if (*s == '"')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN63@http_parse

; 12946:           s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN63@http_parse:

; 12947:         t = s + strlen(s) - 1;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _t$88990[ebp], edx
$LN62@http_parse:

; 12948:         while (t > s && *t <= 32)

	mov	eax, DWORD PTR _t$88990[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	jbe	SHORT $LN61@http_parse
	mov	eax, DWORD PTR _t$88990[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN61@http_parse

; 12949:           t--;

	mov	eax, DWORD PTR _t$88990[ebp]
	sub	eax, 1
	mov	DWORD PTR _t$88990[ebp], eax
	jmp	SHORT $LN62@http_parse
$LN61@http_parse:

; 12950:         if (t >= s && *t == '"')

	mov	eax, DWORD PTR _t$88990[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	jb	SHORT $LN60@http_parse
	mov	eax, DWORD PTR _t$88990[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN60@http_parse

; 12951:           t--;

	mov	eax, DWORD PTR _t$88990[ebp]
	sub	eax, 1
	mov	DWORD PTR _t$88990[ebp], eax
$LN60@http_parse:

; 12952:         t[1] = '\0';

	mov	eax, DWORD PTR _t$88990[ebp]
	mov	BYTE PTR [eax+1], 0

; 12953:         if ((soap->error = soap->fparsehdr(soap, header, s)))

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12268]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN68@http_parse

; 12954:         { if (soap->error < SOAP_STOP)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 1000		; 000003e8H
	jge	SHORT $LN58@http_parse

; 12955:             return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN91@http_parse
$LN58@http_parse:

; 12956:           status = soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	call	@_RTC_Check_4_to_2@4
	mov	WORD PTR _status$[ebp], ax

; 12957:           soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN68@http_parse:

; 12958:         }
; 12959:       }
; 12960:     }

	jmp	$LN79@http_parse
$LN78@http_parse:

; 12961:     if ((s = strchr(soap->msgbuf, ' ')))

	push	32					; 00000020H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN57@http_parse

; 12962:     { k = (unsigned short)soap_strtoul(s, &s, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	@_RTC_Check_4_to_2@4
	mov	WORD PTR _k$[ebp], ax

; 12963:       if (!soap_blank(*s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN55@http_parse
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN56@http_parse
$LN55@http_parse:

; 12964:         k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
$LN56@http_parse:

; 12965:     }
; 12966:     else

	jmp	SHORT $LN86@http_parse
$LN57@http_parse:

; 12967:       k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
$LN86@http_parse:

; 12968:   } while (k == 100);

	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 100				; 00000064H
	je	$LN87@http_parse

; 12969:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Finished HTTP header parsing, status = %d\n", k));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN53@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN52@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN52@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN53@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89011[ebp], ecx
	movzx	eax, WORD PTR _k$[ebp]
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0CL@FEONOLBF@Finished?5HTTP?5header?5parsing?0?5st@
	mov	ecx, DWORD PTR _fdebug$89011[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89011[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@http_parse:

; 12970:   s = strstr(soap->msgbuf, "HTTP/");

	push	OFFSET ??_C@_05FKGKDBHO@HTTP?1?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 12971:   if (s && s[7] != '1')

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN50@http_parse
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+7]
	cmp	ecx, 49					; 00000031H
	je	SHORT $LN50@http_parse

; 12972:   { if (soap->keep_alive == 1)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	cmp	ecx, 1
	jne	SHORT $LN49@http_parse

; 12973:       soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN49@http_parse:

; 12974:     if (k == 0 && (soap->omode & SOAP_IO) == SOAP_IO_CHUNK) /* k == 0 for HTTP request */

	movzx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jne	SHORT $LN50@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN50@http_parse

; 12975:     { soap->imode |= SOAP_IO_CHUNK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 3
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 12976:       soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_STORE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -4					; fffffffcH
	or	ecx, 2
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN50@http_parse:

; 12977:     }
; 12978:   }
; 12979:   if (soap->keep_alive < 0)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jge	SHORT $LN47@http_parse

; 12980:     soap->keep_alive = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN47@http_parse:

; 12981:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Keep alive connection = %d\n", soap->keep_alive));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN46@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN45@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN45@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN46@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89022[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_0BM@ELFKEDB@Keep?5alive?5connection?5?$DN?5?$CFd?6?$AA@
	mov	edx, DWORD PTR _fdebug$89022[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89022[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN46@http_parse:

; 12982:   if (k == 0)

	movzx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jne	$LN43@http_parse

; 12983:   { size_t l = 0;

	mov	DWORD PTR _l$89025[ebp], 0

; 12984:     if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN42@http_parse

; 12985:     { if (!strncmp(soap->msgbuf, "POST ", l = 5))

	mov	DWORD PTR _l$89025[ebp], 5
	mov	esi, esp
	mov	eax, DWORD PTR _l$89025[ebp]
	push	eax
	push	OFFSET ??_C@_05LPJJJLLB@POST?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN41@http_parse

; 12986:         httpcmd = 1;

	mov	eax, 1
	mov	WORD PTR _httpcmd$[ebp], ax
	jmp	$LN42@http_parse
$LN41@http_parse:

; 12987:       else if (!strncmp(soap->msgbuf, "GET ", l = 4))

	mov	DWORD PTR _l$89025[ebp], 4
	mov	esi, esp
	mov	eax, DWORD PTR _l$89025[ebp]
	push	eax
	push	OFFSET ??_C@_04IBPFIGHK@GET?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN39@http_parse

; 12988:         httpcmd = 2;

	mov	eax, 2
	mov	WORD PTR _httpcmd$[ebp], ax
	jmp	$LN42@http_parse
$LN39@http_parse:

; 12989:       else if (!strncmp(soap->msgbuf, "PUT ", l = 4))

	mov	DWORD PTR _l$89025[ebp], 4
	mov	esi, esp
	mov	eax, DWORD PTR _l$89025[ebp]
	push	eax
	push	OFFSET ??_C@_04DCMJKHH@PUT?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN37@http_parse

; 12990:         httpcmd = 3;

	mov	eax, 3
	mov	WORD PTR _httpcmd$[ebp], ax
	jmp	$LN42@http_parse
$LN37@http_parse:

; 12991:       else if (!strncmp(soap->msgbuf, "DELETE ", l = 7))

	mov	DWORD PTR _l$89025[ebp], 7
	mov	esi, esp
	mov	eax, DWORD PTR _l$89025[ebp]
	push	eax
	push	OFFSET ??_C@_07GOAKFIAN@DELETE?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN35@http_parse

; 12992:         httpcmd = 4;

	mov	eax, 4
	mov	WORD PTR _httpcmd$[ebp], ax
	jmp	SHORT $LN42@http_parse
$LN35@http_parse:

; 12993:       else if (!strncmp(soap->msgbuf, "HEAD ", l = 5))

	mov	DWORD PTR _l$89025[ebp], 5
	mov	esi, esp
	mov	eax, DWORD PTR _l$89025[ebp]
	push	eax
	push	OFFSET ??_C@_05PMJKDPIC@HEAD?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN42@http_parse

; 12994:         httpcmd = 5;

	mov	eax, 5
	mov	WORD PTR _httpcmd$[ebp], ax
$LN42@http_parse:

; 12995:     }
; 12996:     if (s && httpcmd)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN32@http_parse
	movzx	eax, WORD PTR _httpcmd$[ebp]
	test	eax, eax
	je	$LN32@http_parse

; 12997:     { size_t m = strlen(soap->endpoint);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87320				; 00015518H
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _m$89042[ebp], eax

; 12998:       size_t n = m + (s - soap->msgbuf) - l - 1;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, eax
	add	ecx, DWORD PTR _m$89042[ebp]
	sub	ecx, DWORD PTR _l$89025[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$89043[ebp], ecx

; 12999:       if (m > n)

	mov	eax, DWORD PTR _m$89042[ebp]
	cmp	eax, DWORD PTR _n$89043[ebp]
	jbe	SHORT $LN31@http_parse

; 13000:         m = n;

	mov	eax, DWORD PTR _n$89043[ebp]
	mov	DWORD PTR _m$89042[ebp], eax
$LN31@http_parse:

; 13001:       if (n >= sizeof(soap->endpoint))

	cmp	DWORD PTR _n$89043[ebp], 1024		; 00000400H
	jb	SHORT $LN30@http_parse

; 13002:         n = sizeof(soap->endpoint) - 1;

	mov	DWORD PTR _n$89043[ebp], 1023		; 000003ffH
$LN30@http_parse:

; 13003:       strncpy(soap->path, soap->msgbuf + l, n - m);

	mov	eax, DWORD PTR _n$89043[ebp]
	sub	eax, DWORD PTR _m$89042[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _l$89025[ebp]
	mov	edx, DWORD PTR _soap$[ebp]
	lea	eax, DWORD PTR [edx+ecx+78004]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 88344				; 00015918H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13004:       soap->path[n - m] = '\0';

	mov	eax, DWORD PTR _n$89043[ebp]
	sub	eax, DWORD PTR _m$89042[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+eax+88344], 0

; 13005:       strcat(soap->endpoint, soap->path);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 88344				; 00015918H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 87320				; 00015518H
	push	ecx
	call	_strcat
	add	esp, 8

; 13006:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Target endpoint='%s'\n", soap->endpoint));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN29@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN28@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN28@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN29@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89050[ebp], ecx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87320				; 00015518H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BG@FJPACGIL@Target?5endpoint?$DN?8?$CFs?8?6?$AA@
	mov	ecx, DWORD PTR _fdebug$89050[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89050[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@http_parse:

; 13007:       if (httpcmd > 1)

	movzx	eax, WORD PTR _httpcmd$[ebp]
	cmp	eax, 1
	jle	$LN26@http_parse

; 13008:       { switch (httpcmd)

	movzx	eax, WORD PTR _httpcmd$[ebp]
	mov	DWORD PTR tv380[ebp], eax
	mov	ecx, DWORD PTR tv380[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv380[ebp], ecx
	cmp	DWORD PTR tv380[ebp], 3
	ja	$LN19@http_parse
	mov	edx, DWORD PTR tv380[ebp]
	jmp	DWORD PTR $LN97@http_parse[edx*4]
$LN23@http_parse:

; 13009:         { case  2: soap->error = soap->fget(soap); break;

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12236]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	jmp	SHORT $LN24@http_parse
$LN22@http_parse:

; 13010:           case  3: soap->error = soap->fput(soap); break;

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12240]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	jmp	SHORT $LN24@http_parse
$LN21@http_parse:

; 13011:           case  4: soap->error = soap->fdel(soap); break;

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12244]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	jmp	SHORT $LN24@http_parse
$LN20@http_parse:

; 13012:           case  5: soap->error = soap->fhead(soap); break;

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12248]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	jmp	SHORT $LN24@http_parse
$LN19@http_parse:

; 13013: 	  default: soap->error = SOAP_HTTP_METHOD; break;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 19		; 00000013H
$LN24@http_parse:

; 13014: 	}
; 13015:         if (soap->error == SOAP_OK)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	jne	SHORT $LN18@http_parse

; 13016:           soap->error = SOAP_STOP; /* prevents further processing */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 1000		; 000003e8H
$LN18@http_parse:

; 13017:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN91@http_parse
$LN26@http_parse:

; 13018:       }
; 13019:       if (status)

	movzx	eax, WORD PTR _status$[ebp]
	test	eax, eax
	je	SHORT $LN17@http_parse

; 13020:         return soap->error = status;

	movzx	eax, WORD PTR _status$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90460]
	jmp	$LN91@http_parse
$LN17@http_parse:

; 13021:     }

	jmp	SHORT $LN43@http_parse
$LN32@http_parse:

; 13022:     else if (status)

	movzx	eax, WORD PTR _status$[ebp]
	test	eax, eax
	je	SHORT $LN15@http_parse

; 13023:       return soap->error = status;

	movzx	eax, WORD PTR _status$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90460]
	jmp	$LN91@http_parse
	jmp	SHORT $LN43@http_parse
$LN15@http_parse:

; 13024:     else if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN43@http_parse

; 13025:       return soap->error = 405;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 405		; 00000195H
	mov	eax, 405				; 00000195H
	jmp	$LN91@http_parse
$LN43@http_parse:

; 13026:   }
; 13027:   soap->status = k;

	movzx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90456], eax

; 13028:   /* Status OK (HTTP 200) */
; 13029:   if (k == 0 || k == 200)

	movzx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	je	SHORT $LN11@http_parse
	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 200				; 000000c8H
	jne	SHORT $LN12@http_parse
$LN11@http_parse:

; 13030:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN91@http_parse
$LN12@http_parse:

; 13031:   /* Status 201 (Created), 202 (Accepted), ... and HTTP 400 and 500 errors.
; 13032:      Only keep parsing HTTP body when content-length>0 or chunked is set.
; 13033:   */
; 13034:   if (((k > 200 && k <= 299) || k == 400 || k == 500) && (soap->length > 0 || (soap->imode & SOAP_IO) == SOAP_IO_CHUNK))

	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 200				; 000000c8H
	jle	SHORT $LN8@http_parse
	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 299				; 0000012bH
	jle	SHORT $LN9@http_parse
$LN8@http_parse:
	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 400				; 00000190H
	je	SHORT $LN9@http_parse
	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 500				; 000001f4H
	jne	SHORT $LN10@http_parse
$LN9@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12452], 0
	ja	SHORT $LN7@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN10@http_parse
$LN7@http_parse:

; 13035:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN91@http_parse
$LN10@http_parse:

; 13036:   /* HTTP 400 and 500 headers are supposed to set content-length or chunked.
; 13037:      For those that don't we keep parsing the body only if content type is
; 13038:      given and connection closes.
; 13039:   */
; 13040:   if ((k == 400 || k == 500) && (soap->http_content || soap->keep_alive == 0))

	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 400				; 00000190H
	je	SHORT $LN5@http_parse
	movzx	eax, WORD PTR _k$[ebp]
	cmp	eax, 500				; 000001f4H
	jne	SHORT $LN6@http_parse
$LN5@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN4@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	jne	SHORT $LN6@http_parse
$LN4@http_parse:

; 13041:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN91@http_parse
$LN6@http_parse:

; 13042:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP error %d\n", k));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@http_parse
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@http_parse:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@http_parse
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89081[ebp], ecx
	movzx	eax, WORD PTR _k$[ebp]
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0P@LPMLFOGK@HTTP?5error?5?$CFd?6?$AA@
	mov	ecx, DWORD PTR _fdebug$89081[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89081[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@http_parse:

; 13043:   return soap_set_receiver_error(soap, "HTTP Error", soap->msgbuf, k);

	movzx	eax, WORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	push	OFFSET ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H
$LN91@http_parse:

; 13044: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN96@http_parse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 8592				; 00002190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN96@http_parse:
	DD	2
	DD	$LN95@http_parse
$LN95@http_parse:
	DD	-8200					; ffffdff8H
	DD	8192					; 00002000H
	DD	$LN93@http_parse
	DD	-8212					; ffffdfecH
	DD	4
	DD	$LN94@http_parse
$LN94@http_parse:
	DB	115					; 00000073H
	DB	0
$LN93@http_parse:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
	npad	3
$LN97@http_parse:
	DD	$LN23@http_parse
	DD	$LN22@http_parse
	DD	$LN21@http_parse
	DD	$LN20@http_parse
_http_parse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@	; `string'
PUBLIC	??_C@_08KDOEBHGA@Location?$AA@			; `string'
PUBLIC	??_C@_0L@BIMPHKBC@SOAPAction?$AA@		; `string'
PUBLIC	??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@ ; `string'
PUBLIC	??_C@_0N@IOPAKPOD@100?9continue?$AA@		; `string'
PUBLIC	??_C@_06GHDJNLIG@Expect?$AA@			; `string'
PUBLIC	??_C@_05ELABLNGD@realm?$AA@			; `string'
PUBLIC	??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@	; `string'
PUBLIC	_soap_base642s
PUBLIC	??_C@_07LLIFBKCB@Basic?5?$CK?$AA@		; `string'
PUBLIC	??_C@_0O@NAFGPKMI@Authorization?$AA@		; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_0L@FFDPOIEG@keep?9alive?$AA@		; `string'
PUBLIC	??_C@_0L@PJJKMLL@Connection?$AA@		; `string'
PUBLIC	??_C@_07KCKHAHHI@chunked?$AA@			; `string'
PUBLIC	??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@	; `string'
PUBLIC	??_C@_04HOHEGKBO@gzip?$AA@			; `string'
PUBLIC	??_C@_07FNHFFEJG@deflate?$AA@			; `string'
PUBLIC	??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@	; `string'
PUBLIC	??_C@_0P@HOJGPHBA@Content?9Length?$AA@		; `string'
PUBLIC	??_C@_06DDLLCOJG@action?$AA@			; `string'
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_08KIKGFOKI@boundary?$AA@			; `string'
PUBLIC	??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@	; `string'
PUBLIC	??_C@_0BC@GGLOKPIO@multipart?1related?$AA@	; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1?$AA@		; `string'
PUBLIC	??_C@_04CPPPJGME@Host?$AA@			; `string'
;	COMDAT ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@
CONST	SEGMENT
??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@ DB 'X-Forwarded-For', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDOEBHGA@Location?$AA@
CONST	SEGMENT
??_C@_08KDOEBHGA@Location?$AA@ DB 'Location', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
CONST	SEGMENT
??_C@_0L@BIMPHKBC@SOAPAction?$AA@ DB 'SOAPAction', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@
CONST	SEGMENT
??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@ DB 'HTTP/1.1 100 Contin'
	DB	'ue', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IOPAKPOD@100?9continue?$AA@
CONST	SEGMENT
??_C@_0N@IOPAKPOD@100?9continue?$AA@ DB '100-continue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GHDJNLIG@Expect?$AA@
CONST	SEGMENT
??_C@_06GHDJNLIG@Expect?$AA@ DB 'Expect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELABLNGD@realm?$AA@
CONST	SEGMENT
??_C@_05ELABLNGD@realm?$AA@ DB 'realm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
CONST	SEGMENT
??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@ DB 'WWW-Authenticate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLIFBKCB@Basic?5?$CK?$AA@
CONST	SEGMENT
??_C@_07LLIFBKCB@Basic?5?$CK?$AA@ DB 'Basic *', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAFGPKMI@Authorization?$AA@
CONST	SEGMENT
??_C@_0O@NAFGPKMI@Authorization?$AA@ DB 'Authorization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
CONST	SEGMENT
??_C@_0L@FFDPOIEG@keep?9alive?$AA@ DB 'keep-alive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJJKMLL@Connection?$AA@
CONST	SEGMENT
??_C@_0L@PJJKMLL@Connection?$AA@ DB 'Connection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KCKHAHHI@chunked?$AA@
CONST	SEGMENT
??_C@_07KCKHAHHI@chunked?$AA@ DB 'chunked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@ DB 'Transfer-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHEGKBO@gzip?$AA@
CONST	SEGMENT
??_C@_04HOHEGKBO@gzip?$AA@ DB 'gzip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FNHFFEJG@deflate?$AA@
CONST	SEGMENT
??_C@_07FNHFFEJG@deflate?$AA@ DB 'deflate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@ DB 'Content-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
CONST	SEGMENT
??_C@_0P@HOJGPHBA@Content?9Length?$AA@ DB 'Content-Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLLCOJG@action?$AA@
CONST	SEGMENT
??_C@_06DDLLCOJG@action?$AA@ DB 'action', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KIKGFOKI@boundary?$AA@
CONST	SEGMENT
??_C@_08KIKGFOKI@boundary?$AA@ DB 'boundary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@
CONST	SEGMENT
??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@ DB 'multipart/form-data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GGLOKPIO@multipart?1related?$AA@
CONST	SEGMENT
??_C@_0BC@GGLOKPIO@multipart?1related?$AA@ DB 'multipart/related', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1?$AA@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1?$AA@ DB 'http://', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPPPJGME@Host?$AA@
CONST	SEGMENT
??_C@_04CPPPJGME@Host?$AA@ DB 'Host', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _http_parse_header
_TEXT	SEGMENT
_s$89137 = -32						; size = 4
_n$89136 = -20						; size = 4
_action$89094 = -8					; size = 4
_soap$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
_http_parse_header PROC					; COMDAT

; 13053: { if (!soap_tag_cmp(key, "Host"))

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_04CPPPJGME@Host?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@http_parse@2

; 13054:   {
; 13055: #ifdef WITH_OPENSSL
; 13056:     if (soap->imode & SOAP_ENC_SSL)
; 13057:       strcpy(soap->endpoint, "https://");
; 13058:     else
; 13059: #endif
; 13060:       strcpy(soap->endpoint, "http://");

	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87320				; 00015518H
	push	eax
	call	_strcpy
	add	esp, 8

; 13061:     strncat(soap->endpoint, val, sizeof(soap->endpoint) - 8);

	mov	esi, esp
	push	1016					; 000003f8H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 87320				; 00015518H
	push	ecx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13062:     soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+88343], 0
	jmp	$LN43@http_parse@2
$LN44@http_parse@2:

; 13063:   }
; 13064: #ifndef WITH_LEANER
; 13065:   else if (!soap_tag_cmp(key, "Content-Type"))

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN42@http_parse@2

; 13066:   { const char *action;
; 13067:     soap->http_content = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+36], eax

; 13068:     if (soap_get_header_attribute(soap, val, "application/dime"))

	push	OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN41@http_parse@2

; 13069:       soap->mode |= SOAP_ENC_DIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 13070:     else if (soap_get_header_attribute(soap, val, "multipart/related")

	jmp	$LN40@http_parse@2
$LN41@http_parse@2:

; 13071:           || soap_get_header_attribute(soap, val, "multipart/form-data"))

	push	OFFSET ??_C@_0BC@GGLOKPIO@multipart?1related?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN38@http_parse@2
	push	OFFSET ??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN40@http_parse@2
$LN38@http_parse@2:

; 13072:     { soap->mime.boundary = soap_strdup(soap, soap_get_header_attribute(soap, val, "boundary"));

	push	OFFSET ??_C@_08KIKGFOKI@boundary?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90524], eax

; 13073:       soap->mime.start = soap_strdup(soap, soap_get_header_attribute(soap, val, "start"));

	push	OFFSET ??_C@_05FAGFPHJG@start?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90528], eax

; 13074:       soap->mode |= SOAP_ENC_MIME;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN40@http_parse@2:

; 13075:     }
; 13076:     action = soap_get_header_attribute(soap, val, "action");

	push	OFFSET ??_C@_06DDLLCOJG@action?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _action$89094[ebp], eax

; 13077:     if (action)

	cmp	DWORD PTR _action$89094[ebp], 0
	je	SHORT $LN37@http_parse@2

; 13078:     { if (*action == '"')

	mov	eax, DWORD PTR _action$89094[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN36@http_parse@2

; 13079:       { soap->action = soap_strdup(soap, action + 1);

	mov	eax, DWORD PTR _action$89094[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90392], eax

; 13080:         soap->action[strlen(soap->action) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90392]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+90392]
	mov	BYTE PTR [eax+ecx-1], 0

; 13081:       }
; 13082:       else

	jmp	SHORT $LN37@http_parse@2
$LN36@http_parse@2:

; 13083:         soap->action = soap_strdup(soap, action);

	mov	eax, DWORD PTR _action$89094[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90392], eax
$LN37@http_parse@2:

; 13084:     }
; 13085:   }

	jmp	$LN43@http_parse@2
$LN42@http_parse@2:

; 13086: #endif
; 13087:   else if (!soap_tag_cmp(key, "Content-Length"))

	push	OFFSET ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@http_parse@2

; 13088:   { soap->length = soap_strtoul(val, NULL, 10);

	mov	esi, esp
	push	10					; 0000000aH
	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12452], eax
	jmp	$LN43@http_parse@2
$LN33@http_parse@2:

; 13089:   }
; 13090:   else if (!soap_tag_cmp(key, "Content-Encoding"))

	push	OFFSET ??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@http_parse@2

; 13091:   { if (!soap_tag_cmp(val, "deflate"))

	push	OFFSET ??_C@_07FNHFFEJG@deflate?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@http_parse@2

; 13092: #ifdef WITH_ZLIB
; 13093:       soap->zlib_in = SOAP_ZLIB_DEFLATE;
; 13094: #else
; 13095:       return SOAP_ZLIB_ERROR;

	mov	eax, 31					; 0000001fH
	jmp	$LN45@http_parse@2
	jmp	SHORT $LN29@http_parse@2
$LN30@http_parse@2:

; 13096: #endif
; 13097:     else if (!soap_tag_cmp(val, "gzip"))

	push	OFFSET ??_C@_04HOHEGKBO@gzip?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@http_parse@2

; 13098: #ifdef WITH_GZIP
; 13099:       soap->zlib_in = SOAP_ZLIB_GZIP;
; 13100: #else
; 13101:       return SOAP_ZLIB_ERROR;

	mov	eax, 31					; 0000001fH
	jmp	$LN45@http_parse@2
$LN29@http_parse@2:

; 13102: #endif
; 13103:   }

	jmp	$LN43@http_parse@2
$LN31@http_parse@2:

; 13104: #ifdef WITH_ZLIB
; 13105:   else if (!soap_tag_cmp(key, "Accept-Encoding"))
; 13106:   {
; 13107: #ifdef WITH_GZIP
; 13108:     if (strchr(val, '*') || soap_get_header_attribute(soap, val, "gzip"))
; 13109:       soap->zlib_out = SOAP_ZLIB_GZIP;
; 13110:     else
; 13111: #endif
; 13112:     if (strchr(val, '*') || soap_get_header_attribute(soap, val, "deflate"))
; 13113:       soap->zlib_out = SOAP_ZLIB_DEFLATE;
; 13114:     else
; 13115:       soap->zlib_out = SOAP_ZLIB_NONE;
; 13116:   }
; 13117: #endif
; 13118:   else if (!soap_tag_cmp(key, "Transfer-Encoding"))

	push	OFFSET ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@http_parse@2

; 13119:   { soap->mode &= ~SOAP_IO;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 13120:     if (!soap_tag_cmp(val, "chunked"))

	push	OFFSET ??_C@_07KCKHAHHI@chunked?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@http_parse@2

; 13121:       soap->mode |= SOAP_IO_CHUNK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 3
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN25@http_parse@2:

; 13122:   }

	jmp	$LN43@http_parse@2
$LN26@http_parse@2:

; 13123:   else if (!soap_tag_cmp(key, "Connection"))

	push	OFFSET ??_C@_0L@PJJKMLL@Connection?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@http_parse@2

; 13124:   { if (!soap_tag_cmp(val, "keep-alive"))

	push	OFFSET ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@http_parse@2

; 13125:       soap->keep_alive = -soap->keep_alive;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	neg	ecx
	call	@_RTC_Check_4_to_2@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
	jmp	SHORT $LN21@http_parse@2
$LN22@http_parse@2:

; 13126:     else if (!soap_tag_cmp(val, "close"))

	push	OFFSET ??_C@_05LBOHBHFK@close?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@http_parse@2

; 13127:       soap->keep_alive = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax
$LN21@http_parse@2:

; 13128:   }

	jmp	$LN43@http_parse@2
$LN23@http_parse@2:

; 13129: #ifndef WITH_LEAN
; 13130:   else if (!soap_tag_cmp(key, "Authorization"))

	push	OFFSET ??_C@_0O@NAFGPKMI@Authorization?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN18@http_parse@2

; 13131:   { if (!soap_tag_cmp(val, "Basic *"))

	push	OFFSET ??_C@_07LLIFBKCB@Basic?5?$CK?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN17@http_parse@2

; 13132:     { int n;
; 13133:       char *s;
; 13134:       soap_base642s(soap, val + 6, soap->tmpbuf, sizeof(soap->tmpbuf) - 1, &n);

	lea	eax, DWORD PTR _n$89136[ebp]
	push	eax
	push	1023					; 000003ffH
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_base642s
	add	esp, 20					; 00000014H

; 13135:       soap->tmpbuf[n] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _n$89136[ebp]
	mov	BYTE PTR [eax+79028], 0

; 13136:       if ((s = strchr(soap->tmpbuf, ':')))

	push	58					; 0000003aH
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _s$89137[ebp], eax
	cmp	DWORD PTR _s$89137[ebp], 0
	je	SHORT $LN17@http_parse@2

; 13137:       { *s = '\0';

	mov	eax, DWORD PTR _s$89137[ebp]
	mov	BYTE PTR [eax], 0

; 13138:         soap->userid = soap_strdup(soap, soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12224], eax

; 13139:         soap->passwd = soap_strdup(soap, s + 1);

	mov	eax, DWORD PTR _s$89137[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12228], eax
$LN17@http_parse@2:

; 13140:       }
; 13141:     }
; 13142:   }

	jmp	$LN43@http_parse@2
$LN18@http_parse@2:

; 13143:   else if (!soap_tag_cmp(key, "WWW-Authenticate"))

	push	OFFSET ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@http_parse@2

; 13144:   { soap->authrealm = soap_strdup(soap, soap_get_header_attribute(soap, val + 6, "realm"));

	push	OFFSET ??_C@_05ELABLNGD@realm?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	push	eax
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_strdup
	add	esp, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90396], eax
	jmp	$LN43@http_parse@2
$LN14@http_parse@2:

; 13145:   }
; 13146:   else if (!soap_tag_cmp(key, "Expect"))

	push	OFFSET ??_C@_06GHDJNLIG@Expect?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN12@http_parse@2

; 13147:   { if (!soap_tag_cmp(val, "100-continue"))

	push	OFFSET ??_C@_0N@IOPAKPOD@100?9continue?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@http_parse@2

; 13148:     { if ((soap->error = soap->fposthdr(soap, "HTTP/1.1 100 Continue", NULL))
; 13149:        || (soap->error = soap->fposthdr(soap, NULL, NULL)))

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	jne	SHORT $LN9@http_parse@2
	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN11@http_parse@2
$LN9@http_parse@2:

; 13150:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN45@http_parse@2
$LN11@http_parse@2:

; 13151:     }
; 13152:   }

	jmp	$LN43@http_parse@2
$LN12@http_parse@2:

; 13153: #endif
; 13154:   else if (!soap_tag_cmp(key, "SOAPAction"))

	push	OFFSET ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@http_parse@2

; 13155:   { if (*val == '"')

	mov	eax, DWORD PTR _val$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN6@http_parse@2

; 13156:     { soap->action = soap_strdup(soap, val + 1);

	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90392], eax

; 13157:       soap->action[strlen(soap->action) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90392]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [edx+90392]
	mov	BYTE PTR [eax+ecx-1], 0

; 13158:     }
; 13159:     else

	jmp	SHORT $LN5@http_parse@2
$LN6@http_parse@2:

; 13160:       soap->action = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90392], eax
$LN5@http_parse@2:
	jmp	SHORT $LN43@http_parse@2
$LN7@http_parse@2:

; 13161:   }
; 13162:   else if (!soap_tag_cmp(key, "Location"))

	push	OFFSET ??_C@_08KDOEBHGA@Location?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@http_parse@2

; 13163:   { strncpy(soap->endpoint, val, sizeof(soap->endpoint));

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 87320				; 00015518H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13164:     soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+88343], 0
	jmp	SHORT $LN43@http_parse@2
$LN3@http_parse@2:

; 13165:   }
; 13166:   else if (!soap_tag_cmp(key, "X-Forwarded-For"))

	push	OFFSET ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@http_parse@2

; 13167:   { soap->proxy_from = soap_strdup(soap, val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90452], eax
$LN43@http_parse@2:

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
$LN45@http_parse@2:

; 13178: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN49@http_parse@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN49@http_parse@2:
	DD	1
	DD	$LN48@http_parse@2
$LN48@http_parse@2:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN47@http_parse@2
$LN47@http_parse@2:
	DB	110					; 0000006eH
	DB	0
_http_parse_header ENDP
_TEXT	ENDS
PUBLIC	_soap_decode_val
PUBLIC	_soap_decode_key
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_get_header_attribute
_TEXT	SEGMENT
_flag$89172 = -20					; size = 2
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_line$ = 12						; size = 4
_key$ = 16						; size = 4
_soap_get_header_attribute PROC				; COMDAT

; 13189: { register const char *s = line;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 13190:   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN4@soap_get_h@2
$LN3@soap_get_h@2:

; 13191:   { while (*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@soap_get_h@2

; 13192:     { register short flag;
; 13193:       s = soap_decode_key(soap->tmpbuf, sizeof(soap->tmpbuf), s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_soap_decode_key
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _s$[ebp], eax

; 13194:       flag = soap_tag_cmp(soap->tmpbuf, key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_soap_tag_cmp
	add	esp, 8
	mov	ecx, eax
	call	@_RTC_Check_4_to_2@4
	mov	WORD PTR _flag$89172[ebp], ax

; 13195:       s = soap_decode_val(soap->tmpbuf, sizeof(soap->tmpbuf), s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_soap_decode_val
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _s$[ebp], eax

; 13196:       if (!flag)

	movsx	eax, WORD PTR _flag$89172[ebp]
	test	eax, eax
	jne	SHORT $LN1@soap_get_h@2

; 13197:         return soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	jmp	SHORT $LN5@soap_get_h@2
$LN1@soap_get_h@2:

; 13198:     }

	jmp	SHORT $LN3@soap_get_h@2
$LN4@soap_get_h@2:

; 13199:   }
; 13200:   return NULL;

	xor	eax, eax
$LN5@soap_get_h@2:

; 13201: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_get_header_attribute ENDP
_TEXT	ENDS
PUBLIC	??_C@_03NBBPFACD@?$DN?0?$DL?$AA@		; `string'
;	COMDAT ??_C@_03NBBPFACD@?$DN?0?$DL?$AA@
CONST	SEGMENT
??_C@_03NBBPFACD@?$DN?0?$DL?$AA@ DB '=,;', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_decode_key
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_val$ = 16						; size = 4
_soap_decode_key PROC					; COMDAT

; 13212: { return soap_decode(buf, len, val, "=,;");

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_03NBBPFACD@?$DN?0?$DL?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_soap_decode
	add	esp, 16					; 00000010H

; 13213: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_decode_key ENDP
_TEXT	ENDS
PUBLIC	??_C@_02NFLHGFB@?0?$DL?$AA@			; `string'
;	COMDAT ??_C@_02NFLHGFB@?0?$DL?$AA@
CONST	SEGMENT
??_C@_02NFLHGFB@?0?$DL?$AA@ DB ',;', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_decode_val
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_val$ = 16						; size = 4
_soap_decode_val PROC					; COMDAT

; 13224: { if (*val != '=')

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _val$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN1@soap_decod

; 13225:   { *buf = '\0';

	mov	eax, DWORD PTR _buf$[ebp]
	mov	BYTE PTR [eax], 0

; 13226:     return val;

	mov	eax, DWORD PTR _val$[ebp]
	jmp	SHORT $LN2@soap_decod
$LN1@soap_decod:

; 13227:   }
; 13228:   return soap_decode(buf, len, val + 1, ",;");

	push	OFFSET ??_C@_02NFLHGFB@?0?$DL?$AA@
	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_soap_decode
	add	esp, 16					; 00000010H
$LN2@soap_decod:

; 13229: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_decode_val ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_decode
_TEXT	SEGMENT
tv157 = -224						; size = 4
tv145 = -220						; size = 4
_t$ = -20						; size = 4
_s$ = -8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_val$ = 16						; size = 4
_sep$ = 20						; size = 4
_soap_decode PROC					; COMDAT

; 13238: { const char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13239:   char *t = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 13240:   for (s = val; *s; s++)

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN15@soap_decod@2
$LN14@soap_decod@2:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN15@soap_decod@2:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@soap_decod@2

; 13241:     if (*s != ' ' && *s != '\t' && !strchr(sep, *s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN12@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	je	SHORT $LN12@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _sep$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN12@soap_decod@2

; 13242:       break;

	jmp	SHORT $LN13@soap_decod@2
$LN12@soap_decod@2:

; 13243:   if (*s == '"')

	jmp	SHORT $LN14@soap_decod@2
$LN13@soap_decod@2:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN7@soap_decod@2

; 13244:   { s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN10@soap_decod@2:

; 13245:     while (*s && *s != '"' && --len)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN9@soap_decod@2
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	je	SHORT $LN9@soap_decod@2

; 13246:       *t++ = *s++;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	jmp	SHORT $LN10@soap_decod@2
$LN9@soap_decod@2:

; 13247:   }
; 13248:   else

	jmp	$LN8@soap_decod@2
$LN7@soap_decod@2:

; 13249:   { while (*s && !soap_blank(*s) && !strchr(sep, *s) && --len)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN8@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN5@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	$LN8@soap_decod@2
$LN5@soap_decod@2:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _sep$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN8@soap_decod@2
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	je	$LN8@soap_decod@2

; 13250:     { if (*s == '%')

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	$LN4@soap_decod@2

; 13251:       { *t++ = ((s[1] >= 'A' ? (s[1] & 0x7) + 9 : s[1] - '0') << 4)
; 13252:               + (s[2] >= 'A' ? (s[2] & 0x7) + 9 : s[2] - '0');

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN18@soap_decod@2
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	and	eax, 7
	add	eax, 9
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN19@soap_decod@2
$LN18@soap_decod@2:
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	sub	edx, 48					; 00000030H
	mov	DWORD PTR tv145[ebp], edx
$LN19@soap_decod@2:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN20@soap_decod@2
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	and	eax, 7
	add	eax, 9
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN21@soap_decod@2
$LN20@soap_decod@2:
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	sub	edx, 48					; 00000030H
	mov	DWORD PTR tv157[ebp], edx
$LN21@soap_decod@2:
	mov	ecx, DWORD PTR tv145[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR tv157[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13253:         s += 3;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 3
	mov	DWORD PTR _s$[ebp], eax

; 13254:       }
; 13255:       else

	jmp	SHORT $LN3@soap_decod@2
$LN4@soap_decod@2:

; 13256:         *t++ = *s++;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN3@soap_decod@2:

; 13257:     }

	jmp	$LN7@soap_decod@2
$LN8@soap_decod@2:

; 13258:   }
; 13259:   *t = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0
$LN2@soap_decod@2:

; 13260:   while (*s && !strchr(sep, *s))

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@soap_decod@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _sep$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@soap_decod@2

; 13261:     s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN2@soap_decod@2
$LN1@soap_decod@2:

; 13262:   return s;

	mov	eax, DWORD PTR _s$[ebp]

; 13263: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@	; `string'
PUBLIC	??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@ ; `string'
PUBLIC	??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@ ; `string'
PUBLIC	??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@ ; `string'
PUBLIC	??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@ ; `string'
PUBLIC	_soap_envelope_begin_out
;	COMDAT ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
CONST	SEGMENT
??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@ DB 'SOAP-ENV:Envelope', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@
CONST	SEGMENT
??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@ DB '-'
	DB	'-%s', 0dH, 0aH, 'Content-Type: %s', 0dH, 0aH, 'Content-Transf'
	DB	'er-Encoding: binary', 0dH, 0aH, 'Content-ID: %s', 0dH, 0aH, 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@
CONST	SEGMENT
??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@ DB 'text/xml; ch'
	DB	'arset=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@
CONST	SEGMENT
??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@ DB 'appli'
	DB	'cation/soap+xml; charset=utf-8', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@
CONST	SEGMENT
??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@ DB 'appli'
	DB	'cation/xop+xml; charset=utf-8; type="application/soap+xml"', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_envelope_begin_out
_TEXT	SEGMENT
_s$89218 = -20						; size = 4
_n$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_envelope_begin_out PROC				; COMDAT

; 13273: {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13274: #ifndef WITH_LEANER
; 13275:   size_t n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 13276:   if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && soap->mime.start && strlen(soap->mime.boundary) + strlen(soap->mime.start) < sizeof(soap->tmpbuf) - 80)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	$LN11@soap_envel
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	$LN11@soap_envel
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90528], 0
	je	$LN11@soap_envel
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90528]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, 944				; 000003b0H
	jae	$LN11@soap_envel

; 13277:   { const char *s;
; 13278:     if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN10@soap_envel
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	jne	SHORT $LN10@soap_envel

; 13279:       s = "application/dime";

	mov	DWORD PTR _s$89218[ebp], OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	jmp	SHORT $LN9@soap_envel
$LN10@soap_envel:

; 13280:     else if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN8@soap_envel

; 13281:     { if (soap->mode & SOAP_ENC_MTOM)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN7@soap_envel

; 13282:         s = "application/xop+xml; charset=utf-8; type=\"application/soap+xml\"";

	mov	DWORD PTR _s$89218[ebp], OFFSET ??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@

; 13283:       else

	jmp	SHORT $LN6@soap_envel
$LN7@soap_envel:

; 13284:         s = "application/soap+xml; charset=utf-8";

	mov	DWORD PTR _s$89218[ebp], OFFSET ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@
$LN6@soap_envel:

; 13285:     }
; 13286:     else

	jmp	SHORT $LN9@soap_envel
$LN8@soap_envel:

; 13287:       s = "text/xml; charset=utf-8";

	mov	DWORD PTR _s$89218[ebp], OFFSET ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@
$LN9@soap_envel:

; 13288:     sprintf(soap->tmpbuf, "--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n", soap->mime.boundary, s, soap->mime.start);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90528]
	push	ecx
	mov	edx, DWORD PTR _s$89218[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	push	OFFSET ??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13289:     n = strlen(soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 13290:     if (soap_send_raw(soap, soap->tmpbuf, n))

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@soap_envel

; 13291:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN12@soap_envel
$LN11@soap_envel:

; 13292:   }
; 13293:   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN3@soap_envel

; 13294:     soap->dime.size = soap->count;	/* DIME in MIME correction */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12448]
	mov	DWORD PTR [eax+90480], edx
$LN3@soap_envel:

; 13295:   if (!(soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	jne	SHORT $LN2@soap_envel
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN2@soap_envel

; 13296:   { if (soap_putdimehdr(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putdimehdr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_envel

; 13297:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN12@soap_envel
$LN2@soap_envel:

; 13298:   }
; 13299: #endif
; 13300:   soap->part = SOAP_IN_ENVELOPE;

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13301:   return soap_element_begin_out(soap, "SOAP-ENV:Envelope", 0, NULL);

	push	0
	push	0
	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_out
	add	esp, 16					; 00000010H
$LN12@soap_envel:

; 13302: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_envelope_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_end_out
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_envelope_end_out
_TEXT	SEGMENT
tv167 = -196						; size = 4
_soap$ = 8						; size = 4
_soap_envelope_end_out PROC				; COMDAT

; 13311: { if (soap_element_end_out(soap, "SOAP-ENV:Envelope"))

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_envel@2

; 13312:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN8@soap_envel@2
$LN7@soap_envel@2:

; 13313: #ifndef WITH_LEANER
; 13314:   if ((soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	$LN6@soap_envel@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	$LN6@soap_envel@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	jne	$LN6@soap_envel@2

; 13315:   { soap->dime.size = soap->count - soap->dime.size;	/* DIME in MIME correction */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12448]
	sub	edx, DWORD PTR [ecx+90480]
	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90480], edx

; 13316:     sprintf(soap->id, soap->dime_id_format, 0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 81076				; 00013cb4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13317:     soap->dime.id = soap->id;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90500], eax

; 13318:     if (soap->local_namespaces)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN5@soap_envel@2

; 13319:     { if (soap->local_namespaces[0].out)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN4@soap_envel@2

; 13320:         soap->dime.type = (char*)soap->local_namespaces[0].out;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+90504], eax

; 13321:       else

	jmp	SHORT $LN5@soap_envel@2
$LN4@soap_envel@2:

; 13322:         soap->dime.type = (char*)soap->local_namespaces[0].ns;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+90504], eax
$LN5@soap_envel@2:

; 13323:     }
; 13324:     soap->dime.options = NULL;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90508], 0

; 13325:     soap->dime.flags = SOAP_DIME_MB | SOAP_DIME_ABSURI;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+90492], 36		; 00000024H

; 13326:     if (!soap->dime.first)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90516], 0
	jne	SHORT $LN2@soap_envel@2

; 13327:       soap->dime.flags |= SOAP_DIME_ME;

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+90492]
	or	ecx, 2
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [ecx+90492], al
$LN2@soap_envel@2:

; 13328:     soap->count += 12 + ((strlen(soap->dime.id)+3)&(~3)) + (soap->dime.type ? ((strlen(soap->dime.type)+3)&(~3)) : 0);

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90504], 0
	je	SHORT $LN10@soap_envel@2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90504]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	DWORD PTR tv167[ebp], eax
	jmp	SHORT $LN11@soap_envel@2
$LN10@soap_envel@2:
	mov	DWORD PTR tv167[ebp], 0
$LN11@soap_envel@2:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90500]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	edx, DWORD PTR tv167[ebp]
	lea	eax, DWORD PTR [eax+edx+12]
	mov	ecx, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR [ecx+12448]
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+12448], eax
$LN6@soap_envel@2:

; 13329:   }
; 13330:   if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	SHORT $LN1@soap_envel@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	jne	SHORT $LN1@soap_envel@2

; 13331:     return soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90480]
	neg	ecx
	and	ecx, 3
	push	ecx
	push	OFFSET _soap_padding
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@soap_envel@2
$LN1@soap_envel@2:

; 13332: #endif
; 13333:   soap->part = SOAP_END_ENVELOPE;

	mov	eax, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13334:   return SOAP_OK;

	xor	eax, eax
$LN8@soap_envel@2:

; 13335: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_envelope_end_out ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA	; `soap_envelope_begin_in'::`2'::__LINE__Var
PUBLIC	??_C@_04PNIFHPHN@html?$AA@			; `string'
PUBLIC	_soap_envelope_begin_in
;	COMDAT ?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA DD 03420H ; `soap_envelope_begin_in'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html?$AA@
CONST	SEGMENT
??_C@_04PNIFHPHN@html?$AA@ DB 'html', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_envelope_begin_in
_TEXT	SEGMENT
_ns$89261 = -44						; size = 4
_f$89258 = -32						; size = 4
_s$89254 = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_envelope_begin_in PROC				; COMDAT

; 13344: { register struct Namespace *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13345:   soap->part = SOAP_IN_ENVELOPE;

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13346:   if (soap_element_begin_in(soap, "SOAP-ENV:Envelope", 0, NULL))

	push	0
	push	0
	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN12@soap_envel@3

; 13347:   {
; 13348: #ifndef WITH_LEAN
; 13349:     if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "html", 0, NULL))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 3
	jne	SHORT $LN11@soap_envel@3
	push	0
	push	0
	push	OFFSET ??_C@_04PNIFHPHN@html?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN11@soap_envel@3

; 13350:     { /* get HTML from buffer, stop receiving to avoid HTML parsing issues */
; 13351:       char *s;
; 13352: #ifndef WITH_NOIO
; 13353:       size_t (*f)(struct soap*, char*, size_t) = soap->frecv;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12312]
	mov	DWORD PTR _f$89258[ebp], ecx

; 13354:       soap->frecv = frecv_stop;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12312], OFFSET _frecv_stop

; 13355: #endif
; 13356:       soap_revert(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_revert
	add	esp, 4

; 13357:       s = soap_string_in(soap, 1, -1, -1);

	push	-1
	push	-1
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_string_in
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s$89254[ebp], eax

; 13358: #ifndef WITH_NOIO
; 13359:       soap->frecv = f;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _f$89258[ebp]
	mov	DWORD PTR [eax+12312], ecx

; 13360: #endif
; 13361:       return soap_set_receiver_error(soap, "HTTP Error", s, SOAP_HTTP_ERROR);

	push	29					; 0000001dH
	mov	eax, DWORD PTR _s$89254[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_receiver_error
	add	esp, 16					; 00000010H
	jmp	$LN13@soap_envel@3
$LN11@soap_envel@3:

; 13362:     }
; 13363: #endif
; 13364:     if (soap->error == SOAP_TAG_MISMATCH)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 3
	jne	SHORT $LN10@soap_envel@3

; 13365:       return soap->error = SOAP_VERSIONMISMATCH;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 39		; 00000027H
	mov	eax, 39					; 00000027H
	jmp	$LN13@soap_envel@3
$LN10@soap_envel@3:

; 13366:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN13@soap_envel@3
$LN12@soap_envel@3:

; 13367:   }
; 13368:   p = soap->local_namespaces;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _p$[ebp], ecx

; 13369:   if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN9@soap_envel@3

; 13370:   { const char *ns = p[0].out;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _ns$89261[ebp], ecx

; 13371:     if (!ns)

	cmp	DWORD PTR _ns$89261[ebp], 0
	jne	SHORT $LN8@soap_envel@3

; 13372:       ns = p[0].ns;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ns$89261[ebp], ecx
$LN8@soap_envel@3:

; 13373:     if (!strcmp(ns, soap_env1))

	push	OFFSET _soap_env1
	mov	eax, DWORD PTR _ns$89261[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@soap_envel@3

; 13374:     { soap->version = 1; /* make sure we use SOAP 1.1 */

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax

; 13375:       if (p[1].out)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN6@soap_envel@3

; 13376:         SOAP_FREE(soap, p[1].out);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA
	add	edx, 32					; 00000020H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN6@soap_envel@3:

; 13377:       if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc1))))

	push	42					; 0000002aH
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN5@soap_envel@3

; 13378:         strcpy(p[1].out, soap_enc1);

	push	OFFSET _soap_enc1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN5@soap_envel@3:

; 13379:     }

	jmp	$LN9@soap_envel@3
$LN7@soap_envel@3:

; 13380:     else if (!strcmp(ns, soap_env2))

	push	OFFSET _soap_env2
	mov	eax, DWORD PTR _ns$89261[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_envel@3

; 13381:     { soap->version = 2; /* make sure we use SOAP 1.2 */

	mov	eax, 2
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+6], ax

; 13382:       if (p[1].out)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@soap_envel@3

; 13383:         SOAP_FREE(soap, p[1].out);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR ?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA
	add	edx, 39					; 00000027H
	push	edx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_track_free
	add	esp, 16					; 00000010H
$LN2@soap_envel@3:

; 13384:       if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc2))))

	push	40					; 00000028H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_envelope_begin_in@@9@4JA
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN9@soap_envel@3

; 13385:         strcpy(p[1].out, soap_enc2);

	push	OFFSET _soap_enc2
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN9@soap_envel@3:

; 13386:     }
; 13387:   }
; 13388:   return SOAP_OK;

	xor	eax, eax
$LN13@soap_envel@3:

; 13389: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_envelope_begin_in ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _frecv_stop
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_frecv_stop PROC					; COMDAT

; 1042 : { return 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax

; 1043 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_frecv_stop ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_end_in
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_envelope_end_in
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_envelope_end_in PROC				; COMDAT

; 13398: { soap->part = SOAP_END_ENVELOPE;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 8
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13399:   return soap_element_end_in(soap, "SOAP-ENV:Envelope");

	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_in
	add	esp, 8

; 13400: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_envelope_end_in ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@		; `string'
PUBLIC	??_C@_04MJIIEFNN@Body?$AA@			; `string'
PUBLIC	_soap_body_begin_out
;	COMDAT ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
CONST	SEGMENT
??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@ DB 'SOAP-ENV:Body', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MJIIEFNN@Body?$AA@
CONST	SEGMENT
??_C@_04MJIIEFNN@Body?$AA@ DB 'Body', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_body_begin_out
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_body_begin_out PROC				; COMDAT

; 13409: { soap->part = SOAP_IN_BODY;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 6
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13410:   if (soap->version == 1)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	jne	SHORT $LN3@soap_body_

; 13411:     soap->encoding = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87296], ax
$LN3@soap_body_:

; 13412: #ifndef WITH_LEAN
; 13413:   if ((soap->mode & SOAP_XML_SEC) && soap_set_attr(soap, "wsu:Id", "Body"))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN2@soap_body_
	push	OFFSET ??_C@_04MJIIEFNN@Body?$AA@
	push	OFFSET ??_C@_06BGJENONN@wsu?3Id?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_attr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_body_

; 13414:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN4@soap_body_
$LN2@soap_body_:

; 13415: #endif
; 13416:   if (soap_element(soap, "SOAP-ENV:Body", 0, NULL))

	push	0
	push	0
	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_body_

; 13417:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN4@soap_body_
$LN1@soap_body_:

; 13418:   return soap_element_start_end_out(soap, NULL);

	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_start_end_out
	add	esp, 8
$LN4@soap_body_:

; 13419: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_body_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_body_end_out
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_body_end_out
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_body_end_out PROC					; COMDAT

; 13428: { if (soap_element_end_out(soap, "SOAP-ENV:Body"))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_out
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_body_@2

; 13429:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN2@soap_body_@2
$LN1@soap_body_@2:

; 13430:   soap->part = SOAP_END_BODY;

	mov	eax, 7
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13431:   return SOAP_OK;

	xor	eax, eax
$LN2@soap_body_@2:

; 13432: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_body_end_out ENDP
_TEXT	ENDS
PUBLIC	_soap_body_begin_in
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_body_begin_in
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_body_begin_in PROC				; COMDAT

; 13441: { soap->part = SOAP_IN_BODY;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 6
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13442:   if (soap_element_begin_in(soap, "SOAP-ENV:Body", 0, NULL))

	push	0
	push	0
	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_begin_in
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@soap_body_@3

; 13443:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN3@soap_body_@3
$LN2@soap_body_@3:

; 13444:   if (!soap->body)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+12442]
	test	ecx, ecx
	jne	SHORT $LN1@soap_body_@3

; 13445:     soap->part = SOAP_NO_BODY;

	mov	eax, 5
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax
$LN1@soap_body_@3:

; 13446:   return SOAP_OK;

	xor	eax, eax
$LN3@soap_body_@3:

; 13447: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_body_begin_in ENDP
_TEXT	ENDS
PUBLIC	_soap_body_end_in
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_body_end_in
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_body_end_in PROC					; COMDAT

; 13456: { if (soap->part == SOAP_NO_BODY)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+87304]
	cmp	ecx, 5
	jne	SHORT $LN1@soap_body_@4

; 13457:     return SOAP_OK;

	xor	eax, eax
	jmp	SHORT $LN2@soap_body_@4
$LN1@soap_body_@4:

; 13458:   soap->part = SOAP_END_BODY;

	mov	eax, 7
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+87304], ax

; 13459:   return soap_element_end_in(soap, "SOAP-ENV:Body");

	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_element_end_in
	add	esp, 8
$LN2@soap_body_@4:

; 13460: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_body_end_in ENDP
_TEXT	ENDS
PUBLIC	_soap_recv_header
EXTRN	_soap_getheader:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_recv_header
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_recv_header PROC					; COMDAT

; 13469: { if (soap_getheader(soap) && soap->error == SOAP_TAG_MISMATCH)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getheader
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@soap_recv_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 3
	jne	SHORT $LN3@soap_recv_@2

; 13470:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
	jmp	SHORT $LN2@soap_recv_@2
$LN3@soap_recv_@2:

; 13471:   else if (soap->error == SOAP_OK && soap->fheader)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	jne	SHORT $LN2@soap_recv_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12272], 0
	je	SHORT $LN2@soap_recv_@2

; 13472:     soap->error = soap->fheader(soap);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12272]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
$LN2@soap_recv_@2:

; 13473:   return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]

; 13474: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_recv_header ENDP
_TEXT	ENDS
PUBLIC	_soap_set_endpoint
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_endpoint
_TEXT	SEGMENT
_n$ = -32						; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_soap_set_endpoint PROC					; COMDAT

; 13483: { register const char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13484:   register size_t i, n;
; 13485:   soap->endpoint[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+87320], 0

; 13486:   soap->host[0] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+89368], 0

; 13487:   soap->path[0] = '/';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+88344], 47		; 0000002fH

; 13488:   soap->path[1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+88345], 0

; 13489:   soap->port = 80;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90408], 80		; 00000050H

; 13490:   if (!endpoint || !*endpoint)

	cmp	DWORD PTR _endpoint$[ebp], 0
	je	SHORT $LN15@soap_set_e@2
	mov	eax, DWORD PTR _endpoint$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN16@soap_set_e@2
$LN15@soap_set_e@2:

; 13491:     return;

	jmp	$LN17@soap_set_e@2
$LN16@soap_set_e@2:

; 13492: #ifdef WITH_OPENSSL
; 13493:   if (!soap_tag_cmp(endpoint, "https:*"))
; 13494:     soap->port = 443;
; 13495: #endif
; 13496:   strncpy(soap->endpoint, endpoint, sizeof(soap->endpoint) - 1);

	mov	esi, esp
	push	1023					; 000003ffH
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 87320				; 00015518H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13497:   soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+88343], 0

; 13498:   s = strchr(endpoint, ':');

	mov	esi, esp
	push	58					; 0000003aH
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _s$[ebp], eax

; 13499:   if (s && s[1] == '/' && s[2] == '/')

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN14@soap_set_e@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN14@soap_set_e@2
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN14@soap_set_e@2

; 13500:     s += 3;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 3
	mov	DWORD PTR _s$[ebp], eax

; 13501:   else

	jmp	SHORT $LN13@soap_set_e@2
$LN14@soap_set_e@2:

; 13502:     s = endpoint;

	mov	eax, DWORD PTR _endpoint$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN13@soap_set_e@2:

; 13503:   n = strlen(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 13504:   if (n >= sizeof(soap->host))

	cmp	DWORD PTR _n$[ebp], 1024		; 00000400H
	jb	SHORT $LN12@soap_set_e@2

; 13505:     n = sizeof(soap->host) - 1;

	mov	DWORD PTR _n$[ebp], 1023		; 000003ffH
$LN12@soap_set_e@2:

; 13506: #ifdef WITH_IPV6
; 13507:   if (s[0] == '[')
; 13508:   { s++;
; 13509:     for (i = 0; i < n; i++)
; 13510:     { if (s[i] == ']')
; 13511:       { s++;
; 13512:         --n;
; 13513:         break;
; 13514:       }
; 13515:       soap->host[i] = s[i];
; 13516:     }
; 13517:   }
; 13518:   else
; 13519:   { for (i = 0; i < n; i++)
; 13520:     { soap->host[i] = s[i];
; 13521:       if (s[i] == '/' || s[i] == ':')
; 13522:         break;
; 13523:     }
; 13524:   }
; 13525: #else
; 13526:   for (i = 0; i < n; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@soap_set_e@2
$LN10@soap_set_e@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@soap_set_e@2:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jae	SHORT $LN9@soap_set_e@2

; 13527:   { soap->host[i] = s[i];

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+89368], dl

; 13528:     if (s[i] == '/' || s[i] == ':')

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN7@soap_set_e@2
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN8@soap_set_e@2
$LN7@soap_set_e@2:

; 13529:       break;

	jmp	SHORT $LN9@soap_set_e@2
$LN8@soap_set_e@2:

; 13530:   }

	jmp	SHORT $LN10@soap_set_e@2
$LN9@soap_set_e@2:

; 13531: #endif
; 13532:   soap->host[i] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax+89368], 0

; 13533:   if (s[i] == ':')

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN6@soap_set_e@2

; 13534:   { soap->port = (int)atol(s + i + 1);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90408], eax

; 13535:     for (i++; i < n; i++)

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN5@soap_set_e@2
$LN4@soap_set_e@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@soap_set_e@2:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jae	SHORT $LN6@soap_set_e@2

; 13536:       if (s[i] == '/')

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN2@soap_set_e@2

; 13537:         break;

	jmp	SHORT $LN6@soap_set_e@2
$LN2@soap_set_e@2:

; 13538:   }

	jmp	SHORT $LN4@soap_set_e@2
$LN6@soap_set_e@2:

; 13539:   if (i < n && s[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jae	SHORT $LN17@soap_set_e@2
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@soap_set_e@2

; 13540:   { strncpy(soap->path, s + i, sizeof(soap->path));

	mov	esi, esp
	push	1024					; 00000400H
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 88344				; 00015918H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13541:     soap->path[sizeof(soap->path) - 1] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+89367], 0
$LN17@soap_set_e@2:

; 13542:   }
; 13543: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_endpoint ENDP
_TEXT	ENDS
PUBLIC	_soap_connect_command
PUBLIC	_soap_connect
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_connect
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_action$ = 16						; size = 4
_soap_connect PROC					; COMDAT

; 13552: { return soap_connect_command(soap, SOAP_POST, endpoint, action);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _action$[ebp]
	push	eax
	mov	ecx, DWORD PTR _endpoint$[ebp]
	push	ecx
	push	2000					; 000007d0H
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_connect_command
	add	esp, 16					; 00000010H

; 13553: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_connect ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LLHAEKON@soap?4udp?3?$AA@		; `string'
PUBLIC	??_C@_0DC@BEIFDMGG@Connect?1reconnect?5to?5host?$DN?8?$CFs?8?5p@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_09LLHAEKON@soap?4udp?3?$AA@
CONST	SEGMENT
??_C@_09LLHAEKON@soap?4udp?3?$AA@ DB 'soap.udp:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BEIFDMGG@Connect?1reconnect?5to?5host?$DN?8?$CFs?8?5p@
CONST	SEGMENT
??_C@_0DC@BEIFDMGG@Connect?1reconnect?5to?5host?$DN?8?$CFs?8?5p@ DB 'Conn'
	DB	'ect/reconnect to host=''%s'' path=''%s'' port=%d', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_connect_command
_TEXT	SEGMENT
_k$89360 = -1080					; size = 4
_fdebug$89352 = -1068					; size = 4
_count$ = -1056						; size = 4
_port$ = -1044						; size = 4
_host$ = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_http_command$ = 12					; size = 4
_endpoint$ = 16						; size = 4
_action$ = 20						; size = 4
_soap_connect_command PROC				; COMDAT

; 13562: { char host[sizeof(soap->host)];

	push	ebp
	mov	ebp, esp
	sub	esp, 1276				; 000004fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1276]
	mov	ecx, 319				; 0000013fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 13563:   int port;
; 13564:   size_t count;
; 13565:   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 13566:   strcpy(host, soap->host); /* save previous host name to compare */

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 89368				; 00015d18H
	push	eax
	lea	ecx, DWORD PTR _host$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 13567:   port = soap->port; /* save previous port to compare */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	mov	DWORD PTR _port$[ebp], ecx

; 13568:   soap->status = http_command;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _http_command$[ebp]
	mov	DWORD PTR [eax+90456], ecx

; 13569:   soap_set_endpoint(soap, endpoint);

	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_endpoint
	add	esp, 8

; 13570: #ifndef WITH_LEANER
; 13571:   if (soap->fconnect)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12280], 0
	je	SHORT $LN19@soap_conne

; 13572:   { if ((soap->error = soap->fconnect(soap, endpoint, soap->host, soap->port)))

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 89368				; 00015d18H
	push	edx
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12280]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN18@soap_conne

; 13573:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN20@soap_conne
$LN18@soap_conne:

; 13574:   }
; 13575:   else

	jmp	$LN17@soap_conne
$LN19@soap_conne:

; 13576: #endif
; 13577:   if (soap->fopen && *soap->host)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12296], 0
	je	$LN17@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+89368]
	test	ecx, ecx
	je	$LN17@soap_conne

; 13578:   { if (!soap->keep_alive || !soap_valid_socket(soap->socket) || strcmp(soap->host, host) || soap->port != port || !soap->fpoll || soap->fpoll(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	je	SHORT $LN14@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN14@soap_conne
	lea	eax, DWORD PTR _host$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 89368				; 00015d18H
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	cmp	ecx, DWORD PTR _port$[ebp]
	jne	SHORT $LN14@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12316], 0
	je	SHORT $LN14@soap_conne
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12316]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN17@soap_conne
$LN14@soap_conne:

; 13579:     { soap->keep_alive = 0; /* to force close */

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 13580:       soap->omode &= ~SOAP_IO_UDP; /* to force close */

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 13581:       soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4

; 13582:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Connect/reconnect to host='%s' path='%s' port=%d\n", soap->host, soap->path, soap->port));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN13@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN12@soap_conne
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN12@soap_conne:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN13@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89352[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 88344				; 00015918H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 89368				; 00015d18H
	push	eax
	push	OFFSET ??_C@_0DC@BEIFDMGG@Connect?1reconnect?5to?5host?$DN?8?$CFs?8?5p@
	mov	ecx, DWORD PTR _fdebug$89352[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89352[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@soap_conne:

; 13583: #ifndef WITH_LEAN
; 13584:       if (!strncmp(endpoint, "soap.udp:", 9))

	mov	esi, esp
	push	9
	push	OFFSET ??_C@_09LLHAEKON@soap?4udp?3?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN10@soap_conne

; 13585:         soap->omode |= SOAP_IO_UDP;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 4
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN10@soap_conne:

; 13586: #endif
; 13587:       soap->socket = soap->fopen(soap, endpoint, soap->host, soap->port);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 89368				; 00015d18H
	push	edx
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12296]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+12408], eax

; 13588:       if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN9@soap_conne

; 13589:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN20@soap_conne
$LN9@soap_conne:

; 13590:       soap->keep_alive = ((soap->omode & SOAP_IO_KEEPALIVE) != 0);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 16					; 00000010H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [edx+90412], cx
$LN17@soap_conne:

; 13591:     }
; 13592:   }
; 13593:   count = soap_count_attachments(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_count_attachments
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 13594:   if (soap_begin_send(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_begin_send
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@soap_conne

; 13595:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN20@soap_conne
$LN8@soap_conne:

; 13596:   if (http_command != SOAP_POST)

	cmp	DWORD PTR _http_command$[ebp], 2000	; 000007d0H
	je	SHORT $LN7@soap_conne

; 13597:   { soap->mode &= ~SOAP_IO;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 13598:     soap->mode |= SOAP_IO_BUFFER;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN7@soap_conne:

; 13599:   }
; 13600: #ifndef WITH_NOHTTP
; 13601:   soap->action = soap_strdup(soap, action);

	mov	eax, DWORD PTR _action$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90392], eax

; 13602:   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML) && endpoint)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	je	$LN6@soap_conne
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	jne	$LN6@soap_conne
	cmp	DWORD PTR _endpoint$[ebp], 0
	je	$LN6@soap_conne

; 13603:   { unsigned int k = soap->mode;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _k$89360[ebp], ecx

; 13604:     soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -1028				; fffffbfcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 13605:     if ((k & SOAP_IO) != SOAP_IO_FLUSH)

	mov	eax, DWORD PTR _k$89360[ebp]
	and	eax, 3
	je	SHORT $LN5@soap_conne

; 13606:       soap->mode |= SOAP_IO_BUFFER;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@soap_conne:

; 13607:     if ((soap->error = soap->fpost(soap, endpoint, soap->host, soap->port, soap->path, action, count)))

	mov	esi, esp
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _action$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 88344				; 00015918H
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90408]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 89368				; 00015d18H
	push	edx
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12232]
	call	eax
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [ecx+90460], eax
	mov	edx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [edx+90460], 0
	je	SHORT $LN4@soap_conne

; 13608:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN20@soap_conne
$LN4@soap_conne:

; 13609: #ifndef WITH_LEANER
; 13610:     if ((k & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _k$89360[ebp]
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN3@soap_conne

; 13611:     { if (soap_flush(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_flush
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@soap_conne

; 13612:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN20@soap_conne
$LN3@soap_conne:

; 13613:     }
; 13614: #endif
; 13615:     soap->mode = k;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _k$89360[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN6@soap_conne:

; 13616:   }
; 13617:   if (http_command != SOAP_POST)

	cmp	DWORD PTR _http_command$[ebp], 2000	; 000007d0H
	je	SHORT $LN1@soap_conne

; 13618:     return soap_end_send(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_send
	add	esp, 4
	jmp	SHORT $LN20@soap_conne
$LN1@soap_conne:

; 13619: #endif
; 13620:   return SOAP_OK;

	xor	eax, eax
$LN20@soap_conne:

; 13621: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@soap_conne
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1276				; 000004fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@soap_conne:
	DD	1
	DD	$LN23@soap_conne
$LN23@soap_conne:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN22@soap_conne
$LN22@soap_conne:
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_soap_connect_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HHLKNDKA@New?5count?5is?5?$CFlu?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@BKDIMHIF@Size?5of?5MIME?5attachment?5content?5@ ; `string'
PUBLIC	??_C@_0CK@JLCKIAGB@Calculating?5the?5size?5of?5MIME?5att@ ; `string'
PUBLIC	??_C@_0CO@CANBMAPB@Size?5of?5DIME?5attachment?5content?5@ ; `string'
PUBLIC	??_C@_0CK@GDCJJIIM@Calculating?5the?5size?5of?5DIME?5att@ ; `string'
PUBLIC	??_C@_0EC@EDLODNFG@Calculating?5the?5message?5size?5wit@ ; `string'
;	COMDAT ??_C@_0BI@HHLKNDKA@New?5count?5is?5?$CFlu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BI@HHLKNDKA@New?5count?5is?5?$CFlu?5bytes?6?$AA@ DB 'New count is '
	DB	'%lu bytes', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BKDIMHIF@Size?5of?5MIME?5attachment?5content?5@
CONST	SEGMENT
??_C@_0CO@BKDIMHIF@Size?5of?5MIME?5attachment?5content?5@ DB 'Size of MIM'
	DB	'E attachment content is %lu bytes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JLCKIAGB@Calculating?5the?5size?5of?5MIME?5att@
CONST	SEGMENT
??_C@_0CK@JLCKIAGB@Calculating?5the?5size?5of?5MIME?5att@ DB 'Calculating'
	DB	' the size of MIME attachments', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CANBMAPB@Size?5of?5DIME?5attachment?5content?5@
CONST	SEGMENT
??_C@_0CO@CANBMAPB@Size?5of?5DIME?5attachment?5content?5@ DB 'Size of DIM'
	DB	'E attachment content is %lu bytes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GDCJJIIM@Calculating?5the?5size?5of?5DIME?5att@
CONST	SEGMENT
??_C@_0CK@GDCJJIIM@Calculating?5the?5size?5of?5DIME?5att@ DB 'Calculating'
	DB	' the size of DIME attachments', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDLODNFG@Calculating?5the?5message?5size?5wit@
CONST	SEGMENT
??_C@_0EC@EDLODNFG@Calculating?5the?5message?5size?5wit@ DB 'Calculating '
	DB	'the message size with attachments, current count=%lu', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_count_attachments
_TEXT	SEGMENT
_fdebug$88217 = -116					; size = 4
_fdebug$88210 = -104					; size = 4
_s$88200 = -92						; size = 4
_fdebug$88195 = -80					; size = 4
_n$88190 = -68						; size = 4
_fdebug$88186 = -56					; size = 4
_fdebug$88172 = -44					; size = 4
_fdebug$88164 = -32					; size = 4
_count$ = -20						; size = 4
_content$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_count_attachments PROC				; COMDAT

; 10981: {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10982: #ifndef WITH_LEANER
; 10983:   register struct soap_multipart *content;
; 10984:   register size_t count = soap->count;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12448]
	mov	DWORD PTR _count$[ebp], ecx

; 10985:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the message size with attachments, current count=%lu\n", (unsigned long)count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN34@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN33@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN33@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN34@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88164[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@EDLODNFG@Calculating?5the?5message?5size?5wit@
	mov	ecx, DWORD PTR _fdebug$88164[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88164[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@soap_count:

; 10986:   if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	je	$LN31@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	jne	$LN31@soap_count

; 10987:   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of DIME attachments\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN30@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN29@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN29@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN30@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88172[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CK@GDCJJIIM@Calculating?5the?5size?5of?5DIME?5att@
	mov	eax, DWORD PTR _fdebug$88172[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88172[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@soap_count:

; 10988:     for (content = soap->dime.first; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90516]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	SHORT $LN27@soap_count
$LN26@soap_count:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$[ebp], ecx
$LN27@soap_count:
	cmp	DWORD PTR _content$[ebp], 0
	je	$LN31@soap_count

; 10989:     { count += 12 + ((content->size+3)&(~3));

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _count$[ebp], eax

; 10990:       if (content->id)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN24@soap_count

; 10991:         count += ((strlen(content->id)+3)&(~3));

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 3
	and	eax, -4					; fffffffcH
	add	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN24@soap_count:

; 10992:       if (content->type)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN23@soap_count

; 10993:         count += ((strlen(content->type)+3)&(~3));

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 3
	and	eax, -4					; fffffffcH
	add	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN23@soap_count:

; 10994:       if (content->options)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN22@soap_count

; 10995:         count += ((((unsigned char)content->options[2] << 8) | ((unsigned char)content->options[3]))+7)&(~3);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 8
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movzx	eax, BYTE PTR [ecx+3]
	or	edx, eax
	add	edx, 7
	and	edx, -4					; fffffffcH
	add	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], edx
$LN22@soap_count:

; 10996:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Size of DIME attachment content is %lu bytes\n", (unsigned long)content->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN21@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN20@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN20@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN21@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88186[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CO@CANBMAPB@Size?5of?5DIME?5attachment?5content?5@
	mov	edx, DWORD PTR _fdebug$88186[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88186[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@soap_count:

; 10997:     }

	jmp	$LN26@soap_count
$LN31@soap_count:

; 10998:   }
; 10999:   if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	$LN18@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	$LN18@soap_count

; 11000:   { register size_t n = strlen(soap->mime.boundary);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$88190[ebp], eax

; 11001:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of MIME attachments\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN17@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN16@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN16@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN17@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88195[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0CK@JLCKIAGB@Calculating?5the?5size?5of?5MIME?5att@
	mov	eax, DWORD PTR _fdebug$88195[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88195[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@soap_count:

; 11002:     for (content = soap->mime.first; content; content = content->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90536]
	mov	DWORD PTR _content$[ebp], ecx
	jmp	SHORT $LN14@soap_count
$LN13@soap_count:
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _content$[ebp], ecx
$LN14@soap_count:
	cmp	DWORD PTR _content$[ebp], 0
	je	$LN12@soap_count

; 11003:     { register const char *s;
; 11004:       /* count \r\n--boundary\r\n */
; 11005:       count += 6 + n;

	mov	eax, DWORD PTR _n$88190[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6]
	mov	DWORD PTR _count$[ebp], edx

; 11006:       /* count Content-Type: ...\r\n */
; 11007:       if (content->type)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN11@soap_count

; 11008:         count += 16 + strlen(content->type);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _count$[ebp], eax
$LN11@soap_count:

; 11009:       /* count Content-Transfer-Encoding: ...\r\n */
; 11010:       s = soap_code_str(mime_codes, content->encoding);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET _mime_codes
	call	_soap_code_str
	add	esp, 8
	mov	DWORD PTR _s$88200[ebp], eax

; 11011:       if (s)

	cmp	DWORD PTR _s$88200[ebp], 0
	je	SHORT $LN10@soap_count

; 11012:         count += 29 + strlen(s);

	mov	eax, DWORD PTR _s$88200[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _count$[ebp]
	lea	edx, DWORD PTR [ecx+eax+29]
	mov	DWORD PTR _count$[ebp], edx
$LN10@soap_count:

; 11013:       /* count Content-ID: ...\r\n */
; 11014:       if (content->id)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN9@soap_count

; 11015:         count += 14 + strlen(content->id);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+eax+14]
	mov	DWORD PTR _count$[ebp], eax
$LN9@soap_count:

; 11016:       /* count Content-Location: ...\r\n */
; 11017:       if (content->location)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN8@soap_count

; 11018:         count += 20 + strlen(content->location);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _count$[ebp], eax
$LN8@soap_count:

; 11019:       /* count Content-Description: ...\r\n */
; 11020:       if (content->description)

	mov	eax, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN7@soap_count

; 11021:         count += 23 + strlen(content->description);

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+eax+23]
	mov	DWORD PTR _count$[ebp], eax
$LN7@soap_count:

; 11022:       /* count \r\n...content */
; 11023:       count += 2 + content->size;

	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _count$[ebp], eax

; 11024:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Size of MIME attachment content is %lu bytes\n", (unsigned long)content->size));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88210[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _content$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CO@BKDIMHIF@Size?5of?5MIME?5attachment?5content?5@
	mov	edx, DWORD PTR _fdebug$88210[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88210[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_count:

; 11025:     }

	jmp	$LN13@soap_count
$LN12@soap_count:

; 11026:     /* count \r\n--boundary-- */
; 11027:     count += 6 + n;

	mov	eax, DWORD PTR _n$88190[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6]
	mov	DWORD PTR _count$[ebp], edx
$LN18@soap_count:

; 11028:   }
; 11029:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New count is %lu bytes\n", (unsigned long)count));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN3@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_count
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_count:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_count
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$88217[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@HHLKNDKA@New?5count?5is?5?$CFlu?5bytes?6?$AA@
	mov	ecx, DWORD PTR _fdebug$88217[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$88217[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_count:

; 11030:   return count;

	mov	eax, DWORD PTR _count$[ebp]

; 11031: #else
; 11032:   return soap->count;
; 11033: #endif
; 11034: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_count_attachments ENDP
_TEXT	ENDS
PUBLIC	_soap_s2base64
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2base64
_TEXT	SEGMENT
_p$ = -32						; size = 4
_m$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_s2base64 PROC					; COMDAT

; 13630: { register int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13631:   register unsigned long m;
; 13632:   register char *p;
; 13633:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN22@soap_s2bas

; 13634:     t = (char*)soap_malloc(soap, (n + 2) / 3 * 4 + 1);

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [eax*4+1]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN22@soap_s2bas:

; 13635:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN21@soap_s2bas

; 13636:   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 13637:     return NULL;

	xor	eax, eax
	jmp	$LN23@soap_s2bas
$LN21@soap_s2bas:

; 13638:   }
; 13639:   p = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 13640:   t[0] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 13641:   if (!s)

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN20@soap_s2bas

; 13642:     return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN23@soap_s2bas
$LN20@soap_s2bas:

; 13643:   for (; n > 2; n -= 3, s += 3)

	jmp	SHORT $LN19@soap_s2bas
$LN18@soap_s2bas:
	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 3
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 3
	mov	DWORD PTR _s$[ebp], ecx
$LN19@soap_s2bas:
	cmp	DWORD PTR _n$[ebp], 2
	jle	SHORT $LN17@soap_s2bas

; 13644:   { m = s[0];

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _m$[ebp], ecx

; 13645:     m = (m << 8) | s[1];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax

; 13646:     m = (m << 8) | s[2];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax

; 13647:     for (i = 4; i > 0; m >>= 6)

	mov	DWORD PTR _i$[ebp], 4
	jmp	SHORT $LN16@soap_s2bas
$LN15@soap_s2bas:
	mov	eax, DWORD PTR _m$[ebp]
	shr	eax, 6
	mov	DWORD PTR _m$[ebp], eax
$LN16@soap_s2bas:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN14@soap_s2bas

; 13648:       t[--i] = soap_base64o[m & 0x3F];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _soap_base64o[ecx]
	mov	BYTE PTR [edx], al
	jmp	SHORT $LN15@soap_s2bas
$LN14@soap_s2bas:

; 13649:     t += 4;

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 4
	mov	DWORD PTR _t$[ebp], eax

; 13650:   }

	jmp	$LN18@soap_s2bas
$LN17@soap_s2bas:

; 13651:   t[0] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 13652:   if (n > 0)

	cmp	DWORD PTR _n$[ebp], 0
	jle	$LN13@soap_s2bas

; 13653:   { m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 13654:     for (i = 0; i < n; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@soap_s2bas
$LN11@soap_s2bas:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@soap_s2bas:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN10@soap_s2bas

; 13655:       m = (m << 8) | *s++;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	eax, edx
	mov	DWORD PTR _m$[ebp], eax
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN11@soap_s2bas
$LN10@soap_s2bas:

; 13656:     for (; i < 3; i++)

	jmp	SHORT $LN9@soap_s2bas
$LN8@soap_s2bas:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@soap_s2bas:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN7@soap_s2bas

; 13657:       m <<= 8;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 8
	mov	DWORD PTR _m$[ebp], eax
	jmp	SHORT $LN8@soap_s2bas
$LN7@soap_s2bas:

; 13658:     for (i++; i > 0; m >>= 6)

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN6@soap_s2bas
$LN5@soap_s2bas:
	mov	eax, DWORD PTR _m$[ebp]
	shr	eax, 6
	mov	DWORD PTR _m$[ebp], eax
$LN6@soap_s2bas:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN4@soap_s2bas

; 13659:       t[--i] = soap_base64o[m & 0x3F];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _soap_base64o[ecx]
	mov	BYTE PTR [edx], al
	jmp	SHORT $LN5@soap_s2bas
$LN4@soap_s2bas:

; 13660:     for (i = 3; i > n; i--)

	mov	DWORD PTR _i$[ebp], 3
	jmp	SHORT $LN3@soap_s2bas
$LN2@soap_s2bas:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@soap_s2bas:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jle	SHORT $LN1@soap_s2bas

; 13661:       t[i] = '=';

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	jmp	SHORT $LN2@soap_s2bas
$LN1@soap_s2bas:

; 13662:     t[4] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax+4], 0
$LN13@soap_s2bas:

; 13663:   }
; 13664:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN23@soap_s2bas:

; 13665: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2base64 ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_base642s
_TEXT	SEGMENT
tv90 = -268						; size = 4
_b$89440 = -68						; size = 4
_p$ = -56						; size = 4
_m$ = -44						; size = 4
_c$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_l$ = 20						; size = 4
_n$ = 24						; size = 4
_soap_base642s PROC					; COMDAT

; 13674: { register int i, j, c;

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13675:   register unsigned long m;
; 13676:   register const char *p;
; 13677:   if (!s || !*s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN28@soap_base6
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN29@soap_base6
$LN28@soap_base6:

; 13678:   { if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN27@soap_base6

; 13679:       *n = 0;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], 0
$LN27@soap_base6:

; 13680:     if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN26@soap_base6

; 13681:       return NULL;

	xor	eax, eax
	jmp	$LN30@soap_base6
$LN26@soap_base6:

; 13682:     return SOAP_NON_NULL;

	mov	eax, OFFSET _soap_padding
	jmp	$LN30@soap_base6
$LN29@soap_base6:

; 13683:   }
; 13684:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN25@soap_base6

; 13685:   { l = (strlen(s) + 3) / 4 * 3;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 3
	shr	eax, 2
	imul	eax, 3
	mov	DWORD PTR _l$[ebp], eax

; 13686:     t = (char*)soap_malloc(soap, l);

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN25@soap_base6:

; 13687:   }
; 13688:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN24@soap_base6

; 13689:   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 13690:     return NULL;

	xor	eax, eax
	jmp	$LN30@soap_base6
$LN24@soap_base6:

; 13691:   }
; 13692:   p = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 13693:   if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN22@soap_base6

; 13694:     *n = 0;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], 0
$LN22@soap_base6:

; 13695:   for (;;)
; 13696:   { for (i = 0; i < SOAP_BLKLEN; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@soap_base6
$LN19@soap_base6:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@soap_base6:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN18@soap_base6

; 13697:     { m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 13698:       j = 0;

	mov	DWORD PTR _j$[ebp], 0
$LN17@soap_base6:

; 13699:       while (j < 4)

	cmp	DWORD PTR _j$[ebp], 4
	jge	$LN16@soap_base6

; 13700:       { c = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 13701:         if (c == '=' || !c)

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	je	SHORT $LN14@soap_base6
	cmp	DWORD PTR _c$[ebp], 0
	jne	$LN15@soap_base6
$LN14@soap_base6:

; 13702:         { i *= 3;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 3
	mov	DWORD PTR _i$[ebp], eax

; 13703:           switch (j)

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	cmp	DWORD PTR tv90[ebp], 2
	je	SHORT $LN11@soap_base6
	cmp	DWORD PTR tv90[ebp], 3
	je	SHORT $LN10@soap_base6
	jmp	SHORT $LN12@soap_base6
$LN11@soap_base6:

; 13704:           { case 2:
; 13705:               *t++ = (char)((m >> 4) & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	shr	ecx, 4
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13706:               i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 13707:               break;

	jmp	SHORT $LN12@soap_base6
$LN10@soap_base6:

; 13708:             case 3:
; 13709:               *t++ = (char)((m >> 10) & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13710:               *t++ = (char)((m >> 2) & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	shr	ecx, 2
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13711:               i += 2;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN12@soap_base6:

; 13712:           }
; 13713:           if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN9@soap_base6

; 13714:             *n += i;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx
$LN9@soap_base6:

; 13715:           return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN30@soap_base6
$LN15@soap_base6:

; 13716:         }
; 13717:         c -= '+';

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 43					; 0000002bH
	mov	DWORD PTR _c$[ebp], eax

; 13718:         if (c >= 0 && c <= 79)

	js	SHORT $LN8@soap_base6
	cmp	DWORD PTR _c$[ebp], 79			; 0000004fH
	jg	SHORT $LN8@soap_base6

; 13719:         { int b = soap_base64i[c];

	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, BYTE PTR _soap_base64i[eax]
	mov	DWORD PTR _b$89440[ebp], ecx

; 13720:           if (b >= 64)

	cmp	DWORD PTR _b$89440[ebp], 64		; 00000040H
	jl	SHORT $LN7@soap_base6

; 13721:           { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 13722:             return NULL;

	xor	eax, eax
	jmp	$LN30@soap_base6
$LN7@soap_base6:

; 13723:           }
; 13724:           m = (m << 6) + b;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _b$89440[ebp]
	mov	DWORD PTR _m$[ebp], eax

; 13725:           j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN6@soap_base6
$LN8@soap_base6:

; 13726:         }
; 13727:         else if (!soap_blank(c + '+'))

	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 43					; 0000002bH
	js	SHORT $LN4@soap_base6
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 43					; 0000002bH
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN6@soap_base6
$LN4@soap_base6:

; 13728:         { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 4

; 13729:           return NULL;

	xor	eax, eax
	jmp	$LN30@soap_base6
$LN6@soap_base6:

; 13730:         }
; 13731:       }

	jmp	$LN17@soap_base6
$LN16@soap_base6:

; 13732:       *t++ = (char)((m >> 16) & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13733:       *t++ = (char)((m >> 8) & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13734:       *t++ = (char)(m & 0xFF);

	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, 255				; 000000ffH
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13735:       if (l < 3)

	cmp	DWORD PTR _l$[ebp], 3
	jae	SHORT $LN3@soap_base6

; 13736:       { if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN2@soap_base6

; 13737:           *n += i;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@soap_base6:

; 13738:         return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	SHORT $LN30@soap_base6
$LN3@soap_base6:

; 13739:       }
; 13740:       l -= 3;

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 3
	mov	DWORD PTR _l$[ebp], eax

; 13741:     }

	jmp	$LN19@soap_base6
$LN18@soap_base6:

; 13742:     if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN1@soap_base6

; 13743:       *n += 3 * SOAP_BLKLEN;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 768				; 00000300H
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@soap_base6:

; 13744:   }

	jmp	$LN22@soap_base6
$LN30@soap_base6:

; 13745: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_base642s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2hex
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_s2hex
_TEXT	SEGMENT
_m$89465 = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_s2hex PROC					; COMDAT

; 13754: { register char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13755:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN6@soap_s2hex

; 13756:     t = (char*)soap_malloc(soap, 2 * n + 1);

	mov	eax, DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN6@soap_s2hex:

; 13757:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@soap_s2hex

; 13758:   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 13759:     return NULL;

	xor	eax, eax
	jmp	$LN7@soap_s2hex
$LN5@soap_s2hex:

; 13760:   }
; 13761:   p = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 13762:   t[0] = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0

; 13763:   if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN4@soap_s2hex
	jmp	SHORT $LN3@soap_s2hex
$LN2@soap_s2hex:

; 13764:   { for (; n > 0; n--)

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN3@soap_s2hex:
	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN4@soap_s2hex

; 13765:     { register int m = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _m$89465[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 13766:       *t++ = (char)((m >> 4) + (m > 159 ? 'a' - 10 : '0'));

	mov	ecx, DWORD PTR _m$89465[ebp]
	sar	ecx, 4
	xor	eax, eax
	cmp	DWORD PTR _m$89465[ebp], 159		; 0000009fH
	setle	al
	sub	eax, 1
	and	eax, 39					; 00000027H
	add	eax, 48					; 00000030H
	add	ecx, eax
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13767:       m &= 0x0F;

	mov	eax, DWORD PTR _m$89465[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _m$89465[ebp], eax

; 13768:       *t++ = (char)(m + (m > 9 ? 'a' - 10 : '0'));

	xor	ecx, ecx
	cmp	DWORD PTR _m$89465[ebp], 9
	setle	cl
	sub	ecx, 1
	and	ecx, 39					; 00000027H
	add	ecx, 48					; 00000030H
	add	ecx, DWORD PTR _m$89465[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13769:     }

	jmp	$LN2@soap_s2hex
$LN4@soap_s2hex:

; 13770:   }
; 13771:   *t++ = '\0';

	mov	eax, DWORD PTR _t$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$[ebp], ecx

; 13772:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN7@soap_s2hex:

; 13773: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_s2hex ENDP
_TEXT	ENDS
PUBLIC	_soap_hex2s
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_hex2s
_TEXT	SEGMENT
tv129 = -236						; size = 4
tv91 = -232						; size = 4
_d2$89487 = -32						; size = 4
_d1$89486 = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_l$ = 20						; size = 4
_n$ = 24						; size = 4
_soap_hex2s PROC					; COMDAT

; 13782: { register const char *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13783:   if (!s || !*s)

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN10@soap_hex2s
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@soap_hex2s
$LN10@soap_hex2s:

; 13784:   { if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN9@soap_hex2s

; 13785:       *n = 0;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@soap_hex2s:

; 13786:     if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN8@soap_hex2s

; 13787:       return NULL;

	xor	eax, eax
	jmp	$LN12@soap_hex2s
$LN8@soap_hex2s:

; 13788:     return SOAP_NON_NULL;

	mov	eax, OFFSET _soap_padding
	jmp	$LN12@soap_hex2s
$LN11@soap_hex2s:

; 13789:   }
; 13790:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN7@soap_hex2s

; 13791:   { l = strlen(s) / 2;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	shr	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 13792:     t = (char*)soap_malloc(soap, l);

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_malloc
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN7@soap_hex2s:

; 13793:   }
; 13794:   if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN6@soap_hex2s

; 13795:   { soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H

; 13796:     return NULL;

	xor	eax, eax
	jmp	$LN12@soap_hex2s
$LN6@soap_hex2s:

; 13797:   }
; 13798:   p = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN5@soap_hex2s:

; 13799:   while (l)

	cmp	DWORD PTR _l$[ebp], 0
	je	$LN4@soap_hex2s

; 13800:   { register int d1, d2;
; 13801:     d1 = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d1$89486[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 13802:     if (!d1)

	cmp	DWORD PTR _d1$89486[ebp], 0
	jne	SHORT $LN3@soap_hex2s

; 13803:       break;

	jmp	$LN4@soap_hex2s
$LN3@soap_hex2s:

; 13804:     d2 = *s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d2$89487[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 13805:     if (!d2)

	cmp	DWORD PTR _d2$89487[ebp], 0
	jne	SHORT $LN2@soap_hex2s

; 13806:       break;

	jmp	SHORT $LN4@soap_hex2s
$LN2@soap_hex2s:

; 13807:     *t++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');

	cmp	DWORD PTR _d1$89486[ebp], 65		; 00000041H
	jl	SHORT $LN14@soap_hex2s
	mov	eax, DWORD PTR _d1$89486[ebp]
	and	eax, 7
	add	eax, 9
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN15@soap_hex2s
$LN14@soap_hex2s:
	mov	ecx, DWORD PTR _d1$89486[ebp]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR tv91[ebp], ecx
$LN15@soap_hex2s:
	cmp	DWORD PTR _d2$89487[ebp], 65		; 00000041H
	jl	SHORT $LN16@soap_hex2s
	mov	edx, DWORD PTR _d2$89487[ebp]
	and	edx, 7
	add	edx, 9
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN17@soap_hex2s
$LN16@soap_hex2s:
	mov	eax, DWORD PTR _d2$89487[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR tv129[ebp], eax
$LN17@soap_hex2s:
	mov	ecx, DWORD PTR tv91[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR tv129[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _t$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx

; 13808:     l--;

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 13809:   }

	jmp	$LN5@soap_hex2s
$LN4@soap_hex2s:

; 13810:   if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN1@soap_hex2s

; 13811:     *n = (int)(t - p);

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@soap_hex2s:

; 13812:   return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN12@soap_hex2s:

; 13813: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_hex2s ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@	; `string'
PUBLIC	??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@ ; `string'
PUBLIC	??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@ ; `string'
PUBLIC	_soap_puthttphdr
;	COMDAT ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@ DB '; start-info="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@ DB '"; start="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@ DB 'm'
	DB	'ultipart/related; boundary="%s"; type="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@
CONST	SEGMENT
??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@ DB 'appli'
	DB	'cation/xop+xml; charset=utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@
CONST	SEGMENT
??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@ DB 'text/html; '
	DB	'charset=utf-8', 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_puthttphdr
_TEXT	SEGMENT
tv211 = -244						; size = 4
tv132 = -244						; size = 4
_t$89514 = -44						; size = 4
_r$89500 = -32						; size = 4
_err$89499 = -20					; size = 4
_s$89498 = -8						; size = 4
_soap$ = 8						; size = 4
_status$ = 12						; size = 4
_count$ = 16						; size = 4
_soap_puthttphdr PROC					; COMDAT

; 13823: { if (soap->status != SOAP_GET)

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 2001		; 000007d1H
	je	$LN21@soap_putht

; 13824:   { register const char *s = "text/xml; charset=utf-8";

	mov	DWORD PTR _s$89498[ebp], OFFSET ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@

; 13825:     register int err = SOAP_OK;

	mov	DWORD PTR _err$89499[ebp], 0

; 13826: #ifndef WITH_LEANER
; 13827:     register const char *r = NULL;

	mov	DWORD PTR _r$89500[ebp], 0

; 13828: #endif
; 13829:     if (status == SOAP_FILE && soap->http_content)

	cmp	DWORD PTR _status$[ebp], 1003		; 000003ebH
	jne	SHORT $LN20@soap_putht
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN20@soap_putht

; 13830:       s = soap->http_content;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _s$89498[ebp], ecx
	jmp	SHORT $LN19@soap_putht
$LN20@soap_putht:

; 13831:     else if (status == SOAP_HTML)

	cmp	DWORD PTR _status$[ebp], 1002		; 000003eaH
	jne	SHORT $LN18@soap_putht

; 13832:       s = "text/html; charset=utf-8";

	mov	DWORD PTR _s$89498[ebp], OFFSET ??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@
	jmp	SHORT $LN19@soap_putht
$LN18@soap_putht:

; 13833:     else if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN15@soap_putht
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN19@soap_putht
$LN15@soap_putht:

; 13834:     { if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN19@soap_putht

; 13835:         s = "application/soap+xml; charset=utf-8";

	mov	DWORD PTR _s$89498[ebp], OFFSET ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@
$LN19@soap_putht:

; 13836:     }
; 13837: #ifndef WITH_LEANER
; 13838:     if (soap->mode & (SOAP_ENC_DIME | SOAP_ENC_MTOM))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 640				; 00000280H
	je	SHORT $LN13@soap_putht

; 13839:     { if (soap->mode & SOAP_ENC_MTOM)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 512				; 00000200H
	je	SHORT $LN12@soap_putht

; 13840:       { r = s;

	mov	eax, DWORD PTR _s$89498[ebp]
	mov	DWORD PTR _r$89500[ebp], eax

; 13841:         s = "application/xop+xml; charset=utf-8";

	mov	DWORD PTR _s$89498[ebp], OFFSET ??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@

; 13842:       }
; 13843:       else

	jmp	SHORT $LN13@soap_putht
$LN12@soap_putht:

; 13844:         s = "application/dime";

	mov	DWORD PTR _s$89498[ebp], OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
$LN13@soap_putht:

; 13845:     }
; 13846:     if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && strlen(soap->mime.boundary) + strlen(soap->mime.start ? soap->mime.start : SOAP_STR_EOS) < sizeof(soap->tmpbuf) - 80)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	$LN10@soap_putht
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90524], 0
	je	$LN10@soap_putht
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90528], 0
	je	SHORT $LN24@soap_putht
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90528]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN25@soap_putht
$LN24@soap_putht:
	mov	DWORD PTR tv132[ebp], OFFSET _soap_padding
$LN25@soap_putht:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR tv132[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, 944				; 000003b0H
	jae	$LN10@soap_putht

; 13847:     { register const char *t = strchr(s, ';');

	mov	esi, esp
	push	59					; 0000003bH
	mov	eax, DWORD PTR _s$89498[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$89514[ebp], eax

; 13848:       sprintf(soap->tmpbuf, "multipart/related; boundary=\"%s\"; type=\"", soap->mime.boundary);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90524]
	push	ecx
	push	OFFSET ??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13849:       if (t)

	cmp	DWORD PTR _t$89514[ebp], 0
	je	SHORT $LN9@soap_putht

; 13850:         strncat(soap->tmpbuf, s, t - s);

	mov	eax, DWORD PTR _t$89514[ebp]
	sub	eax, DWORD PTR _s$89498[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _s$89498[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13851:       else

	jmp	SHORT $LN8@soap_putht
$LN9@soap_putht:

; 13852:         strcat(soap->tmpbuf, s);

	mov	eax, DWORD PTR _s$89498[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_strcat
	add	esp, 8
$LN8@soap_putht:

; 13853:       if (soap->mime.start)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90528], 0
	je	SHORT $LN7@soap_putht

; 13854:       { strcat(soap->tmpbuf, "\"; start=\"");

	push	OFFSET ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcat
	add	esp, 8

; 13855:         strcat(soap->tmpbuf, soap->mime.start);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90528]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	_strcat
	add	esp, 8
$LN7@soap_putht:

; 13856:       }
; 13857:       strcat(soap->tmpbuf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcat
	add	esp, 8

; 13858:       if (r)

	cmp	DWORD PTR _r$89500[ebp], 0
	je	SHORT $LN6@soap_putht

; 13859:       { strcat(soap->tmpbuf, "; start-info=\"");

	push	OFFSET ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcat
	add	esp, 8

; 13860:         strcat(soap->tmpbuf, r);

	mov	eax, DWORD PTR _r$89500[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_strcat
	add	esp, 8

; 13861:         strcat(soap->tmpbuf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcat
	add	esp, 8
$LN6@soap_putht:

; 13862:       }
; 13863:       s = soap->tmpbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	DWORD PTR _s$89498[ebp], eax
$LN10@soap_putht:

; 13864:     }
; 13865: #endif
; 13866:     if (s && (err = soap->fposthdr(soap, "Content-Type", s)))

	cmp	DWORD PTR _s$89498[ebp], 0
	je	SHORT $LN5@soap_putht
	mov	esi, esp
	mov	eax, DWORD PTR _s$89498[ebp]
	push	eax
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$89499[ebp], eax
	cmp	DWORD PTR _err$89499[ebp], 0
	je	SHORT $LN5@soap_putht

; 13867:       return err;

	mov	eax, DWORD PTR _err$89499[ebp]
	jmp	$LN22@soap_putht
$LN5@soap_putht:

; 13868: #ifdef WITH_ZLIB
; 13869:     if (soap->omode & SOAP_ENC_ZLIB)
; 13870:     {
; 13871: #ifdef WITH_GZIP
; 13872:       err = soap->fposthdr(soap, "Content-Encoding", soap->zlib_out == SOAP_ZLIB_DEFLATE ? "deflate" : "gzip");
; 13873: #else
; 13874:       err = soap->fposthdr(soap, "Content-Encoding", "deflate");
; 13875: #endif
; 13876:       if (err)
; 13877:         return err;
; 13878:     }
; 13879: #endif
; 13880: #ifndef WITH_LEANER
; 13881:     if ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN4@soap_putht

; 13882:       err = soap->fposthdr(soap, "Transfer-Encoding", "chunked");

	mov	esi, esp
	push	OFFSET ??_C@_07KCKHAHHI@chunked?$AA@
	push	OFFSET ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$89499[ebp], eax

; 13883:     else

	jmp	SHORT $LN3@soap_putht
$LN4@soap_putht:

; 13884: #endif
; 13885:     if (s)

	cmp	DWORD PTR _s$89498[ebp], 0
	je	SHORT $LN3@soap_putht

; 13886:     { sprintf(soap->tmpbuf, "%lu", (unsigned long)count);

	mov	esi, esp
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13887:       err = soap->fposthdr(soap, "Content-Length", soap->tmpbuf);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$89499[ebp], eax
$LN3@soap_putht:

; 13888:     }
; 13889:     if (err)

	cmp	DWORD PTR _err$89499[ebp], 0
	je	SHORT $LN21@soap_putht

; 13890:       return err;

	mov	eax, DWORD PTR _err$89499[ebp]
	jmp	SHORT $LN22@soap_putht
$LN21@soap_putht:

; 13891:   }
; 13892:   return soap->fposthdr(soap, "Connection", soap->keep_alive ? "keep-alive" : "close");

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+90412]
	test	ecx, ecx
	je	SHORT $LN26@soap_putht
	mov	DWORD PTR tv211[ebp], OFFSET ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
	jmp	SHORT $LN27@soap_putht
$LN26@soap_putht:
	mov	DWORD PTR tv211[ebp], OFFSET ??_C@_05LBOHBHFK@close?$AA@
$LN27@soap_putht:
	mov	esi, esp
	mov	edx, DWORD PTR tv211[ebp]
	push	edx
	push	OFFSET ??_C@_0L@PJJKMLL@Connection?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@soap_putht:

; 13893: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_puthttphdr ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_get
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_http_get PROC						; COMDAT

; 13902: { return SOAP_GET_METHOD;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 15					; 0000000fH

; 13903: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_http_get ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_put
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_http_put PROC						; COMDAT

; 13912: { return SOAP_PUT_METHOD;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 16					; 00000010H

; 13913: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_http_put ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_del
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_http_del PROC						; COMDAT

; 13922: { return SOAP_DEL_METHOD;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 17					; 00000011H

; 13923: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_http_del ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_head
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_http_head PROC						; COMDAT

; 13932: { return SOAP_HEAD_METHOD;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, 18					; 00000012H

; 13933: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_http_head ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@		; `string'
PUBLIC	??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@	; `string'
PUBLIC	??_C@_06FFOGOLGD@Basic?5?$AA@			; `string'
PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_0L@DMPACEMJ@User?9Agent?$AA@		; `string'
PUBLIC	??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@		; `string'
PUBLIC	??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@		; `string'
PUBLIC	??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@ ; `string'
PUBLIC	??_C@_06EFCFIIJL@httpg?3?$AA@			; `string'
PUBLIC	??_C@_06GLIDCHCJ@http?3?$CK?$AA@		; `string'
PUBLIC	??_C@_04HCJEIHPL@POST?$AA@			; `string'
PUBLIC	??_C@_03HAPOJHBM@GET?$AA@			; `string'
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@ DB '"%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@
CONST	SEGMENT
??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@ DB 'Proxy-Authorization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFOGOLGD@Basic?5?$AA@
CONST	SEGMENT
??_C@_06FFOGOLGD@Basic?5?$AA@ DB 'Basic ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ DB '%s:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMPACEMJ@User?9Agent?$AA@
CONST	SEGMENT
??_C@_0L@DMPACEMJ@User?9Agent?$AA@ DB 'User-Agent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
CONST	SEGMENT
??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@ DB 'gSOAP/2.7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@
CONST	SEGMENT
??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@ DB '%s:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@ DB '%s /%s HTTP/%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@ DB '%s %s HTTP/%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFCFIIJL@httpg?3?$AA@
CONST	SEGMENT
??_C@_06EFCFIIJL@httpg?3?$AA@ DB 'httpg:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLIDCHCJ@http?3?$CK?$AA@
CONST	SEGMENT
??_C@_06GLIDCHCJ@http?3?$CK?$AA@ DB 'http:*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCJEIHPL@POST?$AA@
CONST	SEGMENT
??_C@_04HCJEIHPL@POST?$AA@ DB 'POST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAPOJHBM@GET?$AA@
CONST	SEGMENT
??_C@_03HAPOJHBM@GET?$AA@ DB 'GET', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _http_post
_TEXT	SEGMENT
tv275 = -220						; size = 4
tv139 = -220						; size = 4
_err$ = -20						; size = 4
_s$ = -8						; size = 4
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_host$ = 16						; size = 4
_port$ = 20						; size = 4
_path$ = 24						; size = 4
_action$ = 28						; size = 4
_count$ = 32						; size = 4
_http_post PROC						; COMDAT

; 13942: { register const char *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13943:   register int err;
; 13944:   if (soap->status == SOAP_GET)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 2001		; 000007d1H
	jne	SHORT $LN19@http_post

; 13945:     s = "GET";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_03HAPOJHBM@GET?$AA@

; 13946:   else

	jmp	SHORT $LN18@http_post
$LN19@http_post:

; 13947:     s = "POST";

	mov	DWORD PTR _s$[ebp], OFFSET ??_C@_04HCJEIHPL@POST?$AA@
$LN18@http_post:

; 13948: #ifdef PALM
; 13949:   if (!endpoint || (soap_tag_cmp(endpoint, "http:*") && soap_tag_cmp(endpoint, "https:*") && strncmp(endpoint, "httpg:", 6)) && strncmp(endpoint, "_beam:", 6) && strncmp(endpoint, "_local:", 7) && strncmp(endpoint, "_btobex:", 8))
; 13950: #else
; 13951:   if (!endpoint || (soap_tag_cmp(endpoint, "http:*") && soap_tag_cmp(endpoint, "https:*") && strncmp(endpoint, "httpg:", 6)))

	cmp	DWORD PTR _endpoint$[ebp], 0
	je	SHORT $LN16@http_post
	push	OFFSET ??_C@_06GLIDCHCJ@http?3?$CK?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@http_post
	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@http_post
	mov	esi, esp
	push	6
	push	OFFSET ??_C@_06EFCFIIJL@httpg?3?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN17@http_post
$LN16@http_post:

; 13952: #endif
; 13953:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN20@http_post
$LN17@http_post:

; 13954:   if (strlen(endpoint) + strlen(soap->http_version) > sizeof(soap->tmpbuf) - 80)

	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, 944				; 000003b0H
	jbe	SHORT $LN15@http_post

; 13955:     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN20@http_post
$LN15@http_post:

; 13956:   if (soap->proxy_host && soap_tag_cmp(endpoint, "https:*"))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90436], 0
	je	SHORT $LN14@http_post
	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	mov	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@http_post

; 13957:     sprintf(soap->tmpbuf, "%s %s HTTP/%s", s, endpoint, soap->http_version);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _endpoint$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13958:   else

	jmp	SHORT $LN13@http_post
$LN14@http_post:

; 13959:     sprintf(soap->tmpbuf, "%s /%s HTTP/%s", s, (*path == '/' ? path + 1 : path), soap->http_version);

	mov	eax, DWORD PTR _path$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN22@http_post
	mov	edx, DWORD PTR _path$[ebp]
	add	edx, 1
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN23@http_post
$LN22@http_post:
	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR tv139[ebp], eax
$LN23@http_post:
	mov	esi, esp
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR tv139[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@http_post:

; 13960:   if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN12@http_post

; 13961:     return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN20@http_post
$LN12@http_post:

; 13962: #ifdef WITH_OPENSSL
; 13963:   if ((soap->ssl && soap->port != 443) || (!soap->ssl && soap->port != 80))
; 13964:     sprintf(soap->tmpbuf, "%s:%d", host, port);
; 13965:   else
; 13966:     strcpy(soap->tmpbuf, host);
; 13967: #else
; 13968:   if (port != 80)

	cmp	DWORD PTR _port$[ebp], 80		; 00000050H
	je	SHORT $LN11@http_post

; 13969:     sprintf(soap->tmpbuf, "%s:%d", host, port);

	mov	esi, esp
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13970:   else

	jmp	SHORT $LN10@http_post
$LN11@http_post:

; 13971:     strcpy(soap->tmpbuf, host);

	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79028				; 000134b4H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN10@http_post:

; 13972: #endif
; 13973:   if ((err = soap->fposthdr(soap, "Host", soap->tmpbuf))
; 13974:    || (err = soap->fposthdr(soap, "User-Agent", "gSOAP/2.7"))
; 13975:    || (err = soap_puthttphdr(soap, SOAP_OK, count)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_04CPPPJGME@Host?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN8@http_post
	mov	esi, esp
	push	OFFSET ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
	push	OFFSET ??_C@_0L@DMPACEMJ@User?9Agent?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN8@http_post
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_puthttphdr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN9@http_post
$LN8@http_post:

; 13976:     return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN20@http_post
$LN9@http_post:

; 13977: #ifdef WITH_ZLIB
; 13978: #ifdef WITH_GZIP
; 13979:   if ((err = soap->fposthdr(soap, "Accept-Encoding", "gzip, deflate")))
; 13980: #else
; 13981:   if ((err = soap->fposthdr(soap, "Accept-Encoding", "deflate")))
; 13982: #endif
; 13983:     return err;
; 13984: #endif
; 13985: #ifndef WITH_LEAN
; 13986:   if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12224], 0
	je	$LN7@http_post
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12228], 0
	je	$LN7@http_post
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12224]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12228]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, 761				; 000002f9H
	jae	$LN7@http_post

; 13987:   { sprintf(soap->tmpbuf + 262, "%s:%s", soap->userid, soap->passwd);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12228]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12224]
	push	eax
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79290				; 000135baH
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13988:     strcpy(soap->tmpbuf, "Basic ");

	push	OFFSET ??_C@_06FFOGOLGD@Basic?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcpy
	add	esp, 8

; 13989:     soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79290				; 000135baH
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79034				; 000134baH
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79290				; 000135baH
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_s2base64
	add	esp, 16					; 00000010H

; 13990:     if ((err = soap->fposthdr(soap, "Authorization", soap->tmpbuf)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0O@NAFGPKMI@Authorization?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN7@http_post

; 13991:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN20@http_post
$LN7@http_post:

; 13992:   }
; 13993:   if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90444], 0
	je	$LN5@http_post
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90448], 0
	je	$LN5@http_post
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90444]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90448]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, 761				; 000002f9H
	jae	$LN5@http_post

; 13994:   { sprintf(soap->tmpbuf + 262, "%s:%s", soap->proxy_userid, soap->proxy_passwd);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90448]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+90444]
	push	eax
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79290				; 000135baH
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13995:     strcpy(soap->tmpbuf, "Basic ");

	push	OFFSET ??_C@_06FFOGOLGD@Basic?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	_strcpy
	add	esp, 8

; 13996:     soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79290				; 000135baH
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 79034				; 000134baH
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79290				; 000135baH
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_s2base64
	add	esp, 16					; 00000010H

; 13997:     if ((err = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN5@http_post

; 13998:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN20@http_post
$LN5@http_post:

; 13999:   }
; 14000: #endif
; 14001: #ifdef WITH_COOKIES
; 14002: #ifdef WITH_OPENSSL
; 14003:   if (soap_putcookies(soap, host, path, soap->ssl != NULL))
; 14004:     return soap->error;
; 14005: #else
; 14006:   if (soap_putcookies(soap, host, path, 0))
; 14007:     return soap->error;
; 14008: #endif
; 14009: #endif
; 14010:   if (soap->status != SOAP_GET && (soap->version == 1 || (action && *action && strlen(action) < sizeof(soap->tmpbuf) - 2)))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90456], 2001		; 000007d1H
	je	$LN3@http_post
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 1
	je	SHORT $LN2@http_post
	cmp	DWORD PTR _action$[ebp], 0
	je	$LN3@http_post
	mov	eax, DWORD PTR _action$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@http_post
	mov	eax, DWORD PTR _action$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 1022				; 000003feH
	jae	SHORT $LN3@http_post
$LN2@http_post:

; 14011:   { sprintf(soap->tmpbuf, "\"%s\"", action?action:"");

	cmp	DWORD PTR _action$[ebp], 0
	je	SHORT $LN24@http_post
	mov	eax, DWORD PTR _action$[ebp]
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN25@http_post
$LN24@http_post:
	mov	DWORD PTR tv275[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@http_post:
	mov	esi, esp
	mov	ecx, DWORD PTR tv275[ebp]
	push	ecx
	push	OFFSET ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14012:     if ((err = soap->fposthdr(soap, "SOAPAction", soap->tmpbuf)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN3@http_post

; 14013:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	SHORT $LN20@http_post
$LN3@http_post:

; 14014:   }
; 14015:   return soap->fposthdr(soap, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@http_post:

; 14016: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_http_post ENDP
_TEXT	ENDS
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _http_post_header
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
_http_post_header PROC					; COMDAT

; 14044: { if (key)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN4@http_post_

; 14045:   { if (http_send_header(soap, key))

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_http_send_header
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@http_post_

; 14046:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@http_post_
$LN3@http_post_:

; 14047:     if (val && (soap_send_raw(soap, ": ", 2) || http_send_header(soap, val)))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN4@http_post_
	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@http_post_
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_http_send_header
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@http_post_
$LN1@http_post_:

; 14048:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN5@http_post_
$LN4@http_post_:

; 14049:   }
; 14050:   return soap_send_raw(soap, "\r\n", 2);

	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
$LN5@http_post_:

; 14051: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_http_post_header ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_send_header
_TEXT	SEGMENT
_t$ = -8						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_http_send_header PROC					; COMDAT

; 14025: { register const char *t;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN5@http_send_:

; 14026:   do
; 14027:   { t = strchr(s, '\n'); /* disallow \n in HTTP headers */

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _t$[ebp], eax

; 14028:     if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@http_send_

; 14029:       t = s + strlen(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _t$[ebp], eax
$LN2@http_send_:

; 14030:     if (soap_send_raw(soap, s, t - s))

	mov	eax, DWORD PTR _t$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_send_raw
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@http_send_

; 14031:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN6@http_send_
$LN1@http_send_:

; 14032:     s = t + 1;

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 14033:   } while (*t);

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@http_send_

; 14034:   return SOAP_OK;

	xor	eax, eax
$LN6@http_send_:

; 14035: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_http_send_header ENDP
_TEXT	ENDS
PUBLIC	??_C@_06LGMEBDBC@Server?$AA@			; `string'
PUBLIC	??_C@_0BG@PEMBGADP@Error?5?$CFs?5?$CIstatus?$DN?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@	; `string'
PUBLIC	??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@	; `string'
PUBLIC	??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@	; `string'
PUBLIC	??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_06PGDKHFME@Status?$AA@			; `string'
PUBLIC	??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0N@BILIEHNO@Status?5?$DN?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@		; `string'
PUBLIC	??_C@_06DAENNINM@200?5OK?$AA@			; `string'
EXTRN	_soap_faultcode:PROC
;	COMDAT ??_C@_06LGMEBDBC@Server?$AA@
CONST	SEGMENT
??_C@_06LGMEBDBC@Server?$AA@ DB 'Server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEMBGADP@Error?5?$CFs?5?$CIstatus?$DN?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BG@PEMBGADP@Error?5?$CFs?5?$CIstatus?$DN?$CFd?$CJ?6?$AA@ DB 'Error'
	DB	' %s (status=%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@
CONST	SEGMENT
??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@ DB '500 Internal Ser'
	DB	'ver Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@
CONST	SEGMENT
??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@ DB '400 Bad Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
CONST	SEGMENT
??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@ DB 'SOAP-ENV:Sender', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@ DB 'Basic realm="%s'
	DB	'"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@
CONST	SEGMENT
??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@ DB 'gSOAP Web Service', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@ DB 'HTTP/%s %d %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGDKHFME@Status?$AA@
CONST	SEGMENT
??_C@_06PGDKHFME@Status?$AA@ DB 'Status', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@ DB 'HTTP/%s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BILIEHNO@Status?5?$DN?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@BILIEHNO@Status?5?$DN?5?$CFs?6?$AA@ DB 'Status = %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@
CONST	SEGMENT
??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@ DB '202 ACCEPTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAENNINM@200?5OK?$AA@
CONST	SEGMENT
??_C@_06DAENNINM@200?5OK?$AA@ DB '200 OK', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _http_response
_TEXT	SEGMENT
tv175 = -260						; size = 4
tv172 = -256						; size = 4
_fdebug$89662 = -56					; size = 4
_s$89651 = -44						; size = 4
_fdebug$89626 = -32					; size = 4
_s$89616 = -20						; size = 4
_err$ = -8						; size = 4
_soap$ = 8						; size = 4
_status$ = 12						; size = 4
_count$ = 16						; size = 4
_http_response PROC					; COMDAT

; 14060: { register int err;

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14061: #ifdef WMW_RPM_IO
; 14062:   if (soap->rpmreqid)
; 14063:     httpOutputEnable(soap->rpmreqid);
; 14064: #endif
; 14065:   if (strlen(soap->http_version) > 4)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 4
	jbe	SHORT $LN38@http_respo

; 14066:     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN39@http_respo
$LN38@http_respo:

; 14067:   if (!status || status == SOAP_HTML || status == SOAP_FILE)

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN36@http_respo
	cmp	DWORD PTR _status$[ebp], 1002		; 000003eaH
	je	SHORT $LN36@http_respo
	cmp	DWORD PTR _status$[ebp], 1003		; 000003ebH
	jne	$LN37@http_respo
$LN36@http_respo:

; 14068:   { const char *s;
; 14069:     if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN34@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN35@http_respo
$LN34@http_respo:

; 14070:       s = "200 OK";

	mov	DWORD PTR _s$89616[ebp], OFFSET ??_C@_06DAENNINM@200?5OK?$AA@

; 14071:     else

	jmp	SHORT $LN33@http_respo
$LN35@http_respo:

; 14072:       s = "202 ACCEPTED";

	mov	DWORD PTR _s$89616[ebp], OFFSET ??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@
$LN33@http_respo:

; 14073:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Status = %s\n", s));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN32@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN31@http_respo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN31@http_respo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN32@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89626[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _s$89616[ebp]
	push	eax
	push	OFFSET ??_C@_0N@BILIEHNO@Status?5?$DN?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$89626[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89626[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@http_respo:

; 14074: #ifdef WMW_RPM_IO
; 14075:     if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
; 14076: #else
; 14077:     if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	jne	SHORT $LN28@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN29@http_respo
$LN28@http_respo:

; 14078: #endif
; 14079:     { sprintf(soap->tmpbuf, "HTTP/%s %s", soap->http_version, s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$89616[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	push	OFFSET ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14080:       if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN27@http_respo

; 14081:         return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN27@http_respo:

; 14082:     }

	jmp	SHORT $LN26@http_respo
$LN29@http_respo:

; 14083:     else if ((err = soap->fposthdr(soap, "Status", s)))

	mov	esi, esp
	mov	eax, DWORD PTR _s$89616[ebp]
	push	eax
	push	OFFSET ??_C@_06PGDKHFME@Status?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN26@http_respo

; 14084:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN26@http_respo:

; 14085:   }

	jmp	$LN24@http_respo
$LN37@http_respo:

; 14086:   else if (status >= 200 && status < 600)

	cmp	DWORD PTR _status$[ebp], 200		; 000000c8H
	jl	$LN23@http_respo
	cmp	DWORD PTR _status$[ebp], 600		; 00000258H
	jge	$LN23@http_respo

; 14087:   { sprintf(soap->tmpbuf, "HTTP/%s %d %s", soap->http_version, status, http_error(soap, status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_http_error
	add	esp, 8
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	OFFSET ??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 79028				; 000134b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14088:     if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN22@http_respo

; 14089:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN22@http_respo:

; 14090: #ifndef WITH_LEAN
; 14091:     if (status == 401)

	cmp	DWORD PTR _status$[ebp], 401		; 00000191H
	jne	$LN21@http_respo

; 14092:     { sprintf(soap->tmpbuf, "Basic realm=\"%s\"", (soap->authrealm ? strlen(soap->authrealm) : 18) < sizeof(soap->tmpbuf) - 14 ? soap->authrealm : "gSOAP Web Service");

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90396], 0
	je	SHORT $LN41@http_respo
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+90396]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN42@http_respo
$LN41@http_respo:
	mov	DWORD PTR tv172[ebp], 18		; 00000012H
$LN42@http_respo:
	cmp	DWORD PTR tv172[ebp], 1010		; 000003f2H
	jae	SHORT $LN43@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90396]
	mov	DWORD PTR tv175[ebp], ecx
	jmp	SHORT $LN44@http_respo
$LN43@http_respo:
	mov	DWORD PTR tv175[ebp], OFFSET ??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@
$LN44@http_respo:
	mov	esi, esp
	mov	edx, DWORD PTR tv175[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14093:       if ((err = soap->fposthdr(soap, "WWW-Authenticate", soap->tmpbuf)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN20@http_respo

; 14094:         return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN20@http_respo:

; 14095:     }

	jmp	SHORT $LN19@http_respo
$LN21@http_respo:

; 14096:     else if ((status >= 301 && status <= 303) || status == 307)

	cmp	DWORD PTR _status$[ebp], 301		; 0000012dH
	jl	SHORT $LN16@http_respo
	cmp	DWORD PTR _status$[ebp], 303		; 0000012fH
	jle	SHORT $LN17@http_respo
$LN16@http_respo:
	cmp	DWORD PTR _status$[ebp], 307		; 00000133H
	jne	SHORT $LN19@http_respo
$LN17@http_respo:

; 14097:     { if ((err = soap->fposthdr(soap, "Location", soap->endpoint)))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 87320				; 00015518H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_08KDOEBHGA@Location?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN19@http_respo

; 14098:         return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN19@http_respo:

; 14099:     }
; 14100: #endif
; 14101:   }
; 14102:   else

	jmp	$LN24@http_respo
$LN23@http_respo:

; 14103:   { const char *s = *soap_faultcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$89651[ebp], ecx

; 14104:     if (soap->version == 2 && (!s || !strcmp(s, "SOAP-ENV:Sender")))

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN13@http_respo
	cmp	DWORD PTR _s$89651[ebp], 0
	je	SHORT $LN12@http_respo
	push	OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	mov	eax, DWORD PTR _s$89651[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@http_respo
$LN12@http_respo:

; 14105:       s = "400 Bad Request";

	mov	DWORD PTR _s$89651[ebp], OFFSET ??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@

; 14106:     else

	jmp	SHORT $LN11@http_respo
$LN13@http_respo:

; 14107:       s = "500 Internal Server Error";

	mov	DWORD PTR _s$89651[ebp], OFFSET ??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@
$LN11@http_respo:

; 14108:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error %s (status=%d)\n", s, status));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN10@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN9@http_respo
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN9@http_respo:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN10@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89662[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$89651[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@PEMBGADP@Error?5?$CFs?5?$CIstatus?$DN?$CFd?$CJ?6?$AA@
	mov	edx, DWORD PTR _fdebug$89662[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89662[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@http_respo:

; 14109: #ifdef WMW_RPM_IO
; 14110:     if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
; 14111: #else
; 14112:     if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12404], -1
	jne	SHORT $LN6@http_respo
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	SHORT $LN7@http_respo
$LN6@http_respo:

; 14113: #endif
; 14114:     { sprintf(soap->tmpbuf, "HTTP/%s %s", soap->http_version, s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$89651[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	push	OFFSET ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14115:       if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN5@http_respo

; 14116:         return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	$LN39@http_respo
$LN5@http_respo:

; 14117:     }

	jmp	SHORT $LN24@http_respo
$LN7@http_respo:

; 14118:     else if ((err = soap->fposthdr(soap, "Status", s)))	/* CGI */

	mov	esi, esp
	mov	eax, DWORD PTR _s$89651[ebp]
	push	eax
	push	OFFSET ??_C@_06PGDKHFME@Status?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12256]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN24@http_respo

; 14119:       return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	SHORT $LN39@http_respo
$LN24@http_respo:

; 14120:   }
; 14121:   if ((err = soap->fposthdr(soap, "Server", "gSOAP/2.7"))
; 14122:    || (err = soap_puthttphdr(soap, status, count)))

	mov	esi, esp
	push	OFFSET ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
	push	OFFSET ??_C@_06LGMEBDBC@Server?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN1@http_respo
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_puthttphdr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN2@http_respo
$LN1@http_respo:

; 14123:     return err;

	mov	eax, DWORD PTR _err$[ebp]
	jmp	SHORT $LN39@http_respo
$LN2@http_respo:

; 14124: #ifdef WITH_COOKIES
; 14125:   if (soap_putsetcookies(soap))
; 14126:     return soap->error;
; 14127: #endif
; 14128:   return soap->fposthdr(soap, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12256]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN39@http_respo:

; 14129: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_http_response ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _http_error
_TEXT	SEGMENT
_msg$ = -8						; size = 4
_soap$ = 8						; size = 4
_status$ = 12						; size = 4
_http_error PROC					; COMDAT

; 3470 : { register const char *msg = SOAP_STR_EOS;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _msg$[ebp], OFFSET _soap_padding

; 3471 : #ifndef WITH_LEAN
; 3472 :   msg = soap_code_str(h_http_error_codes, status);

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET _h_http_error_codes
	call	_soap_code_str
	add	esp, 8
	mov	DWORD PTR _msg$[ebp], eax

; 3473 :   if (!msg)

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN1@http_error

; 3474 :     msg = SOAP_STR_EOS;

	mov	DWORD PTR _msg$[ebp], OFFSET _soap_padding
$LN1@http_error:

; 3475 : #endif
; 3476 :   return msg;

	mov	eax, DWORD PTR _msg$[ebp]

; 3477 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_http_error ENDP
_TEXT	ENDS
PUBLIC	_soap_response
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_response
_TEXT	SEGMENT
_n$89683 = -20						; size = 4
_count$ = -8						; size = 4
_soap$ = 8						; size = 4
_status$ = 12						; size = 4
_soap_response PROC					; COMDAT

; 14139: { register size_t count;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14140:   if (!(soap->omode & (SOAP_ENC_XML | SOAP_IO_STORE /* this tests for chunking too */))
; 14141:    && (status == SOAP_HTML || status == SOAP_FILE))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 66					; 00000042H
	jne	SHORT $LN8@soap_respo
	cmp	DWORD PTR _status$[ebp], 1002		; 000003eaH
	je	SHORT $LN7@soap_respo
	cmp	DWORD PTR _status$[ebp], 1003		; 000003ebH
	jne	SHORT $LN8@soap_respo
$LN7@soap_respo:

; 14142:   { soap->omode &= ~SOAP_IO;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 14143:     soap->omode |= SOAP_IO_STORE;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 2
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN8@soap_respo:

; 14144:   }
; 14145:   soap->status = status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+90456], ecx

; 14146:   count = soap_count_attachments(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_count_attachments
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 14147:   if (soap_begin_send(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_begin_send
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_respo

; 14148:     return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	$LN9@soap_respo
$LN6@soap_respo:

; 14149: #ifndef WITH_NOHTTP
; 14150:   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML))

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 3
	cmp	ecx, 2
	je	$LN5@soap_respo
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	jne	$LN5@soap_respo

; 14151:   { register int n = soap->mode;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _n$89683[ebp], ecx

; 14152:     soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -1028				; fffffbfcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 14153:     if ((n & SOAP_IO) != SOAP_IO_FLUSH)

	mov	eax, DWORD PTR _n$89683[ebp]
	and	eax, 3
	je	SHORT $LN4@soap_respo

; 14154:       soap->mode |= SOAP_IO_BUFFER;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN4@soap_respo:

; 14155:     if ((soap->error = soap->fresponse(soap, status, count)))

	mov	esi, esp
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12260]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+90460], eax
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	SHORT $LN3@soap_respo

; 14156:       return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN9@soap_respo
$LN3@soap_respo:

; 14157: #ifndef WITH_LEANER
; 14158:     if ((n & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _n$89683[ebp]
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN2@soap_respo

; 14159:     { if (soap_flush(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_flush
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_respo

; 14160:         return soap->error;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [eax+90460]
	jmp	SHORT $LN9@soap_respo
$LN2@soap_respo:

; 14161:     }
; 14162: #endif
; 14163:     soap->mode = n;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _n$89683[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN5@soap_respo:

; 14164:   }
; 14165: #endif
; 14166:   return SOAP_OK;

	xor	eax, eax
$LN9@soap_respo:

; 14167: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_response ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PNOEHBEA@Error?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@ ; `string'
PUBLIC	??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@ ; `string'
PUBLIC	??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@ ; `string'
PUBLIC	??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@	; `string'
PUBLIC	??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@ ; `string'
PUBLIC	??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@ ; `string'
PUBLIC	??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@ ; `string'
PUBLIC	??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@	; `string'
PUBLIC	??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@ ; `string'
PUBLIC	??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@	; `string'
PUBLIC	??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@	; `string'
PUBLIC	??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@ ; `string'
PUBLIC	??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@ ; `string'
PUBLIC	??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@	; `string'
PUBLIC	??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@	; `string'
PUBLIC	??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@ ; `string'
PUBLIC	??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@ ; `string'
PUBLIC	??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@ ; `string'
PUBLIC	??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@ ; `string'
PUBLIC	??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@	; `string'
PUBLIC	??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@	; `string'
PUBLIC	??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@	; `string'
PUBLIC	??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@ ; `string'
PUBLIC	??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@	; `string'
PUBLIC	??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@ ; `string'
PUBLIC	??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@ ; `string'
PUBLIC	??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@ ; `string'
PUBLIC	??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@ ; `string'
PUBLIC	??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@ ; `string'
PUBLIC	??_C@_0M@HCPCIMCN@Fatal?5error?$AA@		; `string'
PUBLIC	??_C@_0L@PDEMLIEM@User?5error?$AA@		; `string'
PUBLIC	??_C@_0BA@DMKNFBBB@namespace?5error?$AA@	; `string'
PUBLIC	??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@ ; `string'
PUBLIC	??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@ ; `string'
PUBLIC	??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@ ; `string'
PUBLIC	??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@ ; `string'
PUBLIC	??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@ ; `string'
PUBLIC	??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@ ; `string'
PUBLIC	??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@	; `string'
PUBLIC	??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@ ; `string'
PUBLIC	??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@	; `string'
PUBLIC	??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@ ; `string'
PUBLIC	??_C@_0N@LCJPOAAP@Server?5fault?$AA@		; `string'
PUBLIC	??_C@_0N@JOEFJCHK@Client?5fault?$AA@		; `string'
PUBLIC	??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@	; `string'
PUBLIC	_soap_set_fault
EXTRN	__imp__memmove:PROC
EXTRN	_soap_faultsubcode:PROC
EXTRN	_soap_faultstring:PROC
;	COMDAT ??_C@_08PNOEHBEA@Error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08PNOEHBEA@Error?5?$CFd?$AA@ DB 'Error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@ DB 'HTTP Error: %d %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@
CONST	SEGMENT
??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@ DB 'End of file '
	DB	'or no input: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@
CONST	SEGMENT
??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@ DB 'Stopped: no res'
	DB	'ponse sent', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@
CONST	SEGMENT
??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@ DB 'Maximum numb'
	DB	'er of open connections was reached', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@
CONST	SEGMENT
??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@ DB 'content length vio'
	DB	'lation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@
CONST	SEGMENT
??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@ DB 'occurrence violation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@
CONST	SEGMENT
??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@ DB 'prohibited attr'
	DB	'ibute present', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@
CONST	SEGMENT
??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@ DB 'missing required'
	DB	' attribute', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@
CONST	SEGMENT
??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@ DB 'Zlib/'
	DB	'gzip not installed for (de)compression: recompile with -DWITH'
	DB	'_GZIP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@
CONST	SEGMENT
??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@ DB 'End of MIME error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@
CONST	SEGMENT
??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@ DB 'MIME href'
	DB	' to missing attachment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@
CONST	SEGMENT
??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@ DB 'MIME format error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@
CONST	SEGMENT
??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@ DB 'End of DIME error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@
CONST	SEGMENT
??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@ DB 'DIME versi'
	DB	'on/transmission error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@
CONST	SEGMENT
??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@ DB 'DIME href'
	DB	' to missing attachment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@
CONST	SEGMENT
??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@ DB 'DIME format error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@
CONST	SEGMENT
??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@ DB 'Plugin registry error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@
CONST	SEGMENT
??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@ DB 'OpenSSL not '
	DB	'installed: recompile with -DWITH_OPENSSL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@
CONST	SEGMENT
??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@ DB 'An HTTP proc'
	DB	'essing error occurred', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@
CONST	SEGMENT
??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@ DB 'Message too'
	DB	' large for UDP packet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@
CONST	SEGMENT
??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@ DB 'incompatibl'
	DB	'e object type ref/id pair ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@
CONST	SEGMENT
??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@ DB 'SOAP-ENC:MissingID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@
CONST	SEGMENT
??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@ DB 'missing id for ref ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@
CONST	SEGMENT
??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@ DB 'SOAP-ENC:DuplicateID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@
CONST	SEGMENT
??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@ DB 'multiple defi'
	DB	'nitions of id ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@ DB 'nil not allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@
CONST	SEGMENT
??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@ DB 'Array index out'
	DB	' of bounds', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@ DB 'Header line too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@
CONST	SEGMENT
??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@ DB 'Memory overf'
	DB	'low or memory corruption error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@ DB 'Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@ DB 'HTTP method no'
	DB	't implemented', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@
CONST	SEGMENT
??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@ DB 'HTTP HEAD me'
	DB	'thod not implemented', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@ DB 'HTTP PUT '
	DB	'method not implemented', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@ DB 'HTTP GET '
	DB	'method not implemented', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@
CONST	SEGMENT
??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@ DB 'Data required '
	DB	'for operation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@
CONST	SEGMENT
??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@ DB 'Method '
	DB	'''%s'' not implemented: method name or namespace not recogniz'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCPCIMCN@Fatal?5error?$AA@
CONST	SEGMENT
??_C@_0M@HCPCIMCN@Fatal?5error?$AA@ DB 'Fatal error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDEMLIEM@User?5error?$AA@
CONST	SEGMENT
??_C@_0L@PDEMLIEM@User?5error?$AA@ DB 'User error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMKNFBBB@namespace?5error?$AA@
CONST	SEGMENT
??_C@_0BA@DMKNFBBB@namespace?5error?$AA@ DB 'namespace error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@
CONST	SEGMENT
??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@ DB 'Unsupported'
	DB	' SOAP data encoding', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@
CONST	SEGMENT
??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@ DB 'SOAP-ENV:DataE'
	DB	'ncodingUnknown', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@
CONST	SEGMENT
??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@ DB 'Invalid SOA'
	DB	'P message or SOAP version mismatch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@
CONST	SEGMENT
??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@ DB 'SOAP-ENV:VersionMi'
	DB	'smatch', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@
CONST	SEGMENT
??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@ DB 'The d'
	DB	'ata in element ''%s'' must be understood but cannot be handle'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@
CONST	SEGMENT
??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@ DB 'SOAP-ENV:MustUnders'
	DB	'tand', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@
CONST	SEGMENT
??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@ DB 'No XML element tag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@
CONST	SEGMENT
??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@ DB 'Well-formedness v'
	DB	'iolation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@
CONST	SEGMENT
??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@ DB 'data type mismatch ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@ DB 'tag name o'
	DB	'r namespace mismatch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCJPOAAP@Server?5fault?$AA@
CONST	SEGMENT
??_C@_0N@LCJPOAAP@Server?5fault?$AA@ DB 'Server fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOEFJCHK@Client?5fault?$AA@
CONST	SEGMENT
??_C@_0N@JOEFJCHK@Client?5fault?$AA@ DB 'Client fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
CONST	SEGMENT
??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@ DB 'SOAP-ENV:Client', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_set_fault
_TEXT	SEGMENT
tv80 = -220						; size = 4
_s$ = -20						; size = 4
_c$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_set_fault PROC					; COMDAT

; 14188: { const char **c = soap_faultcode(soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 14189:   const char **s = soap_faultstring(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultstring
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 14190:   if (soap->fseterror)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12320], 0
	je	SHORT $LN60@soap_set_f@2

; 14191:     soap->fseterror(soap, c, s);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12320]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN60@soap_set_f@2:

; 14192:   if (!*c)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN59@soap_set_f@2

; 14193:   { if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN58@soap_set_f@2

; 14194:       *c = "SOAP-ENV:Sender";

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@

; 14195:     else

	jmp	SHORT $LN59@soap_set_f@2
$LN58@soap_set_f@2:

; 14196:       *c = "SOAP-ENV:Client";

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN59@soap_set_f@2:

; 14197:   }
; 14198:   if (*s)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN56@soap_set_f@2

; 14199:     return;

	jmp	$LN61@soap_set_f@2
$LN56@soap_set_f@2:

; 14200:   switch (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 1000		; 000003e8H
	jg	SHORT $LN63@soap_set_f@2
	cmp	DWORD PTR tv80[ebp], 1000		; 000003e8H
	je	$LN6@soap_set_f@2
	mov	edx, DWORD PTR tv80[ebp]
	add	edx, 1
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 47			; 0000002fH
	ja	$LN3@soap_set_f@2
	mov	eax, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN64@soap_set_f@2[eax*4]
$LN63@soap_set_f@2:
	jmp	$LN3@soap_set_f@2
$LN53@soap_set_f@2:

; 14201:   {
; 14202: #ifndef WITH_LEAN
; 14203:     case SOAP_CLI_FAULT:
; 14204:       *s = "Client fault";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0N@JOEFJCHK@Client?5fault?$AA@

; 14205:       break;

	jmp	$LN61@soap_set_f@2
$LN52@soap_set_f@2:

; 14206:     case SOAP_SVR_FAULT:
; 14207:       *s = "Server fault";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0N@LCJPOAAP@Server?5fault?$AA@

; 14208:       break;

	jmp	$LN61@soap_set_f@2
$LN51@soap_set_f@2:

; 14209:     case SOAP_TAG_MISMATCH:
; 14210:       *s = soap_set_validation_fault(soap, "tag name or namespace mismatch", NULL);

	push	0
	push	OFFSET ??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14211:       break;

	jmp	$LN61@soap_set_f@2
$LN50@soap_set_f@2:

; 14212:     case SOAP_TYPE:
; 14213:       *s = soap_set_validation_fault(soap, "data type mismatch ", soap->type);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 83124				; 000144b4H
	push	eax
	push	OFFSET ??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx], eax

; 14214:       break;

	jmp	$LN61@soap_set_f@2
$LN49@soap_set_f@2:

; 14215:     case SOAP_SYNTAX_ERROR:
; 14216:       *s = "Well-formedness violation";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@

; 14217:       break;

	jmp	$LN61@soap_set_f@2
$LN48@soap_set_f@2:

; 14218:     case SOAP_NO_TAG:
; 14219:       *s = "No XML element tag";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@

; 14220:       break;

	jmp	$LN61@soap_set_f@2
$LN47@soap_set_f@2:

; 14221:     case SOAP_MUSTUNDERSTAND:
; 14222:       *c = "SOAP-ENV:MustUnderstand";

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@

; 14223:       sprintf(soap->msgbuf, "The data in element '%s' must be understood but cannot be handled", soap->tag);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14224:       *s = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14225:       break;

	jmp	$LN61@soap_set_f@2
$LN46@soap_set_f@2:

; 14226:     case SOAP_VERSIONMISMATCH:
; 14227:       *c = "SOAP-ENV:VersionMismatch";

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@

; 14228:       *s = "Invalid SOAP message or SOAP version mismatch";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@

; 14229:       break;

	jmp	$LN61@soap_set_f@2
$LN45@soap_set_f@2:

; 14230:     case SOAP_DATAENCODINGUNKNOWN:
; 14231:       *c = "SOAP-ENV:DataEncodingUnknown";

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@

; 14232:       *s = "Unsupported SOAP data encoding";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@

; 14233:       break;

	jmp	$LN61@soap_set_f@2
$LN44@soap_set_f@2:

; 14234:     case SOAP_NAMESPACE:
; 14235:       *s = soap_set_validation_fault(soap, "namespace error", NULL);

	push	0
	push	OFFSET ??_C@_0BA@DMKNFBBB@namespace?5error?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14236:       break;

	jmp	$LN61@soap_set_f@2
$LN43@soap_set_f@2:

; 14237:     case SOAP_USER_ERROR:
; 14238:       *s = "User error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0L@PDEMLIEM@User?5error?$AA@

; 14239:       break;

	jmp	$LN61@soap_set_f@2
$LN42@soap_set_f@2:

; 14240:     case SOAP_FATAL_ERROR:
; 14241:       *s = "Fatal error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0M@HCPCIMCN@Fatal?5error?$AA@

; 14242:       break;

	jmp	$LN61@soap_set_f@2
$LN41@soap_set_f@2:

; 14243:     case SOAP_NO_METHOD:
; 14244:       sprintf(soap->msgbuf, "Method '%s' not implemented: method name or namespace not recognized", soap->tag);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 80052				; 000138b4H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14245:       *s = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14246:       break;

	jmp	$LN61@soap_set_f@2
$LN40@soap_set_f@2:

; 14247:     case SOAP_NO_DATA:
; 14248:       *s = "Data required for operation";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@

; 14249:       break;

	jmp	$LN61@soap_set_f@2
$LN39@soap_set_f@2:

; 14250:     case SOAP_GET_METHOD:
; 14251:       *s = "HTTP GET method not implemented";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@

; 14252:       break;

	jmp	$LN61@soap_set_f@2
$LN38@soap_set_f@2:

; 14253:     case SOAP_PUT_METHOD:
; 14254:       *s = "HTTP PUT method not implemented";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@

; 14255:       break;

	jmp	$LN61@soap_set_f@2
$LN37@soap_set_f@2:

; 14256:     case SOAP_HEAD_METHOD:
; 14257:       *s = "HTTP HEAD method not implemented";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@

; 14258:       break;

	jmp	$LN61@soap_set_f@2
$LN36@soap_set_f@2:

; 14259:     case SOAP_HTTP_METHOD:
; 14260:       *s = "HTTP method not implemented";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@

; 14261:       break;

	jmp	$LN61@soap_set_f@2
$LN35@soap_set_f@2:

; 14262:     case SOAP_EOM:
; 14263:       *s = "Out of memory";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@

; 14264:       break;

	jmp	$LN61@soap_set_f@2
$LN34@soap_set_f@2:

; 14265:     case SOAP_MOE:
; 14266:       *s = "Memory overflow or memory corruption error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@

; 14267:       break;

	jmp	$LN61@soap_set_f@2
$LN33@soap_set_f@2:

; 14268:     case SOAP_HDR:
; 14269:       *s = "Header line too long";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@

; 14270:       break;

	jmp	$LN61@soap_set_f@2
$LN32@soap_set_f@2:

; 14271:     case SOAP_IOB:
; 14272:       *s = "Array index out of bounds";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@

; 14273:       break;

	jmp	$LN61@soap_set_f@2
$LN31@soap_set_f@2:

; 14274:     case SOAP_NULL:
; 14275:       *s = soap_set_validation_fault(soap, "nil not allowed", NULL);

	push	0
	push	OFFSET ??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14276:       break;

	jmp	$LN61@soap_set_f@2
$LN30@soap_set_f@2:

; 14277:     case SOAP_DUPLICATE_ID:
; 14278:       *s = soap_set_validation_fault(soap, "multiple definitions of id ", soap->id);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	push	eax
	push	OFFSET ??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx], eax

; 14279:       if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN29@soap_set_f@2

; 14280:         *soap_faultsubcode(soap) = "SOAP-ENC:DuplicateID";

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	DWORD PTR [eax], OFFSET ??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@
$LN29@soap_set_f@2:

; 14281:       break;

	jmp	$LN61@soap_set_f@2
$LN28@soap_set_f@2:

; 14282:     case SOAP_MISSING_ID:
; 14283:       *s = soap_set_validation_fault(soap, "missing id for ref ", soap->id);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	push	eax
	push	OFFSET ??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx], eax

; 14284:       if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN27@soap_set_f@2

; 14285:         *soap_faultsubcode(soap) = "SOAP-ENC:MissingID";

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	DWORD PTR [eax], OFFSET ??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@
$LN27@soap_set_f@2:

; 14286:       break;

	jmp	$LN61@soap_set_f@2
$LN26@soap_set_f@2:

; 14287:     case SOAP_HREF:
; 14288:       *s = soap_set_validation_fault(soap, "incompatible object type ref/id pair ", soap->id);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 81076				; 00013cb4H
	push	eax
	push	OFFSET ??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx], eax

; 14289:       break;

	jmp	$LN61@soap_set_f@2
$LN25@soap_set_f@2:

; 14290:     case SOAP_FAULT:
; 14291:       break;

	jmp	$LN61@soap_set_f@2
$LN24@soap_set_f@2:

; 14292: #ifndef WITH_NOIO
; 14293:     case SOAP_UDP_ERROR:
; 14294:       *s = "Message too large for UDP packet";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@

; 14295:       break;

	jmp	$LN61@soap_set_f@2
$LN23@soap_set_f@2:

; 14296:     case SOAP_TCP_ERROR:
; 14297:       *s = tcp_error(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_tcp_error
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14298:       break;

	jmp	$LN61@soap_set_f@2
$LN22@soap_set_f@2:

; 14299: #endif
; 14300:     case SOAP_HTTP_ERROR:
; 14301:       *s = "An HTTP processing error occurred";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@

; 14302:       break;

	jmp	$LN61@soap_set_f@2
$LN21@soap_set_f@2:

; 14303:     case SOAP_SSL_ERROR:
; 14304: #ifdef WITH_OPENSSL
; 14305:       *s = "SSL error";
; 14306: #else
; 14307:       *s = "OpenSSL not installed: recompile with -DWITH_OPENSSL";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@

; 14308: #endif
; 14309:       break;

	jmp	$LN61@soap_set_f@2
$LN20@soap_set_f@2:

; 14310:     case SOAP_PLUGIN_ERROR:
; 14311:       *s = "Plugin registry error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@

; 14312:       break;

	jmp	$LN61@soap_set_f@2
$LN19@soap_set_f@2:

; 14313:     case SOAP_DIME_ERROR:
; 14314:       *s = "DIME format error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@

; 14315:       break;

	jmp	$LN61@soap_set_f@2
$LN18@soap_set_f@2:

; 14316:     case SOAP_DIME_HREF:
; 14317:       *s = "DIME href to missing attachment";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@

; 14318:       break;

	jmp	$LN61@soap_set_f@2
$LN17@soap_set_f@2:

; 14319:     case SOAP_DIME_MISMATCH:
; 14320:       *s = "DIME version/transmission error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@

; 14321:       break;

	jmp	$LN61@soap_set_f@2
$LN16@soap_set_f@2:

; 14322:     case SOAP_DIME_END:
; 14323:       *s = "End of DIME error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@

; 14324:       break;

	jmp	$LN61@soap_set_f@2
$LN15@soap_set_f@2:

; 14325:     case SOAP_MIME_ERROR:
; 14326:       *s = "MIME format error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@

; 14327:       break;

	jmp	$LN61@soap_set_f@2
$LN14@soap_set_f@2:

; 14328:     case SOAP_MIME_HREF:
; 14329:       *s = "MIME href to missing attachment";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@

; 14330:       break;

	jmp	$LN61@soap_set_f@2
$LN13@soap_set_f@2:

; 14331:     case SOAP_MIME_END:
; 14332:       *s = "End of MIME error";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@

; 14333:       break;

	jmp	$LN61@soap_set_f@2
$LN12@soap_set_f@2:

; 14334:     case SOAP_ZLIB_ERROR:
; 14335: #ifdef WITH_ZLIB
; 14336:       sprintf(soap->msgbuf, "Zlib/gzip error: '%s'", soap->d_stream->msg?soap->d_stream->msg:"");
; 14337:       *s = soap->msgbuf;
; 14338: #else
; 14339:       *s = "Zlib/gzip not installed for (de)compression: recompile with -DWITH_GZIP";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@

; 14340: #endif
; 14341:       break;

	jmp	$LN61@soap_set_f@2
$LN11@soap_set_f@2:

; 14342:     case SOAP_REQUIRED:
; 14343:       *s = soap_set_validation_fault(soap, "missing required attribute", NULL);

	push	0
	push	OFFSET ??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14344:       break;

	jmp	$LN61@soap_set_f@2
$LN10@soap_set_f@2:

; 14345:     case SOAP_PROHIBITED:
; 14346:       *s = soap_set_validation_fault(soap, "prohibited attribute present", NULL);

	push	0
	push	OFFSET ??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14347:       break;

	jmp	$LN61@soap_set_f@2
$LN9@soap_set_f@2:

; 14348:     case SOAP_OCCURS:
; 14349:       *s = soap_set_validation_fault(soap, "occurrence violation", NULL);

	push	0
	push	OFFSET ??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14350:       break;

	jmp	$LN61@soap_set_f@2
$LN8@soap_set_f@2:

; 14351:     case SOAP_LENGTH:
; 14352:       *s = soap_set_validation_fault(soap, "content length violation", NULL);

	push	0
	push	OFFSET ??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_validation_fault
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14353:       break;

	jmp	$LN61@soap_set_f@2
$LN7@soap_set_f@2:

; 14354:     case SOAP_FD_EXCEEDED:
; 14355:       *s = "Maximum number of open connections was reached";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@

; 14356:       break;

	jmp	$LN61@soap_set_f@2
$LN6@soap_set_f@2:

; 14357:     case SOAP_STOP:
; 14358:       *s = "Stopped: no response sent";

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@

; 14359:       break;

	jmp	$LN61@soap_set_f@2
$LN5@soap_set_f@2:

; 14360: #endif
; 14361:     case SOAP_EOF:
; 14362: #ifndef WITH_NOIO
; 14363:       strcpy(soap->msgbuf, soap_strerror(soap));

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_strerror
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 14364: #ifndef WITH_LEAN
; 14365:       if (strlen(soap->msgbuf) + 25 < sizeof(soap->msgbuf))

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 25					; 00000019H
	cmp	eax, 1024				; 00000400H
	jae	SHORT $LN4@soap_set_f@2

; 14366:       { memmove(soap->msgbuf + 25, soap->msgbuf, strlen(soap->msgbuf) + 1);

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78029				; 000130cdH
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14367:         memcpy(soap->msgbuf, "End of file or no input: ", 25);

	push	25					; 00000019H
	push	OFFSET ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@soap_set_f@2:

; 14368:       }
; 14369: #endif
; 14370:       *s = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14371:       break;

	jmp	$LN61@soap_set_f@2
$LN3@soap_set_f@2:

; 14372: #else
; 14373:       *s = "End of file or no input";
; 14374:       break;
; 14375: #endif
; 14376:     default:
; 14377: #ifndef WITH_NOHTTP
; 14378: #ifndef WITH_LEAN
; 14379:       if (soap->error > 200 && soap->error < 600)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 200		; 000000c8H
	jle	SHORT $LN2@soap_set_f@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 600		; 00000258H
	jge	SHORT $LN2@soap_set_f@2

; 14380:       { sprintf(soap->msgbuf, "HTTP Error: %d %s", soap->error, http_error(soap, soap->error));

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_http_error
	add	esp, 8
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	push	ecx
	push	OFFSET ??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78004				; 000130b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14381:         *s = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 14382:       }
; 14383:       else

	jmp	SHORT $LN61@soap_set_f@2
$LN2@soap_set_f@2:

; 14384: #endif
; 14385: #endif
; 14386:       { sprintf(soap->msgbuf, "Error %d", soap->error);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	push	ecx
	push	OFFSET ??_C@_08PNOEHBEA@Error?5?$CFd?$AA@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78004				; 000130b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14387:         *s = soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax
$LN61@soap_set_f@2:

; 14388:       }
; 14389:     }
; 14390: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN64@soap_set_f@2:
	DD	$LN5@soap_set_f@2
	DD	$LN3@soap_set_f@2
	DD	$LN53@soap_set_f@2
	DD	$LN52@soap_set_f@2
	DD	$LN51@soap_set_f@2
	DD	$LN50@soap_set_f@2
	DD	$LN49@soap_set_f@2
	DD	$LN48@soap_set_f@2
	DD	$LN32@soap_set_f@2
	DD	$LN47@soap_set_f@2
	DD	$LN44@soap_set_f@2
	DD	$LN43@soap_set_f@2
	DD	$LN42@soap_set_f@2
	DD	$LN25@soap_set_f@2
	DD	$LN41@soap_set_f@2
	DD	$LN40@soap_set_f@2
	DD	$LN39@soap_set_f@2
	DD	$LN38@soap_set_f@2
	DD	$LN3@soap_set_f@2
	DD	$LN37@soap_set_f@2
	DD	$LN36@soap_set_f@2
	DD	$LN35@soap_set_f@2
	DD	$LN34@soap_set_f@2
	DD	$LN33@soap_set_f@2
	DD	$LN31@soap_set_f@2
	DD	$LN30@soap_set_f@2
	DD	$LN28@soap_set_f@2
	DD	$LN26@soap_set_f@2
	DD	$LN24@soap_set_f@2
	DD	$LN23@soap_set_f@2
	DD	$LN22@soap_set_f@2
	DD	$LN21@soap_set_f@2
	DD	$LN12@soap_set_f@2
	DD	$LN19@soap_set_f@2
	DD	$LN18@soap_set_f@2
	DD	$LN17@soap_set_f@2
	DD	$LN16@soap_set_f@2
	DD	$LN15@soap_set_f@2
	DD	$LN14@soap_set_f@2
	DD	$LN13@soap_set_f@2
	DD	$LN46@soap_set_f@2
	DD	$LN20@soap_set_f@2
	DD	$LN45@soap_set_f@2
	DD	$LN11@soap_set_f@2
	DD	$LN10@soap_set_f@2
	DD	$LN9@soap_set_f@2
	DD	$LN8@soap_set_f@2
	DD	$LN7@soap_set_f@2
_soap_set_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@ ; `string'
PUBLIC	??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@ ; `string'
;	COMDAT ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
CONST	SEGMENT
??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@ DB 'Validation co'
	DB	'nstraint violation: %s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
CONST	SEGMENT
??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@ DB 'Validation co'
	DB	'nstraint violation: %s%s in element <%s>', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_set_validation_fault
_TEXT	SEGMENT
tv79 = -196						; size = 4
tv72 = -196						; size = 4
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_set_validation_fault PROC				; COMDAT

; 14174: { if (*soap->tag)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, BYTE PTR [eax+80052]
	test	ecx, ecx
	je	SHORT $LN2@soap_set_v

; 14175:     sprintf(soap->msgbuf, "Validation constraint violation: %s%s in element <%s>", s, t?t:SOAP_STR_EOS, soap->tag);

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN5@soap_set_v
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN6@soap_set_v
$LN5@soap_set_v:
	mov	DWORD PTR tv72[ebp], OFFSET _soap_padding
$LN6@soap_set_v:
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 80052				; 000138b4H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR tv72[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14176:   else

	jmp	SHORT $LN1@soap_set_v
$LN2@soap_set_v:

; 14177:     sprintf(soap->msgbuf, "Validation constraint violation: %s%s", s, t?t:SOAP_STR_EOS);

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN7@soap_set_v
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@soap_set_v
$LN7@soap_set_v:
	mov	DWORD PTR tv79[ebp], OFFSET _soap_padding
$LN8@soap_set_v:
	mov	esi, esp
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_set_v:

; 14178:   return soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H

; 14179: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_validation_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@OJPCPBNC@Sending?5back?5fault?5struct?5for?5er@ ; `string'
PUBLIC	_soap_send_fault
EXTRN	_soap_putfault:PROC
EXTRN	_soap_putheader:PROC
EXTRN	_soap_serializefault:PROC
EXTRN	_soap_serializeheader:PROC
;	COMDAT ??_C@_0CN@OJPCPBNC@Sending?5back?5fault?5struct?5for?5er@
CONST	SEGMENT
??_C@_0CN@OJPCPBNC@Sending?5back?5fault?5struct?5for?5er@ DB 'Sending bac'
	DB	'k fault struct for error code %d', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_send_fault
_TEXT	SEGMENT
_sfd$89833 = -584					; size = 260
_rfd$89832 = -316					; size = 260
_timeout$89831 = -48					; size = 8
_fdebug$89827 = -32					; size = 4
_r$ = -20						; size = 4
_status$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_send_fault PROC					; COMDAT

; 14399: { register int status = soap->error;

	push	ebp
	mov	ebp, esp
	sub	esp, 780				; 0000030cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-780]
	mov	ecx, 195				; 000000c3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR _status$[ebp], ecx

; 14400:   int r = 1;

	mov	DWORD PTR _r$[ebp], 1

; 14401:   if (status == SOAP_STOP)

	cmp	DWORD PTR _status$[ebp], 1000		; 000003e8H
	jne	SHORT $LN21@soap_send_@2

; 14402:     return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN22@soap_send_@2
$LN21@soap_send_@2:

; 14403:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Sending back fault struct for error code %d\n", soap->error));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN20@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN19@soap_send_@2
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN19@soap_send_@2:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN20@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89827[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	push	ecx
	push	OFFSET ??_C@_0CN@OJPCPBNC@Sending?5back?5fault?5struct?5for?5er@
	mov	edx, DWORD PTR _fdebug$89827[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89827[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@soap_send_@2:

; 14404:   soap->keep_alive = 0; /* to terminate connection */

	xor	eax, eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	WORD PTR [ecx+90412], ax

; 14405:   soap_set_fault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_fault
	add	esp, 4

; 14406: #ifndef WITH_NOIO
; 14407: #ifndef WITH_LEAN
; 14408:   if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12408], -1
	je	$LN17@soap_send_@2

; 14409:   { struct timeval timeout;
; 14410:     fd_set rfd, sfd;
; 14411:     timeout.tv_sec = 0;

	mov	DWORD PTR _timeout$89831[ebp], 0

; 14412:     timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$89831[ebp+4], 0

; 14413:     FD_ZERO(&rfd);

	mov	DWORD PTR _rfd$89832[ebp], 0

; 14414:     FD_ZERO(&sfd);

	mov	DWORD PTR _sfd$89833[ebp], 0
$LN16@soap_send_@2:

; 14415:     FD_SET(soap->socket, &rfd);

	cmp	DWORD PTR _rfd$89832[ebp], 64		; 00000040H
	jae	SHORT $LN15@soap_send_@2
	mov	eax, DWORD PTR _rfd$89832[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _rfd$89832[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _rfd$89832[ebp]
	add	eax, 1
	mov	DWORD PTR _rfd$89832[ebp], eax
$LN15@soap_send_@2:
	xor	eax, eax
	jne	SHORT $LN16@soap_send_@2
$LN12@soap_send_@2:

; 14416:     FD_SET(soap->socket, &sfd);

	cmp	DWORD PTR _sfd$89833[ebp], 64		; 00000040H
	jae	SHORT $LN11@soap_send_@2
	mov	eax, DWORD PTR _sfd$89833[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	mov	DWORD PTR _sfd$89833[ebp+eax*4+4], edx
	mov	eax, DWORD PTR _sfd$89833[ebp]
	add	eax, 1
	mov	DWORD PTR _sfd$89833[ebp], eax
$LN11@soap_send_@2:
	xor	eax, eax
	jne	SHORT $LN12@soap_send_@2

; 14417:     r = select((int)soap->socket + 1, &rfd, &sfd, NULL, &timeout);

	lea	eax, DWORD PTR _timeout$89831[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _sfd$89833[ebp]
	push	ecx
	lea	edx, DWORD PTR _rfd$89832[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12408]
	add	ecx, 1
	push	ecx
	call	_select@20
	mov	DWORD PTR _r$[ebp], eax

; 14418:     if (r > 0)

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN17@soap_send_@2

; 14419:     { if (!FD_ISSET(soap->socket, &sfd)
; 14420:        || (FD_ISSET(soap->socket, &rfd)
; 14421:         && recv(soap->socket, soap->tmpbuf, 1, MSG_PEEK) < 0))

	lea	eax, DWORD PTR _sfd$89833[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN6@soap_send_@2
	lea	eax, DWORD PTR _rfd$89832[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN17@soap_send_@2
	push	2
	push	1
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 79028				; 000134b4H
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12408]
	push	edx
	call	_recv@16
	test	eax, eax
	jge	SHORT $LN17@soap_send_@2
$LN6@soap_send_@2:

; 14422:         r = 0;

	mov	DWORD PTR _r$[ebp], 0
$LN17@soap_send_@2:

; 14423:     }
; 14424:   }
; 14425: #endif
; 14426: #endif
; 14427:   if ((status != SOAP_EOF || (!soap->recv_timeout && !soap->send_timeout)) && r > 0)

	cmp	DWORD PTR _status$[ebp], -1
	jne	SHORT $LN4@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	$LN5@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN5@soap_send_@2
$LN4@soap_send_@2:
	cmp	DWORD PTR _r$[ebp], 0
	jle	$LN5@soap_send_@2

; 14428:   { soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 14429:     soap_serializeheader(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_serializeheader
	add	esp, 4

; 14430:     soap_serializefault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_serializefault
	add	esp, 4

; 14431:     soap_begin_count(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_begin_count
	add	esp, 4

; 14432:     if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8
	je	SHORT $LN3@soap_send_@2

; 14433:     { soap_envelope_begin_out(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_envelope_begin_out
	add	esp, 4

; 14434:       soap_putheader(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putheader
	add	esp, 4

; 14435:       soap_body_begin_out(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_body_begin_out
	add	esp, 4

; 14436:       soap_putfault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putfault
	add	esp, 4

; 14437:       soap_body_end_out(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_body_end_out
	add	esp, 4

; 14438:       soap_envelope_end_out(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_envelope_end_out
	add	esp, 4
$LN3@soap_send_@2:

; 14439:     }
; 14440:     soap_end_count(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_count
	add	esp, 4

; 14441:     if (soap_response(soap, status)
; 14442:      || soap_envelope_begin_out(soap)
; 14443:      || soap_putheader(soap)
; 14444:      || soap_body_begin_out(soap)
; 14445:      || soap_putfault(soap)
; 14446:      || soap_body_end_out(soap)
; 14447:      || soap_envelope_end_out(soap))

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_response
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_envelope_begin_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putheader
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_body_begin_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_putfault
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_body_end_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_envelope_end_out
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_send_@2
$LN1@soap_send_@2:

; 14448:       return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
	jmp	SHORT $LN22@soap_send_@2
$LN2@soap_send_@2:

; 14449:     soap_end_send(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_send
	add	esp, 4
$LN5@soap_send_@2:

; 14450:   }
; 14451:   soap->error = status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+90460], ecx

; 14452:   return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
$LN22@soap_send_@2:

; 14453: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@soap_send_@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 780				; 0000030cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN28@soap_send_@2:
	DD	3
	DD	$LN27@soap_send_@2
$LN27@soap_send_@2:
	DD	-48					; ffffffd0H
	DD	8
	DD	$LN24@soap_send_@2
	DD	-316					; fffffec4H
	DD	260					; 00000104H
	DD	$LN25@soap_send_@2
	DD	-584					; fffffdb8H
	DD	260					; 00000104H
	DD	$LN26@soap_send_@2
$LN26@soap_send_@2:
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN25@soap_send_@2:
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$LN24@soap_send_@2:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_soap_send_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OLEKEGJF@Fault?5code?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@	; `string'
PUBLIC	??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@	; `string'
PUBLIC	??_C@_0EE@JBGFJJJO@Error?3?5soap_get_soapfault?$CI?$CJ?5fail@ ; `string'
PUBLIC	??_C@_0BG@BFGAALIE@Receiving?5SOAP?5Fault?6?$AA@ ; `string'
PUBLIC	_soap_recv_fault
EXTRN	_soap_getfault:PROC
;	COMDAT ??_C@_0P@OLEKEGJF@Fault?5code?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@OLEKEGJF@Fault?5code?5?$CFs?6?$AA@ DB 'Fault code %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
CONST	SEGMENT
??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@ DB 'SOAP-ENV:Receiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
CONST	SEGMENT
??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@ DB 'SOAP-ENV:Server', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JBGFJJJO@Error?3?5soap_get_soapfault?$CI?$CJ?5fail@
CONST	SEGMENT
??_C@_0EE@JBGFJJJO@Error?3?5soap_get_soapfault?$CI?$CJ?5fail@ DB 'Error: '
	DB	'soap_get_soapfault() failed. Is this a SOAP message at all?', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BFGAALIE@Receiving?5SOAP?5Fault?6?$AA@
CONST	SEGMENT
??_C@_0BG@BFGAALIE@Receiving?5SOAP?5Fault?6?$AA@ DB 'Receiving SOAP Fault'
	DB	0aH, 00H					; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_recv_fault
_TEXT	SEGMENT
tv134 = -256						; size = 4
_fdebug$89898 = -56					; size = 4
_s$89881 = -44						; size = 4
_fdebug$89878 = -32					; size = 4
_fdebug$89871 = -20					; size = 4
_status$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_recv_fault PROC					; COMDAT

; 14462: { register int status = soap->error;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR _status$[ebp], ecx

; 14463:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Receiving SOAP Fault\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN23@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN22@soap_recv_@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN22@soap_recv_@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN23@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89871[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0BG@BFGAALIE@Receiving?5SOAP?5Fault?6?$AA@
	mov	eax, DWORD PTR _fdebug$89871[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89871[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@soap_recv_@3:

; 14464:   soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0

; 14465:   if (soap_getfault(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_getfault
	add	esp, 4
	test	eax, eax
	je	$LN20@soap_recv_@3

; 14466:   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Error: soap_get_soapfault() failed. Is this a SOAP message at all?\n"));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN19@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN18@soap_recv_@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN18@soap_recv_@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN19@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89878[ebp], ecx
	mov	esi, esp
	push	OFFSET ??_C@_0EE@JBGFJJJO@Error?3?5soap_get_soapfault?$CI?$CJ?5fail@
	mov	eax, DWORD PTR _fdebug$89878[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89878[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@soap_recv_@3:

; 14467:     *soap_faultcode(soap) = (soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client");

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN26@soap_recv_@3
	mov	DWORD PTR tv134[ebp], OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	jmp	SHORT $LN27@soap_recv_@3
$LN26@soap_recv_@3:
	mov	DWORD PTR tv134[ebp], OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN27@soap_recv_@3:
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_faultcode
	add	esp, 4
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR [eax], ecx

; 14468:     soap->error = status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+90460], ecx

; 14469:     soap_set_fault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_fault
	add	esp, 4

; 14470:   }
; 14471:   else

	jmp	$LN16@soap_recv_@3
$LN20@soap_recv_@3:

; 14472:   { register const char *s = *soap_faultcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$89881[ebp], ecx

; 14473:     if (!soap_match_tag(soap, s, "SOAP-ENV:Server") || !soap_match_tag(soap, s, "SOAP-ENV:Receiver"))

	push	OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@soap_recv_@3
	push	OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@soap_recv_@3
$LN14@soap_recv_@3:

; 14474:       status = SOAP_SVR_FAULT;

	mov	DWORD PTR _status$[ebp], 2
	jmp	$LN13@soap_recv_@3
$LN15@soap_recv_@3:

; 14475:     else if (!soap_match_tag(soap, s, "SOAP-ENV:Client") || !soap_match_tag(soap, s, "SOAP-ENV:Sender"))

	push	OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@soap_recv_@3
	push	OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@soap_recv_@3
$LN11@soap_recv_@3:

; 14476:       status = SOAP_CLI_FAULT;

	mov	DWORD PTR _status$[ebp], 1
	jmp	$LN13@soap_recv_@3
$LN12@soap_recv_@3:

; 14477:     else if (!soap_match_tag(soap, s, "SOAP-ENV:MustUnderstand"))

	push	OFFSET ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@soap_recv_@3

; 14478:       status = SOAP_MUSTUNDERSTAND;

	mov	DWORD PTR _status$[ebp], 8
	jmp	$LN13@soap_recv_@3
$LN9@soap_recv_@3:

; 14479:     else if (!soap_match_tag(soap, s, "SOAP-ENV:VersionMismatch"))

	push	OFFSET ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_match_tag
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@soap_recv_@3

; 14480:       status = SOAP_VERSIONMISMATCH;

	mov	DWORD PTR _status$[ebp], 39		; 00000027H

; 14481:     else

	jmp	SHORT $LN13@soap_recv_@3
$LN7@soap_recv_@3:

; 14482:     { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Fault code %s\n", s));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN4@soap_recv_@3
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN4@soap_recv_@3:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN5@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$89898[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _s$89881[ebp]
	push	eax
	push	OFFSET ??_C@_0P@OLEKEGJF@Fault?5code?5?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fdebug$89898[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$89898[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@soap_recv_@3:

; 14483:       status = SOAP_FAULT;

	mov	DWORD PTR _status$[ebp], 12		; 0000000cH
$LN13@soap_recv_@3:

; 14484:     }
; 14485:     if (soap_body_end_in(soap)
; 14486:      || soap_envelope_end_in(soap)
; 14487:      || soap_end_recv(soap))

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_body_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_envelope_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_recv_@3
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_recv_@3
$LN1@soap_recv_@3:

; 14488:       return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
	jmp	SHORT $LN24@soap_recv_@3
$LN2@soap_recv_@3:

; 14489:     soap->error = status;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+90460], ecx
$LN16@soap_recv_@3:

; 14490:   }
; 14491:   return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
$LN24@soap_recv_@3:

; 14492: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_recv_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_send_empty_response
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_send_empty_response
_TEXT	SEGMENT
_m$ = -8						; size = 4
_soap$ = 8						; size = 4
_httpstatuscode$ = 12					; size = 4
_soap_send_empty_response PROC				; COMDAT

; 14502: { register soap_mode m = soap->omode;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _m$[ebp], ecx

; 14503:   soap->count = 0;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+12448], 0

; 14504:   if ((m & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR _m$[ebp]
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN3@soap_send_@3

; 14505:   { soap->omode &= ~SOAP_IO_CHUNK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 14506:     soap->omode |= SOAP_IO_BUFFER;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 1
	mov	edx, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN3@soap_send_@3:

; 14507:   }
; 14508:   if (soap_response(soap, httpstatuscode) || soap_end_send(soap))

	mov	eax, DWORD PTR _httpstatuscode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_response
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_send
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_send_@3
$LN1@soap_send_@3:

; 14509:   { soap->omode = m;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 14510:     return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
	jmp	SHORT $LN4@soap_send_@3
$LN2@soap_send_@3:

; 14511:   }
; 14512:   soap->omode = m;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 14513:   return SOAP_OK;

	xor	eax, eax
$LN4@soap_send_@3:

; 14514: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_send_empty_response ENDP
_TEXT	ENDS
PUBLIC	_soap_recv_empty_response
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_recv_empty_response
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_recv_empty_response PROC				; COMDAT

; 14525: { if (soap_begin_recv(soap) || soap_end_recv(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_begin_recv
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@soap_recv_@4
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_end_recv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@soap_recv_@4
$LN2@soap_recv_@4:

; 14526:   { if (soap->error != 202)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 202		; 000000caH
	je	SHORT $LN1@soap_recv_@4

; 14527:       return soap_closesock(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_closesock
	add	esp, 4
	jmp	SHORT $LN4@soap_recv_@4
$LN1@soap_recv_@4:

; 14528:     soap->error = SOAP_OK;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 0
$LN3@soap_recv_@4:

; 14529:   }
; 14530:   return SOAP_OK;

	xor	eax, eax
$LN4@soap_recv_@4:

; 14531: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_recv_empty_response ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@ ; `string'
PUBLIC	??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@ ; `string'
PUBLIC	??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@ ; `string'
EXTRN	__imp__FormatMessageA@28:PROC
;	COMDAT ??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out after %ds receive delay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out after %ds send or %ds receive delay', 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_strerror
_TEXT	SEGMENT
_len$89921 = -20					; size = 4
_err$ = -8						; size = 4
_soap$ = 8						; size = 4
_soap_strerror PROC					; COMDAT

; 14540: { register int err = soap->errnum;

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90468]
	mov	DWORD PTR _err$[ebp], ecx

; 14541:   if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN4@soap_strer

; 14542:   {
; 14543: #ifndef WIN32
; 14544:     return strerror(err);
; 14545: #else
; 14546: #ifndef UNDER_CE
; 14547:     DWORD len;
; 14548:     *soap->msgbuf = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	mov	BYTE PTR [eax+78004], 0

; 14549:     len = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)soap->msgbuf, (DWORD)sizeof(soap->msgbuf), NULL);

	mov	esi, esp
	push	0
	push	1024					; 00000400H
	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _err$[ebp]
	push	ecx
	push	0
	push	4608					; 00001200H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _len$89921[ebp], eax

; 14550: #else
; 14551:     DWORD i, len;
; 14552:     *soap->msgbuf = '\0';
; 14553:     len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, 0, (LPTSTR)soap->msgbuf, (DWORD)(sizeof(soap->msgbuf)/sizeof(TCHAR)), NULL);
; 14554:     for (i = 0; i <= len; i++)
; 14555:     { if (((TCHAR*)soap->msgbuf)[i] < 0x80)
; 14556:         soap->msgbuf[i] = (char)((TCHAR*)soap->msgbuf)[i];
; 14557:       else
; 14558:         soap->msgbuf[i] = '?';
; 14559:     }
; 14560: #endif
; 14561:     return soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	jmp	SHORT $LN5@soap_strer
$LN4@soap_strer:

; 14562: #endif
; 14563:   }
; 14564: #ifndef WITH_LEAN
; 14565:   if (soap->recv_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jle	SHORT $LN3@soap_strer

; 14566:   { if (soap->send_timeout > 0)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LN2@soap_strer

; 14567:       sprintf(soap->msgbuf, "Operation interrupted or timed out after %ds send or %ds receive delay", soap->send_timeout, soap->recv_timeout);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET ??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 78004				; 000130b4H
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14568:     else

	jmp	SHORT $LN1@soap_strer
$LN2@soap_strer:

; 14569:       sprintf(soap->msgbuf, "Operation interrupted or timed out after %ds receive delay", soap->recv_timeout);

	mov	esi, esp
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET ??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@
	mov	edx, DWORD PTR _soap$[ebp]
	add	edx, 78004				; 000130b4H
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_strer:

; 14570:     return soap->msgbuf;

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, 78004				; 000130b4H
	jmp	SHORT $LN5@soap_strer
$LN3@soap_strer:

; 14571:   }
; 14572: #endif
; 14573:   return "Operation interrupted or timed out";

	mov	eax, OFFSET ??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@
$LN5@soap_strer:

; 14574: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_strerror ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_set_sender_error
_TEXT	SEGMENT
tv72 = -196						; size = 4
_soap$ = 8						; size = 4
_faultstring$ = 12					; size = 4
_faultdetailXML$ = 16					; size = 4
_soaperror$ = 20					; size = 4
_soap_set_sender_error PROC				; COMDAT

; 14601: { return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client", NULL, faultstring, faultdetailXML, soaperror);

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN3@soap_set_s
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	jmp	SHORT $LN4@soap_set_s
$LN3@soap_set_s:
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN4@soap_set_s:
	mov	edx, DWORD PTR _soaperror$[ebp]
	push	edx
	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultstring$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv72[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_error
	add	esp, 24					; 00000018H

; 14602: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_sender_error ENDP
_TEXT	ENDS
EXTRN	_soap_faultdetail:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_set_error
_TEXT	SEGMENT
_s$89942 = -8						; size = 4
_soap$ = 8						; size = 4
_faultcode$ = 12					; size = 4
_faultsubcodeQName$ = 16				; size = 4
_faultstring$ = 20					; size = 4
_faultdetailXML$ = 24					; size = 4
_soaperror$ = 28					; size = 4
_soap_set_error PROC					; COMDAT

; 14582: { *soap_faultcode(soap) = faultcode;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	ecx, DWORD PTR _faultcode$[ebp]
	mov	DWORD PTR [eax], ecx

; 14583:   if (faultsubcodeQName)

	cmp	DWORD PTR _faultsubcodeQName$[ebp], 0
	je	SHORT $LN3@soap_set_e@3

; 14584:     *soap_faultsubcode(soap) = faultsubcodeQName;

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	ecx, DWORD PTR _faultsubcodeQName$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@soap_set_e@3:

; 14585:   *soap_faultstring(soap) = faultstring;

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultstring
	add	esp, 4
	mov	ecx, DWORD PTR _faultstring$[ebp]
	mov	DWORD PTR [eax], ecx

; 14586:   if (faultdetailXML && *faultdetailXML)

	cmp	DWORD PTR _faultdetailXML$[ebp], 0
	je	SHORT $LN2@soap_set_e@3
	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@soap_set_e@3

; 14587:   { register const char **s = soap_faultdetail(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultdetail
	add	esp, 4
	mov	DWORD PTR _s$89942[ebp], eax

; 14588:     if (s)

	cmp	DWORD PTR _s$89942[ebp], 0
	je	SHORT $LN2@soap_set_e@3

; 14589:       *s = faultdetailXML;

	mov	eax, DWORD PTR _s$89942[ebp]
	mov	ecx, DWORD PTR _faultdetailXML$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@soap_set_e@3:

; 14590:   }
; 14591:   return soap->error = soaperror;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soaperror$[ebp]
	mov	DWORD PTR [eax+90460], ecx
	mov	eax, DWORD PTR _soaperror$[ebp]

; 14592: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_error ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_set_receiver_error
_TEXT	SEGMENT
tv72 = -196						; size = 4
_soap$ = 8						; size = 4
_faultstring$ = 12					; size = 4
_faultdetailXML$ = 16					; size = 4
_soaperror$ = 20					; size = 4
_soap_set_receiver_error PROC				; COMDAT

; 14611: { return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : "SOAP-ENV:Server", NULL, faultstring, faultdetailXML, soaperror);

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN3@soap_set_r
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	jmp	SHORT $LN4@soap_set_r
$LN3@soap_set_r:
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
$LN4@soap_set_r:
	mov	edx, DWORD PTR _soaperror$[ebp]
	push	edx
	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultstring$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv72[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_error
	add	esp, 24					; 00000018H

; 14612: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_set_receiver_error ENDP
_TEXT	ENDS
PUBLIC	_soap_sender_fault_subcode
PUBLIC	_soap_sender_fault
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_sender_fault
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_faultstring$ = 12					; size = 4
_faultdetailXML$ = 16					; size = 4
_soap_sender_fault PROC					; COMDAT

; 14636: { return soap_sender_fault_subcode(soap, NULL, faultstring, faultdetailXML);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultstring$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_sender_fault_subcode
	add	esp, 16					; 00000010H

; 14637: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_sender_fault ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_sender_fault_subcode
_TEXT	SEGMENT
tv71 = -196						; size = 4
_soap$ = 8						; size = 4
_faultsubcodeQName$ = 12				; size = 4
_faultstring$ = 16					; size = 4
_faultdetailXML$ = 20					; size = 4
_soap_sender_fault_subcode PROC				; COMDAT

; 14646: { return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client", faultsubcodeQName, faultstring, faultdetailXML);

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN3@soap_sende
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	jmp	SHORT $LN4@soap_sende
$LN3@soap_sende:
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN4@soap_sende:
	mov	edx, DWORD PTR _faultdetailXML$[ebp]
	push	edx
	mov	eax, DWORD PTR _faultstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultsubcodeQName$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv71[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_copy_fault
	add	esp, 20					; 00000014H

; 14647: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_sender_fault_subcode ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_copy_fault
_TEXT	SEGMENT
_t$ = -32						; size = 4
_s$ = -20						; size = 4
_r$ = -8						; size = 4
_soap$ = 8						; size = 4
_faultcode$ = 12					; size = 4
_faultsubcodeQName$ = 16				; size = 4
_faultstring$ = 20					; size = 4
_faultdetailXML$ = 24					; size = 4
_soap_copy_fault PROC					; COMDAT

; 14619: { char *r = NULL, *s = NULL, *t = NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR _r$[ebp], 0
	mov	DWORD PTR _s$[ebp], 0
	mov	DWORD PTR _t$[ebp], 0

; 14620:   if (faultsubcodeQName)

	cmp	DWORD PTR _faultsubcodeQName$[ebp], 0
	je	SHORT $LN3@soap_copy_@2

; 14621:     r = soap_strdup(soap, faultsubcodeQName);

	mov	eax, DWORD PTR _faultsubcodeQName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax
$LN3@soap_copy_@2:

; 14622:   if (faultstring)

	cmp	DWORD PTR _faultstring$[ebp], 0
	je	SHORT $LN2@soap_copy_@2

; 14623:     s = soap_strdup(soap, faultstring);

	mov	eax, DWORD PTR _faultstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax
$LN2@soap_copy_@2:

; 14624:   if (faultdetailXML)

	cmp	DWORD PTR _faultdetailXML$[ebp], 0
	je	SHORT $LN1@soap_copy_@2

; 14625:     t = soap_strdup(soap, faultdetailXML);

	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax
$LN1@soap_copy_@2:

; 14626:   return soap_set_error(soap, faultcode, r, s, t, SOAP_FAULT);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _faultcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_set_error
	add	esp, 24					; 00000018H

; 14627: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_copy_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_receiver_fault_subcode
PUBLIC	_soap_receiver_fault
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_receiver_fault
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_faultstring$ = 12					; size = 4
_faultdetailXML$ = 16					; size = 4
_soap_receiver_fault PROC				; COMDAT

; 14656: { return soap_receiver_fault_subcode(soap, NULL, faultstring, faultdetailXML);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _faultdetailXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultstring$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_receiver_fault_subcode
	add	esp, 16					; 00000010H

; 14657: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_receiver_fault ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _soap_receiver_fault_subcode
_TEXT	SEGMENT
tv71 = -196						; size = 4
_soap$ = 8						; size = 4
_faultsubcodeQName$ = 12				; size = 4
_faultstring$ = 16					; size = 4
_faultdetailXML$ = 20					; size = 4
_soap_receiver_fault_subcode PROC			; COMDAT

; 14666: { return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : "SOAP-ENV:Server", faultsubcodeQName, faultstring, faultdetailXML);

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN3@soap_recei
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	jmp	SHORT $LN4@soap_recei
$LN3@soap_recei:
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
$LN4@soap_recei:
	mov	edx, DWORD PTR _faultdetailXML$[ebp]
	push	edx
	mov	eax, DWORD PTR _faultstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _faultsubcodeQName$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv71[ebp]
	push	edx
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_copy_fault
	add	esp, 20					; 00000014H

; 14667: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_receiver_fault_subcode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@ ; `string'
PUBLIC	??_C@_06BAOMBKPD@Error?5?$AA@			; `string'
PUBLIC	??_C@_07IBLMOOJE@SOAP?51?4?$AA@			; `string'
PUBLIC	??_C@_0L@HPHPPAL@no?5subcode?$AA@		; `string'
PUBLIC	??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@	; `string'
PUBLIC	??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@	; `string'
PUBLIC	??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@ ; `string'
PUBLIC	_soap_print_fault
;	COMDAT ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
CONST	SEGMENT
??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@ DB '%'
	DB	's%d fault: %s [%s]', 0aH, '"%s"', 0aH, 'Detail: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAOMBKPD@Error?5?$AA@
CONST	SEGMENT
??_C@_06BAOMBKPD@Error?5?$AA@ DB 'Error ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
CONST	SEGMENT
??_C@_07IBLMOOJE@SOAP?51?4?$AA@ DB 'SOAP 1.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPHPPAL@no?5subcode?$AA@
CONST	SEGMENT
??_C@_0L@HPHPPAL@no?5subcode?$AA@ DB 'no subcode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
CONST	SEGMENT
??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@ DB '[no reason]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
CONST	SEGMENT
??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@ DB '[no detail]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
CONST	SEGMENT
??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@ DB 'Error: soa'
	DB	'p struct state not initialized', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_print_fault
_TEXT	SEGMENT
tv143 = -260						; size = 4
tv138 = -256						; size = 4
tv129 = -252						; size = 4
tv94 = -248						; size = 4
tv91 = -244						; size = 4
_d$90003 = -44						; size = 4
_s$90002 = -32						; size = 4
_v$90001 = -20						; size = 4
_c$90000 = -8						; size = 4
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_soap_print_fault PROC					; COMDAT

; 14677: { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_print
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN6@soap_print
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN6@soap_print
$LN5@soap_print:

; 14678:     fprintf(fd, "Error: soap struct state not initialized\n");

	mov	esi, esp
	push	OFFSET ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN7@soap_print
$LN6@soap_print:

; 14679:   else if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN7@soap_print

; 14680:   { const char *c, *v = NULL, *s, **d;

	mov	DWORD PTR _v$90001[ebp], 0

; 14681:     d = soap_faultcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	DWORD PTR _d$90003[ebp], eax

; 14682:     if (!*d)

	mov	eax, DWORD PTR _d$90003[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@soap_print

; 14683:       soap_set_fault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_fault
	add	esp, 4
$LN2@soap_print:

; 14684:     c = *d;

	mov	eax, DWORD PTR _d$90003[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _c$90000[ebp], ecx

; 14685:     if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN1@soap_print

; 14686:       v = *soap_faultsubcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$90001[ebp], ecx
$LN1@soap_print:

; 14687:     s = *soap_faultstring(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultstring
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$90002[ebp], ecx

; 14688:     d = soap_faultdetail(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultdetail
	add	esp, 4
	mov	DWORD PTR _d$90003[ebp], eax

; 14689:     fprintf(fd, "%s%d fault: %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, c, v ? v : "no subcode", s ? s : "[no reason]", d && *d ? *d : "[no detail]");

	cmp	DWORD PTR _d$90003[ebp], 0
	je	SHORT $LN9@soap_print
	mov	eax, DWORD PTR _d$90003[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@soap_print
	mov	ecx, DWORD PTR _d$90003[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN10@soap_print
$LN9@soap_print:
	mov	DWORD PTR tv91[ebp], OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_print:
	cmp	DWORD PTR _s$90002[ebp], 0
	je	SHORT $LN11@soap_print
	mov	eax, DWORD PTR _s$90002[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN12@soap_print
$LN11@soap_print:
	mov	DWORD PTR tv94[ebp], OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_print:
	cmp	DWORD PTR _v$90001[ebp], 0
	je	SHORT $LN13@soap_print
	mov	ecx, DWORD PTR _v$90001[ebp]
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN14@soap_print
$LN13@soap_print:
	mov	DWORD PTR tv129[ebp], OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_print:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN15@soap_print
	mov	ecx, DWORD PTR _soap$[ebp]
	movsx	edx, WORD PTR [ecx+6]
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN16@soap_print
$LN15@soap_print:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR tv138[ebp], ecx
$LN16@soap_print:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN17@soap_print
	mov	DWORD PTR tv143[ebp], OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jmp	SHORT $LN18@soap_print
$LN17@soap_print:
	mov	DWORD PTR tv143[ebp], OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN18@soap_print:
	mov	esi, esp
	mov	ecx, DWORD PTR tv91[ebp]
	push	ecx
	mov	edx, DWORD PTR tv94[ebp]
	push	edx
	mov	eax, DWORD PTR tv129[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$90000[ebp]
	push	ecx
	mov	edx, DWORD PTR tv138[ebp]
	push	edx
	mov	eax, DWORD PTR tv143[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 32					; 00000020H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_print:

; 14690:   }
; 14691: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_print_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PPEKPCIO@?5fault?3?5?$AA@		; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_08IAKGCGCB@Detail?3?5?$AA@		; `string'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	_soap_stream_fault
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z:PROC
;	COMDAT ??_C@_08PPEKPCIO@?5fault?3?5?$AA@
CONST	SEGMENT
??_C@_08PPEKPCIO@?5fault?3?5?$AA@ DB ' fault: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAKGCGCB@Detail?3?5?$AA@
CONST	SEGMENT
??_C@_08IAKGCGCB@Detail?3?5?$AA@ DB 'Detail: ', 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_stream_fault
_TEXT	SEGMENT
tv243 = -264						; size = 4
tv151 = -260						; size = 4
tv162 = -256						; size = 4
tv139 = -252						; size = 4
tv131 = -248						; size = 4
tv91 = -244						; size = 4
_d$90111 = -44						; size = 4
_s$90110 = -32						; size = 4
_v$90109 = -20						; size = 4
_c$90108 = -8						; size = 4
_soap$ = 8						; size = 4
_os$ = 12						; size = 4
_soap_stream_fault PROC					; COMDAT

; 14703: { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_strea@2
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN6@soap_strea@2
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN6@soap_strea@2
$LN5@soap_strea@2:

; 14704:     os << "Error: soap struct state not initialized\n";

	push	OFFSET ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
	mov	eax, DWORD PTR _os$[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	jmp	$LN7@soap_strea@2
$LN6@soap_strea@2:

; 14705:   else if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN7@soap_strea@2

; 14706:   { const char *c, *v = NULL, *s, **d;

	mov	DWORD PTR _v$90109[ebp], 0

; 14707:     d = soap_faultcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	DWORD PTR _d$90111[ebp], eax

; 14708:     if (!*d)

	mov	eax, DWORD PTR _d$90111[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@soap_strea@2

; 14709:       soap_set_fault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_fault
	add	esp, 4
$LN2@soap_strea@2:

; 14710:     c = *d;

	mov	eax, DWORD PTR _d$90111[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _c$90108[ebp], ecx

; 14711:     if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN1@soap_strea@2

; 14712:       v = *soap_faultsubcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$90109[ebp], ecx
$LN1@soap_strea@2:

; 14713:     s = *soap_faultstring(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultstring
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$90110[ebp], ecx

; 14714:     d = soap_faultdetail(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultdetail
	add	esp, 4
	mov	DWORD PTR _d$90111[ebp], eax

; 14715:     os << (soap->version ? "SOAP 1." : "Error ")
; 14716:        << (soap->version ? (int)soap->version : soap->error)
; 14717:        << " fault: " << c
; 14718:        << "[" << (v ? v : "no subcode") << "]"
; 14719:        << std::endl
; 14720:        << "\"" << (s ? s : "[no reason]") << "\""
; 14721:        << std::endl
; 14722:        << "Detail: " << (d && *d ? *d : "[no detail]")
; 14723:        << std::endl;

	cmp	DWORD PTR _d$90111[ebp], 0
	je	SHORT $LN9@soap_strea@2
	mov	eax, DWORD PTR _d$90111[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@soap_strea@2
	mov	ecx, DWORD PTR _d$90111[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN10@soap_strea@2
$LN9@soap_strea@2:
	mov	DWORD PTR tv91[ebp], OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_strea@2:
	cmp	DWORD PTR _s$90110[ebp], 0
	je	SHORT $LN11@soap_strea@2
	mov	eax, DWORD PTR _s$90110[ebp]
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN12@soap_strea@2
$LN11@soap_strea@2:
	mov	DWORD PTR tv131[ebp], OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_strea@2:
	cmp	DWORD PTR _v$90109[ebp], 0
	je	SHORT $LN13@soap_strea@2
	mov	ecx, DWORD PTR _v$90109[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	jmp	SHORT $LN14@soap_strea@2
$LN13@soap_strea@2:
	mov	DWORD PTR tv139[ebp], OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_strea@2:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN17@soap_strea@2
	mov	ecx, DWORD PTR _soap$[ebp]
	movsx	edx, WORD PTR [ecx+6]
	mov	DWORD PTR tv162[ebp], edx
	jmp	SHORT $LN18@soap_strea@2
$LN17@soap_strea@2:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR tv162[ebp], ecx
$LN18@soap_strea@2:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN15@soap_strea@2
	mov	DWORD PTR tv151[ebp], OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jmp	SHORT $LN16@soap_strea@2
$LN15@soap_strea@2:
	mov	DWORD PTR tv151[ebp], OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN16@soap_strea@2:
	mov	esi, esp
	mov	ecx, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	ecx
	mov	edx, DWORD PTR tv91[ebp]
	push	edx
	push	OFFSET ??_C@_08IAKGCGCB@Detail?3?5?$AA@
	mov	edi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	ecx, DWORD PTR tv131[ebp]
	push	ecx
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	ebx, esp
	mov	edx, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	edx
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	eax, DWORD PTR tv139[ebp]
	push	eax
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	mov	ecx, DWORD PTR _c$90108[ebp]
	push	ecx
	push	OFFSET ??_C@_08PPEKPCIO@?5fault?3?5?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	mov	ecx, DWORD PTR tv151[ebp]
	push	ecx
	mov	edx, DWORD PTR _os$[ebp]
	push	edx
	mov	DWORD PTR tv243[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, DWORD PTR tv243[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@soap_strea@2:

; 14724:   }
; 14725: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_stream_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@ ; `string'
PUBLIC	_soap_sprint_fault
EXTRN	__imp___snprintf:PROC
;	COMDAT ??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@
CONST	SEGMENT
??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@ DB 'Error: soap'
	DB	' struct not initialized', 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_sprint_fault
_TEXT	SEGMENT
tv144 = -260						; size = 4
tv139 = -256						; size = 4
tv130 = -252						; size = 4
tv95 = -248						; size = 4
tv92 = -244						; size = 4
_d$90143 = -44						; size = 4
_s$90142 = -32						; size = 4
_v$90141 = -20						; size = 4
_c$90140 = -8						; size = 4
_soap$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_soap_sprint_fault PROC					; COMDAT

; 14737: { if (soap_check_state(soap))

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN5@soap_sprin
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN6@soap_sprin
	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN6@soap_sprin
$LN5@soap_sprin:

; 14738:     strncpy(buf, "Error: soap struct not initialized", len);

	mov	esi, esp
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN4@soap_sprin
$LN6@soap_sprin:

; 14739:   else if (soap->error)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN4@soap_sprin

; 14740:   { const char *c, *v = NULL, *s, **d;

	mov	DWORD PTR _v$90141[ebp], 0

; 14741:     d = soap_faultcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultcode
	add	esp, 4
	mov	DWORD PTR _d$90143[ebp], eax

; 14742:     if (!*d)

	mov	eax, DWORD PTR _d$90143[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@soap_sprin

; 14743:       soap_set_fault(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_set_fault
	add	esp, 4
$LN2@soap_sprin:

; 14744:     c = *d;

	mov	eax, DWORD PTR _d$90143[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _c$90140[ebp], ecx

; 14745:     if (soap->version == 2)

	mov	eax, DWORD PTR _soap$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	cmp	ecx, 2
	jne	SHORT $LN1@soap_sprin

; 14746:       v = *soap_faultsubcode(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultsubcode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$90141[ebp], ecx
$LN1@soap_sprin:

; 14747:     s = *soap_faultstring(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultstring
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$90142[ebp], ecx

; 14748:     d = soap_faultdetail(soap);

	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_faultdetail
	add	esp, 4
	mov	DWORD PTR _d$90143[ebp], eax

; 14749: #ifdef WIN32
; 14750:     _snprintf
; 14751: #else
; 14752:     snprintf
; 14753: #endif
; 14754:       (buf, len, "%s%d fault: %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, c, v ? v : "no subcode", s ? s : "[no reason]", d && *d ? *d : "[no detail]");

	cmp	DWORD PTR _d$90143[ebp], 0
	je	SHORT $LN9@soap_sprin
	mov	eax, DWORD PTR _d$90143[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@soap_sprin
	mov	ecx, DWORD PTR _d$90143[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv92[ebp], edx
	jmp	SHORT $LN10@soap_sprin
$LN9@soap_sprin:
	mov	DWORD PTR tv92[ebp], OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_sprin:
	cmp	DWORD PTR _s$90142[ebp], 0
	je	SHORT $LN11@soap_sprin
	mov	eax, DWORD PTR _s$90142[ebp]
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN12@soap_sprin
$LN11@soap_sprin:
	mov	DWORD PTR tv95[ebp], OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_sprin:
	cmp	DWORD PTR _v$90141[ebp], 0
	je	SHORT $LN13@soap_sprin
	mov	ecx, DWORD PTR _v$90141[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN14@soap_sprin
$LN13@soap_sprin:
	mov	DWORD PTR tv130[ebp], OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_sprin:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN15@soap_sprin
	mov	ecx, DWORD PTR _soap$[ebp]
	movsx	edx, WORD PTR [ecx+6]
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN16@soap_sprin
$LN15@soap_sprin:
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90460]
	mov	DWORD PTR tv139[ebp], ecx
$LN16@soap_sprin:
	mov	edx, DWORD PTR _soap$[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	je	SHORT $LN17@soap_sprin
	mov	DWORD PTR tv144[ebp], OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jmp	SHORT $LN18@soap_sprin
$LN17@soap_sprin:
	mov	DWORD PTR tv144[ebp], OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN18@soap_sprin:
	mov	esi, esp
	mov	ecx, DWORD PTR tv92[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	push	edx
	mov	eax, DWORD PTR tv130[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$90140[ebp]
	push	ecx
	mov	edx, DWORD PTR tv139[ebp]
	push	edx
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp___snprintf
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@soap_sprin:

; 14755:   }
; 14756:   return buf;

	mov	eax, DWORD PTR _buf$[ebp]

; 14757: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_sprint_fault ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@ ; `string'
PUBLIC	_soap_print_fault_location
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@ DB '%'
	DB	's%c', 0aH, '<!-- ** HERE ** -->', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT _soap_print_fault_location
_TEXT	SEGMENT
_c2$ = -44						; size = 4
_c1$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_soap_print_fault_location PROC				; COMDAT

; 14768: {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14769: #ifndef WITH_LEAN
; 14770:   int i, j, c1, c2;
; 14771:   if (soap->error && soap->bufidx <= soap->buflen && soap->buflen > 0 && soap->buflen <= SOAP_BUFLEN)

	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90460], 0
	je	$LN6@soap_print@2
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	ja	$LN6@soap_print@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12432], 0
	jbe	$LN6@soap_print@2
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+12432], 65536		; 00010000H
	ja	$LN6@soap_print@2

; 14772:   { i = (int)soap->bufidx - 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 14773:     if (i <= 0)

	cmp	DWORD PTR _i$[ebp], 0
	jg	SHORT $LN4@soap_print@2

; 14774:       i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN4@soap_print@2:

; 14775:     c1 = soap->buf[i];

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+12468]
	mov	DWORD PTR _c1$[ebp], ecx

; 14776:     soap->buf[i] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax+12468], 0

; 14777:     if ((int)soap->buflen >= i + 1024)

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [ecx+12432], eax
	jl	SHORT $LN3@soap_print@2

; 14778:       j = i + 1023;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1023				; 000003ffH
	mov	DWORD PTR _j$[ebp], eax

; 14779:     else

	jmp	SHORT $LN2@soap_print@2
$LN3@soap_print@2:

; 14780:       j = (int)soap->buflen - 1;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12432]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN2@soap_print@2:

; 14781:     c2 = soap->buf[j];

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR [eax+12468]
	mov	DWORD PTR _c2$[ebp], ecx

; 14782:     soap->buf[j] = '\0';

	mov	eax, DWORD PTR _soap$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax+12468], 0

; 14783:     fprintf(fd, "%s%c\n<!-- ** HERE ** -->\n", soap->buf, c1);

	mov	esi, esp
	mov	eax, DWORD PTR _c1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, 12468				; 000030b4H
	push	ecx
	push	OFFSET ??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14784:     if (soap->bufidx < soap->buflen)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [eax+12428]
	cmp	edx, DWORD PTR [ecx+12432]
	jae	SHORT $LN1@soap_print@2

; 14785:       fprintf(fd, "%s\n", soap->buf + soap->bufidx);

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12428]
	mov	edx, DWORD PTR _soap$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12468]
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@soap_print@2:

; 14786:     soap->buf[i] = c1;

	mov	ecx, DWORD PTR _c1$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+12468], al

; 14787:     soap->buf[j] = c2;

	mov	ecx, DWORD PTR _c2$[ebp]
	call	@_RTC_Check_4_to_1@4
	mov	ecx, DWORD PTR _soap$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR [ecx+12468], al
$LN6@soap_print@2:

; 14788:   }
; 14789: #endif
; 14790: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_print_fault_location ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FI@GBLABLCK@Could?5not?5register?5plugin?5?8?$CFs?8?3?5@ ; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_0BI@NCONHDGE@Registered?5?8?$CFs?8?5plugin?6?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??soap_register_plugin_arg@@9@4JA ; `soap_register_plugin_arg'::`2'::__LINE__Var
PUBLIC	_soap_register_plugin_arg
;	COMDAT ??_C@_0FI@GBLABLCK@Could?5not?5register?5plugin?5?8?$CFs?8?3?5@
CONST	SEGMENT
??_C@_0FI@GBLABLCK@Could?5not?5register?5plugin?5?8?$CFs?8?3?5@ DB 'Could'
	DB	' not register plugin ''%s'': plugin returned error %d (or fde'
	DB	'lete callback not set)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NCONHDGE@Registered?5?8?$CFs?8?5plugin?6?$AA@
CONST	SEGMENT
??_C@_0BI@NCONHDGE@Registered?5?8?$CFs?8?5plugin?6?$AA@ DB 'Registered '''
	DB	'%s'' plugin', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??soap_register_plugin_arg@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?1??soap_register_plugin_arg@@9@4JA DD 039d0H ; `soap_register_plugin_arg'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT _soap_register_plugin_arg
_TEXT	SEGMENT
tv149 = -244						; size = 4
_fdebug$90190 = -44					; size = 4
_fdebug$90184 = -32					; size = 4
_r$ = -20						; size = 4
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_fcreate$ = 12						; size = 4
_arg$ = 16						; size = 4
_soap_register_plugin_arg PROC				; COMDAT

; 14800: { register struct soap_plugin *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14801:   register int r;
; 14802:   if (!(p = (struct soap_plugin*)SOAP_MALLOC(soap, sizeof(struct soap_plugin))))

	push	20					; 00000014H
	mov	eax, DWORD PTR ?__LINE__Var@?1??soap_register_plugin_arg@@9@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	call	_soap_track_malloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN8@soap_regis

; 14803:     return soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
	mov	eax, 20					; 00000014H
	jmp	$LN9@soap_regis
$LN8@soap_regis:

; 14804:   p->id = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], 0

; 14805:   p->data = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], 0

; 14806:   p->fcopy = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0

; 14807:   p->fdelete = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+16], 0

; 14808:   r = fcreate(soap, p, arg);

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	DWORD PTR _fcreate$[ebp]
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _r$[ebp], eax

; 14809:   if (!r && p->fdelete)

	cmp	DWORD PTR _r$[ebp], 0
	jne	$LN7@soap_regis
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN7@soap_regis

; 14810:   { p->next = soap->plugins;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _soap$[ebp]
	mov	edx, DWORD PTR [ecx+12220]
	mov	DWORD PTR [eax], edx

; 14811:     soap->plugins = p;

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12220], ecx

; 14812:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Registered '%s' plugin\n", p->id));

	cmp	DWORD PTR _soap$[ebp], 0
	je	SHORT $LN6@soap_regis
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN5@soap_regis
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN5@soap_regis:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN6@soap_regis
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$90184[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0BI@NCONHDGE@Registered?5?8?$CFs?8?5plugin?6?$AA@
	mov	edx, DWORD PTR _fdebug$90184[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$90184[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@soap_regis:

; 14813:     return SOAP_OK;

	xor	eax, eax
	jmp	$LN9@soap_regis
$LN7@soap_regis:

; 14814:   }
; 14815:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not register plugin '%s': plugin returned error %d (or fdelete callback not set)\n", p->id?p->id:"?", r));

	cmp	DWORD PTR _soap$[ebp], 0
	je	$LN3@soap_regis
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	jne	SHORT $LN2@soap_regis
	push	2
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	call	_soap_open_logfile
	add	esp, 8
$LN2@soap_regis:
	mov	eax, DWORD PTR _soap$[ebp]
	cmp	DWORD PTR [eax+90568], 0
	je	SHORT $LN3@soap_regis
	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+90568]
	mov	DWORD PTR _fdebug$90190[ebp], ecx
	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@soap_regis
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN12@soap_regis
$LN11@soap_regis:
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN12@soap_regis:
	mov	esi, esp
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv149[ebp]
	push	ecx
	push	OFFSET ??_C@_0FI@GBLABLCK@Could?5not?5register?5plugin?5?8?$CFs?8?3?5@
	mov	edx, DWORD PTR _fdebug$90190[ebp]
	push	edx
	call	DWORD PTR __imp__fprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _fdebug$90190[ebp]
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@soap_regis:

; 14816:   SOAP_FREE(soap, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??soap_register_plugin_arg@@9@4JA
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET ??_C@_0FM@PNAHPICO@c?3?2users?2crius?2documents?2visual?5@
	mov	edx, DWORD PTR _soap$[ebp]
	push	edx
	call	_soap_track_free
	add	esp, 16					; 00000010H

; 14817:   return r;

	mov	eax, DWORD PTR _r$[ebp]
$LN9@soap_regis:

; 14818: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_register_plugin_arg ENDP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT _fplugin
_TEXT	SEGMENT
_p$ = -8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_fplugin PROC						; COMDAT

; 14825: { register struct soap_plugin *p;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14826:   for (p = soap->plugins; p; p = p->next)

	mov	eax, DWORD PTR _soap$[ebp]
	mov	ecx, DWORD PTR [eax+12220]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN5@fplugin
$LN4@fplugin:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$LN5@fplugin:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@fplugin

; 14827:     if (p->id == id || !strcmp(p->id, id))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _id$[ebp]
	je	SHORT $LN1@fplugin
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@fplugin
$LN1@fplugin:

; 14828:       return p->data;

	mov	eax, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN6@fplugin
$LN2@fplugin:

; 14829:   return NULL;

	jmp	SHORT $LN4@fplugin
$LN3@fplugin:
	xor	eax, eax
$LN6@fplugin:

; 14830: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fplugin ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup_plugin
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT _soap_lookup_plugin
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_lookup_plugin PROC				; COMDAT

; 14839: { return soap->fplugin(soap, id);

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [edx+12332]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14840: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_lookup_plugin ENDP
_TEXT	ENDS
PUBLIC	??_7soap@@6B@					; soap::`vftable'
PUBLIC	??0soap@@QAE@XZ					; soap::soap
PUBLIC	??_R4soap@@6B@					; soap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUsoap@@@8				; soap `RTTI Type Descriptor'
PUBLIC	??_R3soap@@8					; soap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2soap@@8					; soap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@soap@@8				; soap::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Esoap@@UAEPAXI@Z:PROC			; soap::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@soap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@soap@@8 DD FLAT:??_R0?AUsoap@@@8		; soap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3soap@@8
rdata$r	ENDS
;	COMDAT ??_R2soap@@8
rdata$r	SEGMENT
??_R2soap@@8 DD	FLAT:??_R1A@?0A@EA@soap@@8		; soap::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3soap@@8
rdata$r	SEGMENT
??_R3soap@@8 DD	00H					; soap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2soap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUsoap@@@8
_DATA	SEGMENT
??_R0?AUsoap@@@8 DD FLAT:??_7type_info@@6B@		; soap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUsoap@@', 00H
_DATA	ENDS
;	COMDAT ??_R4soap@@6B@
rdata$r	SEGMENT
??_R4soap@@6B@ DD 00H					; soap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUsoap@@@8
	DD	FLAT:??_R3soap@@8
rdata$r	ENDS
;	COMDAT ??_7soap@@6B@
CONST	SEGMENT
??_7soap@@6B@ DD FLAT:??_R4soap@@6B@			; soap::`vftable'
	DD	FLAT:??_Esoap@@UAEPAXI@Z
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??0soap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0soap@@QAE@XZ PROC					; soap::soap, COMDAT
; _this$ = ecx

; 14856: { soap_init(this);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7soap@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_soap_init
	add	esp, 4

; 14857: }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0soap@@QAE@XZ ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	??1soap@@UAE@XZ					; soap::~soap
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??_Gsoap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gsoap@@UAEPAXI@Z PROC				; soap::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1soap@@UAE@XZ				; soap::~soap
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gsoap@@UAEPAXI@Z ENDP				; soap::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0soap@@QAE@H@Z				; soap::soap
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0soap@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_m$ = 8							; size = 4
??0soap@@QAE@H@Z PROC					; soap::soap, COMDAT
; _this$ = ecx

; 14863: { soap_init1(this, m);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7soap@@6B@
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_soap_init1
	add	esp, 8

; 14864: }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0soap@@QAE@H@Z ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	??0soap@@QAE@HH@Z				; soap::soap
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0soap@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_im$ = 8						; size = 4
_om$ = 12						; size = 4
??0soap@@QAE@HH@Z PROC					; soap::soap, COMDAT
; _this$ = ecx

; 14870: { soap_init2(this, im, om);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7soap@@6B@
	mov	eax, DWORD PTR _om$[ebp]
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	_soap_init2
	add	esp, 12					; 0000000cH

; 14871: }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0soap@@QAE@HH@Z ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	??0soap@@QAE@AAU0@@Z				; soap::soap
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0soap@@QAE@AAU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_soap$ = 8						; size = 4
??0soap@@QAE@AAU0@@Z PROC				; soap::soap, COMDAT
; _this$ = ecx

; 14877: { soap_copy_context(this, &soap);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7soap@@6B@
	mov	eax, DWORD PTR _soap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_soap_copy_context
	add	esp, 8

; 14878: }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0soap@@QAE@AAU0@@Z ENDP				; soap::soap
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1soap@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1soap@@UAE@XZ PROC					; soap::~soap, COMDAT
; _this$ = ecx

; 14884: { soap_destroy(this);

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7soap@@6B@
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_soap_delete
	add	esp, 8

; 14885:   soap_end(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_soap_end
	add	esp, 4

; 14886:   soap_done(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_soap_done
	add	esp, 4

; 14887: }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1soap@@UAE@XZ ENDP					; soap::~soap
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z:PROC
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:PROC
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?length@?$char_traits@D@std@@SAIPBD@Z:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv293 = -337						; size = 1
tv286 = -337						; size = 1
tv292 = -336						; size = 4
tv285 = -336						; size = 4
tv291 = -332						; size = 4
tv284 = -332						; size = 4
tv290 = -328						; size = 4
tv288 = -328						; size = 4
tv283 = -328						; size = 4
tv287 = -324						; size = 4
tv136 = -324						; size = 4
tv134 = -324						; size = 4
tv289 = -321						; size = 1
tv282 = -321						; size = 1
$T98335 = -316						; size = 4
$T98336 = -304						; size = 4
$T98337 = -292						; size = 4
$T98338 = -280						; size = 4
$T98339 = -268						; size = 4
__Ok$ = -64						; size = 8
__Pad$ = -48						; size = 4
__Count$ = -36						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 741  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 742  : 	typedef char _Elem;
; 743  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 744  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 745  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	esi, esp
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	DWORD PTR __imp_?length@?$char_traits@D@std@@SAIPBD@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Count$[ebp], eax

; 746  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 747  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jle	SHORT $LN17@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Count$[ebp]
	jle	SHORT $LN17@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	DWORD PTR tv134[ebp], 0
$LN18@operator:
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 748  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 749  : 
; 750  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@operator

; 751  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 752  : 	else

	jmp	$LN13@operator
$LN14@operator:

; 753  : 		{	// state okay, insert
; 754  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 755  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv136[ebp], eax
	mov	eax, DWORD PTR tv136[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator
	jmp	SHORT $LN10@operator
$LN9@operator:

; 756  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN10@operator:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	$LN11@operator

; 757  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 758  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv282[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv283[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv282[ebp]
	push	eax
	mov	ecx, DWORD PTR tv283[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T98335[ebp], ecx
	mov	esi, esp
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	edx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T98336[ebp], edx
	mov	esi, esp
	lea	eax, DWORD PTR $T98335[ebp]
	push	eax
	lea	ecx, DWORD PTR $T98336[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv286[ebp], al
	movzx	edx, BYTE PTR tv286[ebp]
	test	edx, edx
	je	SHORT $LN7@operator

; 759  : 					{	// insertion failed, quit
; 760  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 761  : 					break;

	jmp	SHORT $LN11@operator
$LN7@operator:

; 762  : 					}
; 763  : 
; 764  : 		if (_State == ios_base::goodbit

	jmp	$LN9@operator
$LN11@operator:

; 765  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN6@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	edx, DWORD PTR tv288[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $LN6@operator

; 766  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator:

; 767  : 
; 768  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN5@operator
	jmp	SHORT $LN4@operator
$LN3@operator:

; 769  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	$LN5@operator

; 770  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 771  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv289[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T98337[ebp], ecx
	mov	esi, esp
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv292[ebp], eax
	mov	edx, DWORD PTR tv292[ebp]
	mov	DWORD PTR $T98338[ebp], edx
	mov	esi, esp
	lea	eax, DWORD PTR $T98337[ebp]
	push	eax
	lea	ecx, DWORD PTR $T98338[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv293[ebp], al
	movzx	edx, BYTE PTR tv293[ebp]
	test	edx, edx
	je	SHORT $LN1@operator

; 772  : 					{	// insertion failed, quit
; 773  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 774  : 					break;

	jmp	SHORT $LN5@operator
$LN1@operator:

; 775  : 					}

	jmp	$LN3@operator
$LN5@operator:

; 776  : 		_Ostr.width(0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 777  : 		_CATCH_IO_(_Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN13@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator:

; 778  : 		}
; 779  : 
; 780  : 	_Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 781  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T98339[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T98339[ebp]

; 782  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@operator:
	DD	1
	DD	$LN27@operator
$LN27@operator:
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN25@operator
$LN25@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@sentry

; 97   : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 99   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 102  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	mov	esi, esp
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry@2

; 106  : 				this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sentry@2:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 115  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 117  : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 77   : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 78   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 81   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas@2

; 83   : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas@2:

; 84   : 			}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
END
