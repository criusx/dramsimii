; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\fbdChannel.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?value@integral_c_tag@mpl@boost@@2HB		; boost::mpl::integral_c_tag::value
PUBLIC	?value@?$bool_@$00@mpl@boost@@2_NB		; boost::mpl::bool_<1>::value
PUBLIC	?value@?$bool_@$0A@@mpl@boost@@2_NB		; boost::mpl::bool_<0>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::const_min
PUBLIC	?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::const_max
PUBLIC	?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<char,-128,127>::is_integral
PUBLIC	?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB ; boost::detail::integer_traits_base<char,-128,127>::const_min
PUBLIC	?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB ; boost::detail::integer_traits_base<char,-128,127>::const_max
PUBLIC	?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<signed char,-128,127>::is_integral
PUBLIC	?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB ; boost::detail::integer_traits_base<signed char,-128,127>::const_min
PUBLIC	?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB ; boost::detail::integer_traits_base<signed char,-128,127>::const_max
PUBLIC	?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned char,0,255>::is_integral
PUBLIC	?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB ; boost::detail::integer_traits_base<unsigned char,0,255>::const_min
PUBLIC	?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB ; boost::detail::integer_traits_base<unsigned char,0,255>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<wchar_t,0,65535>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_min
PUBLIC	?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_max
PUBLIC	?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<short,-32768,32767>::is_integral
PUBLIC	?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB ; boost::detail::integer_traits_base<short,-32768,32767>::const_min
PUBLIC	?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB ; boost::detail::integer_traits_base<short,-32768,32767>::const_max
PUBLIC	?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned short,0,65535>::is_integral
PUBLIC	?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_min
PUBLIC	?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_max
PUBLIC	?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::is_integral
PUBLIC	?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_min
PUBLIC	?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_max
PUBLIC	?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::is_integral
PUBLIC	?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_min
PUBLIC	?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_max
PUBLIC	?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::is_integral
PUBLIC	?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_min
PUBLIC	?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_max
PUBLIC	?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::is_integral
PUBLIC	?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_min
PUBLIC	?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_min
PUBLIC	?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_min
PUBLIC	?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_max
PUBLIC	?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB ; boost::type_traits::ice_or<0,0,0,0,0,0,0>::value
PUBLIC	?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB ; boost::type_traits::ice_and<1,1,1,1,1,1,1>::value
PUBLIC	?value@?$ice_not@$00@type_traits@boost@@2_NB	; boost::type_traits::ice_not<1>::value
PUBLIC	?value@?$is_convertible_impl@XX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void>::value
PUBLIC	?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void const >::value
PUBLIC	?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void const volatile >::value
PUBLIC	?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<1>::type::value
PUBLIC	?value@?$select_by_size@$00@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<1>::value
PUBLIC	?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<2>::type::value
PUBLIC	?value@?$select_by_size@$01@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<2>::value
PUBLIC	?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<3>::type::value
PUBLIC	?value@?$select_by_size@$02@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<3>::value
PUBLIC	?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<4>::type::value
PUBLIC	?value@?$select_by_size@$03@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<4>::value
PUBLIC	?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<5>::type::value
PUBLIC	?value@?$select_by_size@$04@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<5>::value
PUBLIC	?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<6>::type::value
PUBLIC	?value@?$select_by_size@$05@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<6>::value
PUBLIC	?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<7>::type::value
PUBLIC	?value@?$select_by_size@$06@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<7>::value
PUBLIC	?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<8>::type::value
PUBLIC	?value@?$select_by_size@$07@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<8>::value
PUBLIC	?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<9>::type::value
PUBLIC	?value@?$select_by_size@$08@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<9>::value
PUBLIC	?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<10>::type::value
PUBLIC	?value@?$select_by_size@$09@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<10>::value
PUBLIC	?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<11>::type::value
PUBLIC	?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<11>::value
PUBLIC	?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<12>::type::value
PUBLIC	?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<12>::value
PUBLIC	?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<13>::type::value
PUBLIC	?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<13>::value
PUBLIC	?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<14>::type::value
PUBLIC	?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<14>::value
PUBLIC	?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<15>::type::value
PUBLIC	?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<15>::value
PUBLIC	?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<16>::type::value
PUBLIC	?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<16>::value
PUBLIC	?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<17>::type::value
PUBLIC	?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<17>::value
PUBLIC	?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<18>::type::value
PUBLIC	?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<18>::value
PUBLIC	?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<19>::type::value
PUBLIC	?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<19>::value
PUBLIC	?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<20>::type::value
PUBLIC	?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<20>::value
PUBLIC	?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<21>::type::value
PUBLIC	?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<21>::value
PUBLIC	?value@?$int_@$00@mpl@boost@@2HB		; boost::mpl::int_<1>::value
PUBLIC	?value@?$int_@$01@mpl@boost@@2HB		; boost::mpl::int_<2>::value
PUBLIC	?value@?$int_@$02@mpl@boost@@2HB		; boost::mpl::int_<3>::value
PUBLIC	?value@?$int_@$03@mpl@boost@@2HB		; boost::mpl::int_<4>::value
PUBLIC	?value@?$int_@$04@mpl@boost@@2HB		; boost::mpl::int_<5>::value
PUBLIC	?value@?$int_@$05@mpl@boost@@2HB		; boost::mpl::int_<6>::value
PUBLIC	?value@?$int_@$06@mpl@boost@@2HB		; boost::mpl::int_<7>::value
PUBLIC	?value@?$int_@$07@mpl@boost@@2HB		; boost::mpl::int_<8>::value
PUBLIC	?value@?$int_@$08@mpl@boost@@2HB		; boost::mpl::int_<9>::value
PUBLIC	?value@?$int_@$09@mpl@boost@@2HB		; boost::mpl::int_<10>::value
PUBLIC	?value@?$int_@$0L@@mpl@boost@@2HB		; boost::mpl::int_<11>::value
PUBLIC	?value@?$int_@$0M@@mpl@boost@@2HB		; boost::mpl::int_<12>::value
PUBLIC	?value@?$arg@$0?0@mpl@boost@@2HB		; boost::mpl::arg<-1>::value
PUBLIC	?value@?$arg@$00@mpl@boost@@2HB			; boost::mpl::arg<1>::value
PUBLIC	?value@?$arg@$01@mpl@boost@@2HB			; boost::mpl::arg<2>::value
PUBLIC	?value@?$arg@$02@mpl@boost@@2HB			; boost::mpl::arg<3>::value
PUBLIC	?value@?$arg@$03@mpl@boost@@2HB			; boost::mpl::arg<4>::value
PUBLIC	?value@?$arg@$04@mpl@boost@@2HB			; boost::mpl::arg<5>::value
PUBLIC	?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void>::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void const >::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void volatile >::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void const volatile >::value
PUBLIC	?value@?$is_scalar_impl@X@detail@boost@@2_NB	; boost::detail::is_scalar_impl<void>::value
PUBLIC	?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void const >::value
PUBLIC	?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void volatile >::value
PUBLIC	?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void const volatile >::value
PUBLIC	?value@?$is_pod_impl@X@detail@boost@@2_NB	; boost::detail::is_pod_impl<void>::value
PUBLIC	?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void const >::value
PUBLIC	?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void volatile >::value
PUBLIC	?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void const volatile >::value
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_c@I$0A@@mpl@boost@@2IB	; boost::mpl::integral_c<unsigned int,0>::value
PUBLIC	?value@?$alignment_logic@$07$07@detail@boost@@2IB ; boost::detail::alignment_logic<8,8>::value
PUBLIC	?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB ; boost::detail::alignment_of_impl<boost::detail::max_align>::value
PUBLIC	?value@?$integral_c@I$07@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,8>::value
PUBLIC	?value@?$alignment_logic@$00$00@detail@boost@@2IB ; boost::detail::alignment_logic<1,1>::value
PUBLIC	?value@?$alignment_of_impl@D@detail@boost@@2IB	; boost::detail::alignment_of_impl<char>::value
PUBLIC	?value@?$integral_c@I$00@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,1>::value
PUBLIC	?value@?$alignment_logic@$01$01@detail@boost@@2IB ; boost::detail::alignment_logic<2,2>::value
PUBLIC	?value@?$alignment_of_impl@F@detail@boost@@2IB	; boost::detail::alignment_of_impl<short>::value
PUBLIC	?value@?$integral_c@I$01@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,2>::value
PUBLIC	?value@?$alignment_logic@$03$03@detail@boost@@2IB ; boost::detail::alignment_logic<4,4>::value
PUBLIC	?value@?$alignment_of_impl@H@detail@boost@@2IB	; boost::detail::alignment_of_impl<int>::value
PUBLIC	?value@?$integral_c@I$03@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,4>::value
PUBLIC	?value@?$alignment_of_impl@J@detail@boost@@2IB	; boost::detail::alignment_of_impl<long>::value
PUBLIC	?value@?$alignment_of_impl@_J@detail@boost@@2IB	; boost::detail::alignment_of_impl<__int64>::value
PUBLIC	?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB ; boost::detail::alignment_of_impl<boost::detail::lower_alignment<8> >::value
PUBLIC	?value@?$is_aligned@$07$07@detail@boost@@2_NB	; boost::detail::is_aligned<8,8>::value
PUBLIC	?found@?$type_with_alignment_imp@$07@detail@boost@@0IB ; boost::detail::type_with_alignment_imp<8>::found
PUBLIC	?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a8>::value
PUBLIC	?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a16>::value
PUBLIC	?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a32>::value
PUBLIC	?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a64>::value
PUBLIC	?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a128>::value
PUBLIC	?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::serialization::collection_size_type>::value
PUBLIC	?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<bool,std::allocator<bool> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<char,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<signed char,std::allocator<signed char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned char,std::allocator<unsigned char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<int,std::allocator<int> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned int,std::allocator<unsigned int> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<long,std::allocator<long> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned long,std::allocator<unsigned long> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<float,std::allocator<float> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<double,std::allocator<double> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned short,std::allocator<unsigned short> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<short,std::allocator<short> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<__int64,std::allocator<__int64> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned __int64,std::allocator<unsigned __int64> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<wchar_t,std::allocator<wchar_t> > >::value
PUBLIC	?has_fixed_range@rand48@boost@@2_NB		; boost::rand48::has_fixed_range
PUBLIC	?min_value@rand48@boost@@2JB			; boost::rand48::min_value
PUBLIC	?max_value@rand48@boost@@2JB			; boost::rand48::max_value
PUBLIC	?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::min_value
PUBLIC	?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::multiplier
PUBLIC	?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::increment
PUBLIC	?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::modulus
PUBLIC	?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::min_value
PUBLIC	?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::multiplier
PUBLIC	?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::increment
PUBLIC	?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::modulus
PUBLIC	?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::min_value
PUBLIC	?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::multiplier
PUBLIC	?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::increment
PUBLIC	?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::modulus
PUBLIC	?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,607,273>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,1279,418>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,2281,1252>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,3217,576>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,4423,2098>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,9689,5502>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,19937,9842>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,23209,13470>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,44497,21034>::is_specialized
PUBLIC	?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::has_fixed_range
PUBLIC	?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::word_size
PUBLIC	?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent1
PUBLIC	?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent2
PUBLIC	?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::step_size
PUBLIC	?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::has_fixed_range
PUBLIC	?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift1
PUBLIC	?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift2
PUBLIC	?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::has_fixed_range
PUBLIC	?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::word_size
PUBLIC	?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent1
PUBLIC	?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent2
PUBLIC	?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::step_size
PUBLIC	?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::iostreams::input>::value
PUBLIC	?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::iostreams::input>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::input>::value
PUBLIC	?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB ; boost::type_traits::ice_or<1,0,0,0,0,0,0>::value
PUBLIC	?value@?$ice_not@$0A@@type_traits@boost@@2_NB	; boost::type_traits::ice_not<0>::value
PUBLIC	?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::input>::value
PUBLIC	?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::iostreams::output>::value
PUBLIC	?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::iostreams::output>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::output>::value
PUBLIC	?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB ; boost::type_traits::ice_and<0,1,1,1,1,1,1>::value
PUBLIC	?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::output>::value
PUBLIC	?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::word_size
PUBLIC	?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::state_size
PUBLIC	?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::shift_size
PUBLIC	?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::mask_bits
PUBLIC	?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::parameter_a
PUBLIC	?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_u
PUBLIC	?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_s
PUBLIC	?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_b
PUBLIC	?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_t
PUBLIC	?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_c
PUBLIC	?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_l
PUBLIC	?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::has_fixed_range
PUBLIC	?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB ; boost::detail::cv_traits_imp<int *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB ; boost::detail::cv_traits_imp<int *>::is_volatile
PUBLIC	?value@?$is_ununsigned_helper@H@detail@boost@@2_NB ; boost::detail::is_ununsigned_helper<int>::value
PUBLIC	?value@?$is_unsigned_imp@H@detail@boost@@2_NB	; boost::detail::is_unsigned_imp<int>::value
PUBLIC	?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> &>,double>::has_fixed_range
PUBLIC	?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> >,double>::has_fixed_range
PUBLIC	?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<bool,std::allocator<bool> > >::value
PUBLIC	?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<char,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<signed char,std::allocator<signed char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned char,std::allocator<unsigned char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<int,std::allocator<int> > >::value
PUBLIC	?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned int,std::allocator<unsigned int> > >::value
PUBLIC	?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<long,std::allocator<long> > >::value
PUBLIC	?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned long,std::allocator<unsigned long> > >::value
PUBLIC	?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<float,std::allocator<float> > >::value
PUBLIC	?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<double,std::allocator<double> > >::value
PUBLIC	?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned short,std::allocator<unsigned short> > >::value
PUBLIC	?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<short,std::allocator<short> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<__int64,std::allocator<__int64> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned __int64,std::allocator<unsigned __int64> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<wchar_t,std::allocator<wchar_t> > >::value
PUBLIC	?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::version_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_reference_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_optional_type>::value
PUBLIC	?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_name_type>::value
PUBLIC	?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::object_id_type>::value
PUBLIC	?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::object_reference_type>::value
PUBLIC	?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::tracking_type>::value
PUBLIC	?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::value
PUBLIC	?value@?$int_@$0A@@mpl@boost@@2HB		; boost::mpl::int_<0>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::output &,boost::iostreams::input>::value
PUBLIC	?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::output,boost::iostreams::input>::value
PUBLIC	?value@?$is_empty_impl@X@detail@boost@@2_NB	; boost::detail::is_empty_impl<void>::value
PUBLIC	?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const >::value
PUBLIC	?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void volatile >::value
PUBLIC	?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const volatile >::value
PUBLIC	?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
PUBLIC	?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
PUBLIC	?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@_J@detail@boost@@2_NB ; boost::detail::is_pointer_helper<__int64>::value
PUBLIC	?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
PUBLIC	?value@?$is_pointer_impl@_J@detail@boost@@2_NB	; boost::detail::is_pointer_impl<__int64>::value
PUBLIC	?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<__int64>::value
PUBLIC	?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
PUBLIC	?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_volatile
PUBLIC	?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_volatile
PUBLIC	?value@?$is_abstract_imp@D@detail@boost@@2_NB	; boost::detail::is_abstract_imp<char>::value
PUBLIC	?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_volatile
PUBLIC	?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::tracking_type>::value
PUBLIC	?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::tracking_type>::value
PUBLIC	?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::tracking_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::version_type>::value
PUBLIC	?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::version_type>::value
PUBLIC	?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::version_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::object_id_type>::value
PUBLIC	?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::object_id_type>::value
PUBLIC	?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::object_id_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::class_id_type>::value
PUBLIC	?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::class_id_type>::value
PUBLIC	?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::class_id_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB ; boost::detail::cv_traits_imp<unsigned int *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB ; boost::detail::cv_traits_imp<unsigned int *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@I@detail@boost@@2_NB	; boost::detail::is_pointer_helper<unsigned int>::value
PUBLIC	?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<unsigned int>::value
PUBLIC	?value@?$is_pointer_impl@I@detail@boost@@2_NB	; boost::detail::is_pointer_impl<unsigned int>::value
PUBLIC	?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,unsigned int>::value
PUBLIC	?value@?$is_arithmetic_impl@I@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<unsigned int>::value
PUBLIC	?value@?$implementation_level@I@serialization@boost@@2HB ; boost::serialization::implementation_level<unsigned int>::value
PUBLIC	?value@?$is_pointer_helper@H@detail@boost@@2_NB	; boost::detail::is_pointer_helper<int>::value
PUBLIC	?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<int>::value
PUBLIC	?value@?$is_pointer_impl@H@detail@boost@@2_NB	; boost::detail::is_pointer_impl<int>::value
PUBLIC	?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,int>::value
PUBLIC	?value@?$is_arithmetic_impl@H@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<int>::value
PUBLIC	?value@?$implementation_level@H@serialization@boost@@2HB ; boost::serialization::implementation_level<int>::value
PUBLIC	?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
;	COMDAT ?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@H@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@H@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@H@detail@boost@@2_NB DB 01H	; boost::detail::is_arithmetic_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB DB 00H ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@H@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@H@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<int>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@I@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@I@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@I@detail@boost@@2_NB DB 01H	; boost::detail::is_arithmetic_impl<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB DB 00H ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@I@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@I@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<unsigned int>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<unsigned int *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB DB 00H	; boost::detail::cv_traits_imp<unsigned int *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_const
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@D@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@D@detail@boost@@2_NB DB 00H	; boost::detail::is_abstract_imp<char>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_const
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 01H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_const
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB DD 01H ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB DB 01H ; boost::detail::is_arithmetic_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<__int64>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_const
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@X@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::iostreams::output,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::iostreams::output &,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0A@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0A@@mpl@boost@@2HB DD 00H		; boost::mpl::int_<0>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::object_reference_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_name_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_optional_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_reference_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<wchar_t,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned __int64,std::allocator<unsigned __int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<__int64,std::allocator<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<short,std::allocator<short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned short,std::allocator<unsigned short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<double,std::allocator<double> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<float,std::allocator<float> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned long,std::allocator<unsigned long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<long,std::allocator<long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned int,std::allocator<unsigned int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<int,std::allocator<int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned char,std::allocator<unsigned char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<signed char,std::allocator<signed char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<char,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<bool,std::allocator<bool> > >::value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB DB 00H ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> >,double>::has_fixed_range
CONST	ENDS
;	COMDAT ?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB DB 00H ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> &>,double>::has_fixed_range
CONST	ENDS
;	COMDAT ?value@?$is_unsigned_imp@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_unsigned_imp@H@detail@boost@@2_NB DB 00H	; boost::detail::is_unsigned_imp<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_ununsigned_helper@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_ununsigned_helper@H@detail@boost@@2_NB DB 00H ; boost::detail::is_ununsigned_helper<int>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<int *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB DB 00H	; boost::detail::cv_traits_imp<int *>::is_const
CONST	ENDS
;	COMDAT ?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB DB 00H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::has_fixed_range
CONST	ENDS
;	COMDAT ?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 012H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_l
CONST	ENDS
;	COMDAT ?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 0efc60000H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_c
CONST	ENDS
;	COMDAT ?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0fH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_t
CONST	ENDS
;	COMDAT ?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 09d2c5680H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_b
CONST	ENDS
;	COMDAT ?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 07H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_s
CONST	ENDS
;	COMDAT ?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0bH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_u
CONST	ENDS
;	COMDAT ?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 09908b0dfH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::parameter_a
CONST	ENDS
;	COMDAT ?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 01fH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::mask_bits
CONST	ENDS
;	COMDAT ?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 018dH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::shift_size
CONST	ENDS
;	COMDAT ?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0270H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::state_size
CONST	ENDS
;	COMDAT ?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 020H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::word_size
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB DB 00H ; boost::type_traits::ice_and<0,1,1,1,1,1,1>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$ice_not@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_not@$0A@@type_traits@boost@@2_NB DB 01H	; boost::type_traits::ice_not<0>::value
CONST	ENDS
;	COMDAT ?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB DB 01H ; boost::type_traits::ice_or<1,0,0,0,0,0,0>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 04H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::step_size
CONST	ENDS
;	COMDAT ?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 02H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent2
CONST	ENDS
;	COMDAT ?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 01dH ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent1
CONST	ENDS
;	COMDAT ?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 020H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::word_size
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB DB 00H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB
CONST	SEGMENT
?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB DD 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift2
CONST	ENDS
;	COMDAT ?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB
CONST	SEGMENT
?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB DD 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift1
CONST	ENDS
;	COMDAT ?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB DB 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 0cH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::step_size
CONST	ENDS
;	COMDAT ?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 0dH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent2
CONST	ENDS
;	COMDAT ?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 01fH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent1
CONST	ENDS
;	COMDAT ?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 020H ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::word_size
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB DB 00H ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,44497,21034>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,23209,13470>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,19937,9842>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,9689,5502>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,4423,2098>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,3217,576>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,2281,1252>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,1279,418>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,607,273>::is_specialized
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0ae529H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 024d69H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0556H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0ae528H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 00H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 07fffffabH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 00H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 09c4eH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 07fffffaaH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 01H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0001000000000000H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 000000000000000bH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 00000005deece66dH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0000ffffffffffffH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0000000000000000H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?max_value@rand48@boost@@2JB
CONST	SEGMENT
?max_value@rand48@boost@@2JB DD 07fffffffH		; boost::rand48::max_value
CONST	ENDS
;	COMDAT ?min_value@rand48@boost@@2JB
CONST	SEGMENT
?min_value@rand48@boost@@2JB DD 00H			; boost::rand48::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@rand48@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@rand48@boost@@2_NB DB 01H		; boost::rand48::has_fixed_range
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<wchar_t,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned __int64,std::allocator<unsigned __int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<__int64,std::allocator<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<short,std::allocator<short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned short,std::allocator<unsigned short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<double,std::allocator<double> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<float,std::allocator<float> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned long,std::allocator<unsigned long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<long,std::allocator<long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned int,std::allocator<unsigned int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<int,std::allocator<int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned char,std::allocator<unsigned char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<signed char,std::allocator<signed char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<char,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<bool,std::allocator<bool> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::serialization::collection_size_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a128>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a32>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a16>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a8>::value
CONST	ENDS
;	COMDAT ?found@?$type_with_alignment_imp@$07@detail@boost@@0IB
CONST	SEGMENT
?found@?$type_with_alignment_imp@$07@detail@boost@@0IB DD 08H ; boost::detail::type_with_alignment_imp<8>::found
CONST	ENDS
;	COMDAT ?value@?$is_aligned@$07$07@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_aligned@$07$07@detail@boost@@2_NB DB 01H	; boost::detail::is_aligned<8,8>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB DD 08H ; boost::detail::alignment_of_impl<boost::detail::lower_alignment<8> >::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@_J@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@_J@detail@boost@@2IB DD 08H	; boost::detail::alignment_of_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@J@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@J@detail@boost@@2IB DD 04H	; boost::detail::alignment_of_impl<long>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$03@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$03@mpl@boost@@2IB DD 04H		; boost::mpl::integral_c<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@H@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@H@detail@boost@@2IB DD 04H	; boost::detail::alignment_of_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$03$03@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$03$03@detail@boost@@2IB DD 04H ; boost::detail::alignment_logic<4,4>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$01@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$01@mpl@boost@@2IB DD 02H		; boost::mpl::integral_c<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@F@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@F@detail@boost@@2IB DD 02H	; boost::detail::alignment_of_impl<short>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$01$01@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$01$01@detail@boost@@2IB DD 02H ; boost::detail::alignment_logic<2,2>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$00@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$00@mpl@boost@@2IB DD 01H		; boost::mpl::integral_c<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@D@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@D@detail@boost@@2IB DD 01H	; boost::detail::alignment_of_impl<char>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$00$00@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$00$00@detail@boost@@2IB DD 01H ; boost::detail::alignment_logic<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$07@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$07@mpl@boost@@2IB DD 08H		; boost::mpl::integral_c<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB DD 08H ; boost::detail::alignment_of_impl<boost::detail::max_align>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$07$07@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$07$07@detail@boost@@2IB DD 08H ; boost::detail::alignment_logic<8,8>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$0A@@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$0A@@mpl@boost@@2IB DD 00H		; boost::mpl::integral_c<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@X@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@X@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$04@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$04@mpl@boost@@2HB DD 05H			; boost::mpl::arg<5>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$03@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$03@mpl@boost@@2HB DD 04H			; boost::mpl::arg<4>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$02@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$02@mpl@boost@@2HB DD 03H			; boost::mpl::arg<3>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$01@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$01@mpl@boost@@2HB DD 02H			; boost::mpl::arg<2>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$00@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$00@mpl@boost@@2HB DD 01H			; boost::mpl::arg<1>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$0?0@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$0?0@mpl@boost@@2HB DD 0ffffffffH		; boost::mpl::arg<-1>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0M@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0M@@mpl@boost@@2HB DD 0cH		; boost::mpl::int_<12>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0L@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0L@@mpl@boost@@2HB DD 0bH		; boost::mpl::int_<11>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$09@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$09@mpl@boost@@2HB DD 0aH			; boost::mpl::int_<10>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$08@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$08@mpl@boost@@2HB DD 09H			; boost::mpl::int_<9>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$07@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$07@mpl@boost@@2HB DD 08H			; boost::mpl::int_<8>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$06@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$06@mpl@boost@@2HB DD 07H			; boost::mpl::int_<7>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$05@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$05@mpl@boost@@2HB DD 06H			; boost::mpl::int_<6>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$04@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$04@mpl@boost@@2HB DD 05H			; boost::mpl::int_<5>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$03@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$03@mpl@boost@@2HB DD 04H			; boost::mpl::int_<4>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$02@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$02@mpl@boost@@2HB DD 03H			; boost::mpl::int_<3>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$01@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$01@mpl@boost@@2HB DD 02H			; boost::mpl::int_<2>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$00@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$00@mpl@boost@@2HB DD 01H			; boost::mpl::int_<1>::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB DD 013H ; boost::iostreams::detail::select_by_size<21>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB DD 013H ; boost::iostreams::detail::select_by_size<21>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB DD 012H ; boost::iostreams::detail::select_by_size<20>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB DD 012H ; boost::iostreams::detail::select_by_size<20>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB DD 011H ; boost::iostreams::detail::select_by_size<19>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB DD 011H ; boost::iostreams::detail::select_by_size<19>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB DD 010H ; boost::iostreams::detail::select_by_size<18>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB DD 010H ; boost::iostreams::detail::select_by_size<18>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB DD 0fH ; boost::iostreams::detail::select_by_size<17>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB DD 0fH ; boost::iostreams::detail::select_by_size<17>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB DD 0eH ; boost::iostreams::detail::select_by_size<16>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB DD 0eH ; boost::iostreams::detail::select_by_size<16>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB DD 0dH ; boost::iostreams::detail::select_by_size<15>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB DD 0dH ; boost::iostreams::detail::select_by_size<15>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB DD 0cH ; boost::iostreams::detail::select_by_size<14>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB DD 0cH ; boost::iostreams::detail::select_by_size<14>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB DD 0bH ; boost::iostreams::detail::select_by_size<13>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB DD 0bH ; boost::iostreams::detail::select_by_size<13>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB DD 0aH ; boost::iostreams::detail::select_by_size<12>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB DD 0aH ; boost::iostreams::detail::select_by_size<12>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB DD 09H ; boost::iostreams::detail::select_by_size<11>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB DD 09H ; boost::iostreams::detail::select_by_size<11>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$09@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$09@detail@iostreams@boost@@2HB DD 08H ; boost::iostreams::detail::select_by_size<10>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB DD 08H ; boost::iostreams::detail::select_by_size<10>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$08@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$08@detail@iostreams@boost@@2HB DD 07H ; boost::iostreams::detail::select_by_size<9>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB DD 07H ; boost::iostreams::detail::select_by_size<9>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$07@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$07@detail@iostreams@boost@@2HB DD 06H ; boost::iostreams::detail::select_by_size<8>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB DD 06H ; boost::iostreams::detail::select_by_size<8>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$06@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$06@detail@iostreams@boost@@2HB DD 05H ; boost::iostreams::detail::select_by_size<7>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB DD 05H ; boost::iostreams::detail::select_by_size<7>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$05@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$05@detail@iostreams@boost@@2HB DD 04H ; boost::iostreams::detail::select_by_size<6>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB DD 04H ; boost::iostreams::detail::select_by_size<6>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$04@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$04@detail@iostreams@boost@@2HB DD 03H ; boost::iostreams::detail::select_by_size<5>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB DD 03H ; boost::iostreams::detail::select_by_size<5>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$03@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$03@detail@iostreams@boost@@2HB DD 02H ; boost::iostreams::detail::select_by_size<4>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB DD 02H ; boost::iostreams::detail::select_by_size<4>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$02@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$02@detail@iostreams@boost@@2HB DD 01H ; boost::iostreams::detail::select_by_size<3>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB DD 01H ; boost::iostreams::detail::select_by_size<3>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$01@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$01@detail@iostreams@boost@@2HB DD 00H ; boost::iostreams::detail::select_by_size<2>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB DD 00H ; boost::iostreams::detail::select_by_size<2>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$00@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$00@detail@iostreams@boost@@2HB DD 0ffffffffH ; boost::iostreams::detail::select_by_size<1>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB DD 0ffffffffH ; boost::iostreams::detail::select_by_size<1>::type::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@XX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@XX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void>::value
CONST	ENDS
;	COMDAT ?value@?$ice_not@$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_not@$00@type_traits@boost@@2_NB DB 00H	; boost::type_traits::ice_not<1>::value
CONST	ENDS
;	COMDAT ?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB DB 01H ; boost::type_traits::ice_and<1,1,1,1,1,1,1>::value
CONST	ENDS
;	COMDAT ?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB DB 00H ; boost::type_traits::ice_or<0,0,0,0,0,0,0>::value
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB
CONST	SEGMENT
?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB DQ ffffffffffffffffH ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB
CONST	SEGMENT
?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB DQ 0000000000000000H ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB
CONST	SEGMENT
?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB DQ 7fffffffffffffffH ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB
CONST	SEGMENT
?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB DQ 8000000000000000H ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB
CONST	SEGMENT
?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB DD 0ffffffffH ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB
CONST	SEGMENT
?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB DD 00H ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB
CONST	SEGMENT
?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB DD 07fffffffH ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB
CONST	SEGMENT
?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB DD 080000000H ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB
CONST	SEGMENT
?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB DD 0ffffffffH ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB
CONST	SEGMENT
?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB DD 00H ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB
CONST	SEGMENT
?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB DD 07fffffffH ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB
CONST	SEGMENT
?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB DD 080000000H ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB
CONST	SEGMENT
?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB DW 0ffffH ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB
CONST	SEGMENT
?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB DW 00H ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned short,0,65535>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB
CONST	SEGMENT
?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB DW 07fffH ; boost::detail::integer_traits_base<short,-32768,32767>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB
CONST	SEGMENT
?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB DW 08000H ; boost::detail::integer_traits_base<short,-32768,32767>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<short,-32768,32767>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB
CONST	SEGMENT
?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB DW 0ffffH ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB
CONST	SEGMENT
?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB DW 00H ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<wchar_t,0,65535>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB
CONST	SEGMENT
?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB DB 0ffH ; boost::detail::integer_traits_base<unsigned char,0,255>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB
CONST	SEGMENT
?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB DB 00H ; boost::detail::integer_traits_base<unsigned char,0,255>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned char,0,255>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB
CONST	SEGMENT
?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB DB 07fH ; boost::detail::integer_traits_base<signed char,-128,127>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB
CONST	SEGMENT
?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB DB 080H ; boost::detail::integer_traits_base<signed char,-128,127>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<signed char,-128,127>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB
CONST	SEGMENT
?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB DB 07fH ; boost::detail::integer_traits_base<char,-128,127>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB
CONST	SEGMENT
?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB DB 080H ; boost::detail::integer_traits_base<char,-128,127>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<char,-128,127>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<bool,0,1>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 00H ; boost::detail::integer_traits_base<bool,0,1>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<bool,0,1>::is_integral
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$bool_@$0A@@mpl@boost@@2_NB
CONST	SEGMENT
?value@?$bool_@$0A@@mpl@boost@@2_NB DB 00H		; boost::mpl::bool_<0>::value
CONST	ENDS
;	COMDAT ?value@?$bool_@$00@mpl@boost@@2_NB
CONST	SEGMENT
?value@?$bool_@$00@mpl@boost@@2_NB DB 01H		; boost::mpl::bool_<1>::value
CONST	ENDS
;	COMDAT ?value@integral_c_tag@mpl@boost@@2HB
CONST	SEGMENT
?value@integral_c_tag@mpl@boost@@2HB DD 00H		; boost::mpl::integral_c_tag::value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
PUBLIC	??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>
PUBLIC	??_7fbdChannel@DRAMsimII@@6B@			; DRAMsimII::fbdChannel::`vftable'
PUBLIC	??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::fbdChannel::fbdChannel
PUBLIC	??_R4fbdChannel@DRAMsimII@@6B@			; DRAMsimII::fbdChannel::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfbdChannel@DRAMsimII@@@8		; DRAMsimII::fbdChannel `RTTI Type Descriptor'
PUBLIC	??_R3fbdChannel@DRAMsimII@@8			; DRAMsimII::fbdChannel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2fbdChannel@DRAMsimII@@8			; DRAMsimII::fbdChannel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8		; DRAMsimII::fbdChannel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EN@Channel@DRAMsimII@@8		; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,77)'
PUBLIC	??_R0?AVChannel@DRAMsimII@@@8			; DRAMsimII::Channel `RTTI Type Descriptor'
PUBLIC	??_R3Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Channel@DRAMsimII@@8		; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::fbdChannel::minProtocolGap
EXTRN	??1Channel@DRAMsimII@@UAE@XZ:PROC		; DRAMsimII::Channel::~Channel
EXTRN	??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z:PROC ; DRAMsimII::Channel::Channel
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ:PROC ; DRAMsimII::Channel::readNextCommand
EXTRN	?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z:PROC ; DRAMsimII::Channel::earliestExecuteTime
EXTRN	?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z:PROC ; DRAMsimII::Channel::earliestExecuteTimeLog
EXTRN	??_EfbdChannel@DRAMsimII@@UAEPAXI@Z:PROC	; DRAMsimII::fbdChannel::`vector deleting destructor'
EXTRN	?nextTick@Channel@DRAMsimII@@UBE_JXZ:PROC	; DRAMsimII::Channel::nextTick
EXTRN	?moveToTime@Channel@DRAMsimII@@UAEX_J@Z:PROC	; DRAMsimII::Channel::moveToTime
;	COMDAT ??_R1A@?0A@EA@Channel@DRAMsimII@@8
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@Channel@DRAMsimII@@8 DD FLAT:??_R0?AVChannel@DRAMsimII@@@8 ; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Channel@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Channel@DRAMsimII@@8 ; DRAMsimII::Channel::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Channel@DRAMsimII@@8 DD 00H			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChannel@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVChannel@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::Channel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChannel@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EN@Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EN@Channel@DRAMsimII@@8 DD FLAT:??_R0?AVChannel@DRAMsimII@@@8 ; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,77)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8 DD FLAT:??_R0?AVfbdChannel@DRAMsimII@@@8 ; DRAMsimII::fbdChannel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R2fbdChannel@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@fbdChannel@DRAMsimII@@8 ; DRAMsimII::fbdChannel::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EN@Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3fbdChannel@DRAMsimII@@8
rdata$r	SEGMENT
??_R3fbdChannel@DRAMsimII@@8 DD 00H			; DRAMsimII::fbdChannel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfbdChannel@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVfbdChannel@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::fbdChannel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfbdChannel@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_R4fbdChannel@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4fbdChannel@DRAMsimII@@6B@ DD 00H			; DRAMsimII::fbdChannel::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfbdChannel@DRAMsimII@@@8
	DD	FLAT:??_R3fbdChannel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_7fbdChannel@DRAMsimII@@6B@
CONST	SEGMENT
??_7fbdChannel@DRAMsimII@@6B@ DD FLAT:??_R4fbdChannel@DRAMsimII@@6B@ ; DRAMsimII::fbdChannel::`vftable'
	DD	FLAT:?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ
	DD	FLAT:?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:??_EfbdChannel@DRAMsimII@@UAEPAXI@Z
	DD	FLAT:?nextTick@Channel@DRAMsimII@@UBE_JXZ
	DD	FLAT:?moveToTime@Channel@DRAMsimII@@UAEX_J@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
__ehfuncinfo$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCcsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_settings$ = 8						; size = 4
_sysConfig$ = 12					; size = 4
_stats$ = 16						; size = 4
??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::fbdChannel::fbdChannel, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _stats$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sysConfig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _settings$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7fbdChannel@DRAMsimII@@6B@
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>

; 26   : 
; 27   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
__ehhandler$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0fbdChannel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::fbdChannel::fbdChannel
PUBLIC	??1fbdChannel@DRAMsimII@@UAE@XZ			; DRAMsimII::fbdChannel::~fbdChannel
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??_GfbdChannel@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GfbdChannel@DRAMsimII@@UAEPAXI@Z PROC		; DRAMsimII::fbdChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1fbdChannel@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GfbdChannel@DRAMsimII@@UAEPAXI@Z ENDP		; DRAMsimII::fbdChannel::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1fbdChannel@DRAMsimII@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1fbdChannel@DRAMsimII@@UAE@XZ$0
__ehfuncinfo$??1fbdChannel@DRAMsimII@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1fbdChannel@DRAMsimII@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1fbdChannel@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1fbdChannel@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::fbdChannel::~fbdChannel, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1fbdChannel@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1fbdChannel@DRAMsimII@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
__ehhandler$??1fbdChannel@DRAMsimII@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1fbdChannel@DRAMsimII@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1fbdChannel@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::fbdChannel::~fbdChannel
PUBLIC	?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastPrechargeTime
PUBLIC	?tWR@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tWR
PUBLIC	?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastCASWTime
PUBLIC	?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastCASTime
PUBLIC	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCMD
PUBLIC	?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRTP
PUBLIC	?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRAS
PUBLIC	?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRTRS
PUBLIC	?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCAS
PUBLIC	?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tWTR
PUBLIC	?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCWD
PUBLIC	?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastCASWTime
PUBLIC	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tBurst
PUBLIC	?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Rank::getLastCASTime
PUBLIC	?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRCD
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRFC
PUBLIC	?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastRefreshTime
PUBLIC	?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tFAW
PUBLIC	?tRC@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRC
PUBLIC	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastRASTime
PUBLIC	?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRRD
PUBLIC	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
PUBLIC	?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
PUBLIC	?tRP@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRP
PUBLIC	?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastPrechargeTime
PUBLIC	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
PUBLIC	?tAL@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tAL
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	?getBank@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getBank
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
PUBLIC	?getRank@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getRank
PUBLIC	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ	; DRAMsimII::Event::getAddress
EXTRN	__imp__exit:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@_RTC_Check_8_to_4@8:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z
_TEXT	SEGMENT
tv133 = -556						; size = 4
$T174300 = -548						; size = 4
$T174301 = -536						; size = 4
$T174302 = -524						; size = 4
$T174303 = -512						; size = 4
$T174304 = -500						; size = 4
$T174305 = -488						; size = 4
$T174306 = -476						; size = 4
$T174307 = -464						; size = 4
$T174308 = -452						; size = 4
_t_cas_gap$148946 = -248				; size = 4
_t_ras_gap$148944 = -236				; size = 4
_t_cas_gap$148938 = -224				; size = 4
_t_ras_gap$148936 = -212				; size = 4
_t_cas_gap$148931 = -200				; size = 4
_t_ras_gap$148929 = -188				; size = 4
_tRFCGap$148921 = -176					; size = 4
_fourth_ras_time$148919 = -164				; size = 8
_tFAWGap$148916 = -148					; size = 4
_tRCGap$148914 = -136					; size = 4
_lastRASTime$148912 = -124				; size = 8
_tRRDGap$148909 = -108					; size = 4
_ras_q_count$148908 = -96				; size = 4
_tRPGap$148906 = -84					; size = 4
_t_al$ = -72						; size = 4
_currentBank$ = -60					; size = 4
_currentRank$ = -48					; size = 4
_this_rank$ = -36					; size = 4
_min_gap$ = -24						; size = 8
_this$ = -8						; size = 4
_this_c$ = 8						; size = 4
?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::fbdChannel::minProtocolGap, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-556]
	mov	ecx, 139				; 0000008bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	// TODO: also consider commands issued one cycle ago which are not yet executed
; 36   : 	tick min_gap = 0;

	mov	DWORD PTR _min_gap$[ebp], 0
	mov	DWORD PTR _min_gap$[ebp+4], 0

; 37   : 
; 38   : 	const unsigned this_rank = this_c->getAddress().getRank();

	mov	ecx, DWORD PTR _this_c$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	mov	DWORD PTR _this_rank$[ebp], eax

; 39   : 	const Rank &currentRank = rank[this_rank];

	mov	eax, DWORD PTR _this_rank$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	DWORD PTR _currentRank$[ebp], eax

; 40   : 	const Bank &currentBank = currentRank.bank[this_c->getAddress().getBank()];

	mov	ecx, DWORD PTR _this_c$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	mov	ecx, DWORD PTR _currentRank$[ebp]
	add	ecx, 388				; 00000184H
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	DWORD PTR _currentBank$[ebp], eax

; 41   : 
; 42   : 	int t_al = timingSpecification.tAL();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tAL@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tAL
	mov	DWORD PTR _t_al$[ebp], eax

; 43   : 
; 44   : 	switch(this_c->getCommandType())

	mov	ecx, DWORD PTR _this_c$[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	DWORD PTR tv133[ebp], eax
	cmp	DWORD PTR tv133[ebp], 12		; 0000000cH
	ja	$LN1@minProtoco
	mov	eax, DWORD PTR tv133[ebp]
	jmp	DWORD PTR $LN30@minProtoco[eax*4]
$LN12@minProtoco:

; 45   : 	{
; 46   : 	case Command::ACTIVATE:
; 47   : 		{
; 48   : 			// respect t_rp of same bank
; 49   : 			int tRPGap = (int)(currentBank.getLastPrechargeTime() - time) + timingSpecification.tRP();

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Bank::getLastPrechargeTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRP@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRP
	add	esi, eax
	mov	DWORD PTR _tRPGap$148906[ebp], esi

; 50   : 
; 51   : 			int ras_q_count = currentRank.lastActivateTimes.size();

	mov	ecx, DWORD PTR _currentRank$[ebp]
	add	ecx, 360				; 00000168H
	call	?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
	mov	DWORD PTR _ras_q_count$148908[ebp], eax

; 52   : 
; 53   : 			// respect tRRD and tRC of all other banks of same rank
; 54   : 			int tRRDGap;
; 55   : 
; 56   : 			if (ras_q_count == 0)

	cmp	DWORD PTR _ras_q_count$148908[ebp], 0
	jne	SHORT $LN11@minProtoco

; 57   : 			{
; 58   : 				tRRDGap = 0;

	mov	DWORD PTR _tRRDGap$148909[ebp], 0

; 59   : 			}
; 60   : 			else

	jmp	SHORT $LN10@minProtoco
$LN11@minProtoco:

; 61   : 			{
; 62   : 				// read tail end of ras history
; 63   : 				//tick *last_ras_time = currentRank.lastCommand::ACTIVATETimes.read(ras_q_count - 1);
; 64   : 				const tick lastRASTime = currentRank.lastActivateTimes.back();

	mov	ecx, DWORD PTR _currentRank$[ebp]
	add	ecx, 360				; 00000168H
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lastRASTime$148912[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _lastRASTime$148912[ebp+4], edx

; 65   : 				// respect the row-to-row activation delay
; 66   : 				tRRDGap = (int)(lastRASTime - time) + timingSpecification.tRRD();				

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lastRASTime$148912[ebp]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _lastRASTime$148912[ebp+4]
	sbb	edx, DWORD PTR [eax+12]
	push	edx
	push	ecx
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRRD
	add	esi, eax
	mov	DWORD PTR _tRRDGap$148909[ebp], esi
$LN10@minProtoco:

; 67   : 			}
; 68   : 
; 69   : 			// respect the row cycle time limitation
; 70   : 			int tRCGap = (int)(currentBank.getLastRASTime() - time) + timingSpecification.tRC();

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastRASTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRC@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRC
	add	esi, eax
	mov	DWORD PTR _tRCGap$148914[ebp], esi

; 71   : 
; 72   : 			// respect the t_faw value for DDR2 and beyond
; 73   : 			int tFAWGap;
; 74   : 
; 75   : 			if (ras_q_count < 4)

	cmp	DWORD PTR _ras_q_count$148908[ebp], 4
	jge	SHORT $LN9@minProtoco

; 76   : 			{
; 77   : 				tFAWGap = 0;

	mov	DWORD PTR _tFAWGap$148916[ebp], 0

; 78   : 			}
; 79   : 			else

	jmp	SHORT $LN8@minProtoco
$LN9@minProtoco:

; 80   : 			{
; 81   : 				// read head of ras history
; 82   : 				const tick fourth_ras_time = currentRank.lastActivateTimes.back();

	mov	ecx, DWORD PTR _currentRank$[ebp]
	add	ecx, 360				; 00000168H
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fourth_ras_time$148919[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _fourth_ras_time$148919[ebp+4], edx

; 83   : 				tFAWGap = (int)(fourth_ras_time - time) + timingSpecification.tFAW();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fourth_ras_time$148919[ebp]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _fourth_ras_time$148919[ebp+4]
	sbb	edx, DWORD PTR [eax+12]
	push	edx
	push	ecx
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tFAW
	add	esi, eax
	mov	DWORD PTR _tFAWGap$148916[ebp], esi
$LN8@minProtoco:

; 84   : 			}
; 85   : 
; 86   : 			// respect tRFC
; 87   : 			int tRFCGap = (int)(currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC();

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Rank::getLastRefreshTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRFC
	add	esi, eax
	mov	DWORD PTR _tRFCGap$148921[ebp], esi

; 88   : 
; 89   : 			min_gap = max(max(max(tRFCGap,tRCGap) , tRPGap) , max(tRRDGap , tFAWGap));

	lea	eax, DWORD PTR _tFAWGap$148916[ebp]
	push	eax
	lea	ecx, DWORD PTR _tRRDGap$148909[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _tRPGap$148906[ebp]
	push	edx
	lea	eax, DWORD PTR _tRCGap$148914[ebp]
	push	eax
	lea	ecx, DWORD PTR _tRFCGap$148921[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	push	eax
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	push	eax
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[ebp], eax
	mov	DWORD PTR _min_gap$[ebp+4], edx

; 90   : 		}
; 91   : 		break;

	jmp	$LN13@minProtoco
$LN7@minProtoco:

; 92   : 
; 93   : 	case Command::READ_AND_PRECHARGE:
; 94   : 		// Auto precharge will be issued as part of command,
; 95   : 		// but DRAM devices are intelligent enough to delay the prec command
; 96   : 		// until tRAS timing is met, so no need to check tRAS timing requirement here.
; 97   : 
; 98   : 	case Command::READ:
; 99   : 		{
; 100  : 			//respect last ras of same rank
; 101  : 			int t_ras_gap = (int)((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - t_al);

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastRASTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRCD
	cdq
	add	esi, eax
	adc	edi, edx
	mov	eax, DWORD PTR _t_al$[ebp]
	cdq
	sub	esi, eax
	sbb	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR _t_ras_gap$148929[ebp], eax

; 102  : 
; 103  : 			// ensure that if no other rank has issued a CAS command that it will treat
; 104  : 			// this as if a CAS command was issued long ago
; 105  : 			//tick other_r_last_cas_time = time - 1000;
; 106  : 			//int other_r_last_cas_length = timingSpecification.tBurst();
; 107  : 			//tick other_r_last_casw_time = time - 1000;
; 108  : 			//int other_r_last_casw_length = timingSpecification.tBurst();
; 109  : 
; 110  : 			// find the most recent cas(w) time and length
; 111  : 			//for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)
; 112  : 			//{
; 113  : 			//	if (rank_id != this_rank)
; 114  : 			//	{
; 115  : 			//		if (rank[rank_id].lastCASTime > other_r_last_cas_time)
; 116  : 			//		{
; 117  : 			//			other_r_last_cas_time = rank[rank_id].lastCASTime;
; 118  : 			//			other_r_last_cas_length = rank[rank_id].lastCASLength;
; 119  : 			//		}
; 120  : 			//		if (rank[rank_id].lastCASWTime > other_r_last_casw_time)
; 121  : 			//		{
; 122  : 			//			other_r_last_casw_time = rank[rank_id].lastCASWTime;
; 123  : 			//			other_r_last_casw_length = rank[rank_id].lastCASWLength;
; 124  : 			//		}
; 125  : 			//	}
; 126  : 			//}
; 127  : 
; 128  : 			//respect last cas of same rank
; 129  : 			// DW 3/9/2006 add these two lines
; 130  : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 131  : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 132  : 			// DW 3/9/2006 replace the line after next with the next line
; 133  : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 134  : 			int t_cas_gap = (int)((currentRank.getLastCASTime() - time) + timingSpecification.tBurst());

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastCASTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR _t_cas_gap$148931[ebp], eax

; 135  : 
; 136  : 			//respect last cas write of same rank
; 137  : 			// DW 3/9/2006 replace the line after next with the next line
; 138  : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 139  : 			t_cas_gap = max(t_cas_gap,(int)((currentRank.getLastCASWTime() - time) + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR()));

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Rank::getLastCASWTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCWD
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tWTR
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR $T174300[ebp], eax
	lea	ecx, DWORD PTR $T174300[ebp]
	push	ecx
	lea	edx, DWORD PTR _t_cas_gap$148931[ebp]
	push	edx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$148931[ebp], eax

; 140  : 
; 141  : 			//if (rank.size() > 1)
; 142  : 			//{
; 143  : 			//respect most recent cas of different rank
; 144  : 			//	t_cas_gap = max(t_cas_gap,(int)(other_r_last_cas_time + other_r_last_cas_length + timingSpecification.tRTRS() - time));
; 145  : 			//respect timing of READ follow WRITE, different ranks.*/
; 146  : 			//	t_cas_gap = max(t_cas_gap,(int)(other_r_last_casw_time + timingSpecification.tCWD() + other_r_last_casw_length + timingSpecification.tRTRS() - timingSpecification.tCAS() - time));
; 147  : 			//}
; 148  : 			min_gap = max(t_ras_gap,t_cas_gap);

	lea	eax, DWORD PTR _t_cas_gap$148931[ebp]
	push	eax
	lea	ecx, DWORD PTR _t_ras_gap$148929[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[ebp], eax
	mov	DWORD PTR _min_gap$[ebp+4], edx

; 149  : 
; 150  : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 151  : 		}
; 152  : 		break;

	jmp	$LN13@minProtoco
$LN6@minProtoco:

; 153  : 
; 154  : 	case Command::WRITE_AND_PRECHARGE:
; 155  : 		// Auto precharge will be issued as part of command, so
; 156  : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 157  : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 158  : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 159  : 
; 160  : 	case Command::WRITE:
; 161  : 		{
; 162  : 			//respect last ras of same rank
; 163  : 			int t_ras_gap = (int)((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - t_al);

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastRASTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRCD
	cdq
	add	esi, eax
	adc	edi, edx
	mov	eax, DWORD PTR _t_al$[ebp]
	cdq
	sub	esi, eax
	sbb	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR _t_ras_gap$148936[ebp], eax

; 164  : 
; 165  : 			/*tick other_r_last_cas_time = time - 1000;
; 166  : 			int other_r_last_cas_length = timingSpecification.tBurst();
; 167  : 			tick other_r_last_casw_time = time - 1000;
; 168  : 			int other_r_last_casw_length = timingSpecification.tBurst();*/
; 169  : 
; 170  : 			// find the most recent CAS/CASW time and length
; 171  : 			// FIXME: change to use iterators
; 172  : 			/*for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)
; 173  : 			{
; 174  : 			if (rank_id != this_rank)
; 175  : 			{
; 176  : 			if (rank[rank_id].lastCASTime > other_r_last_cas_time)
; 177  : 			{
; 178  : 			other_r_last_cas_time = rank[rank_id].lastCASTime;
; 179  : 			other_r_last_cas_length = rank[rank_id].lastCASLength;
; 180  : 			}
; 181  : 			if (rank[rank_id].lastCASWTime > other_r_last_casw_time)
; 182  : 			{
; 183  : 			other_r_last_casw_time = rank[rank_id].lastCASWTime;
; 184  : 			other_r_last_casw_length = rank[rank_id].lastCASWLength;
; 185  : 			}
; 186  : 			}
; 187  : 			}*/
; 188  : 
; 189  : 			// respect last cas to same rank
; 190  : 			int t_cas_gap = (int)(currentRank.getLastCASTime() - time) + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastCASTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCAS
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRTRS
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCWD
	sub	esi, eax
	mov	DWORD PTR _t_cas_gap$148938[ebp], esi

; 191  : 
; 192  : 			// respect last cas to different ranks
; 193  : 			// not in FBD, each rank is on its own channel
; 194  : 			//t_cas_gap = max(t_cas_gap,(int)(other_r_last_cas_time + timingSpecification.tCAS() + other_r_last_cas_length + timingSpecification.tRTRS() - timingSpecification.tCWD() - time));
; 195  : 
; 196  : 			// respect last cas write to same rank
; 197  : 			t_cas_gap = max(t_cas_gap,(int)(currentRank.getLastCASWTime() - time) + timingSpecification.tBurst());

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Rank::getLastCASWTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	add	esi, eax
	mov	DWORD PTR $T174301[ebp], esi
	lea	edx, DWORD PTR $T174301[ebp]
	push	edx
	lea	eax, DWORD PTR _t_cas_gap$148938[ebp]
	push	eax
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$148938[ebp], ecx

; 198  : 
; 199  : 			// respect last cas write to different ranks
; 200  : 			// not in FBD
; 201  : 			//t_cas_gap = max(t_cas_gap,(int)(other_r_last_casw_time + other_r_last_casw_length - time));
; 202  : 
; 203  : 			min_gap = max(t_ras_gap,t_cas_gap);

	lea	eax, DWORD PTR _t_cas_gap$148938[ebp]
	push	eax
	lea	ecx, DWORD PTR _t_ras_gap$148936[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[ebp], eax
	mov	DWORD PTR _min_gap$[ebp+4], edx

; 204  : 		}
; 205  : 		break;

	jmp	$LN13@minProtoco
$LN5@minProtoco:

; 206  : 
; 207  : 	case Command::RETIRE_COMMAND:
; 208  : 		break;

	jmp	$LN13@minProtoco
$LN4@minProtoco:

; 209  : 
; 210  : 	case Command::PRECHARGE:
; 211  : 		{
; 212  : 			// respect t_ras of same bank
; 213  : 			int t_ras_gap = (int)(currentBank.getLastRASTime() - time) + timingSpecification.tRAS();

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastRASTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	sbb	edx, DWORD PTR [ecx+12]
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRAS
	add	esi, eax
	mov	DWORD PTR _t_ras_gap$148944[ebp], esi

; 214  : 
; 215  : 			// respect t_cas of same bank
; 216  : 			int t_cas_gap = max(0,(int)((currentBank.getLastCASTime() - time) + t_al + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD())));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRTP
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCMD
	sub	esi, eax
	mov	DWORD PTR $T174303[ebp], esi
	mov	DWORD PTR $T174304[ebp], 0
	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastCASTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _t_al$[ebp]
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCAS
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	cdq
	add	esi, eax
	adc	edi, edx
	lea	ecx, DWORD PTR $T174303[ebp]
	push	ecx
	lea	edx, DWORD PTR $T174304[ebp]
	push	edx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR $T174302[ebp], eax
	mov	DWORD PTR $T174305[ebp], 0
	lea	eax, DWORD PTR $T174302[ebp]
	push	eax
	lea	ecx, DWORD PTR $T174305[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$148946[ebp], edx

; 217  : 
; 218  : 			// respect t_casw of same bank
; 219  : 			t_cas_gap = max(t_cas_gap,(int)((currentBank.getLastCASWTime() - time) + t_al + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR()));

	mov	ecx, DWORD PTR _currentBank$[ebp]
	call	?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Bank::getLastCASWTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _t_al$[ebp]
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCWD
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	cdq
	add	esi, eax
	adc	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tWR@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tWR
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR $T174306[ebp], eax
	lea	ecx, DWORD PTR $T174306[ebp]
	push	ecx
	lea	edx, DWORD PTR _t_cas_gap$148946[ebp]
	push	edx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _t_cas_gap$148946[ebp], eax

; 220  : 
; 221  : 			min_gap = max(t_ras_gap,t_cas_gap);

	lea	eax, DWORD PTR _t_cas_gap$148946[ebp]
	push	eax
	lea	ecx, DWORD PTR _t_ras_gap$148944[ebp]
	push	ecx
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[ebp], eax
	mov	DWORD PTR _min_gap$[ebp+4], edx

; 222  : 		}
; 223  : 		break;

	jmp	$LN13@minProtoco
$LN3@minProtoco:

; 224  : 
; 225  : 	case Command::PRECHARGE_ALL:
; 226  : 	case Command::ACTIVATE_ALL:
; 227  : 	case Command::DRIVE_COMMAND:
; 228  : 	case Command::DATA_COMMAND:
; 229  : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 230  : 		break;

	jmp	$LN13@minProtoco
$LN2@minProtoco:

; 231  : 
; 232  : 	case Command::REFRESH_ALL:
; 233  : 		// respect tRFC and tRP
; 234  : 		min_gap = max((int)((currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC()),(int)((currentRank.getLastPrechargeTime() - time) + timingSpecification.tRP()));

	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Rank::getLastPrechargeTime
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [eax+8]
	sbb	edi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRP@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRP
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR $T174307[ebp], eax
	mov	ecx, DWORD PTR _currentRank$[ebp]
	call	?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ ; DRAMsimII::Rank::getLastRefreshTime
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	sub	esi, DWORD PTR [ecx+8]
	sbb	edi, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tRFC
	cdq
	add	esi, eax
	adc	edi, edx
	push	edi
	push	esi
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR $T174308[ebp], eax
	lea	edx, DWORD PTR $T174307[ebp]
	push	edx
	lea	eax, DWORD PTR $T174308[ebp]
	push	eax
	call	??$max@H@std@@YAABHABH0@Z		; std::max<int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	cdq
	mov	DWORD PTR _min_gap$[ebp], eax
	mov	DWORD PTR _min_gap$[ebp+4], edx

; 235  : 		break;

	jmp	SHORT $LN13@minProtoco
$LN1@minProtoco:

; 236  : 
; 237  : 	default:
; 238  : 		exit(-20);

	mov	esi, esp
	push	-20					; ffffffecH
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@minProtoco:

; 239  : 		break;
; 240  : 	}
; 241  : 
; 242  : #ifdef DEBUG_MIN_PROTOCOL_GAP
; 243  : 	outStream << this_c->commandType;
; 244  : 	outStream << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]" << endl;
; 245  : #endif
; 246  : 
; 247  : 	//return max(min_gap,timingSpecification.tCMD());
; 248  : 	return min_gap;

	mov	eax, DWORD PTR _min_gap$[ebp]
	mov	edx, DWORD PTR _min_gap$[ebp+4]
$LN16@minProtoco:

; 249  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@minProtoco
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 556				; 0000022cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN29@minProtoco:
	DD	11					; 0000000bH
	DD	$LN28@minProtoco
$LN28@minProtoco:
	DD	-84					; ffffffacH
	DD	4
	DD	$LN17@minProtoco
	DD	-108					; ffffff94H
	DD	4
	DD	$LN18@minProtoco
	DD	-136					; ffffff78H
	DD	4
	DD	$LN19@minProtoco
	DD	-148					; ffffff6cH
	DD	4
	DD	$LN20@minProtoco
	DD	-176					; ffffff50H
	DD	4
	DD	$LN21@minProtoco
	DD	-188					; ffffff44H
	DD	4
	DD	$LN22@minProtoco
	DD	-200					; ffffff38H
	DD	4
	DD	$LN23@minProtoco
	DD	-212					; ffffff2cH
	DD	4
	DD	$LN24@minProtoco
	DD	-224					; ffffff20H
	DD	4
	DD	$LN25@minProtoco
	DD	-236					; ffffff14H
	DD	4
	DD	$LN26@minProtoco
	DD	-248					; ffffff08H
	DD	4
	DD	$LN27@minProtoco
$LN27@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN26@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN25@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN24@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN23@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN22@minProtoco:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN21@minProtoco:
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	70					; 00000046H
	DB	67					; 00000043H
	DB	71					; 00000047H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN20@minProtoco:
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	65					; 00000041H
	DB	87					; 00000057H
	DB	71					; 00000047H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN19@minProtoco:
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	67					; 00000043H
	DB	71					; 00000047H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN18@minProtoco:
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	82					; 00000052H
	DB	68					; 00000044H
	DB	71					; 00000047H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN17@minProtoco:
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	80					; 00000050H
	DB	71					; 00000047H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
	npad	2
$LN30@minProtoco:
	DD	$LN12@minProtoco
	DD	$LN7@minProtoco
	DD	$LN7@minProtoco
	DD	$LN6@minProtoco
	DD	$LN6@minProtoco
	DD	$LN5@minProtoco
	DD	$LN4@minProtoco
	DD	$LN3@minProtoco
	DD	$LN3@minProtoco
	DD	$LN3@minProtoco
	DD	$LN3@minProtoco
	DD	$LN3@minProtoco
	DD	$LN2@minProtoco
?minProtocolGap@fbdChannel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::fbdChannel::minProtocolGap
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?getRank@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getRank@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getRank, COMDAT
; _this$ = ecx

; 87   : 		unsigned getRank() const { return rank; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRank@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getRank
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getBank@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getBank@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getBank, COMDAT
; _this$ = ecx

; 88   : 		unsigned getBank() const { return bank; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getBank@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getBank
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ PROC	; DRAMsimII::Event::getAddress, COMDAT
; _this$ = ecx

; 89   : 		const Address &getAddress() const { return address; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ENDP	; DRAMsimII::Event::getAddress
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ PROC ; DRAMsimII::Command::getCommandType, COMDAT
; _this$ = ecx

; 80   : 		CommandType getCommandType() const { return commandType; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+80]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ENDP ; DRAMsimII::Command::getCommandType
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_TEXT	ENDS
;	COMDAT ?tAL@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tAL@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tAL, COMDAT
; _this$ = ecx

; 64   : 		int tAL() const { return t_al; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tAL@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tAL
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCAS, COMDAT
; _this$ = ecx

; 65   : 		int tCAS() const { return t_cas; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCAS
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tBurst, COMDAT
; _this$ = ecx

; 67   : 		int tBurst() const { return t_burst; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tBurst
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRTP, COMDAT
; _this$ = ecx

; 68   : 		int tRTP() const { return t_rtp; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRTP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRAS, COMDAT
; _this$ = ecx

; 69   : 		int tRAS() const { return t_ras; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRAS
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCWD, COMDAT
; _this$ = ecx

; 70   : 		int tCWD() const { return t_cwd; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCWD
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tWR@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tWR@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tWR, COMDAT
; _this$ = ecx

; 71   : 		int tWR() const { return t_wr; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tWR@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tWR
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCMD, COMDAT
; _this$ = ecx

; 73   : 		int tCMD() const { return t_cmd; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCMD
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRCD, COMDAT
; _this$ = ecx

; 75   : 		int tRCD() const { return t_rcd; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRCD
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRP@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRP@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tRP, COMDAT
; _this$ = ecx

; 76   : 		int tRP() const { return t_rp; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRP@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tRP
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRRD, COMDAT
; _this$ = ecx

; 77   : 		int tRRD() const { return t_rrd; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRRD
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tFAW, COMDAT
; _this$ = ecx

; 78   : 		int tFAW() const { return t_faw; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tFAW
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRFC, COMDAT
; _this$ = ecx

; 79   : 		int tRFC() const { return t_rfc; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRFC
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tWTR, COMDAT
; _this$ = ecx

; 80   : 		int tWTR() const { return t_wtr; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tWTR
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRTRS, COMDAT
; _this$ = ecx

; 81   : 		int tRTRS() const { return t_rtrs; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRTRS
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?tRC@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?tRC@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tRC, COMDAT
; _this$ = ecx

; 82   : 		int tRC() const { return t_rc; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?tRC@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tRC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastRASTime, COMDAT
; _this$ = ecx

; 85   : 		tick getLastRASTime() const { return lastRASTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastRASTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASTime, COMDAT
; _this$ = ecx

; 86   : 		tick getLastCASTime() const { return lastCASTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR [ecx+60]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASWTime, COMDAT
; _this$ = ecx

; 87   : 		tick getLastCASWTime() const {return lastCASWTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR [ecx+68]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASWTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Bank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 89   : 		tick getLastPrechargeTime() const { return lastPrechargeTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR [ecx+76]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Bank::getLastPrechargeTime
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.h
_TEXT	ENDS
;	COMDAT ?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastRefreshTime, COMDAT
; _this$ = ecx

; 105  : 		tick getLastRefreshTime() const { return lastRefreshTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastRefreshTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASTime, COMDAT
; _this$ = ecx

; 106  : 		tick getLastCASTime() const { return lastCASTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASWTime, COMDAT
; _this$ = ecx

; 107  : 		tick getLastCASWTime() const { return lastCASWTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASWTime
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 110  : 		tick getLastPrechargeTime() const { return lastPrechargeAnyBankTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastPrechargeTime
_TEXT	ENDS
PUBLIC	??_C@_1FK@KLKDOCJF@?$AAt?$AAi?$AAm?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AAn?$AAd?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$CL?$AA?5?$AAt?$AAi?$AAm?$AAi?$AAn?$AAg?$AAS?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc@ ; `string'
PUBLIC	??$min@_J@std@@YAAB_JAB_J0@Z			; std::min<__int64>
PUBLIC	??_C@_1CK@EOIDILJG@?$AAn?$AAe?$AAx?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ ; DRAMsimII::fbdChannel::nextFrameExecuteTime
PUBLIC	??_C@_1CM@DDCNBAFL@?$AAn?$AAe?$AAx?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z	; DRAMsimII::fbdChannel::makeFrame
PUBLIC	??_GfbdFrame@DRAMsimII@@QAEPAXI@Z		; DRAMsimII::fbdFrame::`scalar deleting destructor'
PUBLIC	?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandC
PUBLIC	?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandCType
PUBLIC	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
PUBLIC	?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandBType
PUBLIC	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
PUBLIC	??_C@_04KLOEPAKI@C?5F?$FL?$AA@			; `string'
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@		; `string'
PUBLIC	??_C@_02PBFOLPKM@?$FN?5?$AA@			; `string'
PUBLIC	?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandA
PUBLIC	?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandAType
PUBLIC	?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ ; DRAMsimII::fbdChannel::getNextFrame
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??_C@_06PIIJMIIG@T?9?$DOC?5?$FL?$AA@		; `string'
PUBLIC	??_C@_04GNFNGMLO@?$FN?5Q?$FL?$AA@		; `string'
PUBLIC	?getTransactionQueueCount@Channel@DRAMsimII@@QBEIXZ ; DRAMsimII::Channel::getTransactionQueueCount
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_1CE@BGIJBKFE@?$AAt?$AA2?$AAc?$AAR?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA ; `DRAMsimII::fbdChannel::moveToTime'::`2'::__LINE__Var
PUBLIC	?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z	; DRAMsimII::fbdChannel::moveToTime
EXTRN	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ:PROC ; DRAMsimII::Channel::nextTransactionDecodeTime
EXTRN	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z:PROC ; DRAMsimII::Channel::executeCommand
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:PROC
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z:PROC
EXTRN	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z:PROC ; DRAMsimII::Statistics::collectCommandStats
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:PROC
EXTRN	__imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z:PROC
EXTRN	__imp___wassert:PROC
EXTRN	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z:PROC ; DRAMsimII::Channel::transaction2commands
EXTRN	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ:PROC ; DRAMsimII::Channel::getTransaction
EXTRN	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z:PROC ; DRAMsimII::Channel::checkForAvailableCommandSlots
EXTRN	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z:PROC ; DRAMsimII::Channel::readTransaction
;	COMDAT ??_C@_1FK@KLKDOCJF@?$AAt?$AAi?$AAm?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AAn?$AAd?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$CL?$AA?5?$AAt?$AAi?$AAm?$AAi?$AAn?$AAg?$AAS?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
CONST	SEGMENT
??_C@_1FK@KLKDOCJF@?$AAt?$AAi?$AAm?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AAn?$AAd?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$CL?$AA?5?$AAt?$AAi?$AAm?$AAi?$AAn?$AAg?$AAS?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc@ DB 't'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'T', 00H, 'i', 00H, 'm'
	DB	00H, 'e', 00H, ' ', 00H, '+', 00H, ' ', 00H, 't', 00H, 'i', 00H
	DB	'm', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'S', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 't', 00H, 'C'
	DB	00H, 'M', 00H, 'D', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOIDILJG@?$AAn?$AAe?$AAx?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOIDILJG@?$AAn?$AAe?$AAx?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'F', 00H, 'r', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@DDCNBAFL@?$AAn?$AAe?$AAx?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DDCNBAFL@?$AAn?$AAe?$AAx?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'D', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLOEPAKI@C?5F?$FL?$AA@
CONST	SEGMENT
??_C@_04KLOEPAKI@C?5F?$FL?$AA@ DB 'C F[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@
CONST	SEGMENT
??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@ DB '] MG[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PBFOLPKM@?$FN?5?$AA@
CONST	SEGMENT
??_C@_02PBFOLPKM@?$FN?5?$AA@ DB '] ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIIJMIIG@T?9?$DOC?5?$FL?$AA@
CONST	SEGMENT
??_C@_06PIIJMIIG@T?9?$DOC?5?$FL?$AA@ DB 'T->C [', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GNFNGMLO@?$FN?5Q?$FL?$AA@
CONST	SEGMENT
??_C@_04GNFNGMLO@?$FN?5Q?$FL?$AA@ DB '] Q[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@BGIJBKFE@?$AAt?$AA2?$AAc?$AAR?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@BGIJBKFE@?$AAt?$AA2?$AAc?$AAR?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ DB 't'
	DB	00H, '2', 00H, 'c', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'u', 00H
	DB	'l', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
CONST	SEGMENT
??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 'u', 00H, 's'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'c', 00H, 'u', 00H, 'm', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'v', 00H, 'i'
	DB	00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, '2'
	DB	00H, '0', 00H, '0', 00H, '8', 00H, '\', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\'
	DB	00H, 'd', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 's', 00H, 'i', 00H
	DB	'm', 00H, 'i', 00H, 'i', 00H, 'h', 00H, 'g', 00H, '\', 00H, 's'
	DB	00H, 'r', 00H, 'c', 00H, '\', 00H, 'f', 00H, 'b', 00H, 'd', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l'
	DB	00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA DD 0ffH ; `DRAMsimII::fbdChannel::moveToTime'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT ?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z
_TEXT	SEGMENT
tv775 = -416						; size = 4
tv767 = -416						; size = 4
tv759 = -416						; size = 4
tv773 = -412						; size = 4
tv765 = -412						; size = 4
tv757 = -412						; size = 4
tv771 = -408						; size = 4
tv763 = -408						; size = 4
tv755 = -408						; size = 4
tv769 = -404						; size = 4
tv761 = -404						; size = 4
tv753 = -404						; size = 4
tv751 = -404						; size = 4
tv736 = -404						; size = 8
tv375 = -400						; size = 4
tv298 = -400						; size = 4
tv221 = -400						; size = 4
tv153 = -400						; size = 4
tv735 = -396						; size = 4
tv701 = -396						; size = 4
tv684 = -396						; size = 4
tv486 = -396						; size = 4
tv416 = -396						; size = 4
tv376 = -396						; size = 4
tv299 = -396						; size = 4
tv222 = -396						; size = 4
tv154 = -396						; size = 4
$T174386 = -388						; size = 8
$T174387 = -372						; size = 8
$T174390 = -356						; size = 8
$T174391 = -340						; size = 8
$T174394 = -324						; size = 8
$T174395 = -308						; size = 8
$T174398 = -292						; size = 4
$T174399 = -280						; size = 4
_nextFrameTime$149042 = -76				; size = 8
_nextDecodeTime$149039 = -60				; size = 8
_nextFrame$148984 = -44					; size = 4
_t2cResult$148971 = -29					; size = 1
_decodedTransaction$148970 = -20			; size = 4
_this$ = -8						; size = 4
_endTime$ = 8						; size = 8
_transFinishTime$ = 16					; size = 4
?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z PROC	; DRAMsimII::fbdChannel::moveToTime, COMDAT
; _this$ = ecx

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-416]
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN8@moveToTime:

; 256  : 	while (time < endTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv486[ebp], eax
	mov	ecx, DWORD PTR tv486[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _endTime$[ebp+4]
	jg	$LN7@moveToTime
	jl	SHORT $LN25@moveToTime
	mov	eax, DWORD PTR tv486[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _endTime$[ebp]
	jae	$LN7@moveToTime
$LN25@moveToTime:

; 257  : 	{
; 258  : 		// try to convert any transactions into commands first
; 259  : 		if (checkForAvailableCommandSlots(readTransaction(true)))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	movzx	eax, al
	test	eax, eax
	je	$LN6@moveToTime

; 260  : 		{
; 261  : 			// actually remove it from the queue now
; 262  : 			Transaction *decodedTransaction = getTransaction();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
	mov	DWORD PTR _decodedTransaction$148970[ebp], eax

; 263  : 
; 264  : 			// then break into commands and insert into per bank command queues
; 265  : 			bool t2cResult = transaction2commands(decodedTransaction);

	mov	eax, DWORD PTR _decodedTransaction$148970[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands
	mov	BYTE PTR _t2cResult$148971[ebp], al

; 266  : 
; 267  : 			assert(t2cResult == true);

	movzx	eax, BYTE PTR _t2cResult$148971[ebp]
	cmp	eax, 1
	je	SHORT $LN11@moveToTime
	mov	ecx, DWORD PTR ?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA
	add	ecx, 12					; 0000000cH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1CE@BGIJBKFE@?$AAt?$AA2?$AAc?$AAR?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@moveToTime:

; 268  : 
; 269  : 			DEBUG_TRANSACTION_LOG("T->C [" << time << "] Q[" << getTransactionQueueCount() << "]" << decodedTransaction);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR tv154[ebp], ecx
	cmp	DWORD PTR tv154[ebp], 0
	je	SHORT $LN12@moveToTime
	mov	edx, DWORD PTR tv154[ebp]
	add	edx, 8
	mov	DWORD PTR tv153[ebp], edx
	jmp	SHORT $LN13@moveToTime
$LN12@moveToTime:
	mov	DWORD PTR tv153[ebp], 0
$LN13@moveToTime:
	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	edi, esp
	mov	ecx, DWORD PTR _decodedTransaction$148970[ebp]
	push	ecx
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTransactionQueueCount@Channel@DRAMsimII@@QBEIXZ ; DRAMsimII::Channel::getTransactionQueueCount
	mov	ebx, esp
	push	eax
	push	OFFSET ??_C@_04GNFNGMLO@?$FN?5Q?$FL?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	edx, DWORD PTR [edx+8]
	push	edx
	push	OFFSET ??_C@_06PIIJMIIG@T?9?$DOC?5?$FL?$AA@
	mov	ecx, DWORD PTR tv153[ebp]
	push	ecx
	mov	DWORD PTR tv751[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	ecx, DWORD PTR tv751[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 270  : 		}
; 271  : 		// if all available transactions are converted to commands, then execute the frame corresponding to this time
; 272  : 		else

	jmp	$LN5@moveToTime
$LN6@moveToTime:

; 273  : 		{
; 274  : 			// move time up by executing frames
; 275  : 			fbdFrame *nextFrame = getNextFrame();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ ; DRAMsimII::fbdChannel::getNextFrame
	mov	DWORD PTR _nextFrame$148984[ebp], eax

; 276  : 
; 277  : 			// if there's a frame at this time
; 278  : 			if (nextFrame)

	cmp	DWORD PTR _nextFrame$148984[ebp], 0
	je	$LN4@moveToTime

; 279  : 			{
; 280  : 				// execute any commands in this frame
; 281  : 				if (nextFrame->getCommandAType() != Command::INVALID_COMMAND)

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandAType
	cmp	eax, 16					; 00000010H
	je	$LN3@moveToTime

; 282  : 				{
; 283  : 					statistics.collectCommandStats(nextFrame->getCommandA());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandA
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 284  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandA());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR tv222[ebp], ecx
	cmp	DWORD PTR tv222[ebp], 0
	je	SHORT $LN14@moveToTime
	mov	edx, DWORD PTR tv222[ebp]
	add	edx, 8
	mov	DWORD PTR tv221[ebp], edx
	jmp	SHORT $LN15@moveToTime
$LN14@moveToTime:
	mov	DWORD PTR tv221[ebp], 0
$LN15@moveToTime:
	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandA
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	mov	ebx, esp
	push	0
	mov	eax, esp
	push	2
	lea	ecx, DWORD PTR $T174386[ebp]
	push	ecx
	mov	DWORD PTR tv753[ebp], eax
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv753[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	edx, DWORD PTR [edx+8]
	push	edx
	mov	ecx, esp
	push	8
	lea	edx, DWORD PTR $T174387[ebp]
	push	edx
	mov	DWORD PTR tv755[ebp], eax
	mov	DWORD PTR tv757[ebp], ecx
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv757[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, esp
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	push	OFFSET ??_C@_04KLOEPAKI@C?5F?$FL?$AA@
	mov	ecx, DWORD PTR tv221[ebp]
	push	ecx
	mov	DWORD PTR tv759[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, DWORD PTR tv759[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	ecx, DWORD PTR tv755[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 285  : 					executeCommand(nextFrame->getCommandA());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandA
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN3@moveToTime:

; 286  : 				}
; 287  : 				if (nextFrame->getCommandBType() != Command::INVALID_COMMAND && nextFrame->getCommandBType() != Command::DATA_COMMAND)

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandBType
	cmp	eax, 16					; 00000010H
	je	$LN2@moveToTime
	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandBType
	cmp	eax, 10					; 0000000aH
	je	$LN2@moveToTime

; 288  : 				{
; 289  : 					statistics.collectCommandStats(nextFrame->getCommandB());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 290  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandB());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR tv299[ebp], ecx
	cmp	DWORD PTR tv299[ebp], 0
	je	SHORT $LN16@moveToTime
	mov	edx, DWORD PTR tv299[ebp]
	add	edx, 8
	mov	DWORD PTR tv298[ebp], edx
	jmp	SHORT $LN17@moveToTime
$LN16@moveToTime:
	mov	DWORD PTR tv298[ebp], 0
$LN17@moveToTime:
	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	mov	ebx, esp
	push	0
	mov	eax, esp
	push	2
	lea	ecx, DWORD PTR $T174390[ebp]
	push	ecx
	mov	DWORD PTR tv761[ebp], eax
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv761[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	edx, DWORD PTR [edx+8]
	push	edx
	mov	ecx, esp
	push	8
	lea	edx, DWORD PTR $T174391[ebp]
	push	edx
	mov	DWORD PTR tv763[ebp], eax
	mov	DWORD PTR tv765[ebp], ecx
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv765[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, esp
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	push	OFFSET ??_C@_04KLOEPAKI@C?5F?$FL?$AA@
	mov	ecx, DWORD PTR tv298[ebp]
	push	ecx
	mov	DWORD PTR tv767[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, DWORD PTR tv767[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	ecx, DWORD PTR tv763[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 291  : 					executeCommand(nextFrame->getCommandB());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN2@moveToTime:

; 292  : 				}
; 293  : 				if (nextFrame->getCommandCType() != Command::INVALID_COMMAND && nextFrame->getCommandCType() != Command::DATA_COMMAND)

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandCType
	cmp	eax, 16					; 00000010H
	je	$LN4@moveToTime
	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::fbdFrame::getCommandCType
	cmp	eax, 10					; 0000000aH
	je	$LN4@moveToTime

; 294  : 				{
; 295  : 					statistics.collectCommandStats(nextFrame->getCommandC());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandC
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 296  : 					DEBUG_COMMAND_LOG("C F[" << std::hex << setw(8) << time << "] MG[" << setw(2) << 0 << "] " << nextFrame->getCommandC());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR tv376[ebp], ecx
	cmp	DWORD PTR tv376[ebp], 0
	je	SHORT $LN18@moveToTime
	mov	edx, DWORD PTR tv376[ebp]
	add	edx, 8
	mov	DWORD PTR tv375[ebp], edx
	jmp	SHORT $LN19@moveToTime
$LN18@moveToTime:
	mov	DWORD PTR tv375[ebp], 0
$LN19@moveToTime:
	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandC
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	mov	ebx, esp
	push	0
	mov	eax, esp
	push	2
	lea	ecx, DWORD PTR $T174394[ebp]
	push	ecx
	mov	DWORD PTR tv769[ebp], eax
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv769[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_05HKAIPFEL@?$FN?5MG?$FL?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	edx, DWORD PTR [edx+8]
	push	edx
	mov	ecx, esp
	push	8
	lea	edx, DWORD PTR $T174395[ebp]
	push	edx
	mov	DWORD PTR tv771[ebp], eax
	mov	DWORD PTR tv773[ebp], ecx
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	mov	ecx, DWORD PTR tv773[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, esp
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	push	OFFSET ??_C@_04KLOEPAKI@C?5F?$FL?$AA@
	mov	ecx, DWORD PTR tv375[ebp]
	push	ecx
	mov	DWORD PTR tv775[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, DWORD PTR tv775[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	ecx, DWORD PTR tv771[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 297  : 					executeCommand(nextFrame->getCommandC());

	mov	ecx, DWORD PTR _nextFrame$148984[ebp]
	call	?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandC
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
$LN4@moveToTime:

; 298  : 				}
; 299  : 			}
; 300  : 
; 301  : 			delete nextFrame;

	mov	eax, DWORD PTR _nextFrame$148984[ebp]
	mov	DWORD PTR $T174399[ebp], eax
	mov	ecx, DWORD PTR $T174399[ebp]
	mov	DWORD PTR $T174398[ebp], ecx
	cmp	DWORD PTR $T174398[ebp], 0
	je	SHORT $LN20@moveToTime
	push	1
	mov	ecx, DWORD PTR $T174398[ebp]
	call	??_GfbdFrame@DRAMsimII@@QAEPAXI@Z
	mov	DWORD PTR tv416[ebp], eax
	jmp	SHORT $LN21@moveToTime
$LN20@moveToTime:
	mov	DWORD PTR tv416[ebp], 0
$LN21@moveToTime:

; 302  : 
; 303  : 			// then build a frame for t+1, if possible
; 304  : 			makeFrame(time);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ; DRAMsimII::fbdChannel::makeFrame

; 305  : 
; 306  : 			// last, move time forward to either the next transaction decode or frame create time
; 307  : 			tick nextDecodeTime = nextTransactionDecodeTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextTransactionDecodeTime
	mov	DWORD PTR _nextDecodeTime$149039[ebp], eax
	mov	DWORD PTR _nextDecodeTime$149039[ebp+4], edx

; 308  : 			assert(nextDecodeTime > time);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv684[ebp], eax
	mov	ecx, DWORD PTR tv684[ebp]
	mov	edx, DWORD PTR _nextDecodeTime$149039[ebp+4]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN22@moveToTime
	jl	SHORT $LN26@moveToTime
	mov	eax, DWORD PTR tv684[ebp]
	mov	ecx, DWORD PTR _nextDecodeTime$149039[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN22@moveToTime
$LN26@moveToTime:
	mov	edx, DWORD PTR ?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA
	add	edx, 53					; 00000035H
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1CM@DDCNBAFL@?$AAn?$AAe?$AAx?$AAt?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@moveToTime:

; 309  : 			tick nextFrameTime = nextFrameExecuteTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ ; DRAMsimII::fbdChannel::nextFrameExecuteTime
	mov	DWORD PTR _nextFrameTime$149042[ebp], eax
	mov	DWORD PTR _nextFrameTime$149042[ebp+4], edx

; 310  : 			assert(nextFrameTime > time);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv701[ebp], eax
	mov	ecx, DWORD PTR tv701[ebp]
	mov	edx, DWORD PTR _nextFrameTime$149042[ebp+4]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN23@moveToTime
	jl	SHORT $LN27@moveToTime
	mov	eax, DWORD PTR tv701[ebp]
	mov	ecx, DWORD PTR _nextFrameTime$149042[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN23@moveToTime
$LN27@moveToTime:
	mov	edx, DWORD PTR ?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA
	add	edx, 55					; 00000037H
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1CK@EOIDILJG@?$AAn?$AAe?$AAx?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$DO?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@moveToTime:

; 311  : 
; 312  : 
; 313  : 			time = min(endTime, min(nextDecodeTime, nextFrameTime));

	lea	eax, DWORD PTR _nextFrameTime$149042[ebp]
	push	eax
	lea	ecx, DWORD PTR _nextDecodeTime$149039[ebp]
	push	ecx
	call	??$min@_J@std@@YAAB_JAB_J0@Z		; std::min<__int64>
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _endTime$[ebp]
	push	edx
	call	??$min@_J@std@@YAAB_JAB_J0@Z		; std::min<__int64>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+12], eax
$LN5@moveToTime:

; 314  : 		}		
; 315  : 	}

	jmp	$LN8@moveToTime
$LN7@moveToTime:

; 316  : 
; 317  : 
; 318  : 	assert(time <= endTime + timingSpecification.tCMD());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCMD
	cdq
	add	eax, DWORD PTR _endTime$[ebp]
	mov	ecx, DWORD PTR _endTime$[ebp+4]
	adc	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv735[ebp], edx
	mov	DWORD PTR tv736[ebp], eax
	mov	DWORD PTR tv736[ebp+4], ecx
	mov	eax, DWORD PTR tv735[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR tv736[ebp+4]
	jl	SHORT $LN24@moveToTime
	jg	SHORT $LN28@moveToTime
	mov	edx, DWORD PTR tv735[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR tv736[ebp]
	jbe	SHORT $LN24@moveToTime
$LN28@moveToTime:
	mov	ecx, DWORD PTR ?__LINE__Var@?1??moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z@4JA
	add	ecx, 63					; 0000003fH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1FK@KLKDOCJF@?$AAt?$AAi?$AAm?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AAn?$AAd?$AAT?$AAi?$AAm?$AAe?$AA?5?$AA?$CL?$AA?5?$AAt?$AAi?$AAm?$AAi?$AAn?$AAg?$AAS?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAc@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@moveToTime:

; 319  : 
; 320  : 	//*transFinishTime = endTime;
; 321  : 
; 322  : 	M5_TIMING_LOG("ch[" << channelID << "] @ " << std::dec << time);
; 323  : 
; 324  : 	return UINT_MAX;

	or	eax, -1

; 325  : 
; 326  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@moveToTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 416				; 000001a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN32@moveToTime:
	DD	2
	DD	$LN31@moveToTime
$LN31@moveToTime:
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN29@moveToTime
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN30@moveToTime
$LN30@moveToTime:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN29@moveToTime:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?moveToTime@fbdChannel@DRAMsimII@@IAEI_JAA_J@Z ENDP	; DRAMsimII::fbdChannel::moveToTime
_TEXT	ENDS
EXTRN	__imp_?setf@ios_base@std@@QAEHHH@Z:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 190  : 	{	// set basefield to hex

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 191  : 	_Iosbase.setf(ios_base::hex, ios_base::basefield);

	mov	esi, esp
	push	3584					; 00000e00H
	push	2048					; 00000800H
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	DWORD PTR __imp_?setf@ios_base@std@@QAEHHH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 192  : 	return (_Iosbase);

	mov	eax, DWORD PTR __Iosbase$[ebp]

; 193  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.h
_TEXT	ENDS
;	COMDAT ?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandA, COMDAT
; _this$ = ecx

; 78   : 		Command* getCommandA() const { return (Command*)slots[0]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandA@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandA
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandB, COMDAT
; _this$ = ecx

; 79   : 		Command* getCommandB() const { return (Command*)slots[1]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandB
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandC, COMDAT
; _this$ = ecx

; 80   : 		Command* getCommandC() const { return (Command*)slots[2]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandC@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandC
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandAType, COMDAT
; _this$ = ecx

; 86   : 		Command::CommandType getCommandAType() const { return commandSlotType[0]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandAType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandAType
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandBType, COMDAT
; _this$ = ecx

; 87   : 		Command::CommandType getCommandBType() const { return commandSlotType[1]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandBType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandBType
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::fbdFrame::getCommandCType, COMDAT
; _this$ = ecx

; 88   : 		Command::CommandType getCommandCType() const { return commandSlotType[2]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandCType@fbdFrame@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::fbdFrame::getCommandCType
_TEXT	ENDS
PUBLIC	?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.h
;	COMDAT ?getTransactionQueueCount@Channel@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getTransactionQueueCount@Channel@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Channel::getTransactionQueueCount, COMDAT
; _this$ = ecx

; 121  : 		unsigned getTransactionQueueCount() const { return transactionQueue.size(); }				///< determine how many items are in the transaction completion queue

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getTransactionQueueCount@Channel@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Channel::getTransactionQueueCount
_TEXT	ENDS
EXTRN	??3fbdFrame@DRAMsimII@@SAXPAX@Z:PROC		; DRAMsimII::fbdFrame::operator delete
EXTRN	??1fbdFrame@DRAMsimII@@QAE@XZ:PROC		; DRAMsimII::fbdFrame::~fbdFrame
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??_GfbdFrame@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GfbdFrame@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::fbdFrame::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1fbdFrame@DRAMsimII@@QAE@XZ		; DRAMsimII::fbdFrame::~fbdFrame
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3fbdFrame@DRAMsimII@@SAXPAX@Z		; DRAMsimII::fbdFrame::operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GfbdFrame@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::fbdFrame::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_1FI@GLFMPPMH@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?1??nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ@4JA ; `DRAMsimII::fbdChannel::nextFrameExecuteTime'::`2'::__LINE__Var
PUBLIC	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ	; DRAMsimII::fbdFrame::getExecuteTime
PUBLIC	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
;	COMDAT ??_C@_1FI@GLFMPPMH@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
CONST	SEGMENT
??_C@_1FI@GLFMPPMH@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'Q', 00H, 'u', 00H
	DB	'e', 00H, 'u', 00H, 'e', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'c'
	DB	00H, 'u', 00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, ' ', 00H, 't'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ@4JA DD 0149H ; `DRAMsimII::fbdChannel::nextFrameExecuteTime'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT ?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ
_TEXT	SEGMENT
tv128 = -216						; size = 4
tv93 = -212						; size = 8
_this$ = -8						; size = 4
?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ PROC ; DRAMsimII::fbdChannel::nextFrameExecuteTime, COMDAT
; _this$ = ecx

; 329  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 330  : 	assert(frameQueue.front()->getExecuteTime() > time);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
	mov	ecx, eax
	call	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ; DRAMsimII::fbdFrame::getExecuteTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	mov	DWORD PTR tv93[ebp+4], edx
	mov	DWORD PTR tv128[ebp], ecx
	mov	edx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR tv93[ebp+4]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN3@nextFrameE
	jl	SHORT $LN4@nextFrameE
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR tv93[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN3@nextFrameE
$LN4@nextFrameE:
	mov	eax, DWORD PTR ?__LINE__Var@?1??nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ@4JA
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1FI@GLFMPPMH@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@nextFrameE:

; 331  : 	return frameQueue.front()->getExecuteTime();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
	mov	ecx, eax
	call	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ; DRAMsimII::fbdFrame::getExecuteTime

; 332  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?nextFrameExecuteTime@fbdChannel@DRAMsimII@@IBE_JXZ ENDP ; DRAMsimII::fbdChannel::nextFrameExecuteTime
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.h
_TEXT	ENDS
;	COMDAT ?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::fbdFrame::getExecuteTime, COMDAT
; _this$ = ecx

; 76   : 		tick getExecuteTime() const { return executeTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::fbdFrame::getExecuteTime
_TEXT	ENDS
PUBLIC	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
PUBLIC	??_C@_1FK@NIPFNNBA@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?1??getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@3@XZ@4JA ; `DRAMsimII::fbdChannel::getNextFrame'::`2'::__LINE__Var
;	COMDAT ??_C@_1FK@NIPFNNBA@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
CONST	SEGMENT
??_C@_1FK@NIPFNNBA@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'Q', 00H, 'u', 00H
	DB	'e', 00H, 'u', 00H, 'e', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'c'
	DB	00H, 'u', 00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@3@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@3@XZ@4JA DD 014fH ; `DRAMsimII::fbdChannel::getNextFrame'::`2'::__LINE__Var
; Function compile flags: /Odtp /RTCcsu /ZI
_DATA	ENDS
;	COMDAT ?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ
_TEXT	SEGMENT
tv94 = -216						; size = 4
tv91 = -212						; size = 8
_this$ = -8						; size = 4
?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ PROC ; DRAMsimII::fbdChannel::getNextFrame, COMDAT
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	assert(frameQueue.front()->getExecuteTime() == time);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
	mov	ecx, eax
	call	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ; DRAMsimII::fbdFrame::getExecuteTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], eax
	mov	DWORD PTR tv91[ebp+4], edx
	mov	DWORD PTR tv94[ebp], ecx
	mov	edx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR tv91[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN4@getNextFra
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR tv91[ebp+4]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN3@getNextFra
$LN4@getNextFra:
	mov	eax, DWORD PTR ?__LINE__Var@?1??getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@3@XZ@4JA
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1FK@NIPFNNBA@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@getNextFra:

; 337  : 	return frameQueue.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getNextFrame@fbdChannel@DRAMsimII@@IAEPAVfbdFrame@2@XZ ENDP ; DRAMsimII::fbdChannel::getNextFrame
_TEXT	ENDS
PUBLIC	?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandC
PUBLIC	?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandB
PUBLIC	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isReadOrWrite
PUBLIC	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
PUBLIC	?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandA
PUBLIC	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
PUBLIC	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
PUBLIC	?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read
PUBLIC	??_C@_1GG@PDIHMKCF@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi?$AAm@ ; `string'
PUBLIC	?__LINE__Var@?1??makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z@4JA ; `DRAMsimII::fbdChannel::makeFrame'::`2'::__LINE__Var
PUBLIC	?back@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::back
EXTRN	??0fbdFrame@DRAMsimII@@QAE@_J@Z:PROC		; DRAMsimII::fbdFrame::fbdFrame
EXTRN	??2fbdFrame@DRAMsimII@@SAPAXI@Z:PROC		; DRAMsimII::fbdFrame::operator new
;	COMDAT ??_C@_1GG@PDIHMKCF@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi?$AAm@
CONST	SEGMENT
??_C@_1GG@PDIHMKCF@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi?$AAm@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'Q', 00H, 'u', 00H
	DB	'e', 00H, 'u', 00H, 'e', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u'
	DB	00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'c'
	DB	00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z@4JA DD 0159H ; `DRAMsimII::fbdChannel::makeFrame'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z$1
__ehfuncinfo$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z
_TEXT	SEGMENT
tv348 = -332						; size = 8
tv310 = -332						; size = 8
tv280 = -332						; size = 8
tv263 = -332						; size = 8
tv215 = -328						; size = 4
tv155 = -328						; size = 4
$T174444 = -320						; size = 4
$T174445 = -308						; size = 4
$T174448 = -296						; size = 4
$T174449 = -284						; size = 4
_extraFrame$149091 = -80				; size = 4
_i$149087 = -68						; size = 4
_newCommand$149084 = -56				; size = 4
_newCommand$149077 = -44				; size = 4
_newFrame$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_currentTime$ = 8					; size = 8
?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z PROC		; DRAMsimII::fbdChannel::makeFrame, COMDAT
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 80					; 00000050H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 	assert(frameQueue.back()->getExecuteTime() != currentTime);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?back@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::back
	mov	ecx, eax
	call	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ; DRAMsimII::fbdFrame::getExecuteTime
	mov	DWORD PTR tv263[ebp], eax
	mov	DWORD PTR tv263[ebp+4], edx
	mov	eax, DWORD PTR tv263[ebp]
	cmp	eax, DWORD PTR _currentTime$[ebp]
	jne	SHORT $LN14@makeFrame
	mov	ecx, DWORD PTR tv263[ebp+4]
	cmp	ecx, DWORD PTR _currentTime$[ebp+4]
	jne	SHORT $LN14@makeFrame
	mov	edx, DWORD PTR ?__LINE__Var@?1??makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z@4JA
	add	edx, 1
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1GG@PDIHMKCF@?$AAf?$AAr?$AAa?$AAm?$AAe?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAe?$AAT?$AAi?$AAm@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@makeFrame:

; 347  : 
; 348  : 	// decide if a new frame should be made or if commands can be added to an existing CMD+D frame
; 349  : 	fbdFrame *newFrame;
; 350  : 
; 351  : 	// then there is already a frame here that contains data so try to find a command to fill the A slot
; 352  : 	if (frameQueue.front()->getExecuteTime() == currentTime)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
	mov	ecx, eax
	call	?getExecuteTime@fbdFrame@DRAMsimII@@QBE_JXZ ; DRAMsimII::fbdFrame::getExecuteTime
	mov	DWORD PTR tv280[ebp], eax
	mov	DWORD PTR tv280[ebp+4], edx
	mov	eax, DWORD PTR tv280[ebp]
	cmp	eax, DWORD PTR _currentTime$[ebp]
	jne	$LN11@makeFrame
	mov	ecx, DWORD PTR tv280[ebp+4]
	cmp	ecx, DWORD PTR _currentTime$[ebp+4]
	jne	$LN11@makeFrame

; 353  : 	{
; 354  : 		newFrame = frameQueue.read(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read
	mov	DWORD PTR _newFrame$[ebp], eax

; 355  : 		// search for an A command, something that can be executed in < 2 ticks
; 356  : 		// this command should also not conflict with the others in the queue
; 357  : 		// or others
; 358  : 		const Command *newCommand = readNextCommand(NULL, NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	mov	DWORD PTR _newCommand$149077[ebp], eax

; 359  : 		// if the command can be issued on the next tick
; 360  : 		if (newCommand && (minProtocolGap(newCommand) - timingSpecification.tCMD() < 1))

	cmp	DWORD PTR _newCommand$149077[ebp], 0
	je	SHORT $LN10@makeFrame
	mov	esi, esp
	mov	eax, DWORD PTR _newCommand$149077[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCMD
	cdq
	sub	esi, eax
	sbb	edi, edx
	mov	DWORD PTR tv310[ebp], esi
	mov	DWORD PTR tv310[ebp+4], edi
	cmp	DWORD PTR tv310[ebp+4], 0
	jg	SHORT $LN10@makeFrame
	jl	SHORT $LN21@makeFrame
	cmp	DWORD PTR tv310[ebp], 1
	jae	SHORT $LN10@makeFrame
$LN21@makeFrame:

; 361  : 		{
; 362  : 			newFrame->setCommandA(getNextCommand(NULL, NULL));

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	push	eax
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandA
$LN10@makeFrame:

; 363  : 		}
; 364  : 	}
; 365  : 	else

	jmp	$LN9@makeFrame
$LN11@makeFrame:

; 366  : 	{
; 367  : 		newFrame = new fbdFrame(currentTime);

	push	48					; 00000030H
	call	??2fbdFrame@DRAMsimII@@SAPAXI@Z		; DRAMsimII::fbdFrame::operator new
	add	esp, 4
	mov	DWORD PTR $T174445[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T174445[ebp], 0
	je	SHORT $LN15@makeFrame
	mov	eax, DWORD PTR _currentTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T174445[ebp]
	call	??0fbdFrame@DRAMsimII@@QAE@_J@Z		; DRAMsimII::fbdFrame::fbdFrame
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $LN16@makeFrame
$LN15@makeFrame:
	mov	DWORD PTR tv155[ebp], 0
$LN16@makeFrame:
	mov	edx, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T174444[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T174444[ebp]
	mov	DWORD PTR _newFrame$[ebp], eax

; 368  : 		frameQueue.push(newFrame);

	mov	eax, DWORD PTR _newFrame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push

; 369  : 
; 370  : 		// search for an A command, something that can be executed in < 2 ticks
; 371  : 		// this command should also not conflict with the others in the queue
; 372  : 		// or others
; 373  : 		const Command *newCommand = readNextCommand(NULL, NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	mov	DWORD PTR _newCommand$149084[ebp], eax

; 374  : 		// if the command can be issued on the next tick
; 375  : 		if (newCommand && (minProtocolGap(newCommand) - timingSpecification.tCMD() < 1))

	cmp	DWORD PTR _newCommand$149084[ebp], 0
	je	$LN9@makeFrame
	mov	esi, esp
	mov	eax, DWORD PTR _newCommand$149084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCMD
	cdq
	sub	esi, eax
	sbb	edi, edx
	mov	DWORD PTR tv348[ebp], esi
	mov	DWORD PTR tv348[ebp+4], edi
	cmp	DWORD PTR tv348[ebp+4], 0
	jg	$LN9@makeFrame
	jl	SHORT $LN22@makeFrame
	cmp	DWORD PTR tv348[ebp], 1
	jae	$LN9@makeFrame
$LN22@makeFrame:

; 376  : 		{
; 377  : 			newFrame->setCommandA(getNextCommand(NULL, NULL));

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	push	eax
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandA

; 378  : 
; 379  : 			// if this was a CAS+W then the frame type will be CMD+D
; 380  : 			if (newCommand->isReadOrWrite())

	mov	ecx, DWORD PTR _newCommand$149084[ebp]
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	movzx	eax, al
	test	eax, eax
	je	$LN7@makeFrame

; 381  : 			{
; 382  : 				newFrame->setCommandB(NULL);

	push	0
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandB

; 383  : 				newFrame->setCommandC(NULL);

	push	0
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandC

; 384  : 				// create some new frames for the remainder of the data
; 385  : 				for (int i = 1; i < timingSpecification.tBurst(); ++i)

	mov	DWORD PTR _i$149087[ebp], 1
	jmp	SHORT $LN6@makeFrame
$LN5@makeFrame:
	mov	eax, DWORD PTR _i$149087[ebp]
	add	eax, 1
	mov	DWORD PTR _i$149087[ebp], eax
$LN6@makeFrame:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBurst
	cmp	DWORD PTR _i$149087[ebp], eax
	jge	$LN4@makeFrame

; 386  : 				{
; 387  : 					fbdFrame *extraFrame = new fbdFrame(currentTime + i);

	push	48					; 00000030H
	call	??2fbdFrame@DRAMsimII@@SAPAXI@Z		; DRAMsimII::fbdFrame::operator new
	add	esp, 4
	mov	DWORD PTR $T174449[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T174449[ebp], 0
	je	SHORT $LN17@makeFrame
	mov	eax, DWORD PTR _i$149087[ebp]
	cdq
	add	eax, DWORD PTR _currentTime$[ebp]
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	adc	ecx, edx
	push	ecx
	push	eax
	mov	ecx, DWORD PTR $T174449[ebp]
	call	??0fbdFrame@DRAMsimII@@QAE@_J@Z		; DRAMsimII::fbdFrame::fbdFrame
	mov	DWORD PTR tv215[ebp], eax
	jmp	SHORT $LN18@makeFrame
$LN17@makeFrame:
	mov	DWORD PTR tv215[ebp], 0
$LN18@makeFrame:
	mov	edx, DWORD PTR tv215[ebp]
	mov	DWORD PTR $T174448[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T174448[ebp]
	mov	DWORD PTR _extraFrame$149091[ebp], eax

; 388  : 					extraFrame->setCommandA(NULL);

	push	0
	mov	ecx, DWORD PTR _extraFrame$149091[ebp]
	call	?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandA

; 389  : 					extraFrame->setCommandB(NULL);

	push	0
	mov	ecx, DWORD PTR _extraFrame$149091[ebp]
	call	?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandB

; 390  : 					extraFrame->setCommandC(NULL);

	push	0
	mov	ecx, DWORD PTR _extraFrame$149091[ebp]
	call	?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandC

; 391  : 					frameQueue.push(extraFrame);

	mov	eax, DWORD PTR _extraFrame$149091[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push

; 392  : 				}

	jmp	$LN5@makeFrame
$LN4@makeFrame:

; 393  : 			}
; 394  : 			// otherwise try to find two more commands to fill the B and C slots
; 395  : 			else

	jmp	SHORT $LN9@makeFrame
$LN7@makeFrame:

; 396  : 			{
; 397  : 				// overloaded readNextCommand() will only return commands which do not interfere with the commands passed in
; 398  : 				if (readNextCommand(newCommand, NULL))

	push	0
	mov	eax, DWORD PTR _newCommand$149084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	test	eax, eax
	je	SHORT $LN2@makeFrame

; 399  : 				{
; 400  : 					newFrame->setCommandB(getNextCommand(newCommand, NULL));

	push	0
	mov	eax, DWORD PTR _newCommand$149084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	push	eax
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandB
$LN2@makeFrame:

; 401  : 				}
; 402  : 				if (readNextCommand(newCommand, newFrame->getCommandB()))

	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
	push	eax
	mov	eax, DWORD PTR _newCommand$149084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	test	eax, eax
	je	SHORT $LN9@makeFrame

; 403  : 				{
; 404  : 					newFrame->setCommandC(getNextCommand(newCommand, newFrame->getCommandB()));

	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?getCommandB@fbdFrame@DRAMsimII@@QBEPAVCommand@2@XZ ; DRAMsimII::fbdFrame::getCommandB
	push	eax
	mov	eax, DWORD PTR _newCommand$149084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::getNextCommand
	push	eax
	mov	ecx, DWORD PTR _newFrame$[ebp]
	call	?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::fbdFrame::setCommandC
$LN9@makeFrame:

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return true;

	mov	al, 1

; 411  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z$0:
	mov	eax, DWORD PTR $T174445[ebp]
	push	eax
	call	??3fbdFrame@DRAMsimII@@SAXPAX@Z		; DRAMsimII::fbdFrame::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z$1:
	mov	eax, DWORD PTR $T174449[ebp]
	push	eax
	call	??3fbdFrame@DRAMsimII@@SAXPAX@Z		; DRAMsimII::fbdFrame::operator delete
	pop	ecx
	ret	0
__ehhandler$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?makeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ENDP		; DRAMsimII::fbdChannel::makeFrame
PUBLIC	?isWrite@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isWrite
PUBLIC	?isRead@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isRead
EXTRN	@_RTC_Check_4_to_1@4:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
;	COMDAT ?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isReadOrWrite, COMDAT
; _this$ = ecx

; 89   : 		bool isReadOrWrite() const { return isRead() || isWrite(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isReadOrWr
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isReadOrWr
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isReadOrWr
$LN3@isReadOrWr:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isReadOrWr:
	mov	ecx, DWORD PTR tv72[ebp]
	call	@_RTC_Check_4_to_1@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isReadOrWrite
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?isRead@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?isRead@Command@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Command::isRead, COMDAT
; _this$ = ecx

; 84   : 		bool isRead() const { return ((commandType == READ) || (commandType == READ_AND_PRECHARGE)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 1
	je	SHORT $LN3@isRead
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 2
	je	SHORT $LN3@isRead
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@isRead
$LN3@isRead:
	mov	DWORD PTR tv68[ebp], 1
$LN4@isRead:
	mov	ecx, DWORD PTR tv68[ebp]
	call	@_RTC_Check_4_to_1@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isRead@Command@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Command::isRead
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?isWrite@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?isWrite@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isWrite, COMDAT
; _this$ = ecx

; 85   : 		bool isWrite() const { return ((commandType == WRITE) || (commandType == WRITE_AND_PRECHARGE)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 3
	je	SHORT $LN3@isWrite
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 4
	je	SHORT $LN3@isWrite
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@isWrite
$LN3@isWrite:
	mov	DWORD PTR tv68[ebp], 1
$LN4@isWrite:
	mov	ecx, DWORD PTR tv68[ebp]
	call	@_RTC_Check_4_to_1@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isWrite@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isWrite
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdframe.h
_TEXT	ENDS
;	COMDAT ?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandA, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			slots[0] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 51   : 			if (!value)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@setCommand

; 52   : 				// can be empty or a command, but never data
; 53   : 				commandSlotType[0] = Command::INVALID_COMMAND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 16			; 00000010H

; 54   : 			else

	jmp	SHORT $LN3@setCommand
$LN2@setCommand:

; 55   : 				commandSlotType[0] = value->getCommandType();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN3@setCommand:

; 56   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?setCommandA@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandA
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandB, COMDAT
; _this$ = ecx

; 58   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 			slots[1] = value; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 60   : 			if (!value)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@setCommand@2

; 61   : 				// assume that an empty command is data
; 62   : 				commandSlotType[1] = Command::DATA_COMMAND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 10			; 0000000aH

; 63   : 			else

	jmp	SHORT $LN3@setCommand@2
$LN2@setCommand@2:

; 64   : 				commandSlotType[1] = value->getCommandType();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@setCommand@2:

; 65   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?setCommandB@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandB
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::fbdFrame::setCommandC, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			slots[2] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 69   : 			if (!value)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@setCommand@3

; 70   : 				commandSlotType[2] = Command::DATA_COMMAND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 10			; 0000000aH

; 71   : 			else

	jmp	SHORT $LN3@setCommand@3
$LN2@setCommand@3:

; 72   : 				commandSlotType[2] = value->getCommandType();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN3@setCommand@3:

; 73   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?setCommandC@fbdFrame@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::fbdFrame::setCommandC
_TEXT	ENDS
PUBLIC	??_C@_1JK@CNGNKKPE@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAR?$AAa?$AAn?$AAk?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe@ ; `string'
PUBLIC	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ	; DRAMsimII::Bank::front
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	??_C@_1GM@MJNBDHBF@?$AAt?$AAe?$AAm?$AAp?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?1??getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@3@PBV43@0@Z@4JA ; `DRAMsimII::fbdChannel::getNextCommand'::`2'::__LINE__Var
PUBLIC	?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ		; DRAMsimII::Bank::pop
PUBLIC	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
;	COMDAT ??_C@_1JK@CNGNKKPE@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAR?$AAa?$AAn?$AAk?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe@
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
CONST	SEGMENT
??_C@_1JK@CNGNKKPE@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAR?$AAa?$AAn?$AAk?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe@ DB 'c'
	DB	00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '.', 00H, 'b', 00H, 'a'
	DB	00H, 'n', 00H, 'k', 00H, '[', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, '(', 00H, ')', 00H, '.', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '(', 00H, ')', 00H, ']'
	DB	00H, '.', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'n'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@MJNBDHBF@?$AAt?$AAe?$AAm?$AAp?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1GM@MJNBDHBF@?$AAt?$AAe?$AAm?$AAp?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ DB 't'
	DB	00H, 'e', 00H, 'm', 00H, 'p', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, '-', 00H, '>', 00H, 'g'
	DB	00H, 'e', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, ':', 00H, ':', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'R', 00H
	DB	'E', 00H, 'S', 00H, 'H', 00H, '_', 00H, 'A', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@3@PBV43@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@3@PBV43@0@Z@4JA DD 01a5H ; `DRAMsimII::fbdChannel::getNextCommand'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z$2
__ehfuncinfo$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z
_TEXT	SEGMENT
tv198 = -332						; size = 4
tv90 = -328						; size = 4
$T174483 = -320						; size = 12
$T174484 = -297						; size = 1
$T174485 = -288						; size = 12
_cur_bank$149281 = -76					; size = 12
_tempCommand$149108 = -56				; size = 4
_currentRank$149106 = -44				; size = 4
_nextCommand$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_slotACommand$ = 8					; size = 4
_slotBCommand$ = 12					; size = 4
?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z PROC ; DRAMsimII::fbdChannel::getNextCommand, COMDAT
; _this$ = ecx

; 421  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 80					; 00000050H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 	const Command *nextCommand = readNextCommand(slotACommand, slotBCommand);

	mov	eax, DWORD PTR _slotBCommand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _slotACommand$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ; DRAMsimII::fbdChannel::readNextCommand
	mov	DWORD PTR _nextCommand$[ebp], eax

; 423  : 
; 424  : 	if (nextCommand)

	cmp	DWORD PTR _nextCommand$[ebp], 0
	je	$LN7@getNextCom

; 425  : 	{
; 426  : 		Rank &currentRank = rank[nextCommand->getAddress().getRank()];

	mov	ecx, DWORD PTR _nextCommand$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	DWORD PTR _currentRank$149106[ebp], eax

; 427  : 
; 428  : 		// if it was a refresh all command, then dequeue all n banks worth of commands
; 429  : 		if (nextCommand->getCommandType() == Command::REFRESH_ALL)

	mov	ecx, DWORD PTR _nextCommand$[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	jne	$LN6@getNextCom

; 430  : 		{
; 431  : 			Command *tempCommand = NULL;

	mov	DWORD PTR _tempCommand$149108[ebp], 0

; 432  : 
; 433  : 			for (vector<Bank>::iterator cur_bank = currentRank.bank.begin(); cur_bank != currentRank.bank.end(); cur_bank++)

	lea	eax, DWORD PTR _cur_bank$149281[ebp]
	push	eax
	mov	ecx, DWORD PTR _currentRank$149106[ebp]
	add	ecx, 388				; 00000184H
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jmp	SHORT $LN5@getNextCom
$LN4@getNextCom:
	push	0
	lea	eax, DWORD PTR $T174483[ebp]
	push	eax
	lea	ecx, DWORD PTR _cur_bank$149281[ebp]
	call	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174483[ebp]
	call	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN5@getNextCom:
	lea	eax, DWORD PTR $T174485[ebp]
	push	eax
	mov	ecx, DWORD PTR _currentRank$149106[ebp]
	add	ecx, 388				; 00000184H
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv198[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv198[ebp]
	push	edx
	lea	ecx, DWORD PTR _cur_bank$149281[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174484[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T174485[ebp]
	call	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174484[ebp]
	test	eax, eax
	je	SHORT $LN3@getNextCom

; 434  : 			{
; 435  : 				//if (tempCommand)
; 436  : 				//delete tempCommand;
; 437  : 				tempCommand = cur_bank->pop();

	lea	ecx, DWORD PTR _cur_bank$149281[ebp]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ	; DRAMsimII::Bank::pop
	mov	DWORD PTR _tempCommand$149108[ebp], eax

; 438  : 				assert(tempCommand->getCommandType() == Command::REFRESH_ALL);

	mov	ecx, DWORD PTR _tempCommand$149108[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN10@getNextCom
	mov	eax, DWORD PTR ?__LINE__Var@?1??getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@3@PBV43@0@Z@4JA
	add	eax, 17					; 00000011H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1GM@MJNBDHBF@?$AAt?$AAe?$AAm?$AAp?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@getNextCom:

; 439  : 			}

	jmp	$LN4@getNextCom
$LN3@getNextCom:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cur_bank$149281[ebp]
	call	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 440  : 
; 441  : 			return tempCommand;

	mov	eax, DWORD PTR _tempCommand$149108[ebp]
	jmp	SHORT $LN8@getNextCom

; 442  : 
; 443  : 		}
; 444  : 		else

	jmp	SHORT $LN2@getNextCom
$LN6@getNextCom:

; 445  : 		{
; 446  : 			//bank_c &currentBank = currentRank.bank[nextCommand->getAddress().bank_id];
; 447  : 			assert(currentRank.bank[nextCommand->getAddress().getBank()].front() == nextCommand);

	mov	ecx, DWORD PTR _nextCommand$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	mov	ecx, DWORD PTR _currentRank$149106[ebp]
	add	ecx, 388				; 00000184H
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	eax, DWORD PTR _nextCommand$[ebp]
	je	SHORT $LN11@getNextCom
	mov	eax, DWORD PTR ?__LINE__Var@?1??getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@3@PBV43@0@Z@4JA
	add	eax, 26					; 0000001aH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1JK@CNGNKKPE@?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAR?$AAa?$AAn?$AAk?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@getNextCom:

; 448  : 			return currentRank.bank[nextCommand->getAddress().getBank()].pop();

	mov	ecx, DWORD PTR _nextCommand$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	mov	ecx, DWORD PTR _currentRank$149106[ebp]
	add	ecx, 388				; 00000184H
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ	; DRAMsimII::Bank::pop
	jmp	SHORT $LN8@getNextCom
$LN2@getNextCom:

; 449  : 		}
; 450  : 	}
; 451  : 	else

	jmp	SHORT $LN8@getNextCom
$LN7@getNextCom:

; 452  : 	{
; 453  : 		return NULL;

	xor	eax, eax
$LN8@getNextCom:

; 454  : 	}
; 455  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@getNextCom
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN18@getNextCom:
	DD	1
	DD	$LN17@getNextCom
$LN17@getNextCom:
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN15@getNextCom
$LN15@getNextCom:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z$0:
	lea	ecx, DWORD PTR _cur_bank$149281[ebp]
	jmp	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z$2:
	lea	ecx, DWORD PTR $T174485[ebp]
	jmp	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getNextCommand@fbdChannel@DRAMsimII@@IAEPAVCommand@2@PBV32@0@Z ENDP ; DRAMsimII::fbdChannel::getNextCommand
PUBLIC	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
;	COMDAT ?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ PROC		; DRAMsimII::Bank::pop, COMDAT
; _this$ = ecx

; 106  : 		Command *pop() { return perBankQueue.pop(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ ENDP		; DRAMsimII::Bank::pop
_TEXT	ENDS
PUBLIC	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ PROC		; DRAMsimII::Bank::front, COMDAT
; _this$ = ecx

; 110  : 		const inline Command *front() const { return perBankQueue.front(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ENDP		; DRAMsimII::Bank::front
_TEXT	ENDS
PUBLIC	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
PUBLIC	??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::~_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
PUBLIC	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::~_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::~_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
_TEXT	ENDS
PUBLIC	??1_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::~_Iterator_base
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::~_Iterator_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	?_Orphan_me@_Iterator_base@std@@QAEXXZ		; std::_Iterator_base::_Orphan_me
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1_Iterator_base@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Iterator_base@std@@QAE@XZ$0
__ehfuncinfo$??1_Iterator_base@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_Iterator_base@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::~_Iterator_base, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Iterator_base@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 161  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 162  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@Iterator_b:
	DD	1
	DD	$LN6@Iterator_b
$LN6@Iterator_b:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN4@Iterator_b
$LN4@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Iterator_base@std@@QAE@XZ$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??1_Iterator_base@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Iterator_base@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::~_Iterator_base
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ ; `string'
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
CONST	SEGMENT
??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, ' ', 00H, '9', 00H, '.', 00H, '0', 00H, '\', 00H, 'v', 00H
	DB	'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u'
	DB	00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?_Orphan_me@_Iterator_base@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$6734 = -20					; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base@std@@QAEXXZ PROC		; std::_Iterator_base::_Orphan_me, COMDAT
; _this$ = ecx

; 180  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 		if (_Mycont != 0 && _Mycont->_Myfirstiter != _IGNORE_MYITERLIST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_me
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], -3			; fffffffdH
	je	SHORT $LN5@Orphan_me

; 182  : 			{	// adopted, remove self from list
; 183  : 			_Iterator_base **_Pnext =
; 184  : 				(_Iterator_base **)&_Mycont->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$6734[ebp], ecx
$LN3@Orphan_me:

; 185  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$6734[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Orphan_me
	mov	eax, DWORD PTR __Pnext$6734[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN2@Orphan_me

; 186  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$6734[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$6734[ebp], ecx
	jmp	SHORT $LN3@Orphan_me
$LN2@Orphan_me:

; 187  : 
; 188  : 			if (*_Pnext == 0)

	mov	eax, DWORD PTR __Pnext$6734[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@Orphan_me

; 189  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	mov	esi, esp
	push	189					; 000000bdH
	push	OFFSET ??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Orphan_me:

; 190  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$6734[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 191  : 			_Mycont = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@Orphan_me:

; 192  : 			}
; 193  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base@std@@QAEXXZ ENDP		; std::_Iterator_base::_Orphan_me
_TEXT	ENDS
PUBLIC	?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z	; DRAMsimII::fbdChannel::executeFrame
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\fbdchannel.cpp
;	COMDAT ?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_currentTime$ = 8					; size = 8
?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z PROC	; DRAMsimII::fbdChannel::executeFrame, COMDAT
; _this$ = ecx

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 	return true;

	mov	al, 1

; 464  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?executeFrame@fbdChannel@DRAMsimII@@IAE_N_J@Z ENDP	; DRAMsimII::fbdChannel::executeFrame
_TEXT	ENDS
PUBLIC	??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ ; `string'
PUBLIC	??_C@_02DGMJFIKM@R?$FL?$AA@			; `string'
PUBLIC	??_C@_04HDDNHBJH@?$FN?5B?$FL?$AA@		; `string'
PUBLIC	??_C@_0L@MHDLOPIJ@?$FN?7Winner?3?5?$AA@		; `string'
PUBLIC	??_C@_04JMOLNPBG@gap?$FL?$AA@			; `string'
PUBLIC	??_C@_06GKILHJPD@?$FN?5now?$FL?$AA@		; `string'
PUBLIC	??_C@_1BHA@CCOEMDDK@?$AAc?$AAa?$AAn?$AAd?$AAi?$AAd?$AAa?$AAt?$AAe?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe@ ; `string'
PUBLIC	??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@ ; `string'
PUBLIC	??_C@_1KA@MODELNOF@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@ ; `string'
PUBLIC	??_C@_1KA@LLLAOIOH@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@ ; `string'
PUBLIC	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z	; DRAMsimII::Bank::read
PUBLIC	?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
PUBLIC	?isRefresh@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isRefresh
PUBLIC	??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@ ; `string'
PUBLIC	??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@ ; `string'
PUBLIC	??_C@_1BII@BPHIPAGI@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT@ ; `string'
PUBLIC	??_C@_1BMI@FKLBHNEB@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA ; `DRAMsimII::fbdChannel::readNextCommand'::`2'::__LINE__Var
PUBLIC	?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::Bank::nextCommandType
PUBLIC	??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=
PUBLIC	?size@Bank@DRAMsimII@@QBEIXZ			; DRAMsimII::Bank::size
PUBLIC	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getEnqueueTime
PUBLIC	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	?getRankID@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getRankID
PUBLIC	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
PUBLIC	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
PUBLIC	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
PUBLIC	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm
PUBLIC	?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRankCount
PUBLIC	?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getBankCount
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
;	COMDAT ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
CONST	SEGMENT
??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ DB 'This configur'
	DB	'ation and algorithm combination is not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGMJFIKM@R?$FL?$AA@
CONST	SEGMENT
??_C@_02DGMJFIKM@R?$FL?$AA@ DB 'R[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDDNHBJH@?$FN?5B?$FL?$AA@
CONST	SEGMENT
??_C@_04HDDNHBJH@?$FN?5B?$FL?$AA@ DB '] B[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHDLOPIJ@?$FN?7Winner?3?5?$AA@
CONST	SEGMENT
??_C@_0L@MHDLOPIJ@?$FN?7Winner?3?5?$AA@ DB ']', 09H, 'Winner: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JMOLNPBG@gap?$FL?$AA@
CONST	SEGMENT
??_C@_04JMOLNPBG@gap?$FL?$AA@ DB 'gap[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKILHJPD@?$FN?5now?$FL?$AA@
CONST	SEGMENT
??_C@_06GKILHJPD@?$FN?5now?$FL?$AA@ DB '] now[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BHA@CCOEMDDK@?$AAc?$AAa?$AAn?$AAd?$AAi?$AAd?$AAa?$AAt?$AAe?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe@
CONST	SEGMENT
??_C@_1BHA@CCOEMDDK@?$AAc?$AAa?$AAn?$AAd?$AAi?$AAd?$AAa?$AAt?$AAe?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe@ DB 'c'
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e', 00H
	DB	't', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o'
	DB	00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H
	DB	':', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'R', 00H, 'E', 00H, 'S'
	DB	00H, 'H', 00H, '_', 00H, 'A', 00H, 'L', 00H, 'L', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '[', 00H, 'c', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'i', 00H
	DB	'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, '-', 00H, '>', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, '(', 00H, ')', 00H, '.', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '(', 00H, ')', 00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H
	DB	'n', 00H, 'k', 00H, '[', 00H, 'c', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, 'i', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, '-'
	DB	00H, '>', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'A', 00H, 'd', 00H
	DB	'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, '(', 00H, ')'
	DB	00H, '.', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'B', 00H, 'a', 00H
	DB	'n', 00H, 'k', 00H, '(', 00H, ')', 00H, ']', 00H, '.', 00H, 'f'
	DB	00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, 'i', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@
CONST	SEGMENT
??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@ DB 'Serious pro'
	DB	'blems. RAS not followed by CAS.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@MODELNOF@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
CONST	SEGMENT
??_C@_1KA@MODELNOF@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@ DB 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, '[', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I'
	DB	00H, 'D', 00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'n', 00H
	DB	'k', 00H, '[', 00H, 'l', 00H, 'a', 00H, 's', 00H, 't', 00H, 'B'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I', 00H, 'D', 00H, ']', 00H
	DB	'.', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '('
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, '(', 00H, ')', 00H, '.', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I', 00H, 'D'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@LLLAOIOH@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
CONST	SEGMENT
??_C@_1KA@LLLAOIOH@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@ DB 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, '[', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I'
	DB	00H, 'D', 00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'n', 00H
	DB	'k', 00H, '[', 00H, 'l', 00H, 'a', 00H, 's', 00H, 't', 00H, 'B'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I', 00H, 'D', 00H, ']', 00H
	DB	'.', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '('
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, '(', 00H, ')', 00H, '.', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, 'I', 00H, 'D'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
CONST	SEGMENT
??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@ DB 'Did not f'
	DB	'ind a CAS or RAS command when it was expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@
CONST	SEGMENT
??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@ DB 'Serious pro'
	DB	'blems. RAS not followed by CAS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BII@BPHIPAGI@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT@
CONST	SEGMENT
??_C@_1BII@BPHIPAGI@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT@ DB 'o'
	DB	00H, 'l', 00H, 'd', 00H, 'e', 00H, 's', 00H, 't', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, '-', 00H, '>', 00H, 'f', 00H, 'r'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, '-', 00H
	DB	'>', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H
	DB	'n', 00H, 'd', 00H, ':', 00H, ':', 00H, 'R', 00H, 'E', 00H, 'F'
	DB	00H, 'R', 00H, 'E', 00H, 'S', 00H, 'H', 00H, '_', 00H, 'A', 00H
	DB	'L', 00H, 'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, '[', 00H, 'o', 00H, 'l', 00H
	DB	'd', 00H, 'e', 00H, 's', 00H, 't', 00H, 'B', 00H, 'a', 00H, 'n'
	DB	00H, 'k', 00H, '-', 00H, '>', 00H, 'f', 00H, 'r', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H, 'g'
	DB	00H, 'e', 00H, 't', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, '(', 00H, ')', 00H, '.', 00H, 'g'
	DB	00H, 'e', 00H, 't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H
	DB	'(', 00H, ')', 00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'n'
	DB	00H, 'k', 00H, '[', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H
	DB	's', 00H, 't', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't', 00H
	DB	'(', 00H, ')', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, '(', 00H, ')', 00H, '.', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '(', 00H, ')', 00H
	DB	']', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 's', 00H, 't', 00H, 'B'
	DB	00H, 'a', 00H, 'n', 00H, 'k', 00H, '-', 00H, '>', 00H, 'f', 00H
	DB	'r', 00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BMI@FKLBHNEB@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn@
CONST	SEGMENT
??_C@_1BMI@FKLBHNEB@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn@ DB 'o'
	DB	00H, 'l', 00H, 'd', 00H, 'e', 00H, 's', 00H, 't', 00H, 'E', 00H
	DB	'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H
	DB	'-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H, ':', 00H, 'R'
	DB	00H, 'E', 00H, 'F', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'H', 00H
	DB	'_', 00H, 'A', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '[', 00H
	DB	'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 's', 00H, 't', 00H, 'E'
	DB	00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '-', 00H, '>', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H, 'g', 00H, 'e'
	DB	00H, 't', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, '(', 00H, ')', 00H, '.', 00H, 'g', 00H, 'e'
	DB	00H, 't', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '(', 00H
	DB	')', 00H, ']', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '[', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'a', 00H
	DB	'n', 00H, 'k', 00H, '-', 00H, '>', 00H, 'f', 00H, 'r', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, '(', 00H, ')', 00H, '.', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '(', 00H, ')', 00H, ']', 00H, '.', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H
	DB	's', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, '-', 00H, '>', 00H, 'f', 00H, 'r'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA DD 01daH ; `DRAMsimII::fbdChannel::readNextCommand'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z DD 019930522H
	DD	018H
	DD	FLAT:__unwindtable$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$11
	DD	08H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$14
	DD	0aH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$16
	DD	0aH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$17
	DD	0cH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$20
	DD	0eH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$22
	DD	0eH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$23
	DD	010H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$26
	DD	012H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$28
	DD	012H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$29
	DD	014H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$31
	DD	014H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$32
	DD	016H
	DD	FLAT:__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$34
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z
_TEXT	SEGMENT
tv2083 = -1520						; size = 4
tv2081 = -1516						; size = 4
tv1987 = -1516						; size = 8
tv1538 = -1516						; size = 8
tv2079 = -1512						; size = 4
tv1984 = -1508						; size = 8
tv1574 = -1508						; size = 8
tv1535 = -1508						; size = 8
tv1510 = -1508						; size = 8
tv1462 = -1508						; size = 4
tv1458 = -1508						; size = 4
tv1454 = -1508						; size = 4
tv1449 = -1508						; size = 4
tv1445 = -1508						; size = 4
tv1440 = -1508						; size = 4
tv1436 = -1508						; size = 4
tv1426 = -1508						; size = 4
tv1422 = -1508						; size = 4
tv1418 = -1508						; size = 4
tv1414 = -1508						; size = 4
tv1355 = -1508						; size = 4
tv1356 = -1504						; size = 4
tv1259 = -1504						; size = 4
tv1199 = -1504						; size = 4
tv1172 = -1504						; size = 4
tv950 = -1504						; size = 4
tv923 = -1504						; size = 4
tv858 = -1504						; size = 4
tv673 = -1504						; size = 4
tv646 = -1504						; size = 4
tv549 = -1504						; size = 4
tv367 = -1504						; size = 4
tv303 = -1504						; size = 4
tv243 = -1504						; size = 4
tv206 = -1504						; size = 4
tv193 = -1504						; size = 4
tv185 = -1504						; size = 4
tv175 = -1504						; size = 4
tv165 = -1504						; size = 4
tv151 = -1504						; size = 4
tv91 = -1504						; size = 4
$T174544 = -1496					; size = 12
$T174545 = -1473					; size = 1
$T174546 = -1464					; size = 12
$T174547 = -1444					; size = 12
$T174548 = -1421					; size = 1
$T174549 = -1412					; size = 12
$T174550 = -1392					; size = 12
$T174551 = -1369					; size = 1
$T174552 = -1360					; size = 12
$T174553 = -1340					; size = 12
$T174554 = -1317					; size = 1
$T174555 = -1308					; size = 12
$T174557 = -1288					; size = 4
$T174559 = -1276					; size = 4
$T174560 = -1264					; size = 4
$T174561 = -1252					; size = 12
$T174562 = -1229					; size = 1
$T174563 = -1220					; size = 12
$T174564 = -1200					; size = 12
$T174565 = -1177					; size = 1
$T174566 = -1168					; size = 12
$T174567 = -1148					; size = 4
$T174570 = -1136					; size = 12
$T174571 = -1113					; size = 1
$T174572 = -1104					; size = 12
$T174573 = -1084					; size = 12
$T174574 = -1061					; size = 1
$T174575 = -1052					; size = 12
$T174576 = -1032					; size = 4
$T174579 = -1020					; size = 12
$T174580 = -997						; size = 1
$T174581 = -988						; size = 12
$T174582 = -968						; size = 12
$T174583 = -945						; size = 1
$T174584 = -936						; size = 12
$T174585 = -916						; size = 12
$T174586 = -893						; size = 1
$T174587 = -884						; size = 12
_thisBank$149731 = -672					; size = 12
_challengerGap$149722 = -652				; size = 4
_challengerCommand$149720 = -640			; size = 4
_currentBank$149712 = -628				; size = 12
_notAllRefresh$149707 = -605				; size = 1
_currentRank$149699 = -596				; size = 12
_candidateGap$149694 = -576				; size = 4
_candidateCommand$149693 = -564				; size = 4
_next_c$149685 = -552					; size = 4
_temp_c$149681 = -540					; size = 4
_currentBank$149667 = -528				; size = 12
_notAllRefresh$149662 = -505				; size = 1
_currentRank$149654 = -496				; size = 12
_noPendingRefreshes$149644 = -473			; size = 1
_originalTransactionType$149643 = -464			; size = 4
_originalLastBankID$149642 = -452			; size = 4
_originalLastRankID$149641 = -440			; size = 4
_temp_c$149626 = -428					; size = 4
_transactionType$149620 = -416				; size = 4
_next_c$149610 = -404					; size = 4
_temp_c$149606 = -392					; size = 4
_currentBank$149592 = -380				; size = 12
_notAllRefresh$149587 = -357				; size = 1
_currentRank$149579 = -348				; size = 12
_noPendingRefreshes$149569 = -325			; size = 1
_originalTransactionType$149568 = -316			; size = 4
_originalLastBankID$149567 = -304			; size = 4
_originalLastRankID$149566 = -292			; size = 4
_temp_c$149550 = -280					; size = 4
_transactionType$149544 = -268				; size = 4
_currentBank$149514 = -256				; size = 12
_currentBank$149495 = -236				; size = 12
_temp_c$149486 = -216					; size = 4
_bank_id$149478 = -204					; size = 12
_notAllRefresh$149473 = -181				; size = 1
_currentRank$149463 = -172				; size = 12
_oldestExecutableBank$149338 = -152			; size = 12
_oldestBank$149333 = -132				; size = 12
_oldestExecutableCommandTime$149326 = -112		; size = 8
_oldestCommandTime$149323 = -96				; size = 8
_slotBRank$ = -80					; size = 4
_slotARank$ = -68					; size = 4
_lastCommandType$ = -56					; size = 4
_lastRankID$ = -44					; size = 4
_lastBankID$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_slotACommand$ = 8					; size = 4
_slotBCommand$ = 12					; size = 4
?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z PROC ; DRAMsimII::fbdChannel::readNextCommand, COMDAT
; _this$ = ecx

; 474  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1508				; 000005e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1520]
	mov	ecx, 377				; 00000179H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 	// look at the most recently retired command in this channel's history
; 476  : 
; 477  : 	//const Command *lastCommand = historyQueue.back();
; 478  : 
; 479  : 	unsigned lastBankID = lastCommand ? lastCommand->getAddress().getBank() : systemConfig.getBankCount() - 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN123@readNextCo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN124@readNextCo
$LN123@readNextCo:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+168]
	call	?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getBankCount
	sub	eax, 1
	mov	DWORD PTR tv91[ebp], eax
$LN124@readNextCo:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR _lastBankID$[ebp], eax

; 480  : 	unsigned lastRankID = lastCommand ? lastCommand->getAddress().getRank() : systemConfig.getRankCount() - 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN125@readNextCo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN126@readNextCo
$LN125@readNextCo:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+168]
	call	?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRankCount
	sub	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN126@readNextCo:
	mov	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR _lastRankID$[ebp], eax

; 481  : 	const Command::CommandType lastCommandType = lastCommand ? lastCommand->getCommandType() : Command::WRITE_AND_PRECHARGE;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN127@readNextCo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN128@readNextCo
$LN127@readNextCo:
	mov	DWORD PTR tv165[ebp], 4
$LN128@readNextCo:
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR _lastCommandType$[ebp], edx

; 482  : 
; 483  : 	const int slotARank = slotACommand ? slotACommand->getAddress().getRank() : -1;

	cmp	DWORD PTR _slotACommand$[ebp], 0
	je	SHORT $LN129@readNextCo
	mov	ecx, DWORD PTR _slotACommand$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN130@readNextCo
$LN129@readNextCo:
	mov	DWORD PTR tv175[ebp], -1
$LN130@readNextCo:
	mov	eax, DWORD PTR tv175[ebp]
	mov	DWORD PTR _slotARank$[ebp], eax

; 484  : 	const int slotBRank = slotBCommand ? slotBCommand->getAddress().getRank() : -1;

	cmp	DWORD PTR _slotBCommand$[ebp], 0
	je	SHORT $LN131@readNextCo
	mov	ecx, DWORD PTR _slotBCommand$[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN132@readNextCo
$LN131@readNextCo:
	mov	DWORD PTR tv185[ebp], -1
$LN132@readNextCo:
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR _slotBRank$[ebp], eax

; 485  : 
; 486  : 	switch (systemConfig.getCommandOrderingAlgorithm())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 3
	ja	$LN1@readNextCo
	mov	ecx, DWORD PTR tv193[ebp]
	jmp	DWORD PTR $LN201@readNextCo[ecx*4]
$LN118@readNextCo:

; 487  : 	{
; 488  : 		// this strategy attempts to find the oldest command and returns that to be executed
; 489  : 		// however, if the oldest command cannot be issued, the oldest command that can be executed immediately
; 490  : 		// will be returned instead
; 491  : 	case STRICT_ORDER:
; 492  : 		{
; 493  : 			tick oldestCommandTime = TICK_MAX;

	mov	DWORD PTR _oldestCommandTime$149323[ebp], -1
	mov	DWORD PTR _oldestCommandTime$149323[ebp+4], 2147483647 ; 7fffffffH

; 494  : 			tick oldestExecutableCommandTime = TICK_MAX;

	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp], -1
	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp+4], 2147483647 ; 7fffffffH

; 495  : 			vector<Bank>::const_iterator oldestBank;

	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 496  : 			vector<Bank>::const_iterator oldestExecutableBank;

	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 497  : 
; 498  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	lea	eax, DWORD PTR _currentRank$149463[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	jmp	SHORT $LN117@readNextCo
$LN116@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174544[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
	lea	ecx, DWORD PTR $T174544[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN117@readNextCo:
	lea	eax, DWORD PTR $T174546[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	DWORD PTR tv206[ebp], eax
	mov	ecx, DWORD PTR tv206[ebp]
	mov	DWORD PTR tv1414[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR tv1414[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
	mov	BYTE PTR $T174545[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T174546[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174545[ebp]
	test	eax, eax
	je	$LN115@readNextCo

; 499  : 			{
; 500  : 				// do not consider ranks which have already had a command chosen from them
; 501  : 				if (currentRank->getRankID() == slotARank || currentRank->getRankID() == slotBRank)

	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, eax
	call	?getRankID@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getRankID
	cmp	eax, DWORD PTR _slotARank$[ebp]
	je	SHORT $LN113@readNextCo
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, eax
	call	?getRankID@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getRankID
	cmp	eax, DWORD PTR _slotBRank$[ebp]
	jne	SHORT $LN114@readNextCo
$LN113@readNextCo:

; 502  : 					continue;

	jmp	$LN116@readNextCo
$LN114@readNextCo:

; 503  : 
; 504  : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$149473[ebp], 0

; 505  : 
; 506  : 				for (vector<Bank>::const_iterator bank_id = currentRank->bank.begin(); bank_id != currentRank->bank.end(); bank_id++)

	lea	eax, DWORD PTR _bank_id$149478[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	jmp	SHORT $LN112@readNextCo
$LN111@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174547[ebp]
	push	eax
	lea	ecx, DWORD PTR _bank_id$149478[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174547[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN112@readNextCo:
	lea	eax, DWORD PTR $T174549[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv243[ebp], eax
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR tv1418[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv1418[ebp]
	push	edx
	lea	ecx, DWORD PTR _bank_id$149478[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174548[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T174549[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174548[ebp]
	test	eax, eax
	je	$LN110@readNextCo

; 507  : 				{
; 508  : 					if (const Command *temp_c = bank_id->front())

	lea	ecx, DWORD PTR _bank_id$149478[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _temp_c$149486[ebp], eax
	cmp	DWORD PTR _temp_c$149486[ebp], 0
	je	$LN109@readNextCo

; 509  : 					{
; 510  : 						if ((temp_c->getEnqueueTime() < oldestExecutableCommandTime) && (minProtocolGap(temp_c) <= timingSpecification.tCMD()))

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR tv1510[ebp], eax
	mov	DWORD PTR tv1510[ebp+4], edx
	mov	eax, DWORD PTR tv1510[ebp+4]
	cmp	eax, DWORD PTR _oldestExecutableCommandTime$149326[ebp+4]
	jg	$LN109@readNextCo
	jl	SHORT $LN177@readNextCo
	mov	ecx, DWORD PTR tv1510[ebp]
	cmp	ecx, DWORD PTR _oldestExecutableCommandTime$149326[ebp]
	jae	$LN109@readNextCo
$LN177@readNextCo:
	mov	esi, esp
	mov	eax, DWORD PTR _temp_c$149486[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tCMD
	cdq
	mov	DWORD PTR tv1535[ebp], esi
	mov	DWORD PTR tv1535[ebp+4], edi
	mov	DWORD PTR tv1538[ebp], eax
	mov	DWORD PTR tv1538[ebp+4], edx
	mov	ecx, DWORD PTR tv1535[ebp+4]
	cmp	ecx, DWORD PTR tv1538[ebp+4]
	jg	$LN109@readNextCo
	jl	SHORT $LN178@readNextCo
	mov	edx, DWORD PTR tv1535[ebp]
	cmp	edx, DWORD PTR tv1538[ebp]
	ja	$LN109@readNextCo
$LN178@readNextCo:

; 511  : 						{
; 512  : 							// if it's a Command::REFRESH_ALL command and
; 513  : 							// we haven't proved that all the queues aren't Command::REFRESH_ALL commands, search
; 514  : 							if (temp_c->getCommandType() == Command::REFRESH_ALL)

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	jne	$LN107@readNextCo

; 515  : 							{
; 516  : 								if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149473[ebp]
	test	eax, eax
	jne	$LN106@readNextCo

; 517  : 								{
; 518  : 									// try to show that at the head of each queue isn't a refresh command
; 519  : 									for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	eax, DWORD PTR _currentBank$149495[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	jmp	SHORT $LN105@readNextCo
$LN104@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174550[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174550[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN105@readNextCo:
	lea	eax, DWORD PTR $T174552[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv303[ebp], eax
	mov	ecx, DWORD PTR tv303[ebp]
	mov	DWORD PTR tv1422[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR tv1422[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174551[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T174552[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174551[ebp]
	test	eax, eax
	je	SHORT $LN103@readNextCo

; 520  : 									{
; 521  : 										// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 522  : 										if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?size@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::size
	test	eax, eax
	je	SHORT $LN101@readNextCo
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	test	eax, eax
	je	SHORT $LN102@readNextCo
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN102@readNextCo
$LN101@readNextCo:

; 523  : 										{
; 524  : 											notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$149473[ebp], 1

; 525  : 											break;

	jmp	SHORT $LN103@readNextCo
$LN102@readNextCo:

; 526  : 										}

	jmp	$LN104@readNextCo
$LN103@readNextCo:

; 527  : 
; 528  : 									}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 529  : 									// if all are known now to be refresh commands
; 530  : 									if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149473[ebp]
	test	eax, eax
	jne	SHORT $LN106@readNextCo

; 531  : 									{
; 532  : 										oldestExecutableCommandTime = temp_c->getEnqueueTime();

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp], eax
	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp+4], edx

; 533  : 										oldestExecutableBank = bank_id;

	lea	eax, DWORD PTR _bank_id$149478[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
$LN106@readNextCo:

; 534  : 									}
; 535  : 								}
; 536  : 							}

	jmp	$LN109@readNextCo
$LN107@readNextCo:

; 537  : 							else if (temp_c->getEnqueueTime() < oldestCommandTime)

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR tv1574[ebp], eax
	mov	DWORD PTR tv1574[ebp+4], edx
	mov	eax, DWORD PTR tv1574[ebp+4]
	cmp	eax, DWORD PTR _oldestCommandTime$149323[ebp+4]
	jg	$LN98@readNextCo
	jl	SHORT $LN179@readNextCo
	mov	ecx, DWORD PTR tv1574[ebp]
	cmp	ecx, DWORD PTR _oldestCommandTime$149323[ebp]
	jae	$LN98@readNextCo
$LN179@readNextCo:

; 538  : 							{
; 539  : 								// if it's a Command::REFRESH_ALL command and
; 540  : 								// we haven't proved that all the queues aren't Command::REFRESH_ALL commands, search
; 541  : 								if (temp_c->getCommandType() == Command::REFRESH_ALL)

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	jne	$LN97@readNextCo

; 542  : 								{
; 543  : 									if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149473[ebp]
	test	eax, eax
	jne	$LN96@readNextCo

; 544  : 									{
; 545  : 										// try to show that at the head of each queue isn't a refresh command
; 546  : 										for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	eax, DWORD PTR _currentBank$149514[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	jmp	SHORT $LN95@readNextCo
$LN94@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174553[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174553[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN95@readNextCo:
	lea	eax, DWORD PTR $T174555[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv367[ebp], eax
	mov	ecx, DWORD PTR tv367[ebp]
	mov	DWORD PTR tv1426[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv1426[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174554[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T174555[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174554[ebp]
	test	eax, eax
	je	SHORT $LN93@readNextCo

; 547  : 										{
; 548  : 											// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 549  : 											if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?size@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::size
	test	eax, eax
	je	SHORT $LN91@readNextCo
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	test	eax, eax
	je	SHORT $LN92@readNextCo
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN92@readNextCo
$LN91@readNextCo:

; 550  : 											{
; 551  : 												notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$149473[ebp], 1

; 552  : 												break;

	jmp	SHORT $LN93@readNextCo
$LN92@readNextCo:

; 553  : 											}

	jmp	$LN94@readNextCo
$LN93@readNextCo:

; 554  : 
; 555  : 										}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 556  : 										// if all are known now to be refresh commands
; 557  : 										if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149473[ebp]
	test	eax, eax
	jne	SHORT $LN96@readNextCo

; 558  : 										{
; 559  : 											oldestCommandTime = temp_c->getEnqueueTime();

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR _oldestCommandTime$149323[ebp], eax
	mov	DWORD PTR _oldestCommandTime$149323[ebp+4], edx

; 560  : 											oldestBank = bank_id;

	lea	eax, DWORD PTR _bank_id$149478[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
$LN96@readNextCo:

; 561  : 										}
; 562  : 									}
; 563  : 								}
; 564  : 								else

	jmp	SHORT $LN89@readNextCo
$LN97@readNextCo:

; 565  : 								{
; 566  : 									oldestCommandTime = temp_c->getEnqueueTime();

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR _oldestCommandTime$149323[ebp], eax
	mov	DWORD PTR _oldestCommandTime$149323[ebp+4], edx

; 567  : 									oldestBank = bank_id;

	lea	eax, DWORD PTR _bank_id$149478[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
$LN89@readNextCo:

; 568  : 								}
; 569  : 
; 570  : 							}
; 571  : 
; 572  : 							else

	jmp	SHORT $LN109@readNextCo
$LN98@readNextCo:

; 573  : 							{
; 574  : 								oldestExecutableCommandTime = temp_c->getEnqueueTime();

	mov	ecx, DWORD PTR _temp_c$149486[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp], eax
	mov	DWORD PTR _oldestExecutableCommandTime$149326[ebp+4], edx

; 575  : 								oldestExecutableBank = bank_id;

	lea	eax, DWORD PTR _bank_id$149478[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
$LN109@readNextCo:

; 576  : 							}
; 577  : 						}
; 578  : 					}

	jmp	$LN111@readNextCo
$LN110@readNextCo:

; 579  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _bank_id$149478[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	$LN116@readNextCo
$LN115@readNextCo:

; 580  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ

; 581  : 
; 582  : 			// if any executable command was found, prioritize it over those which must wait
; 583  : 			if (oldestExecutableCommandTime < TICK_MAX)

	cmp	DWORD PTR _oldestExecutableCommandTime$149326[ebp+4], 2147483647 ; 7fffffffH
	jg	$LN87@readNextCo
	jl	SHORT $LN180@readNextCo
	cmp	DWORD PTR _oldestExecutableCommandTime$149326[ebp], -1
	jae	$LN87@readNextCo
$LN180@readNextCo:

; 584  : 			{
; 585  : 				assert(oldestExecutableBank->nextCommandType() == Command::REFRESH_ALL || rank[oldestExecutableBank->front()->getAddress().getRank()].bank[oldestExecutableBank->front()->getAddress().getBank()].front() == oldestExecutableBank->front());

	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::Bank::nextCommandType
	cmp	eax, 12					; 0000000cH
	je	$LN133@readNextCo
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	esi, eax
	je	SHORT $LN133@readNextCo
	mov	eax, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	eax, 111				; 0000006fH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1BMI@FKLBHNEB@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN133@readNextCo:

; 586  : 
; 587  : 				return oldestExecutableBank->front();

	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR $T174557[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T174557[ebp]
	jmp	$LN122@readNextCo
	jmp	$LN86@readNextCo
$LN87@readNextCo:

; 588  : 			}
; 589  : 			// if there was a command found
; 590  : 			else if (oldestCommandTime < TICK_MAX)

	cmp	DWORD PTR _oldestCommandTime$149323[ebp+4], 2147483647 ; 7fffffffH
	jg	$LN85@readNextCo
	jl	SHORT $LN181@readNextCo
	cmp	DWORD PTR _oldestCommandTime$149323[ebp], -1
	jae	$LN85@readNextCo
$LN181@readNextCo:

; 591  : 			{
; 592  : 				assert(oldestBank->front()->getCommandType() == Command::REFRESH_ALL || rank[oldestBank->front()->getAddress().getRank()].bank[oldestBank->front()->getAddress().getBank()].front() == oldestBank->front());

	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	$LN134@readNextCo
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	esi, eax
	je	SHORT $LN134@readNextCo
	mov	eax, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	eax, 118				; 00000076H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1BII@BPHIPAGI@?$AAo?$AAl?$AAd?$AAe?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AA?9?$AA?$DO?$AAf?$AAr?$AAo?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN134@readNextCo:

; 593  : 
; 594  : 				return oldestBank->front();

	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR $T174559[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T174559[ebp]
	jmp	$LN122@readNextCo

; 595  : 			}
; 596  : 			else

	jmp	SHORT $LN86@readNextCo
$LN85@readNextCo:

; 597  : 				return NULL;

	mov	DWORD PTR $T174560[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T174560[ebp]
	jmp	$LN122@readNextCo
$LN86@readNextCo:

; 598  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 599  : 		break;

	jmp	$LN119@readNextCo
$LN83@readNextCo:

; 600  : 
; 601  : 		// alternate ranks as we go down banks
; 602  : 	case RANK_ROUND_ROBIN:
; 603  : 		{
; 604  : 			Transaction::TransactionType transactionType;
; 605  : 
; 606  : 			switch (lastCommandType)

	mov	eax, DWORD PTR _lastCommandType$[ebp]
	mov	DWORD PTR tv549[ebp], eax
	cmp	DWORD PTR tv549[ebp], 12		; 0000000cH
	ja	$LN75@readNextCo
	mov	ecx, DWORD PTR tv549[ebp]
	movzx	edx, BYTE PTR $LN182@readNextCo[ecx]
	jmp	DWORD PTR $LN202@readNextCo[edx*4]
$LN80@readNextCo:

; 607  : 			{
; 608  : 				// if it was RAS before and you want to finish doing the read/write
; 609  : 			case Command::ACTIVATE:
; 610  : 				{
; 611  : 					const Command *temp_c =  rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _temp_c$149550[ebp], eax

; 612  : 
; 613  : 					if (temp_c && temp_c->isReadOrWrite())

	cmp	DWORD PTR _temp_c$149550[ebp], 0
	je	SHORT $LN79@readNextCo
	mov	ecx, DWORD PTR _temp_c$149550[ebp]
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN79@readNextCo

; 614  : 					{
; 615  : 						return rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	jmp	$LN122@readNextCo

; 616  : 					}
; 617  : 					else

	jmp	SHORT $LN78@readNextCo
$LN79@readNextCo:

; 618  : 					{
; 619  : 						cerr << "Serious problems. RAS not followed by CAS" << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0CK@MMFCDFIJ@Serious?5problems?4?5RAS?5not?5follow@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 620  : 						exit(2);

	mov	esi, esp
	push	2
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN78@readNextCo:

; 621  : 					}
; 622  : 				}
; 623  : 				break;

	jmp	SHORT $LN81@readNextCo
$LN77@readNextCo:

; 624  : 
; 625  : 			case Command::READ_AND_PRECHARGE:
; 626  : 			case Command::READ:
; 627  : 			case Command::PRECHARGE:
; 628  : 				transactionType = Transaction::READ_TRANSACTION;

	mov	DWORD PTR _transactionType$149544[ebp], 2

; 629  : 				break;

	jmp	SHORT $LN81@readNextCo
$LN76@readNextCo:

; 630  : 
; 631  : 			case Command::REFRESH_ALL:
; 632  : 			case Command::WRITE:
; 633  : 			case Command::WRITE_AND_PRECHARGE:
; 634  : 				transactionType = Transaction::WRITE_TRANSACTION;

	mov	DWORD PTR _transactionType$149544[ebp], 1

; 635  : 				break;	

	jmp	SHORT $LN81@readNextCo
$LN75@readNextCo:

; 636  : 
; 637  : 			default:
; 638  : 				transactionType = Transaction::READ_TRANSACTION;

	mov	DWORD PTR _transactionType$149544[ebp], 2

; 639  : 				cerr << "Did not find a CAS or RAS command when it was expected" << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN81@readNextCo:

; 640  : 				break;
; 641  : 			}
; 642  : 
; 643  : 			unsigned originalLastRankID = lastRankID;

	mov	eax, DWORD PTR _lastRankID$[ebp]
	mov	DWORD PTR _originalLastRankID$149566[ebp], eax

; 644  : 			unsigned originalLastBankID = lastBankID;

	mov	eax, DWORD PTR _lastBankID$[ebp]
	mov	DWORD PTR _originalLastBankID$149567[ebp], eax

; 645  : 			Transaction::TransactionType originalTransactionType = transactionType;

	mov	eax, DWORD PTR _transactionType$149544[ebp]
	mov	DWORD PTR _originalTransactionType$149568[ebp], eax

; 646  : 			bool noPendingRefreshes = false;

	mov	BYTE PTR _noPendingRefreshes$149569[ebp], 0
$LN74@readNextCo:

; 647  : 
; 648  : 			while (true)

	mov	eax, 1
	test	eax, eax
	je	$LN73@readNextCo

; 649  : 			{
; 650  : 				// select the next rank
; 651  : 				lastRankID = (lastRankID + 1) % systemConfig.getRankCount();

	mov	esi, DWORD PTR _lastRankID$[ebp]
	add	esi, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRankCount
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _lastRankID$[ebp], edx

; 652  : 
; 653  : 				// select the next bank when all ranks at this bank have been checked
; 654  : 				if (lastRankID == originalLastRankID)

	mov	eax, DWORD PTR _lastRankID$[ebp]
	cmp	eax, DWORD PTR _originalLastRankID$149566[ebp]
	jne	$LN72@readNextCo

; 655  : 				{
; 656  : 					if (!noPendingRefreshes)

	movzx	eax, BYTE PTR _noPendingRefreshes$149569[ebp]
	test	eax, eax
	jne	$LN71@readNextCo

; 657  : 					{
; 658  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 659  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	lea	eax, DWORD PTR _currentRank$149579[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	jmp	SHORT $LN70@readNextCo
$LN69@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174561[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
	lea	ecx, DWORD PTR $T174561[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN70@readNextCo:
	lea	eax, DWORD PTR $T174563[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	DWORD PTR tv646[ebp], eax
	mov	ecx, DWORD PTR tv646[ebp]
	mov	DWORD PTR tv1436[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR tv1436[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
	mov	BYTE PTR $T174562[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T174563[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174562[ebp]
	test	eax, eax
	je	$LN68@readNextCo

; 660  : 						{
; 661  : 							bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$149587[ebp], 0

; 662  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	eax, DWORD PTR _currentBank$149592[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	jmp	SHORT $LN67@readNextCo
$LN66@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174564[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174564[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN67@readNextCo:
	lea	eax, DWORD PTR $T174566[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv673[ebp], eax
	mov	ecx, DWORD PTR tv673[ebp]
	mov	DWORD PTR tv1440[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR tv1440[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174565[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T174566[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174565[ebp]
	test	eax, eax
	je	SHORT $LN65@readNextCo

; 663  : 							{
; 664  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 665  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?size@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::size
	test	eax, eax
	je	SHORT $LN63@readNextCo
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	test	eax, eax
	je	SHORT $LN64@readNextCo
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN64@readNextCo
$LN63@readNextCo:

; 666  : 								{
; 667  : 									notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$149587[ebp], 1

; 668  : 									break;

	jmp	SHORT $LN65@readNextCo
$LN64@readNextCo:

; 669  : 								}

	jmp	$LN66@readNextCo
$LN65@readNextCo:

; 670  : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 671  : 							// are all the commands refreshes? if so then return this
; 672  : 							if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149587[ebp]
	test	eax, eax
	jne	SHORT $LN62@readNextCo

; 673  : 								return currentRank->bank[lastBankID].front(); // which bank doesn't really matter

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR $T174567[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T174567[ebp]
	jmp	$LN122@readNextCo
$LN62@readNextCo:

; 674  : 						}

	jmp	$LN69@readNextCo
$LN68@readNextCo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ

; 675  : 						noPendingRefreshes = true;

	mov	BYTE PTR _noPendingRefreshes$149569[ebp], 1
$LN71@readNextCo:

; 676  : 					}
; 677  : 
; 678  : 					lastBankID = (lastBankID + 1) % systemConfig.getBankCount();

	mov	esi, DWORD PTR _lastBankID$[ebp]
	add	esi, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getBankCount
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _lastBankID$[ebp], edx

; 679  : 
; 680  : 					// when all ranks and all banks have been checked for a read/write, look for a write/read
; 681  : 					if (lastBankID == originalLastBankID)

	mov	eax, DWORD PTR _lastBankID$[ebp]
	cmp	eax, DWORD PTR _originalLastBankID$149567[ebp]
	jne	SHORT $LN72@readNextCo

; 682  : 					{
; 683  : 
; 684  : 						transactionType = (transactionType == Transaction::WRITE_TRANSACTION) ? Transaction::READ_TRANSACTION : Transaction::WRITE_TRANSACTION;

	mov	eax, DWORD PTR _transactionType$149544[ebp]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 2
	mov	DWORD PTR _transactionType$149544[ebp], eax

; 685  : 						// however, if this type has already been searched for, then there are no commands, so quit
; 686  : 						if (transactionType == originalTransactionType)

	mov	eax, DWORD PTR _transactionType$149544[ebp]
	cmp	eax, DWORD PTR _originalTransactionType$149568[ebp]
	jne	SHORT $LN72@readNextCo

; 687  : 							break;

	jmp	$LN73@readNextCo
$LN72@readNextCo:

; 688  : 					}
; 689  : 				}
; 690  : 
; 691  : 				const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _temp_c$149606[ebp], eax

; 692  : 
; 693  : 				if (temp_c && !temp_c->isRefresh())

	cmp	DWORD PTR _temp_c$149606[ebp], 0
	je	$LN59@readNextCo
	mov	ecx, DWORD PTR _temp_c$149606[ebp]
	call	?isRefresh@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRefresh
	movzx	eax, al
	test	eax, eax
	jne	$LN59@readNextCo

; 694  : 				{
; 695  : 					if (!systemConfig.isReadWriteGrouping())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN58@readNextCo

; 696  : 					{
; 697  : 						return temp_c;

	mov	eax, DWORD PTR _temp_c$149606[ebp]
	jmp	$LN122@readNextCo

; 698  : 					}
; 699  : 					else // have to follow read_write grouping considerations

	jmp	$LN59@readNextCo
$LN58@readNextCo:

; 700  : 					{
; 701  : 						// look at the second command
; 702  : 						const Command *next_c = rank[lastRankID].bank[lastBankID].read(1);	

	push	1
	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	mov	DWORD PTR _next_c$149610[ebp], eax

; 703  : 
; 704  : 						if (next_c)

	cmp	DWORD PTR _next_c$149610[ebp], 0
	je	$LN59@readNextCo

; 705  : 							if ((next_c->isRead() && (transactionType == Transaction::READ_TRANSACTION)) ||
; 706  : 								(next_c->isWrite() && (transactionType == Transaction::WRITE_TRANSACTION)))

	mov	ecx, DWORD PTR _next_c$149610[ebp]
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN53@readNextCo
	cmp	DWORD PTR _transactionType$149544[ebp], 2
	je	SHORT $LN54@readNextCo
$LN53@readNextCo:
	mov	ecx, DWORD PTR _next_c$149610[ebp]
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	movzx	eax, al
	test	eax, eax
	je	$LN59@readNextCo
	cmp	DWORD PTR _transactionType$149544[ebp], 1
	jne	$LN59@readNextCo
$LN54@readNextCo:

; 707  : 							{
; 708  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getBank() == lastBankID);

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	cmp	eax, DWORD PTR _lastBankID$[ebp]
	je	SHORT $LN135@readNextCo
	mov	edx, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	edx, 234				; 000000eaH
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1KA@LLLAOIOH@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN135@readNextCo:

; 709  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getRank() == lastRankID);

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	cmp	eax, DWORD PTR _lastRankID$[ebp]
	je	SHORT $LN136@readNextCo
	mov	edx, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	edx, 235				; 000000ebH
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1KA@MODELNOF@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN136@readNextCo:

; 710  : 								return rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	jmp	$LN122@readNextCo
$LN59@readNextCo:

; 711  : 							}
; 712  : 					}
; 713  : 
; 714  : #ifdef DEBUG_FLAG_2
; 715  : 					cerr << "Looked in ["<< temp_c->getAddress().rank << "] [" << temp_c->getAddress().bank << "] but wrong type, We want [" << transactionType << "]. Candidate command type ";
; 716  : 					cerr << temp_c->getCommandType();
; 717  : 					cerr << " followed by ";
; 718  : 					cerr << rank[lastRankID].bank[lastBankID].getPerBankQueue().read(1)->getCommandType();
; 719  : 					cerr << "count [" << rank[lastRankID].bank[lastBankID].getPerBankQueue().get_count() << "]" << endl;
; 720  : #endif
; 721  : 
; 722  : 				}
; 723  : 
; 724  : #ifdef DEBUG_FLAG_2
; 725  : 				cerr << "Looked in [" << lastRankID << "] [" << lastBankID << "] but Q empty" << endl;
; 726  : #endif
; 727  : 
; 728  : 			}

	jmp	$LN74@readNextCo
$LN73@readNextCo:

; 729  : 		}
; 730  : 		break;

	jmp	$LN119@readNextCo
$LN52@readNextCo:

; 731  : 
; 732  : 		// keep rank id as long as possible, go round robin down a given rank
; 733  : 	case BANK_ROUND_ROBIN:
; 734  : 		{			
; 735  : 			Transaction::TransactionType transactionType;
; 736  : 
; 737  : 			switch (lastCommandType)

	mov	eax, DWORD PTR _lastCommandType$[ebp]
	mov	DWORD PTR tv858[ebp], eax
	cmp	DWORD PTR tv858[ebp], 12		; 0000000cH
	ja	$LN44@readNextCo
	mov	ecx, DWORD PTR tv858[ebp]
	movzx	edx, BYTE PTR $LN183@readNextCo[ecx]
	jmp	DWORD PTR $LN203@readNextCo[edx*4]
$LN49@readNextCo:

; 738  : 			{
; 739  : 			case Command::ACTIVATE:
; 740  : 				{
; 741  : 					const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _temp_c$149626[ebp], eax

; 742  : 
; 743  : 					if ((temp_c) && temp_c->isReadOrWrite())

	cmp	DWORD PTR _temp_c$149626[ebp], 0
	je	SHORT $LN48@readNextCo
	mov	ecx, DWORD PTR _temp_c$149626[ebp]
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN48@readNextCo

; 744  : 					{
; 745  : 						return rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	jmp	$LN122@readNextCo

; 746  : 					}
; 747  : 					else

	jmp	SHORT $LN47@readNextCo
$LN48@readNextCo:

; 748  : 					{
; 749  : 						cerr << "Serious problems. RAS not followed by CAS." << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0CL@JPKPGAJN@Serious?5problems?4?5RAS?5not?5follow@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 750  : 						exit(2);

	mov	esi, esp
	push	2
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@readNextCo:

; 751  : 					}
; 752  : 				}
; 753  : 				break;

	jmp	SHORT $LN50@readNextCo
$LN46@readNextCo:

; 754  : 			case Command::READ_AND_PRECHARGE:
; 755  : 			case Command::READ:
; 756  : 			case Command::PRECHARGE:
; 757  : 				transactionType = Transaction::READ_TRANSACTION;

	mov	DWORD PTR _transactionType$149620[ebp], 2

; 758  : 				break;

	jmp	SHORT $LN50@readNextCo
$LN45@readNextCo:

; 759  : 
; 760  : 			case Command::REFRESH_ALL:
; 761  : 			case Command::WRITE:
; 762  : 			case Command::WRITE_AND_PRECHARGE:
; 763  : 				transactionType = Transaction::WRITE_TRANSACTION;

	mov	DWORD PTR _transactionType$149620[ebp], 1

; 764  : 				break;

	jmp	SHORT $LN50@readNextCo
$LN44@readNextCo:

; 765  : 			default:
; 766  : 				transactionType = Transaction::WRITE_TRANSACTION; // FIXME: added this to ensure no uninit vars

	mov	DWORD PTR _transactionType$149620[ebp], 1

; 767  : 				cerr << "Did not find a CAS or RAS command when it was expected" << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0DH@BABLPBKL@Did?5not?5find?5a?5CAS?5or?5RAS?5comman@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@readNextCo:

; 768  : 				break;
; 769  : 			}
; 770  : 
; 771  : 			unsigned originalLastRankID = lastRankID;

	mov	eax, DWORD PTR _lastRankID$[ebp]
	mov	DWORD PTR _originalLastRankID$149641[ebp], eax

; 772  : 			unsigned originalLastBankID = lastBankID;

	mov	eax, DWORD PTR _lastBankID$[ebp]
	mov	DWORD PTR _originalLastBankID$149642[ebp], eax

; 773  : 			Transaction::TransactionType originalTransactionType = transactionType;

	mov	eax, DWORD PTR _transactionType$149620[ebp]
	mov	DWORD PTR _originalTransactionType$149643[ebp], eax

; 774  : 			bool noPendingRefreshes = false;

	mov	BYTE PTR _noPendingRefreshes$149644[ebp], 0
$LN43@readNextCo:

; 775  : 
; 776  : 			while (true)

	mov	eax, 1
	test	eax, eax
	je	$LN42@readNextCo

; 777  : 			{
; 778  : 				// select the next bank
; 779  : 				lastBankID = (lastBankID + 1) % systemConfig.getBankCount();

	mov	esi, DWORD PTR _lastBankID$[ebp]
	add	esi, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getBankCount
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _lastBankID$[ebp], edx

; 780  : 
; 781  : 				if (lastBankID == originalLastBankID)

	mov	eax, DWORD PTR _lastBankID$[ebp]
	cmp	eax, DWORD PTR _originalLastBankID$149642[ebp]
	jne	$LN41@readNextCo

; 782  : 				{
; 783  : 					if (!noPendingRefreshes)

	movzx	eax, BYTE PTR _noPendingRefreshes$149644[ebp]
	test	eax, eax
	jne	$LN40@readNextCo

; 784  : 					{
; 785  : 						// before switching to the next bank, see if all the queues are refreshes in any rank
; 786  : 						for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	lea	eax, DWORD PTR _currentRank$149654[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	jmp	SHORT $LN39@readNextCo
$LN38@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174570[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
	lea	ecx, DWORD PTR $T174570[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN39@readNextCo:
	lea	eax, DWORD PTR $T174572[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	DWORD PTR tv923[ebp], eax
	mov	ecx, DWORD PTR tv923[ebp]
	mov	DWORD PTR tv1445[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	edx, DWORD PTR tv1445[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
	mov	BYTE PTR $T174571[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T174572[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174571[ebp]
	test	eax, eax
	je	$LN37@readNextCo

; 787  : 						{
; 788  : 							bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$149662[ebp], 0

; 789  : 							for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	eax, DWORD PTR _currentBank$149667[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	jmp	SHORT $LN36@readNextCo
$LN35@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174573[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174573[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN36@readNextCo:
	lea	eax, DWORD PTR $T174575[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv950[ebp], eax
	mov	ecx, DWORD PTR tv950[ebp]
	mov	DWORD PTR tv1449[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	edx, DWORD PTR tv1449[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174574[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	lea	ecx, DWORD PTR $T174575[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174574[ebp]
	test	eax, eax
	je	SHORT $LN34@readNextCo

; 790  : 							{
; 791  : 								// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 792  : 								if ((currentBank->size() == 0) || ((currentBank->front()) && (currentBank->front()->getCommandType() != Command::REFRESH_ALL)))

	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?size@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::size
	test	eax, eax
	je	SHORT $LN32@readNextCo
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	test	eax, eax
	je	SHORT $LN33@readNextCo
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN33@readNextCo
$LN32@readNextCo:

; 793  : 								{
; 794  : 									notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$149662[ebp], 1

; 795  : 									break;

	jmp	SHORT $LN34@readNextCo
$LN33@readNextCo:

; 796  : 								}

	jmp	$LN35@readNextCo
$LN34@readNextCo:

; 797  : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 798  : 							// are all the commands refreshes? if so then return this
; 799  : 							if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149662[ebp]
	test	eax, eax
	jne	SHORT $LN31@readNextCo

; 800  : 								return currentRank->bank[lastBankID].front(); // which bank doesn't really matter

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR $T174576[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T174576[ebp]
	jmp	$LN122@readNextCo
$LN31@readNextCo:

; 801  : 						}

	jmp	$LN38@readNextCo
$LN37@readNextCo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ

; 802  : 						noPendingRefreshes = true;

	mov	BYTE PTR _noPendingRefreshes$149644[ebp], 1
$LN40@readNextCo:

; 803  : 					}
; 804  : 
; 805  : 					lastRankID = (lastRankID + 1) % systemConfig.getRankCount();

	mov	esi, DWORD PTR _lastRankID$[ebp]
	add	esi, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRankCount
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _lastRankID$[ebp], edx

; 806  : 
; 807  : 					if (lastRankID == originalLastRankID)

	mov	eax, DWORD PTR _lastRankID$[ebp]
	cmp	eax, DWORD PTR _originalLastRankID$149641[ebp]
	jne	SHORT $LN41@readNextCo

; 808  : 					{
; 809  : 						transactionType = (transactionType == Transaction::WRITE_TRANSACTION) ? Transaction::READ_TRANSACTION : Transaction::WRITE_TRANSACTION;

	mov	eax, DWORD PTR _transactionType$149620[ebp]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 2
	mov	DWORD PTR _transactionType$149620[ebp], eax

; 810  : 						// however, if this type has already been searched for, then there are no commands, so quit
; 811  : 						if (transactionType == originalTransactionType)

	mov	eax, DWORD PTR _transactionType$149620[ebp]
	cmp	eax, DWORD PTR _originalTransactionType$149643[ebp]
	jne	SHORT $LN41@readNextCo

; 812  : 							break;

	jmp	$LN42@readNextCo
$LN41@readNextCo:

; 813  : 					}
; 814  : 				}
; 815  : 
; 816  : 				const Command *temp_c = rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _temp_c$149681[ebp], eax

; 817  : 
; 818  : 				if (temp_c && temp_c->getCommandType() != Command::REFRESH_ALL)

	cmp	DWORD PTR _temp_c$149681[ebp], 0
	je	$LN28@readNextCo
	mov	ecx, DWORD PTR _temp_c$149681[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	$LN28@readNextCo

; 819  : 				{	
; 820  : 					if(systemConfig.isReadWriteGrouping() == false)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	call	?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@readNextCo

; 821  : 					{
; 822  : 						return temp_c;

	mov	eax, DWORD PTR _temp_c$149681[ebp]
	jmp	$LN122@readNextCo

; 823  : 					}
; 824  : 					else // have to follow read_write grouping considerations

	jmp	$LN28@readNextCo
$LN27@readNextCo:

; 825  : 					{
; 826  : 						// look at the second command
; 827  : 						const Command *next_c =  rank[lastRankID].bank[lastBankID].read(1);

	push	1
	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	mov	DWORD PTR _next_c$149685[ebp], eax

; 828  : 
; 829  : 						if (next_c)

	cmp	DWORD PTR _next_c$149685[ebp], 0
	je	$LN28@readNextCo

; 830  : 							if ((next_c->isRead() && (transactionType == Transaction::READ_TRANSACTION)) ||
; 831  : 								(next_c->isWrite() && (transactionType == Transaction::WRITE_TRANSACTION)))

	mov	ecx, DWORD PTR _next_c$149685[ebp]
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@readNextCo
	cmp	DWORD PTR _transactionType$149620[ebp], 2
	je	SHORT $LN23@readNextCo
$LN22@readNextCo:
	mov	ecx, DWORD PTR _next_c$149685[ebp]
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	movzx	eax, al
	test	eax, eax
	je	$LN28@readNextCo
	cmp	DWORD PTR _transactionType$149620[ebp], 1
	jne	$LN28@readNextCo
$LN23@readNextCo:

; 832  : 							{
; 833  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getBank() == lastBankID);

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	cmp	eax, DWORD PTR _lastBankID$[ebp]
	je	SHORT $LN137@readNextCo
	mov	edx, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	edx, 359				; 00000167H
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1KA@LLLAOIOH@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN137@readNextCo:

; 834  : 								assert(rank[lastRankID].bank[lastBankID].front()->getAddress().getRank() == lastRankID);

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	cmp	eax, DWORD PTR _lastRankID$[ebp]
	je	SHORT $LN138@readNextCo
	mov	edx, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	edx, 360				; 00000168H
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1KA@MODELNOF@?$AAr?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAR?$AAa?$AAn?$AAk?$AAI?$AAD?$AA?$FN?$AA?4?$AAb?$AAa?$AAn?$AAk?$AA?$FL?$AAl?$AAa?$AAs?$AAt?$AAB?$AAa?$AAn?$AAk?$AAI?$AAD@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN138@readNextCo:

; 835  : 								return rank[lastRankID].bank[lastBankID].front();

	mov	eax, DWORD PTR _lastBankID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastRankID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	jmp	$LN122@readNextCo
$LN28@readNextCo:

; 836  : 							}
; 837  : 					}
; 838  : 
; 839  : #ifdef DEBUG_FLAG_2
; 840  : 					cerr << "Looked in ["<< temp_c->getAddress().rank << "] [" << temp_c->getAddress().bank << "] but wrong type, We want [" << transactionType << "]. Candidate command type ";
; 841  : 					cerr << temp_c->getCommandType();
; 842  : 					cerr << " followed by ";
; 843  : 					cerr << rank[lastRankID].bank[lastBankID].getPerBankQueue().read(1)->getCommandType();
; 844  : 					cerr << "count [" << rank[lastRankID].bank[lastBankID].getPerBankQueue().get_count() << "]" << endl;
; 845  : #endif
; 846  : 
; 847  : 				}
; 848  : 
; 849  : #ifdef DEBUG_FLAG_2
; 850  : 				cerr << "Looked in rank=[" << lastRankID << "] bank=[" << lastBankID << "] but Q empty" << endl;
; 851  : #endif
; 852  : 
; 853  : 			}

	jmp	$LN43@readNextCo
$LN42@readNextCo:

; 854  : 		}
; 855  : 		break;

	jmp	$LN119@readNextCo
$LN21@readNextCo:

; 856  : 
; 857  : 	case FIRST_AVAILABLE_AGE:
; 858  : 		{
; 859  : 			const Command *candidateCommand = NULL;

	mov	DWORD PTR _candidateCommand$149693[ebp], 0

; 860  : 
; 861  : 			int candidateGap = INT_MAX;

	mov	DWORD PTR _candidateGap$149694[ebp], 2147483647 ; 7fffffffH

; 862  : 
; 863  : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rank.end(); currentRank++)

	lea	eax, DWORD PTR _currentRank$149699[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	jmp	SHORT $LN20@readNextCo
$LN19@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174579[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
	lea	ecx, DWORD PTR $T174579[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN20@readNextCo:
	lea	eax, DWORD PTR $T174581[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	DWORD PTR tv1172[ebp], eax
	mov	ecx, DWORD PTR tv1172[ebp]
	mov	DWORD PTR tv1454[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	edx, DWORD PTR tv1454[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
	mov	BYTE PTR $T174580[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	lea	ecx, DWORD PTR $T174581[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174580[ebp]
	test	eax, eax
	je	$LN18@readNextCo

; 864  : 			{
; 865  : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$149707[ebp], 0

; 866  : 
; 867  : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != currentRank->bank.end(); currentBank++)

	lea	eax, DWORD PTR _currentBank$149712[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	jmp	SHORT $LN17@readNextCo
$LN16@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174582[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentBank$149712[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174582[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN17@readNextCo:
	lea	eax, DWORD PTR $T174584[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv1199[ebp], eax
	mov	ecx, DWORD PTR tv1199[ebp]
	mov	DWORD PTR tv1458[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	edx, DWORD PTR tv1458[ebp]
	push	edx
	lea	ecx, DWORD PTR _currentBank$149712[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174583[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	lea	ecx, DWORD PTR $T174584[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174583[ebp]
	test	eax, eax
	je	$LN15@readNextCo

; 868  : 				{
; 869  : 					const Command *challengerCommand = currentBank->front();

	lea	ecx, DWORD PTR _currentBank$149712[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	DWORD PTR _challengerCommand$149720[ebp], eax

; 870  : 
; 871  : 					if (challengerCommand)

	cmp	DWORD PTR _challengerCommand$149720[ebp], 0
	je	$LN14@readNextCo

; 872  : 					{
; 873  : 						int challengerGap = minProtocolGap(challengerCommand);

	mov	esi, esp
	mov	eax, DWORD PTR _challengerCommand$149720[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	push	eax
	call	@_RTC_Check_8_to_4@8
	mov	DWORD PTR _challengerGap$149722[ebp], eax

; 874  : 
; 875  : 						if (challengerGap < candidateGap || (candidateGap == challengerGap && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	mov	eax, DWORD PTR _challengerGap$149722[ebp]
	cmp	eax, DWORD PTR _candidateGap$149694[ebp]
	jl	SHORT $LN12@readNextCo
	mov	eax, DWORD PTR _candidateGap$149694[ebp]
	cmp	eax, DWORD PTR _challengerGap$149722[ebp]
	jne	$LN14@readNextCo
	mov	ecx, DWORD PTR _challengerCommand$149720[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	call	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ; DRAMsimII::Event::getEnqueueTime
	mov	DWORD PTR tv1984[ebp], esi
	mov	DWORD PTR tv1984[ebp+4], edi
	mov	DWORD PTR tv1987[ebp], eax
	mov	DWORD PTR tv1987[ebp+4], edx
	mov	eax, DWORD PTR tv1984[ebp+4]
	cmp	eax, DWORD PTR tv1987[ebp+4]
	jg	$LN14@readNextCo
	jl	SHORT $LN12@readNextCo
	mov	ecx, DWORD PTR tv1984[ebp]
	cmp	ecx, DWORD PTR tv1987[ebp]
	jae	$LN14@readNextCo
$LN12@readNextCo:

; 876  : 						{
; 877  : 							if (challengerCommand->getCommandType() == Command::REFRESH_ALL)

	mov	ecx, DWORD PTR _challengerCommand$149720[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	jne	$LN11@readNextCo

; 878  : 							{					
; 879  : 								// if it hasn't been proven to be all refreshes or not yet
; 880  : 								if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149707[ebp]
	test	eax, eax
	jne	$LN10@readNextCo

; 881  : 								{
; 882  : 									for (vector<Bank>::const_iterator thisBank = currentRank->bank.begin(); thisBank != currentRank->bank.end(); thisBank++)

	lea	eax, DWORD PTR _thisBank$149731[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	jmp	SHORT $LN9@readNextCo
$LN8@readNextCo:
	push	0
	lea	eax, DWORD PTR $T174585[ebp]
	push	eax
	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	lea	ecx, DWORD PTR $T174585[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN9@readNextCo:
	lea	eax, DWORD PTR $T174587[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
	mov	DWORD PTR tv1259[ebp], eax
	mov	ecx, DWORD PTR tv1259[ebp]
	mov	DWORD PTR tv1462[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	mov	edx, DWORD PTR tv1462[ebp]
	push	edx
	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	call	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
	mov	BYTE PTR $T174586[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	lea	ecx, DWORD PTR $T174587[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174586[ebp]
	test	eax, eax
	je	SHORT $LN7@readNextCo

; 883  : 									{
; 884  : 										// if any queue is empty or the head of any queue isn't a refresh command, mark this fact and do not choose refresh
; 885  : 										if ((thisBank->size() == 0) || (thisBank->front()->getCommandType() != Command::REFRESH_ALL))

	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?size@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::size
	test	eax, eax
	je	SHORT $LN5@readNextCo
	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN6@readNextCo
$LN5@readNextCo:

; 886  : 										{
; 887  : 											notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$149707[ebp], 1

; 888  : 											break;

	jmp	SHORT $LN7@readNextCo
$LN6@readNextCo:

; 889  : 										}

	jmp	$LN8@readNextCo
$LN7@readNextCo:

; 890  : 									}

	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ

; 891  : 									// are all the commands refreshes? if so then choose this
; 892  : 									if (!notAllRefresh)

	movzx	eax, BYTE PTR _notAllRefresh$149707[ebp]
	test	eax, eax
	jne	SHORT $LN10@readNextCo

; 893  : 									{
; 894  : 										candidateGap = challengerGap;

	mov	eax, DWORD PTR _challengerGap$149722[ebp]
	mov	DWORD PTR _candidateGap$149694[ebp], eax

; 895  : 										candidateCommand = challengerCommand;

	mov	eax, DWORD PTR _challengerCommand$149720[ebp]
	mov	DWORD PTR _candidateCommand$149693[ebp], eax
$LN10@readNextCo:

; 896  : 									}
; 897  : 								}
; 898  : 							}
; 899  : 							else

	jmp	SHORT $LN14@readNextCo
$LN11@readNextCo:

; 900  : 							{
; 901  : 								candidateGap = challengerGap;

	mov	eax, DWORD PTR _challengerGap$149722[ebp]
	mov	DWORD PTR _candidateGap$149694[ebp], eax

; 902  : 								candidateCommand = challengerCommand;

	mov	eax, DWORD PTR _challengerCommand$149720[ebp]
	mov	DWORD PTR _candidateCommand$149693[ebp], eax
$LN14@readNextCo:

; 903  : 							}							
; 904  : 						}
; 905  : 					}

	jmp	$LN16@readNextCo
$LN15@readNextCo:

; 906  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	lea	ecx, DWORD PTR _currentBank$149712[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	$LN19@readNextCo
$LN18@readNextCo:

; 907  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ

; 908  : 
; 909  : 			if (candidateCommand)

	cmp	DWORD PTR _candidateCommand$149693[ebp], 0
	je	$LN2@readNextCo

; 910  : 			{
; 911  : 				assert(candidateCommand->getCommandType() == Command::REFRESH_ALL || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);

	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN139@readNextCo
	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	push	eax
	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	add	eax, 388				; 00000184H
	mov	ecx, eax
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	ecx, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	eax, DWORD PTR _candidateCommand$149693[ebp]
	je	SHORT $LN139@readNextCo
	mov	eax, DWORD PTR ?__LINE__Var@?1??readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@3@PBV43@0@Z@4JA
	add	eax, 437				; 000001b5H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1KI@BGDEGIKL@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1BHA@CCOEMDDK@?$AAc?$AAa?$AAn?$AAd?$AAi?$AAd?$AAa?$AAt?$AAe?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?9?$AA?$DO?$AAg?$AAe?$AAt?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAT?$AAy?$AAp?$AAe@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN139@readNextCo:

; 912  : 
; 913  : 				DEBUG_TIMING_LOG("R[" << candidateCommand->getAddress().getRank() << "] B[" << candidateCommand->getAddress().getBank() << "]\tWinner: " << candidateCommand << "gap[" << candidateGap << "] now[" << time << "]")

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR tv1356[ebp], ecx
	cmp	DWORD PTR tv1356[ebp], 0
	je	SHORT $LN140@readNextCo
	mov	edx, DWORD PTR tv1356[ebp]
	add	edx, 8
	mov	DWORD PTR tv1355[ebp], edx
	jmp	SHORT $LN141@readNextCo
$LN140@readNextCo:
	mov	DWORD PTR tv1355[ebp], 0
$LN141@readNextCo:
	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	edi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	push	OFFSET ??_C@_06GKILHJPD@?$FN?5now?$FL?$AA@
	mov	ebx, esp
	mov	ecx, DWORD PTR _candidateGap$149694[ebp]
	push	ecx
	push	OFFSET ??_C@_04JMOLNPBG@gap?$FL?$AA@
	mov	eax, esp
	mov	edx, DWORD PTR _candidateCommand$149693[ebp]
	push	edx
	push	OFFSET ??_C@_0L@MHDLOPIJ@?$FN?7Winner?3?5?$AA@
	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	mov	DWORD PTR tv2079[ebp], eax
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getBank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getBank
	mov	ecx, esp
	push	eax
	push	OFFSET ??_C@_04HDDNHBJH@?$FN?5B?$FL?$AA@
	mov	DWORD PTR tv2081[ebp], ecx
	mov	ecx, DWORD PTR _candidateCommand$149693[ebp]
	call	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ; DRAMsimII::Event::getAddress
	mov	ecx, eax
	call	?getRank@Address@DRAMsimII@@QBEIXZ	; DRAMsimII::Address::getRank
	mov	ecx, esp
	push	eax
	push	OFFSET ??_C@_02DGMJFIKM@R?$FL?$AA@
	mov	eax, DWORD PTR tv1355[ebp]
	push	eax
	mov	DWORD PTR tv2083[ebp], ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	ecx, DWORD PTR tv2083[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	ecx, DWORD PTR tv2081[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	mov	ecx, DWORD PTR tv2079[ebp]
	cmp	ecx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@readNextCo:

; 914  : 			}
; 915  : 
; 916  : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$149693[ebp]
	jmp	SHORT $LN122@readNextCo

; 917  : 		}
; 918  : 		break;

	jmp	SHORT $LN119@readNextCo
$LN1@readNextCo:

; 919  : 
; 920  : 	default:
; 921  : 		{
; 922  : 			cerr << "This configuration and algorithm combination is not supported" << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 923  : 			exit(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN119@readNextCo:

; 924  : 		}
; 925  : 		break;
; 926  : 	}
; 927  : 	return NULL;

	xor	eax, eax
$LN122@readNextCo:

; 928  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN200@readNextCo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 1520				; 000005f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN200@readNextCo:
	DD	13					; 0000000dH
	DD	$LN199@readNextCo
$LN199@readNextCo:
	DD	-132					; ffffff7cH
	DD	12					; 0000000cH
	DD	$LN185@readNextCo
	DD	-152					; ffffff68H
	DD	12					; 0000000cH
	DD	$LN186@readNextCo
	DD	-172					; ffffff54H
	DD	12					; 0000000cH
	DD	$LN187@readNextCo
	DD	-204					; ffffff34H
	DD	12					; 0000000cH
	DD	$LN188@readNextCo
	DD	-236					; ffffff14H
	DD	12					; 0000000cH
	DD	$LN189@readNextCo
	DD	-256					; ffffff00H
	DD	12					; 0000000cH
	DD	$LN190@readNextCo
	DD	-348					; fffffea4H
	DD	12					; 0000000cH
	DD	$LN191@readNextCo
	DD	-380					; fffffe84H
	DD	12					; 0000000cH
	DD	$LN192@readNextCo
	DD	-496					; fffffe10H
	DD	12					; 0000000cH
	DD	$LN193@readNextCo
	DD	-528					; fffffdf0H
	DD	12					; 0000000cH
	DD	$LN194@readNextCo
	DD	-596					; fffffdacH
	DD	12					; 0000000cH
	DD	$LN195@readNextCo
	DD	-628					; fffffd8cH
	DD	12					; 0000000cH
	DD	$LN196@readNextCo
	DD	-672					; fffffd60H
	DD	12					; 0000000cH
	DD	$LN197@readNextCo
$LN197@readNextCo:
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN196@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN195@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN194@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN193@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN192@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN191@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN190@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN189@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN188@readNextCo:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$LN187@readNextCo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN186@readNextCo:
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$LN185@readNextCo:
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
	npad	3
$LN201@readNextCo:
	DD	$LN118@readNextCo
	DD	$LN83@readNextCo
	DD	$LN52@readNextCo
	DD	$LN21@readNextCo
$LN202@readNextCo:
	DD	$LN80@readNextCo
	DD	$LN77@readNextCo
	DD	$LN76@readNextCo
	DD	$LN75@readNextCo
$LN182@readNextCo:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	npad	3
$LN203@readNextCo:
	DD	$LN49@readNextCo
	DD	$LN46@readNextCo
	DD	$LN45@readNextCo
	DD	$LN44@readNextCo
$LN183@readNextCo:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$0:
	lea	ecx, DWORD PTR _oldestBank$149333[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$1:
	lea	ecx, DWORD PTR _oldestExecutableBank$149338[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$2:
	lea	ecx, DWORD PTR _currentRank$149463[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$4:
	lea	ecx, DWORD PTR $T174546[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$5:
	lea	ecx, DWORD PTR _bank_id$149478[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$7:
	lea	ecx, DWORD PTR $T174549[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$8:
	lea	ecx, DWORD PTR _currentBank$149495[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$10:
	lea	ecx, DWORD PTR $T174552[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$11:
	lea	ecx, DWORD PTR _currentBank$149514[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$13:
	lea	ecx, DWORD PTR $T174555[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$14:
	lea	ecx, DWORD PTR _currentRank$149579[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$16:
	lea	ecx, DWORD PTR $T174563[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$17:
	lea	ecx, DWORD PTR _currentBank$149592[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$19:
	lea	ecx, DWORD PTR $T174566[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$20:
	lea	ecx, DWORD PTR _currentRank$149654[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$22:
	lea	ecx, DWORD PTR $T174572[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$23:
	lea	ecx, DWORD PTR _currentBank$149667[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$25:
	lea	ecx, DWORD PTR $T174575[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$26:
	lea	ecx, DWORD PTR _currentRank$149699[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$28:
	lea	ecx, DWORD PTR $T174581[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$29:
	lea	ecx, DWORD PTR _currentBank$149712[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$31:
	lea	ecx, DWORD PTR $T174584[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$32:
	lea	ecx, DWORD PTR _thisBank$149731[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z$34:
	lea	ecx, DWORD PTR $T174587[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1524]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readNextCommand@fbdChannel@DRAMsimII@@IBEPBVCommand@2@PBV32@0@Z ENDP ; DRAMsimII::fbdChannel::readNextCommand
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
;	COMDAT ?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getEnqueueTime, COMDAT
; _this$ = ecx

; 86   : 		tick getEnqueueTime() const { return enqueueTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getEnqueueTime
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?isRefresh@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?isRefresh@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isRefresh, COMDAT
; _this$ = ecx

; 88   : 		bool isRefresh() const { return (commandType == REFRESH_ALL); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	sete	cl
	call	@_RTC_Check_4_to_1@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isRefresh@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isRefresh
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\systemconfiguration.h
_TEXT	ENDS
;	COMDAT ?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ PROC ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm, COMDAT
; _this$ = ecx

; 90   : 		CommandOrderingAlgorithm getCommandOrderingAlgorithm() const { return commandOrderingAlgorithm; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getRankCount, COMDAT
; _this$ = ecx

; 93   : 		unsigned getRankCount() const { return rankCount; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+360]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getRankCount
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getBankCount, COMDAT
; _this$ = ecx

; 94   : 		unsigned getBankCount() const { return bankCount; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+364]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getBankCount
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::SystemConfiguration::isReadWriteGrouping, COMDAT
; _this$ = ecx

; 107  : 		bool isReadWriteGrouping() const { return readWriteGrouping; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+345]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
_TEXT	ENDS
PUBLIC	?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::read
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
;	COMDAT ?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z PROC		; DRAMsimII::Bank::read, COMDAT
; _this$ = ecx

; 109  : 		const Command *read(const unsigned value) const { return perBankQueue.read(value); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::read
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ENDP		; DRAMsimII::Bank::read
_TEXT	ENDS
PUBLIC	?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::size
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?size@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@Bank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Bank::size, COMDAT
; _this$ = ecx

; 112  : 		unsigned size() const { return perBankQueue.size(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::size
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@Bank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Bank::size
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::Bank::nextCommandType, COMDAT
; _this$ = ecx

; 114  : 		Command::CommandType nextCommandType() const { return perBankQueue.front() ? perBankQueue.front()->getCommandType() : Command::INVALID_COMMAND; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
	test	eax, eax
	je	SHORT $LN3@nextComman
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
	mov	ecx, eax
	call	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@nextComman
$LN3@nextComman:
	mov	DWORD PTR tv73[ebp], 16			; 00000010H
$LN4@nextComman:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::Bank::nextCommandType
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.h
_TEXT	ENDS
;	COMDAT ?getRankID@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getRankID@Rank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Rank::getRankID, COMDAT
; _this$ = ecx

; 102  : 		unsigned getRankID() const { return rankID; }		

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRankID@Rank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Rank::getRankID
_TEXT	ENDS
PUBLIC	??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::~_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
_TEXT	ENDS
PUBLIC	??4?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAEAAU01@ABU01@@Z ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::operator=
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::~_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::~_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
_TEXT	ENDS
PUBLIC	??4?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::operator=
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??4?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAEAAU01@ABU01@@Z PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAEAAU01@ABU01@@Z ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::operator=
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::~_Iterator_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	??4_Iterator_base@std@@QAEAAV01@ABV01@@Z	; std::_Iterator_base::operator=
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??4?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAEAAU01@ABU01@@Z PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base@std@@QAEAAV01@ABV01@@Z ; std::_Iterator_base::operator=
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAEAAU01@ABU01@@Z ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::operator=
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ; std::_Iterator_base::_Adopt
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Lock$6719 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base@std@@QAEAAV01@ABV01@@Z PROC		; std::_Iterator_base::operator=, COMDAT
; _this$ = ecx

; 148  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 		if (_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN1@operator

; 150  : 			{	// change parentage
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$6719[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 152  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 153  : 			_Adopt(_Right._Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ; std::_Iterator_base::_Adopt

; 154  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$6719[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:

; 155  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 156  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN8@operator:
	DD	1
	DD	$LN7@operator
$LN7@operator:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN5@operator
$LN5@operator:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$6719[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base@std@@QAEAAV01@ABV01@@Z ENDP		; std::_Iterator_base::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z$0
__ehfuncinfo$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z
_TEXT	SEGMENT
__Lock$6726 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z PROC ; std::_Iterator_base::_Adopt, COMDAT
; _this$ = ecx

; 165  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		if (_Mycont != _Parent)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent$[ebp]
	je	SHORT $LN3@Adopt

; 167  : 			{	// change parentage
; 168  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$6726[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 169  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 170  : 			if (_Parent != 0 && _Parent->_Myfirstiter != _IGNORE_MYITERLIST)

	cmp	DWORD PTR __Parent$[ebp], 0
	je	SHORT $LN1@Adopt
	mov	eax, DWORD PTR __Parent$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN1@Adopt

; 171  : 				{	// switch to new parent
; 172  : 				_Mynextiter = _Parent->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 173  : 				((_Container_base_secure *)_Parent)->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Adopt:

; 174  : 				}
; 175  : 			_Mycont = _Parent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent$[ebp]
	mov	DWORD PTR [eax], ecx

; 176  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$6726[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Adopt:

; 177  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN9@Adopt:
	DD	1
	DD	$LN8@Adopt
$LN8@Adopt:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN6@Adopt
$LN6@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$6726[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ENDP ; std::_Iterator_base::_Adopt
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::size, COMDAT
; _this$ = ecx

; 243  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 			return count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 245  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
PUBLIC	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
_item$152286 = -20					; size = 4
_this$ = -8						; size = 4
?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::pop, COMDAT
; _this$ = ecx

; 188  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@pop

; 190  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@pop

; 191  : 			else

	jmp	SHORT $LN3@pop
$LN2@pop:

; 192  : 			{
; 193  : 				count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _item$152286[ebp], edx

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	mov	DWORD PTR [eax], 0

; 198  : 
; 199  : 				head = (head + 1) % (unsigned)entry.size();	//advance head_ptr

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 200  : 
; 201  : 				return item;

	mov	eax, DWORD PTR _item$152286[ebp]
$LN3@pop:

; 202  : 			}
; 203  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::pop
_TEXT	ENDS
PUBLIC	??_C@_1GM@LLLNNHIM@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$DP?$AA?5?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?$FL?$AAh?$AAe?$AAa?$AAd?$AA?$FN?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5@ ; `string'
PUBLIC	??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@ ; `string'
PUBLIC	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
;	COMDAT ??_C@_1GM@LLLNNHIM@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$DP?$AA?5?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?$FL?$AAh?$AAe?$AAa?$AAd?$AA?$FN?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5@
CONST	SEGMENT
??_C@_1GM@LLLNNHIM@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$DP?$AA?5?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?$FL?$AAh?$AAe?$AAa?$AAd?$AA?$FN?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '?', 00H, ' ', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 'r', 00H, 'y', 00H, '[', 00H, 'h', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, ']', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, ':', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'y', 00H, '['
	DB	00H, 'h', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ']', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
CONST	SEGMENT
??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 'u', 00H, 's'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'c', 00H, 'u', 00H, 'm', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'v', 00H, 'i'
	DB	00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, '2'
	DB	00H, '0', 00H, '0', 00H, '8', 00H, '\', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\'
	DB	00H, 'd', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 's', 00H, 'i', 00H
	DB	'm', 00H, 'i', 00H, 'i', 00H, 'h', 00H, 'g', 00H, '\', 00H, 's'
	DB	00H, 'r', 00H, 'c', 00H, '\', 00H, 'q', 00H, 'u', 00H, 'e', 00H
	DB	'u', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
tv79 = -208						; size = 4
_this$ = -8						; size = 4
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::front, COMDAT
; _this$ = ecx

; 227  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jbe	SHORT $LN3@front
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN4@front
$LN3@front:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	DWORD PTR tv79[ebp], ecx
$LN4@front:
	cmp	DWORD PTR tv79[ebp], 0
	jne	SHORT $LN5@front
	mov	esi, esp
	push	229					; 000000e5H
	push	OFFSET ??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1GM@LLLNNHIM@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$DP?$AA?5?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?$FL?$AAh?$AAe?$AAa?$AAd?$AA?$FN?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@front:

; 230  : #endif
; 231  : 			return entry[head];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	mov	eax, DWORD PTR [eax]

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::front
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::size, COMDAT
; _this$ = ecx

; 243  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 			return count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 245  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::size
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_offset$ = 8						; size = 4
?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::read, COMDAT
; _this$ = ecx

; 255  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN2@read
	cmp	DWORD PTR _offset$[ebp], 0
	jge	SHORT $LN3@read
$LN2@read:

; 257  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@read

; 258  : 			else

	jmp	SHORT $LN4@read
$LN3@read:

; 259  : 				return entry[(head + offset) % (unsigned)entry.size()];

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
	mov	eax, DWORD PTR [eax]
$LN4@read:

; 260  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::read
_TEXT	ENDS
PUBLIC	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull
PUBLIC	?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve
PUBLIC	??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1
__ehfuncinfo$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
_TEXT	SEGMENT
tv92 = -244						; size = 4
$T174734 = -236						; size = 4
$T174735 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_size$ = 8						; size = 4
_preallocate$ = 12					; size = 1
??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _preallocate$[ebp]
	mov	BYTE PTR [eax+32], cl

; 89   : 			entry.reserve(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve

; 90   : 
; 91   : 			if (preallocate)

	movzx	eax, BYTE PTR _preallocate$[ebp]
	test	eax, eax
	je	SHORT $LN4@Queue
$LN2@Queue:

; 92   : 			{
; 93   : 				while (!isFull())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Queue

; 94   : 				{
; 95   : 					push(::new T());

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T174735[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T174735[ebp], 0
	je	SHORT $LN6@Queue
	push	0
	push	0
	mov	ecx, DWORD PTR $T174735[ebp]
	call	??0fbdFrame@DRAMsimII@@QAE@_J@Z		; DRAMsimII::fbdFrame::fbdFrame
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN7@Queue
$LN6@Queue:
	mov	DWORD PTR tv92[ebp], 0
$LN7@Queue:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T174734[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T174734[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push

; 96   : 				}

	jmp	SHORT $LN2@Queue
$LN4@Queue:

; 97   : 			}
; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
__unwindfunclet$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T174735[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::Queue<DRAMsimII::fbdFrame>
PUBLIC	??_C@_1BG@KAGJJAL@?$AA?$CK?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
PUBLIC	??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
PUBLIC	?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
PUBLIC	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
;	COMDAT ??_C@_1BG@KAGJJAL@?$AA?$CK?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@KAGJJAL@?$AA?$CK?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB '*'
	DB	00H, 'i', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$3
__ehfuncinfo$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
tv156 = -356						; size = 4
tv85 = -352						; size = 4
tv82 = -352						; size = 4
tv76 = -352						; size = 4
$T174748 = -344						; size = 4
$T174749 = -332						; size = 4
$T174752 = -320						; size = 4
$T174753 = -308						; size = 4
$T174756 = -296						; size = 12
$T174757 = -273						; size = 1
$T174758 = -264						; size = 12
_i$152529 = -52						; size = 12
_value$152350 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ PROC	; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>, COMDAT
; _this$ = ecx

; 103  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN7@Queue@2:

; 104  : 			while (T* value = pop())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
	mov	DWORD PTR _value$152350[ebp], eax
	cmp	DWORD PTR _value$152350[ebp], 0
	je	$LN6@Queue@2

; 105  : 			{
; 106  : 				if (pool)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN5@Queue@2

; 107  : 					::delete value;

	mov	eax, DWORD PTR _value$152350[ebp]
	mov	DWORD PTR $T174749[ebp], eax
	mov	ecx, DWORD PTR $T174749[ebp]
	mov	DWORD PTR $T174748[ebp], ecx
	cmp	DWORD PTR $T174748[ebp], 0
	je	SHORT $LN10@Queue@2
	push	0
	mov	ecx, DWORD PTR $T174748[ebp]
	call	??_GfbdFrame@DRAMsimII@@QAEPAXI@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN11@Queue@2
$LN10@Queue@2:
	mov	DWORD PTR tv76[ebp], 0
$LN11@Queue@2:
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 				else

	jmp	SHORT $LN4@Queue@2
$LN5@Queue@2:

; 109  : 					delete value;			

	mov	eax, DWORD PTR _value$152350[ebp]
	mov	DWORD PTR $T174753[ebp], eax
	mov	ecx, DWORD PTR $T174753[ebp]
	mov	DWORD PTR $T174752[ebp], ecx
	cmp	DWORD PTR $T174752[ebp], 0
	je	SHORT $LN12@Queue@2
	push	1
	mov	ecx, DWORD PTR $T174752[ebp]
	call	??_GfbdFrame@DRAMsimII@@QAEPAXI@Z
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@Queue@2
$LN12@Queue@2:
	mov	DWORD PTR tv82[ebp], 0
$LN4@Queue@2:

; 110  : 			}

	jmp	$LN7@Queue@2
$LN6@Queue@2:

; 111  : 			for (typename std::vector<T*>::iterator i = entry.begin(); i != entry.end(); i++)

	lea	eax, DWORD PTR _i$152529[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN3@Queue@2
$LN2@Queue@2:
	push	0
	lea	eax, DWORD PTR $T174756[ebp]
	push	eax
	lea	ecx, DWORD PTR _i$152529[ebp]
	call	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
	lea	ecx, DWORD PTR $T174756[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
$LN3@Queue@2:
	lea	eax, DWORD PTR $T174758[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
	mov	DWORD PTR tv85[ebp], eax
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv156[ebp]
	push	edx
	lea	ecx, DWORD PTR _i$152529[ebp]
	call	??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
	mov	BYTE PTR $T174757[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T174758[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T174757[ebp]
	test	eax, eax
	je	SHORT $LN1@Queue@2

; 112  : 				assert(*i == NULL);

	lea	ecx, DWORD PTR _i$152529[ebp]
	call	??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN14@Queue@2
	mov	esi, esp
	push	112					; 00000070H
	push	OFFSET ??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1BG@KAGJJAL@?$AA?$CK?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@Queue@2:
	jmp	$LN2@Queue@2
$LN1@Queue@2:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _i$152529[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ

; 113  : 		}	

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@Queue@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@Queue@2:
	DD	1
	DD	$LN21@Queue@2
$LN21@Queue@2:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN19@Queue@2
$LN19@Queue@2:
	DB	105					; 00000069H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$1:
	lea	ecx, DWORD PTR _i$152529[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ$3:
	lea	ecx, DWORD PTR $T174758[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE@XZ ENDP	; DRAMsimII::Queue<DRAMsimII::fbdFrame>::~Queue<DRAMsimII::fbdFrame>
PUBLIC	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
PUBLIC	??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@ ; `string'
PUBLIC	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
PUBLIC	??_C@_1BK@CDKDBCEF@?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@ DB 'Input pointer is NUL'
	DB	'L', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@CDKDBCEF@?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@CDKDBCEF@?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_item$ = 8						; size = 4
?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push, COMDAT
; _this$ = ecx

; 147  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 			assert(item != NULL);

	cmp	DWORD PTR _item$[ebp], 0
	jne	SHORT $LN7@push
	mov	esi, esp
	push	148					; 00000094H
	push	OFFSET ??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1BK@CDKDBCEF@?$AAi?$AAt?$AAe?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@push:

; 149  : 			if (count == entry.size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN4@push

; 150  : 				return false;

	xor	al, al
	jmp	$LN5@push
	jmp	SHORT $LN5@push
$LN4@push:

; 151  : 			else if (item == NULL)

	cmp	DWORD PTR _item$[ebp], 0
	jne	SHORT $LN2@push

; 152  : 			{
; 153  : 				std::cerr << "Input pointer is NULL" << std::endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 154  : 				return false;

	xor	al, al
	jmp	SHORT $LN5@push

; 155  : 			}
; 156  : 			else

	jmp	SHORT $LN5@push
$LN2@push:

; 157  : 			{
; 158  : 				count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 159  : 				entry[tail] = item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax], edx

; 160  : 				tail = (tail + 1) % (unsigned)entry.size(); 	//advance tail_ptr

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+8]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 161  : 				return true;

	mov	al, 1
$LN5@push:

; 162  : 			}
; 163  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAE_NPAVfbdFrame@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::push
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ
_TEXT	SEGMENT
_item$152555 = -20					; size = 4
_this$ = -8						; size = 4
?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop, COMDAT
; _this$ = ecx

; 188  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@pop@2

; 190  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@pop@2

; 191  : 			else

	jmp	SHORT $LN3@pop@2
$LN2@pop@2:

; 192  : 			{
; 193  : 				count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _item$152555[ebp], edx

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	DWORD PTR [eax], 0

; 198  : 
; 199  : 				head = (head + 1) % (unsigned)entry.size();	//advance head_ptr

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 200  : 
; 201  : 				return item;

	mov	eax, DWORD PTR _item$152555[ebp]
$LN3@pop@2:

; 202  : 			}
; 203  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QAEPAVfbdFrame@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::pop
_TEXT	ENDS
PUBLIC	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ
_TEXT	SEGMENT
tv79 = -208						; size = 4
_this$ = -8						; size = 4
?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front, COMDAT
; _this$ = ecx

; 227  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jbe	SHORT $LN3@front@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN4@front@2
$LN3@front@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	sete	cl
	mov	DWORD PTR tv79[ebp], ecx
$LN4@front@2:
	cmp	DWORD PTR tv79[ebp], 0
	jne	SHORT $LN5@front@2
	mov	esi, esp
	push	229					; 000000e5H
	push	OFFSET ??_C@_1JK@CBHCFOLP@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAc?$AAr?$AAi?$AAu?$AAs?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe?$AAn?$AAt?$AAs?$AA?2?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5@
	push	OFFSET ??_C@_1GM@LLLNNHIM@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$DP?$AA?5?$AAe?$AAn?$AAt?$AAr?$AAy?$AA?$FL?$AAh?$AAe?$AAa?$AAd?$AA?$FN?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@front@2:

; 230  : #endif
; 231  : 			return entry[head];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	eax, DWORD PTR [eax]

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?front@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::front
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?back@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
?back@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::back, COMDAT
; _this$ = ecx

; 237  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 			return count ? entry[(head + count - 1) % (unsigned)entry.size()] : NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@back
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN4@back
$LN3@back:
	mov	DWORD PTR tv76[ebp], 0
$LN4@back:
	mov	eax, DWORD PTR tv76[ebp]

; 239  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPBVfbdFrame@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::back
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_offset$ = 8						; size = 4
?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read, COMDAT
; _this$ = ecx

; 255  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN2@read@2
	cmp	DWORD PTR _offset$[ebp], 0
	jge	SHORT $LN3@read@2
$LN2@read@2:

; 257  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@read@2

; 258  : 			else

	jmp	SHORT $LN4@read@2
$LN3@read@2:

; 259  : 				return entry[(head + offset) % (unsigned)entry.size()];

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, eax
	mov	eax, esi
	xor	edx, edx
	div	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
	mov	eax, DWORD PTR [eax]
$LN4@read@2:

; 260  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?read@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBEPAVfbdFrame@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::read
_TEXT	ENDS
PUBLIC	??_C@_1BC@MPNNIMC@?$AA?$CB?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IC@FLNOECED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA_?$AA1?$AA_?$AA4@ ; `string'
PUBLIC	?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty
;	COMDAT ??_C@_1BC@MPNNIMC@?$AA?$CB?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?$AA@
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
CONST	SEGMENT
??_C@_1BC@MPNNIMC@?$AA?$CB?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, 'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, '(', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1IC@FLNOECED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA_?$AA1?$AA_?$AA4@
CONST	SEGMENT
??_C@_1IC@FLNOECED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA_?$AA1?$AA_?$AA4@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'b', 00H, 'o', 00H, 'o', 00H
	DB	's', 00H, 't', 00H, '\', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, '1', 00H, '_', 00H, '4', 00H, '0', 00H
	DB	'\', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 's', 00H, 't', 00H, '\'
	DB	00H, 'c', 00H, 'i', 00H, 'r', 00H, 'c', 00H, 'u', 00H, 'l', 00H
	DB	'a', 00H, 'r', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, '\', 00H, 'b', 00H, 'a', 00H, 's', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ
_TEXT	SEGMENT
tv77 = -208						; size = 4
_this$ = -8						; size = 4
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::back, COMDAT
; _this$ = ecx

; 489  :     return_value_type back() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 490  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@back@2
	mov	esi, esp
	push	490					; 000001eaH
	push	OFFSET ??_C@_1IC@FLNOECED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA?2?$AAb?$AAo?$AAo?$AAs?$AAt?$AA_?$AA1?$AA_?$AA4@
	push	OFFSET ??_C@_1BC@MPNNIMC@?$AA?$CB?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@back@2:

; 491  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@back@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN5@back@2
$LN4@back@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv77[ebp], eax
$LN5@back@2:
	mov	eax, DWORD PTR tv77[ebp]
	sub	eax, 8

; 492  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = ecx

; 752  :     size_type size() const { return m_size; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174799 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174799[ebp], 0

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, DWORD PTR $T174799[ebp]
	or	eax, 1
	mov	DWORD PTR $T174799[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174804 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174804[ebp], 0

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, DWORD PTR $T174804[ebp]
	or	eax, 1
	mov	DWORD PTR $T174804[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174809 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174809[ebp], 0

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, DWORD PTR $T174809[ebp]
	or	eax, 1
	mov	DWORD PTR $T174809[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174814 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174814[ebp], 0

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, DWORD PTR $T174814[ebp]
	or	eax, 1
	mov	DWORD PTR $T174814[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
_TEXT	ENDS
PUBLIC	??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; `string'
PUBLIC	??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ ; `string'
PUBLIC	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReportW:PROC
;	COMDAT ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'P', 00H, 'o', 00H, 's', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '('
	DB	00H, ')', 00H, '"', 00H, ',', 00H, ' ', 00H, '0', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@
CONST	SEGMENT
??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H
	DB	'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
CONST	SEGMENT
??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ DB '('
	DB	00H, '"', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'a', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+'
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H
	DB	'r', 00H, 'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u'
	DB	00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ',', 00H, ' '
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
CONST	SEGMENT
??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, ' ', 00H, '9', 00H, '.', 00H, '0', 00H, '\', 00H, 'v', 00H
	DB	'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u'
	DB	00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@2

; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	764					; 000002fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 765  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@2
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@2
	int	3
$LN5@operator@2:
	mov	esi, esp
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@2:

; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@2
	xor	eax, eax
	jne	SHORT $LN6@operator@2
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@2
	int	3
$LN6@operator@2:
	mov	esi, esp
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@2:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]

; 771  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@3

; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	779					; 0000030bH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 780  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@3
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@3
	int	3
$LN5@operator@3:
	mov	esi, esp
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@3:

; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@3
	xor	eax, eax
	jne	SHORT $LN6@operator@3
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@3
	int	3
$LN6@operator@3:
	mov	esi, esp
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@HFAPIBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAB?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@3:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]

; 786  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174827 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174827[ebp], 0

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	mov	eax, DWORD PTR $T174827[ebp]
	or	eax, 1
	mov	DWORD PTR $T174827[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174832 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174832[ebp], 0

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	mov	eax, DWORD PTR $T174832[ebp]
	or	eax, 1
	mov	DWORD PTR $T174832[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
_TEXT	ENDS
PUBLIC	??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@ ; `string'
PUBLIC	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
;	COMDAT ??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@
CONST	SEGMENT
??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H
	DB	'R', 00H, 'a', 00H, 'n', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@4

; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	764					; 000002fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 765  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@4
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@4
	int	3
$LN5@operator@4:
	mov	esi, esp
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@4:

; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@4
	xor	eax, eax
	jne	SHORT $LN6@operator@4
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@4
	int	3
$LN6@operator@4:
	mov	esi, esp
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@4:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 408				; 00000198H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]

; 771  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@5

; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	779					; 0000030bH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 780  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@5
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@5
	int	3
$LN5@operator@5:
	mov	esi, esp
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@5:

; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@5
	xor	eax, eax
	jne	SHORT $LN6@operator@5
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@5
	int	3
$LN6@operator@5:
	mov	esi, esp
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1LK@OPCELHFP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAR?$AAa?$AAn@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@5:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 408				; 00000198H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]

; 786  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = ecx

; 343  : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 344  : 		return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*

; 345  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T174848 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = ecx

; 354  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174848[ebp], 0

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 356  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++

; 357  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T174848[ebp]
	or	ecx, 1
	mov	DWORD PTR $T174848[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 358  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@6
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator@6:
	DD	1
	DD	$LN8@operator@6
$LN8@operator@6:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator@6
$LN6@operator@6:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T174848[ebp]
	and	eax, 1
	je	$LN5@operator@6
	and	DWORD PTR $T174848[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN5@operator@6:
	ret	0
__ehhandler$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 65   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = ecx

; 110  : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*

; 112  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T174868 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = ecx

; 130  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174868[ebp], 0

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 132  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++

; 133  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T174868[ebp]
	or	ecx, 1
	mov	DWORD PTR $T174868[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 134  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@7
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator@7:
	DD	1
	DD	$LN8@operator@7
$LN8@operator@7:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator@7
$LN6@operator@7:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T174868[ebp]
	and	eax, 1
	je	$LN5@operator@7
	and	DWORD PTR $T174868[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN5@operator@7:
	ret	0
__ehhandler$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	call	@_RTC_Check_4_to_1@4

; 217  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->, COMDAT
; _this$ = ecx

; 110  : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*

; 112  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T174887 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = ecx

; 130  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174887[ebp], 0

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 132  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++

; 133  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T174887[ebp]
	or	ecx, 1
	mov	DWORD PTR $T174887[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 134  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@8
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator@8:
	DD	1
	DD	$LN8@operator@8
$LN8@operator@8:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator@8
$LN6@operator@8:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T174887[ebp]
	and	eax, 1
	je	$LN5@operator@8
	and	DWORD PTR $T174887[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
$LN5@operator@8:
	ret	0
__ehhandler$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	call	@_RTC_Check_4_to_1@4

; 217  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
_TEXT	ENDS
PUBLIC	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
_TEXT	ENDS
PUBLIC	??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::~_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 138  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 139  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z PROC ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@ABU01@@Z ENDP ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
_TEXT	ENDS
PUBLIC	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::~_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::~_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@ABV01@@Z		; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@ABV01@@Z	; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0_Iterator_base@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base@std@@QAE@ABV01@@Z PROC		; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 143  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 144  : 		*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base@std@@QAEAAV01@ABV01@@Z ; std::_Iterator_base::operator=

; 145  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base@std@@QAE@ABV01@@Z ENDP		; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@ABV01@@Z	; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::~_Iterator_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::~_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 727  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
_TEXT	ENDS
PUBLIC	??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@ ; `string'
;	COMDAT ??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@
CONST	SEGMENT
??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '*', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H
	DB	'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'C', 00H, 'o'
	DB	00H, 'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@9

; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	764					; 000002fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 765  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@9
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@9
	int	3
$LN5@operator@9:
	mov	esi, esp
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@9:

; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@9
	xor	eax, eax
	jne	SHORT $LN6@operator@9
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@9
	int	3
$LN6@operator@9:
	mov	esi, esp
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@9:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 771  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@10

; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	779					; 0000030bH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 780  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@10
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@10
	int	3
$LN5@operator@10:
	mov	esi, esp
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@10:

; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@10
	xor	eax, eax
	jne	SHORT $LN6@operator@10
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@10
	int	3
$LN6@operator@10:
	mov	esi, esp
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1MO@DFNMEHFD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAC?$AAo?$AAm@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@10:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 			return (entry.size() == count);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	eax, DWORD PTR [ecx]
	sete	dl
	mov	ecx, edx
	call	@_RTC_Check_4_to_1@4

; 370  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isFull@?$Queue@VfbdFrame@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::fbdFrame>::isFull
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n
PUBLIC	??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T174957 = -236						; size = 4
$T174958 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct from _Count * _Ty()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T174957[ebp], esp
	call	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 483  : 		_Construct_n(_Count, _Ty());

	mov	DWORD PTR $T174958[ebp], 0
	lea	eax, DWORD PTR $T174958[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n

; 484  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy
PUBLIC	?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
PUBLIC	?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity
PUBLIC	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
EXTRN	__imp_?_Orphan_all@_Container_base_secure@std@@QBEXXZ:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$0
__tryblocktable$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$4
__unwindtable$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv188 = -280						; size = 4
tv185 = -276						; size = 4
tv190 = -272						; size = 4
$T174977 = -264						; size = 4
$T174978 = -252						; size = 4
__Size$155863 = -48					; size = 4
__Ptr$155852 = -36					; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
	mov	DWORD PTR __Ptr$155852[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	eax, DWORD PTR __Ptr$155852[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T174977[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
	mov	DWORD PTR tv190[ebp], eax
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR tv185[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T174978[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
	mov	DWORD PTR tv188[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$155852[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::deallocate

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$1
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$1:

; 615  : 
; 616  : 			size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	mov	DWORD PTR __Size$155863[ebp], eax

; 617  : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+8]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base_secure@std@@QBEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$155852[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 628  : 			_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$155863[ebp]
	mov	ecx, DWORD PTR __Ptr$155852[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$155852[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z$2:
	mov	ecx, DWORD PTR $T174977[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::reserve
PUBLIC	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T174998 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T174998[ebp], 0

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	mov	eax, DWORD PTR $T174998[ebp]
	or	eax, 1
	mov	DWORD PTR $T174998[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::begin
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
$T175003 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T175003[ebp], 0

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	mov	eax, DWORD PTR $T175003[ebp]
	or	eax, 1
	mov	DWORD PTR $T175003[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::end
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 727  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
_TEXT	ENDS
PUBLIC	??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@ ; `string'
;	COMDAT ??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@
CONST	SEGMENT
??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'f', 00H, 'b', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '*', 00H, ','
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H
	DB	'i', 00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'f'
	DB	00H, 'b', 00H, 'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, ' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':'
	DB	00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@11

; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	764					; 000002fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 765  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@11
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@11
	int	3
$LN5@operator@11:
	mov	esi, esp
	push	0
	push	765					; 000002fdH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@11:

; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@11
	xor	eax, eax
	jne	SHORT $LN6@operator@11
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@11
	int	3
$LN6@operator@11:
	mov	esi, esp
	push	0
	push	768					; 00000300H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@11:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 771  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@12

; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	779					; 0000030bH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 780  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@12
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@12
	int	3
$LN5@operator@12:
	mov	esi, esp
	push	0
	push	780					; 0000030cH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@12:

; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@12
	xor	eax, eax
	jne	SHORT $LN6@operator@12
	mov	esi, esp
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator@12
	int	3
$LN6@operator@12:
	mov	esi, esp
	push	0
	push	783					; 0000030fH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@PGLGIDOK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAR?$AAA?$AAM?$AAs?$AAi?$AAm?$AAI?$AAI?$AA?3?$AA?3?$AAf?$AAb?$AAd@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator@12:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator[]
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty, COMDAT
; _this$ = ecx

; 783  :     bool empty() const { return size() == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	ecx, eax
	call	@_RTC_Check_4_to_1@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	cdq
	mov	ecx, 160				; 000000a0H
	idiv	ecx

; 727  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	cdq
	mov	ecx, 408				; 00000198H
	idiv	ecx

; 727  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx

; 321  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >

; 322  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*

; 340  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
_TEXT	ENDS
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1PA@CKDHABKO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@ ; `string'
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1PA@CKDHABKO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PA@CKDHABKO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
CONST	SEGMENT
??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, '(', 00H, '(', 00H, '(', 00H, '_', 00H, 'M'
	DB	00H, 'y', 00H, 'v', 00H, 'e', 00H, 'c', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, '_', 00H, 'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ')', 00H, '-', 00H, '>', 00H, '_', 00H
	DB	'M', 00H, 'y', 00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, '(', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, ' ', 00H, '*', 00H, ')', 00H, '_', 00H
	DB	'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, '_', 00H, 'M', 00H, 'y', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 't', 00H, ')', 00H, '"', 00H, ','
	DB	00H, ' ', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = ecx

; 68   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 69   : 		{	// construct with pointer _Ptr
; 70   : 		_SCL_SECURE_VALIDATE(_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast));

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN2@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	xor	eax, eax
	jne	SHORT $LN5@Vector_con
	mov	esi, esp
	push	OFFSET ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Vector_con
	int	3
$LN5@Vector_con:
	mov	esi, esp
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1PA@CKDHABKO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Vector_con:

; 71   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ; std::_Iterator_base::_Adopt

; 72   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_secure@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??_C@_1NI@IBJOBBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
;	COMDAT ??_C@_1NI@IBJOBBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NI@IBJOBBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '*', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@13
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN1@operator@13
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@13
$LN1@operator@13:

; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	98					; 00000062H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 99   : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@13
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@13
	int	3
$LN5@operator@13:
	mov	esi, esp
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NI@IBJOBBID@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@13:

; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 107  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
_TEXT	ENDS
PUBLIC	??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@ ; `string'
PUBLIC	?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ ; std::_Iterator_base::_Getmycont
PUBLIC	??_C@_1NK@MGHBJBHO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	?_Has_container@_Iterator_base@std@@QBE_NXZ	; std::_Iterator_base::_Has_container
;	COMDAT ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@
CONST	SEGMENT
??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'p', 00H, 't', 00H
	DB	'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, '(', 00H, '_'
	DB	00H, 'M', 00H, 'y', 00H, 'v', 00H, 'e', 00H, 'c', 00H, ' ', 00H
	DB	'*', 00H, ')', 00H, '(', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, '-', 00H, '>', 00H, '_', 00H, 'G', 00H, 'e', 00H, 't', 00H
	DB	'm', 00H, 'y', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, '('
	DB	00H, ')', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, '_', 00H
	DB	'M', 00H, 'y', 00H, 'l', 00H, 'a', 00H, 's', 00H, 't', 00H, '"'
	DB	00H, ',', 00H, ' ', 00H, '0', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@MGHBJBHO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@MGHBJBHO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, '"', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H
	DB	'>', 00H, '_', 00H, 'H', 00H, 'a', 00H, 's', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H
	DB	'e', 00H, 'r', 00H, '(', 00H, ')', 00H, '"', 00H, ',', 00H, ' '
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base@std@@QBE_NXZ ; std::_Iterator_base::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator@14
	xor	eax, eax
	jne	SHORT $LN7@operator@14
	mov	esi, esp
	push	OFFSET ??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN7@operator@14
	int	3
$LN7@operator@14:
	mov	esi, esp
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NK@MGHBJBHO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@operator@14:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ ; std::_Iterator_base::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+12]
	jb	SHORT $LN3@operator@14
	xor	eax, eax
	jne	SHORT $LN8@operator@14
	mov	esi, esp
	push	OFFSET ??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN8@operator@14
	int	3
$LN8@operator@14:
	mov	esi, esp
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NK@MGHBJBHO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@14:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@14
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@14
$LN1@operator@14:

; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	122					; 0000007aH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@14:

; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 160				; 000000a0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ PROC ; std::_Iterator_base::_Getmycont, COMDAT
; _this$ = ecx

; 196  : 		{	// This member function always exists when we can get a container pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 		return _Mycont;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 198  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ ENDP ; std::_Iterator_base::_Getmycont
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Has_container@_Iterator_base@std@@QBE_NXZ PROC	; std::_Iterator_base::_Has_container, COMDAT
; _this$ = ecx

; 206  : 		{	// This member function always exists when we can get a container pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return _Mycont != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	call	@_RTC_Check_4_to_1@4

; 208  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base@std@@QBE_NXZ ENDP	; std::_Iterator_base::_Has_container
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Compat
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Compat

; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+8]
	sete	al
	mov	ecx, eax
	call	@_RTC_Check_4_to_1@4

; 212  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
_TEXT	ENDS
PUBLIC	??_C@_1PA@BFFIJNEI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
;	COMDAT ??_C@_1PA@BFFIJNEI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PA@BFFIJNEI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = ecx

; 68   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 69   : 		{	// construct with pointer _Ptr
; 70   : 		_SCL_SECURE_VALIDATE(_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast));

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN2@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	xor	eax, eax
	jne	SHORT $LN5@Vector_con@2
	mov	esi, esp
	push	OFFSET ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Vector_con@2
	int	3
$LN5@Vector_con@2:
	mov	esi, esp
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1PA@BFFIJNEI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Vector_con@2:

; 71   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ; std::_Iterator_base::_Adopt

; 72   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_secure@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??_C@_1NI@GAMPBEAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1NI@GAMPBEAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NI@GAMPBEAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '*', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@15
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN1@operator@15
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@15
$LN1@operator@15:

; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	98					; 00000062H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 99   : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@15
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@15
	int	3
$LN5@operator@15:
	mov	esi, esp
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NI@GAMPBEAK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@15:

; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 107  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
_TEXT	ENDS
PUBLIC	??_C@_1NK@FMFKKHKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1NK@FMFKKHKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@FMFKKHKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base@std@@QBE_NXZ ; std::_Iterator_base::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator@16
	xor	eax, eax
	jne	SHORT $LN7@operator@16
	mov	esi, esp
	push	OFFSET ??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN7@operator@16
	int	3
$LN7@operator@16:
	mov	esi, esp
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NK@FMFKKHKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@operator@16:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ ; std::_Iterator_base::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+12]
	jb	SHORT $LN3@operator@16
	xor	eax, eax
	jne	SHORT $LN8@operator@16
	mov	esi, esp
	push	OFFSET ??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN8@operator@16
	int	3
$LN8@operator@16:
	mov	esi, esp
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NK@FMFKKHKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@16:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@16
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@16
$LN1@operator@16:

; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	122					; 0000007aH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@16:

; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 408				; 00000198H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Compat
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Compat

; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+8]
	sete	al
	mov	ecx, eax
	call	@_RTC_Check_4_to_1@4

; 212  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*

; 340  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T175076 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = ecx

; 354  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T175076[ebp], 0

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 356  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++

; 357  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T175076[ebp]
	or	ecx, 1
	mov	DWORD PTR $T175076[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 358  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@17
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN9@operator@17:
	DD	1
	DD	$LN8@operator@17
$LN8@operator@17:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator@17
$LN6@operator@17:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T175076[ebp]
	and	eax, 1
	je	$LN5@operator@17
	and	DWORD PTR $T175076[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
$LN5@operator@17:
	ret	0
__ehhandler$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
PUBLIC	??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	call	@_RTC_Check_4_to_1@4

; 217  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::~_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@ABU01@@Z ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@ABU01@@Z PROC ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@ABU01@@Z ENDP ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@ABV01@@Z	; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill
PUBLIC	?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z$0
__unwindtable$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
tv80 = -224						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n, COMDAT
; _this$ = ecx

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buy(_Count))

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Construct_

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR [ecx+12], edx
	jmp	SHORT $LN5@Construct_
__catch$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 553  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN4@Construct_
	ret	0
$LN5@Construct_:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct_:

; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEXIABQAVfbdFrame@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Construct_n
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::fbdFrame *>::max_size
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::fbdFrame *>::max_size

; 732  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base_secure@std@@QBEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXPAPAVfbdFrame@DRAMsimII@@0@Z ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+8]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1135 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02cH
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T175137 = -292						; size = 44
$T175138 = -240						; size = 32
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T175138[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T175138[ebp]
	push	eax
	lea	ecx, DWORD PTR $T175137[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T175137[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR $T175138[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ$0:
	mov	esi, esp
	lea	ecx, DWORD PTR $T175138[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	esi, esp
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	esi, esp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 36   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@

; 31   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	esi, esp
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 12					; 0000000cH
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
$T175181 = -212						; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T175181[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>

; 426  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_val<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
EXTRN	__imp_??1_Container_base_secure@std@@QAE@XZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base_secure@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::~_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEXPAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::fbdFrame *>
	add	esp, 8

; 146  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::allocate
_TEXT	ENDS
PUBLIC	??_C@_1NC@FOLGDIAG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1NC@FOLGDIAG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_1NC@FOLGDIAG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'B', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
CONST	SEGMENT
??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@ DB '('
	DB	00H, '"', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'a', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+'
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H
	DB	'r', 00H, 'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H
	DB	'A', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, '"', 00H, ',', 00H, ' ', 00H, '0', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Compat, COMDAT
; _this$ = ecx

; 248  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Compat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN3@Compat
$LN1@Compat:

; 250  : 			{
; 251  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	251					; 000000fbH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 252  : 			_SCL_SECURE_INVALID_ARGUMENT;

	xor	eax, eax
	jne	SHORT $LN5@Compat
	mov	esi, esp
	push	OFFSET ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@FOLGDIAG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 253  : 			}
; 254  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Compat
_TEXT	ENDS
PUBLIC	??_C@_1NC@NNKCOGLJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1NC@NNKCOGLJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NC@NNKCOGLJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H
	DB	'I', 00H, ':', 00H, ':', 00H, 'R', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Compat, COMDAT
; _this$ = ecx

; 248  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Compat@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN3@Compat@2
$LN1@Compat@2:

; 250  : 			{
; 251  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	251					; 000000fbH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 252  : 			_SCL_SECURE_INVALID_ARGUMENT;

	xor	eax, eax
	jne	SHORT $LN5@Compat@2
	mov	esi, esp
	push	OFFSET ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat@2
	int	3
$LN5@Compat@2:
	mov	esi, esp
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1NC@NNKCOGLJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat@2:

; 253  : 			}
; 254  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 321  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >

; 322  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
_TEXT	ENDS
PUBLIC	??_C@_1PA@CAJMBLNM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1PA@CAJMBLNM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PA@CAJMBLNM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'f', 00H
	DB	'b', 00H, 'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, '*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'f', 00H, 'b', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '*', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??D?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@18
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN1@operator@18
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@18
$LN1@operator@18:

; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	98					; 00000062H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 99   : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@18
	mov	esi, esp
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator@18
	int	3
$LN5@operator@18:
	mov	esi, esp
	push	0
	push	99					; 00000063H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1PA@CAJMBLNM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@18:

; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 107  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEABQAVfbdFrame@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat

; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+8]
	sete	al
	mov	ecx, eax
	call	@_RTC_Check_4_to_1@4

; 212  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator==
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAEPAPAVfbdFrame@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::fbdFrame *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Buy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1256 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Ufill
_TEXT	ENDS
EXTRN	__imp_??0_Container_base_secure@std@@QAE@XZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base_secure@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVfbdFrame@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >::_Container_base_aux_alloc_empty<std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DRAMsimII::fbdFrame *>::allocator<DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -220						; size = 4
__Count$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::fbdFrame *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVfbdFrame@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::fbdFrame *>::max_size
_TEXT	ENDS
PUBLIC	??_C@_1BAI@GJELONEF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
;	COMDAT ??_C@_1BAI@GJELONEF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_1BAI@GJELONEF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'f', 00H
	DB	'b', 00H, 'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, '*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'f', 00H, 'b', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT
; _this$ = ecx

; 68   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 69   : 		{	// construct with pointer _Ptr
; 70   : 		_SCL_SECURE_VALIDATE(_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast));

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN2@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	xor	eax, eax
	jne	SHORT $LN5@Vector_con@3
	mov	esi, esp
	push	OFFSET ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Vector_con@3
	int	3
$LN5@Vector_con@3:
	mov	esi, esp
	push	0
	push	70					; 00000046H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1BAI@GJELONEF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Vector_con@3:

; 71   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base_secure@2@@Z ; std::_Iterator_base::_Adopt

; 72   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@PAPAVfbdFrame@DRAMsimII@@PBV_Container_base_secure@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??_C@_1PC@BLIHJIPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1PC@BLIHJIPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PC@BLIHJIPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'f', 00H
	DB	'b', 00H, 'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, '*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'f', 00H, 'b', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '+', 00H, '+', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base@std@@QBE_NXZ ; std::_Iterator_base::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator@19
	xor	eax, eax
	jne	SHORT $LN7@operator@19
	mov	esi, esp
	push	OFFSET ??_C@_1DM@LBMEEJPP@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAH?$AAa?$AAs?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN7@operator@19
	int	3
$LN7@operator@19:
	mov	esi, esp
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1PC@BLIHJIPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@operator@19:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base@std@@QBEPBV_Container_base_secure@2@XZ ; std::_Iterator_base::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+12]
	jb	SHORT $LN3@operator@19
	xor	eax, eax
	jne	SHORT $LN8@operator@19
	mov	esi, esp
	push	OFFSET ??_C@_1HE@NMBDDEHP@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAG?$AAe@
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN8@operator@19
	int	3
$LN8@operator@19:
	mov	esi, esp
	push	0
	push	117					; 00000075H
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1PC@BLIHJIPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@19:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@19
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	ja	SHORT $LN2@operator@19
$LN1@operator@19:

; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	122					; 0000007aH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator@19:

; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator++
_TEXT	ENDS
PUBLIC	??_C@_1OK@LMOFOJFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1OK@LMOFOJFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OK@LMOFOJFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'D', 00H, 'R', 00H, 'A', 00H, 'M', 00H, 's', 00H, 'i'
	DB	00H, 'm', 00H, 'I', 00H, 'I', 00H, ':', 00H, ':', 00H, 'f', 00H
	DB	'b', 00H, 'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, '*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'D', 00H, 'R', 00H
	DB	'A', 00H, 'M', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'I', 00H, 'I'
	DB	00H, ':', 00H, ':', 00H, 'f', 00H, 'b', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat, COMDAT
; _this$ = ecx

; 248  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Compat@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN3@Compat@3
$LN1@Compat@3:

; 250  : 			{
; 251  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	251					; 000000fbH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 252  : 			_SCL_SECURE_INVALID_ARGUMENT;

	xor	eax, eax
	jne	SHORT $LN5@Compat@3
	mov	esi, esp
	push	OFFSET ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat@3
	int	3
$LN5@Compat@3:
	mov	esi, esp
	push	0
	push	252					; 000000fcH
	push	OFFSET ??_C@_1HO@CONDIOEO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	push	OFFSET ??_C@_1OK@LMOFOJFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat@3:

; 253  : 			}
; 254  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVfbdFrame@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>::_Ranit<DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVfbdFrame@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::fbdFrame *,int,DRAMsimII::fbdFrame * const *,DRAMsimII::fbdFrame * const &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z:PROC
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:PROC
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?length@?$char_traits@D@std@@SAIPBD@Z:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv293 = -337						; size = 1
tv286 = -337						; size = 1
tv292 = -336						; size = 4
tv285 = -336						; size = 4
tv291 = -332						; size = 4
tv284 = -332						; size = 4
tv290 = -328						; size = 4
tv288 = -328						; size = 4
tv283 = -328						; size = 4
tv287 = -324						; size = 4
tv136 = -324						; size = 4
tv134 = -324						; size = 4
tv289 = -321						; size = 1
tv282 = -321						; size = 1
$T175251 = -316						; size = 4
$T175252 = -304						; size = 4
$T175253 = -292						; size = 4
$T175254 = -280						; size = 4
$T175255 = -268						; size = 4
__Ok$ = -64						; size = 8
__Pad$ = -48						; size = 4
__Count$ = -36						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 741  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 742  : 	typedef char _Elem;
; 743  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 744  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 745  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	esi, esp
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	DWORD PTR __imp_?length@?$char_traits@D@std@@SAIPBD@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Count$[ebp], eax

; 746  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 747  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jle	SHORT $LN17@operator@20
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Count$[ebp]
	jle	SHORT $LN17@operator@20
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN18@operator@20
$LN17@operator@20:
	mov	DWORD PTR tv134[ebp], 0
$LN18@operator@20:
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 748  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 749  : 
; 750  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@operator@20

; 751  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 752  : 	else

	jmp	$LN13@operator@20
$LN14@operator@20:

; 753  : 		{	// state okay, insert
; 754  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 755  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv136[ebp], eax
	mov	eax, DWORD PTR tv136[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator@20
	jmp	SHORT $LN10@operator@20
$LN9@operator@20:

; 756  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN10@operator@20:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	$LN11@operator@20

; 757  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 758  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv282[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv283[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv282[ebp]
	push	eax
	mov	ecx, DWORD PTR tv283[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T175251[ebp], ecx
	mov	esi, esp
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	edx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T175252[ebp], edx
	mov	esi, esp
	lea	eax, DWORD PTR $T175251[ebp]
	push	eax
	lea	ecx, DWORD PTR $T175252[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv286[ebp], al
	movzx	edx, BYTE PTR tv286[ebp]
	test	edx, edx
	je	SHORT $LN7@operator@20

; 759  : 					{	// insertion failed, quit
; 760  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 761  : 					break;

	jmp	SHORT $LN11@operator@20
$LN7@operator@20:

; 762  : 					}
; 763  : 
; 764  : 		if (_State == ios_base::goodbit

	jmp	$LN9@operator@20
$LN11@operator@20:

; 765  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN6@operator@20
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	edx, DWORD PTR tv288[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $LN6@operator@20

; 766  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator@20:

; 767  : 
; 768  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN5@operator@20
	jmp	SHORT $LN4@operator@20
$LN3@operator@20:

; 769  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN4@operator@20:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	$LN5@operator@20

; 770  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 771  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv289[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T175253[ebp], ecx
	mov	esi, esp
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv292[ebp], eax
	mov	edx, DWORD PTR tv292[ebp]
	mov	DWORD PTR $T175254[ebp], edx
	mov	esi, esp
	lea	eax, DWORD PTR $T175253[ebp]
	push	eax
	lea	ecx, DWORD PTR $T175254[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv293[ebp], al
	movzx	edx, BYTE PTR tv293[ebp]
	test	edx, edx
	je	SHORT $LN1@operator@20

; 772  : 					{	// insertion failed, quit
; 773  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 774  : 					break;

	jmp	SHORT $LN5@operator@20
$LN1@operator@20:

; 775  : 					}

	jmp	$LN3@operator@20
$LN5@operator@20:

; 776  : 		_Ostr.width(0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator@20
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 777  : 		_CATCH_IO_(_Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN13@operator@20
	ret	0
$LN19@operator@20:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator@20:

; 778  : 		}
; 779  : 
; 780  : 	_Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 781  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T175255[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T175255[ebp]

; 782  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@operator@20
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@operator@20:
	DD	1
	DD	$LN27@operator@20
$LN27@operator@20:
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN25@operator@20
$LN25@operator@20:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@sentry

; 97   : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 99   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 102  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	mov	esi, esp
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry@2

; 106  : 				this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sentry@2:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 115  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 117  : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 77   : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 78   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 81   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas@2

; 83   : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas@2:

; 84   : 			}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??$_Debug_lt@HH@std@@YA_NABH0PB_WI@Z		; std::_Debug_lt<int,int>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
tv71 = -208						; size = 4
$T175299 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3383 : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	push	3384					; 00000d38H
	push	OFFSET ??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$_Debug_lt@HH@std@@YA_NABH0PB_WI@Z	; std::_Debug_lt<int,int>
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@max
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
$LN4@max:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T175299[ebp], edx
	mov	eax, DWORD PTR $T175299[ebp]

; 3385 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\iomanip
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,int>, COMDAT

; 81   : 	{	// insert by calling function with output stream and argument

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 82   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	cmp	DWORD PTR __Ostr$[ebp], 0
	jne	SHORT $LN3@operator@21
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@operator@21
$LN3@operator@21:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv76[ebp], edx
$LN4@operator@21:
	mov	esi, esp
	mov	eax, DWORD PTR __Manip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	mov	eax, DWORD PTR __Manip$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 83   : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,int>
_TEXT	ENDS
PUBLIC	??$_Debug_lt@_J_J@std@@YA_NAB_J0PB_WI@Z		; std::_Debug_lt<__int64,__int64>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@_J@std@@YAAB_JAB_J0@Z
_TEXT	SEGMENT
tv71 = -208						; size = 4
$T175308 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@_J@std@@YAAB_JAB_J0@Z PROC			; std::min<__int64>, COMDAT

; 3398 : 	{	// return smaller of _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	push	3399					; 00000d47H
	push	OFFSET ??_C@_1IC@MEADOCIB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$_Debug_lt@_J_J@std@@YA_NAB_J0PB_WI@Z	; std::_Debug_lt<__int64,__int64>
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@min
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
$LN4@min:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T175308[ebp], edx
	mov	eax, DWORD PTR $T175308[ebp]

; 3400 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$min@_J@std@@YAAB_JAB_J0@Z ENDP			; std::min<__int64>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$2
__ehfuncinfo$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
tv139 = -268						; size = 4
tv142 = -264						; size = 4
tv138 = -260						; size = 4
tv145 = -256						; size = 4
$T175313 = -248						; size = 4
$T175314 = -236						; size = 4
$T175315 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Ptr$ = 32						; size = 4
??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175314[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175315[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv142[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv139[ebp], eax
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T175313[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T175313[ebp]

; 1149 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z$2:
	mov	ecx, DWORD PTR $T175314[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Umove@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@?$vector@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@IAEPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Umove<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
$T175328 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
	add	esp, 8
	mov	BYTE PTR $T175328[ebp], al
	movzx	edx, BYTE PTR $T175328[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z
_TEXT	SEGMENT
$T175331 = -208						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z PROC ; std::_Allocate<DRAMsimII::fbdFrame *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T175331[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T175331[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@IPAPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::fbdFrame *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T175343 = -209						; size = 1
$T175344 = -197						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T175343[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
	add	esp, 8
	mov	BYTE PTR $T175344[ebp], al
	movzx	eax, BYTE PTR $T175343[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T175344[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '<', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??$_Debug_lt@HH@std@@YA_NABH0PB_WI@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
__Where$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_lt@HH@std@@YA_NABH0PB_WI@Z PROC		; std::_Debug_lt<int,int>, COMDAT

; 260  : 	{	// test if _Left < _Right and operator< is strict weak ordering

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 261  : 	if (!(_Left < _Right))

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN3@Debug_lt

; 262  : 		return (false);

	xor	al, al
	jmp	SHORT $LN4@Debug_lt
	jmp	SHORT $LN2@Debug_lt
$LN3@Debug_lt:

; 263  : 	else if (_Right < _Left)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN2@Debug_lt

; 264  : 		_DEBUG_ERROR2("invalid operator<", _Where, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_lt:

; 265  : 	return (true);

	mov	al, 1
$LN4@Debug_lt:

; 266  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_lt@HH@std@@YA_NABH0PB_WI@Z ENDP		; std::_Debug_lt<int,int>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Debug_lt@_J_J@std@@YA_NAB_J0PB_WI@Z
_TEXT	SEGMENT
tv85 = -200						; size = 4
tv72 = -200						; size = 4
tv84 = -196						; size = 4
tv71 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
__Where$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_lt@_J_J@std@@YA_NAB_J0PB_WI@Z PROC		; std::_Debug_lt<__int64,__int64>, COMDAT

; 260  : 	{	// test if _Left < _Right and operator< is strict weak ordering

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-200]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 261  : 	if (!(_Left < _Right))

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR tv72[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN3@Debug_lt@2
	jg	SHORT $LN6@Debug_lt@2
	mov	edx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR tv72[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jb	SHORT $LN3@Debug_lt@2
$LN6@Debug_lt@2:

; 262  : 		return (false);

	xor	al, al
	jmp	SHORT $LN4@Debug_lt@2
	jmp	SHORT $LN2@Debug_lt@2
$LN3@Debug_lt@2:

; 263  : 	else if (_Right < _Left)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	DWORD PTR tv85[ebp], ecx
	mov	edx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR tv85[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN2@Debug_lt@2
	jl	SHORT $LN7@Debug_lt@2
	mov	edx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR tv85[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN2@Debug_lt@2
$LN7@Debug_lt@2:

; 264  : 		_DEBUG_ERROR2("invalid operator<", _Where, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CE@IGJMOCCK@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_lt@2:

; 265  : 	return (true);

	mov	al, 1
$LN4@Debug_lt@2:

; 266  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_lt@_J_J@std@@YA_NAB_J0PB_WI@Z ENDP		; std::_Debug_lt<__int64,__int64>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::fbdFrame * *>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$2
__ehfuncinfo$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
tv143 = -280						; size = 4
tv146 = -276						; size = 4
tv142 = -272						; size = 4
tv149 = -268						; size = 4
$T175353 = -260						; size = 4
$T175354 = -245						; size = 1
$T175355 = -233						; size = 1
$T175356 = -224						; size = 4
$T175357 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T175354[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::fbdFrame * *>
	add	esp, 4
	mov	BYTE PTR $T175355[ebp], al
	movzx	edx, BYTE PTR $T175354[ebp]
	push	edx
	movzx	eax, BYTE PTR $T175355[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T175356[ebp], esp
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	push	eax
	call	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 8
	mov	DWORD PTR tv149[ebp], eax
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv142[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T175357[ebp], esp
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	push	eax
	call	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv143[ebp], eax
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR $T175353[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T175353[ebp]

; 865  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$2:
	mov	ecx, DWORD PTR $T175356[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAPAVfbdFrame@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVfbdFrame@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::fbdFrame * *,DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@0AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
$T175380 = -212						; size = 4
__Base_tag$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T175380[ebp], 0

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR $T175380[ebp]
	or	eax, 1
	mov	DWORD PTR $T175380[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Checked_ba
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Checked_ba:
	DD	1
	DD	$LN6@Checked_ba
$LN6@Checked_ba:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN5@Checked_ba
$LN5@Checked_ba:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z PROC ; std::_Move_cat<DRAMsimII::fbdFrame * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Move_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Move_cat:
	DD	1
	DD	$LN4@Move_cat
$LN4@Move_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Move_cat
$LN3@Move_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Move_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ENDP ; std::_Move_cat<DRAMsimII::fbdFrame * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv134 = -256						; size = 4
tv137 = -252						; size = 4
tv133 = -248						; size = 4
tv140 = -244						; size = 4
$T175392 = -236						; size = 4
$T175393 = -224						; size = 4
$T175394 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175393[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv133[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175394[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv137[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv134[ebp], eax
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR $T175392[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T175392[ebp]

; 208  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	ecx, DWORD PTR $T175393[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *>,std::_Undefined_move_tag>
PUBLIC	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
PUBLIC	??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z
_TEXT	SEGMENT
$T175407 = -209						; size = 1
$T175408 = -197						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T175407[ebp], al
	movzx	ecx, BYTE PTR $T175407[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T175408[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::fbdFrame * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
$T175412 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T175412[ebp], 0

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T175412[ebp]
	or	ecx, 1
	mov	DWORD PTR $T175412[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1148 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAPAPAVfbdFrame@DRAMsimII@@@Z ; std::_Ptr_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$2
__ehfuncinfo$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
tv144 = -280						; size = 4
tv147 = -276						; size = 4
tv143 = -272						; size = 4
tv150 = -268						; size = 4
$T175416 = -260						; size = 4
$T175417 = -245						; size = 1
$T175418 = -233						; size = 1
$T175419 = -224						; size = 4
$T175420 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T175417[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAPAPAVfbdFrame@DRAMsimII@@@Z ; std::_Ptr_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *>
	add	esp, 8
	mov	BYTE PTR $T175418[ebp], al
	movzx	eax, BYTE PTR $T175417[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T175418[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175419[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	push	ecx
	call	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 8
	mov	DWORD PTR tv150[ebp], eax
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv143[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175420[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	push	ecx
	call	??$_Checked_base@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAV10@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 8
	mov	DWORD PTR tv147[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T175416[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T175416[ebp]

; 823  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z$2:
	mov	ecx, DWORD PTR $T175419[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@stdext@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z PROC ; std::_Iter_cat<DRAMsimII::fbdFrame * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVfbdFrame@DRAMsimII@@@Z ENDP ; std::_Iter_cat<DRAMsimII::fbdFrame * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
PUBLIC	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
;	COMDAT ??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T175438 = -209						; size = 1
__Last$ = -8						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T175438[ebp], al
	movzx	ecx, BYTE PTR $T175438[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAPAPAVfbdFrame@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAPAPAVfbdFrame@DRAMsimII@@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat@2:
	DD	1
	DD	$LN4@Ptr_cat@2
$LN4@Ptr_cat@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat@2
$LN3@Ptr_cat@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@AAPAPAVfbdFrame@DRAMsimII@@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-
PUBLIC	??$_Debug_pointer@PAVfbdFrame@DRAMsimII@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@PB_WI@Z ; std::_Debug_pointer<DRAMsimII::fbdFrame *>
PUBLIC	??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??_C@_1HO@FAAIACEF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ ; `string'
EXTRN	__imp__memmove_s:PROC
;	COMDAT ??_C@_1HO@FAAIACEF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
CONST	SEGMENT
??_C@_1HO@FAAIACEF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, ' ', 00H, '9', 00H, '.', 00H, '0', 00H, '\', 00H, 'v', 00H
	DB	'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u'
	DB	00H, 'd', 00H, 'e', 00H, '\', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv156 = -276						; size = 4
tv153 = -272						; size = 4
tv159 = -268						; size = 4
$T175446 = -260						; size = 4
$T175447 = -248						; size = 4
$T175448 = -236						; size = 4
__Result$ = -32						; size = 4
__Count$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
___formal$ = 36						; size = 4
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 146  : 	_DEBUG_RANGE(_First, _Last);

	push	146					; 00000092H
	push	OFFSET ??_C@_1HO@FAAIACEF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175446[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR tv153[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175447[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv156[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 32					; 00000020H

; 147  : 	_DEBUG_POINTER(_Dest);

	push	147					; 00000093H
	push	OFFSET ??_C@_1HO@FAAIACEF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVfbdFrame@DRAMsimII@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@PB_WI@Z ; std::_Debug_pointer<DRAMsimII::fbdFrame *>
	add	esp, 12					; 0000000cH

; 148  : 	size_t _Count = (size_t)(_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@@Z ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$[ebp], edx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEAAPAVfbdFrame@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator*
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR $T175448[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T175448[ebp]

; 153  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	ecx, DWORD PTR $T175446[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@PAPAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@2@@std@@YAPAPAVfbdFrame@DRAMsimII@@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PAPAV12@AAV?$allocator@PAVfbdFrame@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >,DRAMsimII::fbdFrame * *,std::allocator<DRAMsimII::fbdFrame *> >
PUBLIC	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -5					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::fbdFrame * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::fbdFrame * *>
	add	esp, 8

; 1166 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Checked_ba@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Checked_ba@2:
	DD	1
	DD	$LN4@Checked_ba@2
$LN4@Checked_ba@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Checked_ba@2
$LN3@Checked_ba@2:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVfbdFrame@DRAMsimII@@IPAV12@@std@@YAXPAPAVfbdFrame@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::fbdFrame * *,unsigned int,DRAMsimII::fbdFrame *>
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-, COMDAT
; _this$ = ecx

; 397  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-

; 399  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat

; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 195  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator-
_TEXT	ENDS
PUBLIC	??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T175472 = -233						; size = 1
$T175473 = -224						; size = 4
$T175474 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 1597 : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1598 : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T175472[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 8
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175473[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T175474[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 36					; 00000024H

; 1599 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T175473[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??$_Debug_pointer@PAVfbdFrame@DRAMsimII@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVfbdFrame@DRAMsimII@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@PB_WI@Z PROC ; std::_Debug_pointer<DRAMsimII::fbdFrame *>, COMDAT

; 1570 : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1571 : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 1572 : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 1573 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVfbdFrame@DRAMsimII@@@std@@YAXPAPAVfbdFrame@DRAMsimII@@PB_WI@Z ENDP ; std::_Debug_pointer<DRAMsimII::fbdFrame *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::fbdFrame * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVfbdFrame@DRAMsimII@@@std@@YAPAPAVfbdFrame@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::fbdFrame * *>
; Function compile flags: /Odtp /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat@2:
	DD	1
	DD	$LN4@Iter_cat@2
$LN4@Iter_cat@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat@2
$LN3@Iter_cat@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
_TEXT	ENDS
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??M?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator<
PUBLIC	??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 1585 : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1586 : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 1587 : 		{	// check for non-null pointers, valid range
; 1588 : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 12					; 0000000cH

; 1589 : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
	add	esp, 12					; 0000000cH

; 1590 : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 1591 : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 1592 : 		}
; 1593 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator<, COMDAT
; _this$ = ecx

; 220  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::_Compat

; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	sbb	ecx, ecx
	neg	ecx
	call	@_RTC_Check_4_to_1@4

; 229  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Vector_const_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> >::operator<
; Function compile flags: /Odtp /RTCcsu /ZI
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >, COMDAT

; 1558 : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1559 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@PAVfbdFrame@DRAMsimII@@V?$allocator@PAVfbdFrame@DRAMsimII@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_iterator<DRAMsimII::fbdFrame *,std::allocator<DRAMsimII::fbdFrame *> > >
_TEXT	ENDS
END
