#ifndef M5_DRAMSYSTEM
#define M5_DRAMSYSTEM
#pragma once

#include "mem/physical.hh"
#include "mem/tport.hh"
#include "base/random.hh"
#include "params/M5dramSystem.hh" // this gets autogenerated and creates the params struct

#include "System.h"
#include "fbdSystem.h"
#include "Settings.h"
#include "globals.h"


/// @brief wrapper class to allow M5 to work with DRAMSimII
class M5dramSystem: public PhysicalMemory
{
	// taken from m5 interface
private:

	/// allows event-based simulation, scheduling wake ups for the simulator
	/// @details derived class that allows the wrapper class to interact with the event model
	class TickEvent : public Event
	{

	private:
		
		M5dramSystem *memory;	///< pointer to the wrapper class so static functions may see the single instance

	public:
		// constructor
		TickEvent(M5dramSystem *c);
		
		void process();			///< process to call when a tick event happens

		const char *description();	///< return a string that describes this event
	};

	/// allows this to receive packets and attach to a bus
	class MemoryPort : public SimpleTimingPort
	{
	private:

		M5dramSystem *memory;	///< pointer to the wrapper class so static functions may see the single instance

		Random randomGen;		///< random number generator to help when simulating delays

	public:	

		MemoryPort(const std::string &_name, M5dramSystem *_memory);

		// accessor that was needed to allow the memory system to handle incoming transactions
		void doSendTiming(PacketPtr pkt, Tick t)
		{
			schedSendTiming(pkt,t);
		}	

	protected:

		virtual Tick recvAtomic(PacketPtr pkt);

		virtual void recvFunctional(PacketPtr pkt);

		virtual void recvStatusChange(Status status);

		virtual void getDeviceAddressRanges(AddrRangeList &resp, bool &snoop);

		virtual int deviceBlockSize();

		virtual bool recvTiming(PacketPtr pkt);		
	};



protected:
	TickEvent tickEvent;									///< instance of TickEvent to allow the wrapper to receive/send events to the global queue
	std::vector<MemoryPort*> ports;							///< ports to send/recv data to other simulator components

	int lastPortIndex;										///< the last port accessed
	typedef std::vector<MemoryPort*>::iterator PortIterator;
	DRAMSimII::System *ds;									///< pointer to the DRAMSimII class
	bool needRetry;											///< if the memory system needs to issue a retry statement before any more requests will come in
	unsigned mostRecentChannel;								///< the most recent channel that a request was sent to
	int cpuRatio;											///< the ratio of the cpu frequency to the memory frequency
	//float invCpuRatio;										///< the ratio of the memory frequency to the cpu frequency
	std::map<unsigned,Packet*> transactionLookupTable;
	unsigned currentTransactionID;
	

	//virtual Tick calculateLatency(Packet *);
	//virtual Tick recvTiming(PacketPtr pkt);
	void virtual init();


public:
	typedef M5dramSystemParams Params;						///< the parameters used to initialize the memory sytem object

	M5dramSystem(const Params *);							///< constructor

	// allows other components to get a port which they can send packets to
	virtual Port *getPort(const std::string &if_name, int idx = -1);

	void getAddressRanges(AddrRangeList &resp, bool &snoop);

	int getCPURatio() const { return cpuRatio; }			///< returns the ratio of the cpu frequency to the memory frequency

	//float getInvCPURatio() const { return invCpuRatio; }	///< returns the ratio of the memory frequency to the cpu frequency

	void moveToTime(tick now);

	virtual ~M5dramSystem();
};

#endif
