/* soapStub.h
Generated by gSOAP 2.7.11 from reporting.h
Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
This part of the software is released under one of the following licenses:
GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
*                                                                            *
* Enumerations                                                               *
*                                                                            *
\******************************************************************************/


/******************************************************************************\
*                                                                            *
* Classes and Structs                                                        *
*                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__anyType() : __item(NULL), soap(NULL) { }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (10)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__boolean() : __item((bool)0) { }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (12)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_xsd__float */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__float() : __item(0) { }
	virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (14)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__int() : __item(0) { }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (15)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
	LONG64 __item;
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_xsd__long */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__long() : __item(0) { }
	virtual ~xsd__long() { }
};
#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (17)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	xsd__string()  { }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSessionIDElement
#define SOAP_TYPE__ns2__getSessionIDElement (19)
/* ns2:getSessionIDElement */
class SOAP_CMAC _ns2__getSessionIDElement
{
public:
	std::string *String_USCORE1;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns2__getSessionIDElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__getSessionIDElement() : String_USCORE1(NULL), soap(NULL) { }
	virtual ~_ns2__getSessionIDElement() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSessionIDResponseElement
#define SOAP_TYPE__ns2__getSessionIDResponseElement (20)
/* ns2:getSessionIDResponseElement */
class SOAP_CMAC _ns2__getSessionIDResponseElement
{
public:
	int result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns2__getSessionIDResponseElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__getSessionIDResponseElement() : result(0), soap(NULL) { }
	virtual ~_ns2__getSessionIDResponseElement() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSettingsFileElement
#define SOAP_TYPE__ns2__getSettingsFileElement (21)
/* ns2:getSettingsFileElement */
class SOAP_CMAC _ns2__getSettingsFileElement
{
public:
	int int_USCORE1;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns2__getSettingsFileElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__getSettingsFileElement() : int_USCORE1(0), soap(NULL) { }
	virtual ~_ns2__getSettingsFileElement() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSettingsFileResponseElement
#define SOAP_TYPE__ns2__getSettingsFileResponseElement (22)
/* ns2:getSettingsFileResponseElement */
class SOAP_CMAC _ns2__getSettingsFileResponseElement
{
public:
	std::string *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns2__getSettingsFileResponseElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__getSettingsFileResponseElement() : result(NULL), soap(NULL) { }
	virtual ~_ns2__getSettingsFileResponseElement() { }
};
#endif

#ifndef SOAP_TYPE__ns2__submitEpochResultElement
#define SOAP_TYPE__ns2__submitEpochResultElement (23)
/* ns2:submitEpochResultElement */
class SOAP_CMAC _ns2__submitEpochResultElement
{
public:
	std::string *sessionID;	/* optional element of type xsd:string */
	LONG64 epoch;	/* required element of type xsd:long */
	std::vector<int >channel;	/* optional element of type xsd:int */
	std::vector<int >rank;	/* optional element of type xsd:int */
	std::vector<float >PsysACTSTBY;	/* optional element of type xsd:float */
	std::vector<float >PsysACT;	/* optional element of type xsd:float */
	float PsysRD;	/* required element of type xsd:float */
	float PsysWR;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns2__submitEpochResultElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__submitEpochResultElement() : sessionID(NULL), epoch(0), PsysRD(0), PsysWR(0), soap(NULL) { }
	virtual ~_ns2__submitEpochResultElement() { }
};
#endif

#ifndef SOAP_TYPE__ns2__submitEpochResultResponseElement
#define SOAP_TYPE__ns2__submitEpochResultResponseElement (24)
/* ns2:submitEpochResultResponseElement */
class SOAP_CMAC _ns2__submitEpochResultResponseElement
{
public:
	bool result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns2__submitEpochResultResponseElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	_ns2__submitEpochResultResponseElement() : result((bool)0), soap(NULL) { }
	virtual ~_ns2__submitEpochResultResponseElement() { }
};
#endif

#ifndef SOAP_TYPE___ns1__getSessionID
#define SOAP_TYPE___ns1__getSessionID (31)
/* Operation wrapper: */
struct __ns1__getSessionID
{
public:
	_ns2__getSessionIDElement *ns2__getSessionIDElement;	/* optional element of type ns2:getSessionIDElement */
};
#endif

#ifndef SOAP_TYPE___ns1__getSettingsFile
#define SOAP_TYPE___ns1__getSettingsFile (35)
/* Operation wrapper: */
struct __ns1__getSettingsFile
{
public:
	_ns2__getSettingsFileElement *ns2__getSettingsFileElement;	/* optional element of type ns2:getSettingsFileElement */
};
#endif

#ifndef SOAP_TYPE___ns1__submitEpochResult
#define SOAP_TYPE___ns1__submitEpochResult (39)
/* Operation wrapper: */
struct __ns1__submitEpochResult
{
public:
	_ns2__submitEpochResultElement *ns2__submitEpochResultElement;	/* optional element of type ns2:submitEpochResultElement */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (40)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (41)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (43)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (46)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (47)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
*                                                                            *
* Types with Custom Serializers                                              *
*                                                                            *
\******************************************************************************/


/******************************************************************************\
*                                                                            *
* Typedefs                                                                   *
*                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
*                                                                            *
* Typedef Synonyms                                                           *
*                                                                            *
\******************************************************************************/


/******************************************************************************\
*                                                                            *
* Externals                                                                  *
*                                                                            *
\******************************************************************************/


/******************************************************************************\
*                                                                            *
* Stubs                                                                      *
*                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getSessionID(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__getSessionIDElement *ns2__getSessionIDElement, _ns2__getSessionIDResponseElement *ns2__getSessionIDResponseElement);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getSettingsFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__getSettingsFileElement *ns2__getSettingsFileElement, _ns2__getSettingsFileResponseElement *ns2__getSettingsFileResponseElement);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__submitEpochResult(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns2__submitEpochResultElement *ns2__submitEpochResultElement, _ns2__submitEpochResultResponseElement *ns2__submitEpochResultResponseElement);

#endif

/* End of soapStub.h */
