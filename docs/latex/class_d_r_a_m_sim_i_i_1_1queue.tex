\section{DRAMSimII::queue$<$ T $>$ Class Template Reference}
\label{class_d_r_a_m_sim_i_i_1_1queue}\index{DRAMSimII::queue@{DRAMSimII::queue}}
the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} template class, a circular \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  push/pop are O(1) operations, while random insertions are O(n) operations  


{\tt \#include $<$queue.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf queue} (const {\bf queue}$<$ T $>$ \&a)\label{class_d_r_a_m_sim_i_i_1_1queue_61da2b87747151cb97b93b60e908b13e}

\begin{CompactList}\small\item\em copy constructor  copy the existing \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}, making copies of each element \item\end{CompactList}\item 
{\bf queue} (const unsigned size, const bool preallocate=false)
\begin{CompactList}\small\item\em constructor  create a \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} of a certain size and optionally fill it with empty elements \item\end{CompactList}\item 
{\bf $\sim$queue} ()\label{class_d_r_a_m_sim_i_i_1_1queue_bbf6aa95f8571f95f82b15d01a610259}

\begin{CompactList}\small\item\em destructor  remove the elements and delete them before removing the rest of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
void {\bf resize} (unsigned size, bool preallocate=false)
\begin{CompactList}\small\item\em change the size of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  remove all existing elements and create a new \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} of a different size \item\end{CompactList}\item 
bool {\bf push} (T $\ast$item)
\begin{CompactList}\small\item\em add an item to the back of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  issue a warning if the element is null false if the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} is already full to the tail pointer position and remove from the head \item\end{CompactList}\item 
T $\ast$ {\bf acquire\_\-item} ()
\begin{CompactList}\small\item\em treat this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} like an object pool and retrieve an item  if there is no available object, then create one \item\end{CompactList}\item 
T $\ast$ {\bf pop} ()
\begin{CompactList}\small\item\em remove the item at the front of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
const T $\ast$ {\bf front} () const 
\begin{CompactList}\small\item\em get a pointer to the item at the head of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  similar to peek() \item\end{CompactList}\item 
const T $\ast$ {\bf back} () const \label{class_d_r_a_m_sim_i_i_1_1queue_38f3ed229f1291ef2a0f0c92a6104f40}

\begin{CompactList}\small\item\em to get a pointer to the item most recently inserted into the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
unsigned {\bf size} () const \label{class_d_r_a_m_sim_i_i_1_1queue_bee6a3baa30b6aa9bdb96662f98257b6}

\begin{CompactList}\small\item\em get the number of entries currently in this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
unsigned {\bf get\_\-depth} () const \label{class_d_r_a_m_sim_i_i_1_1queue_f505fd4b33c32a8f9f05b1f7a4594f0c}

\begin{CompactList}\small\item\em get the number of entries this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} can hold \item\end{CompactList}\item 
T $\ast$ {\bf read} (const unsigned offset) const \label{class_d_r_a_m_sim_i_i_1_1queue_7356be11acaec100966f42977535860f}

\begin{CompactList}\small\item\em get a pointer to the item at this offset without removing it \item\end{CompactList}\item 
void {\bf release\_\-item} (T $\ast$item)\label{class_d_r_a_m_sim_i_i_1_1queue_7df9f9af08c7de6a18b6219c59beded4}

\begin{CompactList}\small\item\em release item into pool  This is useful for when the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} holds preallocated pieces of memory and one would like to store them when they are not in use \item\end{CompactList}\item 
bool {\bf insert} (T $\ast$item, const int offset)\label{class_d_r_a_m_sim_i_i_1_1queue_76317259d18ecad4825dfd32cb3b9fe8}

\begin{CompactList}\small\item\em this function makes this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} a non-FIFO \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}.  Allows insertion into the middle or at any end \item\end{CompactList}\item 
unsigned {\bf freecount} () const \label{class_d_r_a_m_sim_i_i_1_1queue_b8ce3b1f938db3a6f937641523665a4e}

\begin{CompactList}\small\item\em the number of entries still available in this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
bool {\bf isFull} () const \label{class_d_r_a_m_sim_i_i_1_1queue_b596552eb4380af021cc429975976fe9}

\begin{CompactList}\small\item\em whether or not there is room for any more entries in this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \item\end{CompactList}\item 
bool {\bf isEmpty} () const \label{class_d_r_a_m_sim_i_i_1_1queue_e19373bf7734926ee9ec6770ea24fd05}

\begin{CompactList}\small\item\em whether or not this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} has no entries in it \item\end{CompactList}\item 
{\bf queue}$<$ T $>$ \& {\bf operator=} (const {\bf queue}$<$ T $>$ \&right)\label{class_d_r_a_m_sim_i_i_1_1queue_0d0becbd338b4d91f77050d11055e0f9}

\begin{CompactList}\small\item\em assignment operator overload  moves all the objects from the rhs object to the lhs object \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class T$>$ class DRAMSimII::queue$<$ T $>$}

the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} template class, a circular \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  push/pop are O(1) operations, while random insertions are O(n) operations 

\subsection{Constructor \& Destructor Documentation}
\index{DRAMSimII::queue@{DRAMSimII::queue}!queue@{queue}}
\index{queue@{queue}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf DRAMSimII::queue}$<$ T $>$::{\bf queue} (const unsigned {\em size}, const bool {\em preallocate} = {\tt false})\hspace{0.3cm}{\tt  [inline, explicit]}}\label{class_d_r_a_m_sim_i_i_1_1queue_986ef00407863a66f5c78a2d95306e45}


constructor  create a \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} of a certain size and optionally fill it with empty elements 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em size}]the depth of the circular \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  whether or not to fill the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} with blank elements, defaults to false \end{description}
\end{Desc}


\subsection{Member Function Documentation}
\index{DRAMSimII::queue@{DRAMSimII::queue}!resize@{resize}}
\index{resize@{resize}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf DRAMSimII::queue}$<$ T $>$::resize (unsigned {\em size}, bool {\em preallocate} = {\tt false})\hspace{0.3cm}{\tt  [inline]}}\label{class_d_r_a_m_sim_i_i_1_1queue_06a859e857db55651b76b0329565f32e}


change the size of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  remove all existing elements and create a new \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} of a different size 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em size}]the depth to set the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} to \item[{\em preallocate}]whether or not to fill the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} with blank elements, defaults to false \end{description}
\end{Desc}
\index{DRAMSimII::queue@{DRAMSimII::queue}!push@{push}}
\index{push@{push}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ bool {\bf DRAMSimII::queue}$<$ T $>$::push (T $\ast$ {\em item})\hspace{0.3cm}{\tt  [inline]}}\label{class_d_r_a_m_sim_i_i_1_1queue_2cdd5b43cc7c7b997e4f09a7fa37dceb}


add an item to the back of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  issue a warning if the element is null false if the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} is already full to the tail pointer position and remove from the head 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em item}]the item to be inserted into the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \end{description}
\end{Desc}
\index{DRAMSimII::queue@{DRAMSimII::queue}!acquire\_\-item@{acquire\_\-item}}
\index{acquire\_\-item@{acquire\_\-item}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T$\ast$ {\bf DRAMSimII::queue}$<$ T $>$::acquire\_\-item ()\hspace{0.3cm}{\tt  [inline]}}\label{class_d_r_a_m_sim_i_i_1_1queue_b5e7803cf2972041e8e61a275e788bea}


treat this \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} like an object pool and retrieve an item  if there is no available object, then create one 

\begin{Desc}
\item[Returns:]a new item which may or may not be initialized \end{Desc}
\index{DRAMSimII::queue@{DRAMSimII::queue}!pop@{pop}}
\index{pop@{pop}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T$\ast$ {\bf DRAMSimII::queue}$<$ T $>$::pop ()\hspace{0.3cm}{\tt  [inline]}}\label{class_d_r_a_m_sim_i_i_1_1queue_c27452b36943099fa2257770c4a5df7d}


remove the item at the front of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} 

\begin{Desc}
\item[Returns:]the item at the head of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}, NULL if the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} is empty \end{Desc}
\index{DRAMSimII::queue@{DRAMSimII::queue}!front@{front}}
\index{front@{front}!DRAMSimII::queue@{DRAMSimII::queue}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ const T$\ast$ {\bf DRAMSimII::queue}$<$ T $>$::front () const\hspace{0.3cm}{\tt  [inline]}}\label{class_d_r_a_m_sim_i_i_1_1queue_3713586d59f37a0048f50c0648904f6c}


get a pointer to the item at the head of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}  similar to peek() 

\begin{Desc}
\item[Returns:]a pointer to the item at the front of the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue}, or NULL if the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} is empty \end{Desc}


The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
src/queue.h\end{CompactItemize}
