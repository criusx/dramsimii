\section{DRAMSimII::dramChannel Class Reference}
\label{class_d_r_a_m_sim_i_i_1_1dram_channel}\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc.  


{\tt \#include $<$dramChannel.h$>$}

Inheritance diagram for DRAMSimII::dramChannel:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=86pt]{class_d_r_a_m_sim_i_i_1_1dram_channel__inherit__graph}
\end{center}
\end{figure}
Collaboration diagram for DRAMSimII::dramChannel:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_d_r_a_m_sim_i_i_1_1dram_channel__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
bool {\bf enqueue} ({\bf transaction} $\ast$in)
\begin{CompactList}\small\item\em enqueue the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} into the transactionQueue \item\end{CompactList}\item 
bool {\bf isFull} () const \label{class_d_r_a_m_sim_i_i_1_1dram_channel_6b2d0565da7b1363e77651018b6cfaf7}

\begin{CompactList}\small\item\em determines whether there is room for more transactions \item\end{CompactList}\item 
unsigned {\bf getChannelID} () const \label{class_d_r_a_m_sim_i_i_1_1dram_channel_7ec05928c5b3bc7962028635756512f8}

\begin{CompactList}\small\item\em return the ordinal of this channel \item\end{CompactList}\item 
bool {\bf checkForAvailableCommandSlots} (const {\bf transaction} $\ast$trans) const 
\begin{CompactList}\small\item\em determines if there are enough \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} slots for the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} to be decoded \item\end{CompactList}\item 
bool {\bf transaction2commands} ({\bf transaction} $\ast$)
\begin{CompactList}\small\item\em converts a \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} into corresponding commands \item\end{CompactList}\item 
{\bf command} $\ast$ {\bf getNextCommand} ()
\begin{CompactList}\small\item\em chooses and dequeues the next \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} to execute \item\end{CompactList}\item 
void {\bf doPowerCalculation} ()
\begin{CompactList}\small\item\em performs power calculations for this epoch and cumulative \item\end{CompactList}\item 
void {\bf executeCommand} ({\bf command} $\ast$thisCommand, const int gap)
\begin{CompactList}\small\item\em Updates the channel time to what it would be had this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} been executed Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t\_\-faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min\_\-protocol\_\-gap(). \item\end{CompactList}\item 
tick\_\-t {\bf nextTransactionDecodeTime} () const 
\begin{CompactList}\small\item\em determine when the next \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} in the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} will be decoded \item\end{CompactList}\item 
virtual tick\_\-t {\bf nextTick} () const 
\begin{CompactList}\small\item\em determines when the next \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} is decoded, \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} ready to be executed or next refresh \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} arrives \item\end{CompactList}\item 
virtual const {\bf command} $\ast$ {\bf readNextCommand} () const 
\begin{CompactList}\small\item\em returns a pointer to the \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} which would be chosen to be executed next \item\end{CompactList}\item 
virtual const void $\ast$ {\bf moveChannelToTime} (const tick\_\-t endTime, tick\_\-t $\ast$transFinishTime)
\begin{CompactList}\small\item\em Moves the specified channel to at least the time given. \item\end{CompactList}\item 
virtual int {\bf minProtocolGap} (const {\bf command} $\ast$thisCommand) const 
\begin{CompactList}\small\item\em find the protocol gap between a \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} and current system state \item\end{CompactList}\item 
virtual tick\_\-t {\bf earliestExecuteTime} (const {\bf command} $\ast$thisCommand) const 
\begin{CompactList}\small\item\em Returns the soonest time that this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} may execute. \item\end{CompactList}\item 
const {\bf dramTimingSpecification} \& {\bf getTimingSpecification} () const \label{class_d_r_a_m_sim_i_i_1_1dram_channel_a4ac4104d757a069a4bf66ee1666e1e9}

\begin{CompactList}\small\item\em returns a reference to access the timing specification \item\end{CompactList}\item 
{\bf rank\_\-c} \& {\bf getRank} (const unsigned rankNum)\label{class_d_r_a_m_sim_i_i_1_1dram_channel_21f0220576bba0787b4f66c88b695011}

\begin{CompactList}\small\item\em get a reference to this channel's rank n \item\end{CompactList}\item 
const {\bf rank\_\-c} \& {\bf getRank} (const unsigned rankNum) const \label{class_d_r_a_m_sim_i_i_1_1dram_channel_700236322c377b9e5b584e8ebb7f4be0}

\begin{CompactList}\small\item\em get a const reference to this channel's rank n \item\end{CompactList}\item 
std::vector$<$ {\bf rank\_\-c} $>$ \& {\bf getRank} ()\label{class_d_r_a_m_sim_i_i_1_1dram_channel_8d9145f1876ab899ab7aaa62e1812438}

\begin{CompactList}\small\item\em get a reference to this channel's ranks \item\end{CompactList}\item 
const {\bf transaction} $\ast$ {\bf readTransaction} (bool) const 
\item 
void {\bf setStatistics} ({\bf dramStatistics} $\ast$value)\label{class_d_r_a_m_sim_i_i_1_1dram_channel_9a64bf05caefb16fbfb887088ff803c6}

\begin{CompactList}\small\item\em set the statistics pointer to a \doxyref{dramStatistics}{p.}{class_d_r_a_m_sim_i_i_1_1dram_statistics} object \item\end{CompactList}\item 
void {\bf setTime} (tick\_\-t new\_\-time)\label{class_d_r_a_m_sim_i_i_1_1dram_channel_b95c52bf381fec1bad04a24a885ebe4a}

\begin{CompactList}\small\item\em update the time for this channel \item\end{CompactList}\item 
void {\bf setChannelID} (const unsigned value)\label{class_d_r_a_m_sim_i_i_1_1dram_channel_129c6142df4274809e57cacdf0c0f27e}

\begin{CompactList}\small\item\em set the channel ordinal \item\end{CompactList}\item 
enum transaction\_\-type\_\-t {\bf setReadWriteType} (const int, const int) const \label{class_d_r_a_m_sim_i_i_1_1dram_channel_fe49f12bf3bbe52b0b34767d2e50fbb7}

\begin{CompactList}\small\item\em determine whether a read or write \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} should be generated \item\end{CompactList}\item 
{\bf dramChannel} (const {\bf dramSettings} \&settings, const {\bf dramSystemConfiguration} \&sysConfig)
\begin{CompactList}\small\item\em constructs the \doxyref{dramChannel}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel} using this settings reference, also makes a reference to the \doxyref{dramSystemConfiguration}{p.}{class_d_r_a_m_sim_i_i_1_1dram_system_configuration} object \item\end{CompactList}\item 
{\bf dramChannel} (const {\bf dramChannel} \&)
\begin{CompactList}\small\item\em copy constructor, reassigns the ordinal to each rank as they are duplicated \item\end{CompactList}\end{CompactItemize}
\subsection*{Protected Attributes}
\begin{CompactItemize}
\item 
tick\_\-t {\bf time}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_d5ea207e8f6ca775f08b738779178b9f}

\begin{CompactList}\small\item\em channel time, allow for channel concurrency \item\end{CompactList}\item 
tick\_\-t {\bf lastRefreshTime}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_7b58c17eaa96327002b14325ce9e14f2}

\begin{CompactList}\small\item\em tells me when last refresh was done \item\end{CompactList}\item 
unsigned {\bf lastRankID}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_d42b6872d9f1c74087c3fd6e0ece60af}

\begin{CompactList}\small\item\em id of the last accessed rank of this channel \item\end{CompactList}\item 
{\bf dramTimingSpecification} {\bf timingSpecification}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_ca5241f728fec14593390cc04f4d89b5}

\begin{CompactList}\small\item\em the timing specs for this channel \item\end{CompactList}\item 
{\bf queue}$<$ {\bf transaction} $>$ {\bf transactionQueue}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_fde025b97580f33ab6a7249eefce3111}

\begin{CompactList}\small\item\em \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} for the channel \item\end{CompactList}\item 
{\bf transaction} $\ast$$\ast$ {\bf refreshCounter}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_2e6f993837a79b013c8b69844fdefe49}

\begin{CompactList}\small\item\em holds the next refresh commands \item\end{CompactList}\item 
{\bf queue}$<$ {\bf command} $>$ {\bf historyQueue}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_c5a60b4ef57a6bf8b6d6b84974a1eeb6}

\begin{CompactList}\small\item\em what were the last N commands to this channel? \item\end{CompactList}\item 
{\bf queue}$<$ {\bf transaction} $>$ {\bf completionQueue}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_e5ff742a1e3f170a56073fdf84af1804}

\begin{CompactList}\small\item\em completed\_\-q, can send status back to memory controller \item\end{CompactList}\item 
const {\bf dramSystemConfiguration} \& {\bf systemConfig}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_d1262026f63598d2f81b269f0b2c9c82}

\begin{CompactList}\small\item\em a pointer to common system config values \item\end{CompactList}\item 
{\bf dramStatistics} $\ast$ {\bf statistics}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_666ac5bdc34b2ecf7ef78d79bceed8da}

\begin{CompactList}\small\item\em backward pointer to the stats engine \item\end{CompactList}\item 
{\bf powerConfig} {\bf powerModel}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_49959a2c6c76f5cd89d5e291b61ec66c}

\begin{CompactList}\small\item\em the power model for this channel, retains power stats \item\end{CompactList}\item 
{\bf dramAlgorithm} {\bf algorithm}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_dd2db461af0f6acfe9c76648986b5d85}

\begin{CompactList}\small\item\em the algorithms used for \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction}, \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command}, etc. ordering \item\end{CompactList}\item 
unsigned {\bf channelID}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_46dc0a846d3cbcbaae8708d3b1090d2c}

\begin{CompactList}\small\item\em the ordinal value of this channel (0..n) \item\end{CompactList}\item 
std::vector$<$ {\bf rank\_\-c} $>$ {\bf rank}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_74cb774fccff04075a4c6b53f334266f}

\begin{CompactList}\small\item\em vector of the array of ranks \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc. 

\subsection{Constructor \& Destructor Documentation}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!dramChannel@{dramChannel}}
\index{dramChannel@{dramChannel}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}dramChannel::dramChannel (const {\bf dramSettings} \& {\em settings}, const {\bf dramSystemConfiguration} \& {\em sysConfig})\hspace{0.3cm}{\tt  [explicit]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_cdaec331a7930937338e6d13b8a5fafa}


constructs the \doxyref{dramChannel}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel} using this settings reference, also makes a reference to the \doxyref{dramSystemConfiguration}{p.}{class_d_r_a_m_sim_i_i_1_1dram_system_configuration} object 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em settings}]the settings file that defines the number of ranks, refresh policy, etc. \item[{\em sysConfig}]a const reference is made to this for some functions to grab parameters from \end{description}
\end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!dramChannel@{dramChannel}}
\index{dramChannel@{dramChannel}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}dramChannel::dramChannel (const {\bf dramChannel} \& {\em dc})}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_3723ed088ee0924079374d418a1c30d6}


copy constructor, reassigns the ordinal to each rank as they are duplicated 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dc}]the \doxyref{dramChannel}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel} object to be copied \end{description}
\end{Desc}


\subsection{Member Function Documentation}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!enqueue@{enqueue}}
\index{enqueue@{enqueue}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool dramChannel::enqueue ({\bf transaction} $\ast$ {\em in})}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_25fbc7884a5c0828136e9d727384878c}


enqueue the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} into the transactionQueue 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em in}]the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} to be put into the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true if there was room in the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} for this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} and the algorithm allowed it, false otherwise \end{Desc}


\begin{Desc}
\item[{\bf Todo}]probably should set the enqueue time = time here \end{Desc}


\begin{Desc}
\item[{\bf Todo}]add support for additional \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} ordering algorithms, such as read, instruction, fetch first \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!checkForAvailableCommandSlots@{checkForAvailableCommandSlots}}
\index{checkForAvailableCommandSlots@{checkForAvailableCommandSlots}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool dramChannel::checkForAvailableCommandSlots (const {\bf transaction} $\ast$ {\em trans}) const}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_b944151b57e8b653d7c1a1d1be0c55ca}


determines if there are enough \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} slots for the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} to be decoded 

this will ensure that a given \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} can be broken into and inserted as commands in this channel if there is not enough room according to a given algorithm, then it will indicate that this is not possible \begin{Desc}
\item[Author:]Joe Gross \end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em trans}]the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} to be considered \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true if there is enough room, false otherwise \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!transaction2commands@{transaction2commands}}
\index{transaction2commands@{transaction2commands}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool dramChannel::transaction2commands ({\bf transaction} $\ast$ {\em newTransaction})}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_f0bfd23f2eaeeb89e8a0b7deb6f77b42}


converts a \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} into corresponding commands 

takes a \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} and divides it into a number of commands, depending which row buffer management policy is chosen\par
 currently will divide it into RAS, CAS, Pre or RAS, CAS+P and insert these commands into the per bank queues\par
 the CAS \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} will contain a pointer to the host \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} to indicate that a read \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} has available data \begin{Desc}
\item[Author:]Joe Gross \end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em newTransaction}]the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} which is divided up \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true if the \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} was able to be divided up and put into per bank queues \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!getNextCommand@{getNextCommand}}
\index{getNextCommand@{getNextCommand}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf command} $\ast$ dramChannel::getNextCommand ()}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_d3026d3d3f3a28d838dd84f14c968a31}


chooses and dequeues the next \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} to execute 

Chooses the \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} which should be executed next from the given channel Choice is made based on command\_\-ordering\_\-algorithm from system config Command returned has already been removed from the per\_\-bank\_\-command\_\-queue from which it was selected \begin{Desc}
\item[Author:]Joe Gross \end{Desc}
\begin{Desc}
\item[Returns:]a pointer to the next \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!doPowerCalculation@{doPowerCalculation}}
\index{doPowerCalculation@{doPowerCalculation}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void dramChannel::doPowerCalculation ()}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_0c33c13c0b509b454689b26760e0799d}


performs power calculations for this epoch and cumulative 

calculates the power according to Micron technical note TN-47-04\par
 also does breakdowns of power consumed per channel and per epoch as well as averaged over time \begin{Desc}
\item[Author:]Joe Gross \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!executeCommand@{executeCommand}}
\index{executeCommand@{executeCommand}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void dramChannel::executeCommand ({\bf command} $\ast$ {\em thisCommand}, const int {\em gap})}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_858085111517b116cf4bbc0d83ffb5d5}


Updates the channel time to what it would be had this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} been executed Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t\_\-faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min\_\-protocol\_\-gap(). 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em this\_\-command}]The \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} to execute against the current state\item[{\em gap}]The minimum amount of time to delay before executing the \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command}\end{description}
\end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!nextTransactionDecodeTime@{nextTransactionDecodeTime}}
\index{nextTransactionDecodeTime@{nextTransactionDecodeTime}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}tick\_\-t dramChannel::nextTransactionDecodeTime () const}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_e99f5571782e60957e4fa13f6c9a94e3}


determine when the next \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} in the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} will be decoded 

\begin{Desc}
\item[Returns:]the time when the decoding will be complete \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!nextTick@{nextTick}}
\index{nextTick@{nextTick}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}tick\_\-t dramChannel::nextTick () const\hspace{0.3cm}{\tt  [virtual]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_ba42ea2ba7be4f39772072f565fa76fd}


determines when the next \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} is decoded, \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} ready to be executed or next refresh \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} arrives 

\begin{Desc}
\item[Returns:]the time when the next \doxyref{event}{p.}{class_d_r_a_m_sim_i_i_1_1event} happens \end{Desc}
\begin{Desc}
\item[See also:]readTransactionSimple() \doxyref{readNextCommand()}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel_d219df39009a854f2078c57a28ef569c} \doxyref{earliestExecuteTime()}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel_0dff30a96a252de8fb413f61d3de1384} \doxyref{checkForAvailableCommandSlots()}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel_b944151b57e8b653d7c1a1d1be0c55ca} \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!readNextCommand@{readNextCommand}}
\index{readNextCommand@{readNextCommand}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const {\bf command} $\ast$ dramChannel::readNextCommand () const\hspace{0.3cm}{\tt  [virtual]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_d219df39009a854f2078c57a28ef569c}


returns a pointer to the \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} which would be chosen to be executed next 

chooses a \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} according to the \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} ordering algorithm, tries to choose a \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} which can execute \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} is not actually removed from the per bank queues \begin{Desc}
\item[Author:]Joe Gross \end{Desc}
\begin{Desc}
\item[Returns:]a const pointer to the next available \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} \end{Desc}
\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!moveChannelToTime@{moveChannelToTime}}
\index{moveChannelToTime@{moveChannelToTime}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const void $\ast$ dramChannel::moveChannelToTime (const tick\_\-t {\em endTime}, tick\_\-t $\ast$ {\em transFinishTime})\hspace{0.3cm}{\tt  [virtual]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_0388ba607f4b4b26f3025090a69a7e89}


Moves the specified channel to at least the time given. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em endTime}]move the channel until it is at this time \item[{\em transFinishTime}]the time that this \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} finished \end{description}
\end{Desc}


\begin{Desc}
\item[{\bf Todo}]should this switch to use \doxyref{nextTransactionDecodeTime()}{p.}{class_d_r_a_m_sim_i_i_1_1dram_channel_e99f5571782e60957e4fa13f6c9a94e3} ? \end{Desc}


Reimplemented in {\bf DRAMSimII::fbdChannel} \doxyref{}{p.}{class_d_r_a_m_sim_i_i_1_1fbd_channel_00c50e85c0b23eefa8fb69319d66d72e}.\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!minProtocolGap@{minProtocolGap}}
\index{minProtocolGap@{minProtocolGap}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int dramChannel::minProtocolGap (const {\bf command} $\ast$ {\em this\_\-c}) const\hspace{0.3cm}{\tt  [virtual]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_629da11d3f3af08daaefa01a3838baf7}


find the protocol gap between a \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} and current system state 



Reimplemented in {\bf DRAMSimII::fbdChannel} \doxyref{}{p.}{class_d_r_a_m_sim_i_i_1_1fbd_channel_d24e63bfb96f77bc0c9457a39d32081f}.\index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!earliestExecuteTime@{earliestExecuteTime}}
\index{earliestExecuteTime@{earliestExecuteTime}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}tick\_\-t dramChannel::earliestExecuteTime (const {\bf command} $\ast$ {\em currentCommand}) const\hspace{0.3cm}{\tt  [virtual]}}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_0dff30a96a252de8fb413f61d3de1384}


Returns the soonest time that this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} may execute. 

Looks at all of the timing parameters and decides when the this \doxyref{command}{p.}{class_d_r_a_m_sim_i_i_1_1command} may soonest execute \index{DRAMSimII::dramChannel@{DRAMSimII::dramChannel}!readTransaction@{readTransaction}}
\index{readTransaction@{readTransaction}!DRAMSimII::dramChannel@{DRAMSimII::dramChannel}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const {\bf transaction} $\ast$ dramChannel::readTransaction (bool {\em bufferDelay}) const}\label{class_d_r_a_m_sim_i_i_1_1dram_channel_8601c0847f1b1710f17f7b9f6fc97574}


read the next available \doxyref{transaction}{p.}{class_d_r_a_m_sim_i_i_1_1transaction} for this channel without actually removing it from the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} if bufferDelay is set, then only transactions that have been in the \doxyref{queue}{p.}{class_d_r_a_m_sim_i_i_1_1queue} long enough to decode are considered 

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
src/dramChannel.h\item 
src/dramChannel.cpp\item 
src/executeCommand.cpp\item 
src/getNextCommand.cpp\item 
src/minProtocolGap.cpp\item 
src/transaction2commands.cpp\end{CompactItemize}
