\section{DRAMsimII::fbdChannel Class Reference}
\label{class_d_r_a_msim_i_i_1_1fbd_channel}\index{DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}}
a fully buffered DIMM channel  


{\tt \#include $<$fbdChannel.h$>$}

Inherits {\bf DRAMsimII::Channel}.

Collaboration diagram for DRAMsimII::fbdChannel:\subsection*{Protected Member Functions}
\begin{CompactItemize}
\item 
tick {\bf minProtocolGap} (const {\bf Command} $\ast$this\_\-c) const 
\begin{CompactList}\small\item\em find the protocol gap between a command and current system state \item\end{CompactList}\item 
const {\bf Command} $\ast$ {\bf readNextCommand} (const {\bf Command} $\ast$slotAFrame, const {\bf Command} $\ast$slotBFrame) const 
\begin{CompactList}\small\item\em Chooses the command which should be executed next from the given channel Choice is made based on command\_\-ordering\_\-algorithm from system config \doxyref{Command}{p.}{class_d_r_a_msim_i_i_1_1_command} returned is not yet removed from the per\_\-bank\_\-command\_\-queue from which it was selected. \item\end{CompactList}\item 
{\bf Command} $\ast$ {\bf getNextCommand} (const {\bf Command} $\ast$slotAFrame, const {\bf Command} $\ast$slotBFrame)
\begin{CompactList}\small\item\em Chooses the command which should be executed next from the given channel Choice is made based on command\_\-ordering\_\-algorithm from system config \doxyref{Command}{p.}{class_d_r_a_msim_i_i_1_1_command} returned has already been removed from the per\_\-bank\_\-command\_\-queue from which it was selected. \item\end{CompactList}\end{CompactItemize}
\subsection*{Private Member Functions}
\begin{CompactItemize}
\item 
void {\bf retireCommand} ({\bf Command} $\ast$)
\begin{CompactList}\small\item\em adds this command to the history queue \item\end{CompactList}\item 
bool {\bf checkForAvailableCommandSlots} (const {\bf Transaction} $\ast$trans) const 
\begin{CompactList}\small\item\em determines if there are enough command slots for the transaction to be decoded \item\end{CompactList}\item 
bool {\bf transaction2commands} ({\bf Transaction} $\ast$)
\begin{CompactList}\small\item\em converts a transaction into corresponding commands \item\end{CompactList}\item 
{\bf Command} $\ast$ {\bf getNextCommand} (const {\bf Command} $\ast$useThisCommand=NULL)
\begin{CompactList}\small\item\em chooses and dequeues the next command to execute \item\end{CompactList}\item 
{\bf Transaction} $\ast$ {\bf getTransaction} ()
\begin{CompactList}\small\item\em get the next transaction, whether a refresh transaction or a normal R/W transaction \item\end{CompactList}\item 
{\bf Transaction} $\ast$ {\bf getAvailableTransaction} (unsigned useThis=UINT\_\-MAX)
\begin{CompactList}\small\item\em removes and returns the next decodable transaction \item\end{CompactList}\item 
const {\bf Transaction} $\ast$ {\bf readTransaction} (bool) const 
\begin{CompactList}\small\item\em returns a pointer to the next transaction to issue to this channel without removing it \item\end{CompactList}\item 
unsigned {\bf readAvailableTransaction} (bool) const 
\begin{CompactList}\small\item\em read a transaction that is ready to go, out of order possibly \item\end{CompactList}\item 
{\bf Transaction} $\ast$ {\bf createNextRefresh} ()
\begin{CompactList}\small\item\em get the next refresh command and remove it from the queue \item\end{CompactList}\item 
const {\bf Transaction} $\ast$ {\bf readNextRefresh} () const 
\begin{CompactList}\small\item\em returns a pointer to the next refresh transaction that's going to be issued to this channel \item\end{CompactList}\item 
tick {\bf nextRefreshTime} () const 
\begin{CompactList}\small\item\em get the next refresh time \item\end{CompactList}\item 
tick {\bf nextTransactionDecodeTime} () const 
\begin{CompactList}\small\item\em determine when the next transaction incomingTransaction the queue will be decoded \item\end{CompactList}\item 
tick {\bf nextCommandExecuteTime} () const 
\begin{CompactList}\small\item\em determines the next time available for a command to issue \item\end{CompactList}\item 
void {\bf executeCommand} ({\bf Command} $\ast$thisCommand)
\begin{CompactList}\small\item\em Updates the channel time to what it would be had this command been executed. \item\end{CompactList}\item 
virtual const {\bf Command} $\ast$ {\bf readNextCommand} () const 
\begin{CompactList}\small\item\em returns a pointer to the command which would be chosen to be executed next \item\end{CompactList}\item 
virtual tick {\bf earliestExecuteTime} (const {\bf Command} $\ast$thisCommand) const 
\begin{CompactList}\small\item\em Returns the soonest time that this command may execute. \item\end{CompactList}\item 
virtual tick {\bf earliestExecuteTimeLog} (const {\bf Command} $\ast$thisCommand) const 
\begin{CompactList}\small\item\em Returns the soonest time that this command may execute, tracks the limiting factor. \item\end{CompactList}\item 
bool {\bf enqueue} ({\bf Transaction} $\ast$in)
\begin{CompactList}\small\item\em enqueue the transaction into the transactionQueue \item\end{CompactList}\item 
bool {\bf isFull} () const \label{class_d_r_a_msim_i_i_1_1_channel_65ae17bc6c997287f6337531ed7ef59b}

\begin{CompactList}\small\item\em determines whether there is room for more transactions \item\end{CompactList}\item 
unsigned {\bf getChannelID} () const \label{class_d_r_a_msim_i_i_1_1_channel_6686ab8add8a9c0fe1a3b3bb029e38b6}

\begin{CompactList}\small\item\em return the ordinal of this channel \item\end{CompactList}\item 
void {\bf doPowerCalculation} (const tick systemTime)
\begin{CompactList}\small\item\em performs power calculations for this epoch and cumulative \item\end{CompactList}\item 
virtual tick {\bf nextTick} () const 
\begin{CompactList}\small\item\em determines when the next transaction is decoded, command ready to be executed or next refresh command arrives \item\end{CompactList}\item 
void {\bf resetToTime} (const tick {\bf time})
\begin{CompactList}\small\item\em reset some stats to account for the fact that fast-forwarding has moved time forward significantly \item\end{CompactList}\item 
void {\bf getPendingTransactions} (std::queue$<$ std::pair$<$ unsigned, tick $>$ $>$ \&)
\begin{CompactList}\small\item\em return any transactions that finished when \doxyref{moveToTime()}{p.}{class_d_r_a_msim_i_i_1_1_channel_86f558398b775ae647115f2de5394563} was called \item\end{CompactList}\item 
virtual void {\bf moveToTime} (const tick currentTime)
\begin{CompactList}\small\item\em Moves the specified channel to at least the time given. \item\end{CompactList}\item 
const {\bf TimingSpecification} \& {\bf getTimingSpecification} () const \label{class_d_r_a_msim_i_i_1_1_channel_3010ef141c980c8070206174e27dc6f2}

\begin{CompactList}\small\item\em returns a reference to access the timing specification \item\end{CompactList}\item 
{\bf Rank} \& {\bf getRank} (const unsigned rankNum)\label{class_d_r_a_msim_i_i_1_1_channel_0c7d8ee5fbf5ca79dd112e3161fe56a1}

\begin{CompactList}\small\item\em get a reference to this channel's rank n \item\end{CompactList}\item 
const {\bf Rank} \& {\bf getRank} (const unsigned rankNum) const \label{class_d_r_a_msim_i_i_1_1_channel_6c9930bd4bc28c8e56712fd36c2a2366}

\begin{CompactList}\small\item\em get a const reference to this channel's rank n \item\end{CompactList}\item 
std::vector$<$ {\bf Rank} $>$ \& {\bf getRank} ()\label{class_d_r_a_msim_i_i_1_1_channel_0bff9dc2207e7d3963d57523220c6eaa}

\begin{CompactList}\small\item\em get a reference to this channel's ranks \item\end{CompactList}\item 
const std::vector$<$ {\bf Rank} $>$ \& {\bf getRank} () const \label{class_d_r_a_msim_i_i_1_1_channel_31fdce469dc9e14f2a25d87913b628fd}

\begin{CompactList}\small\item\em get a const reference to this channel's ranks \item\end{CompactList}\item 
tick {\bf getTime} () const \label{class_d_r_a_msim_i_i_1_1_channel_861366579b98a0c6071612bb8b28d72c}

\begin{CompactList}\small\item\em get the time that this channel is at \item\end{CompactList}\item 
unsigned {\bf getLastRankID} () const \label{class_d_r_a_msim_i_i_1_1_channel_6d959ab956cc8ec9853bd097c4100b58}

\begin{CompactList}\small\item\em get the last rank id a command was issued to \item\end{CompactList}\item 
unsigned {\bf getTransactionQueueCount} () const \label{class_d_r_a_msim_i_i_1_1_channel_bfc824e8625764da6d626d49e064fa0f}

\begin{CompactList}\small\item\em determine how many items are in the transaction completion queue \item\end{CompactList}\item 
unsigned {\bf getTransactionQueueDepth} () const \label{class_d_r_a_msim_i_i_1_1_channel_1729c7902d94d7107ad1c037ac48c61b}

\begin{CompactList}\small\item\em determine how large the transaction completion queue is \item\end{CompactList}\item 
void {\bf setTime} (tick value)\label{class_d_r_a_msim_i_i_1_1_channel_aff9e370a63a946599760762979f3763}

\begin{CompactList}\small\item\em update the time for this channel \item\end{CompactList}\item 
void {\bf setChannelID} (const unsigned value)\label{class_d_r_a_msim_i_i_1_1_channel_c6d32458f9e270d265fd478921a50acc}

\begin{CompactList}\small\item\em set the channel ordinal \item\end{CompactList}\item 
Transaction::TransactionType {\bf setReadWriteType} (const int) const 
\begin{CompactList}\small\item\em counts the number of reads and writes so far and returns whichever had more \item\end{CompactList}\item 
bool {\bf operator==} (const {\bf Channel} \&right) const 
\begin{CompactList}\small\item\em the equality operator, to determine if the channels are equal incomingTransaction value \item\end{CompactList}\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
tick {\bf time}\label{class_d_r_a_msim_i_i_1_1_channel_e9426aeb784a6a3fedcf59d8c689a254}

\begin{CompactList}\small\item\em channel time, allow for channel concurrency \item\end{CompactList}\item 
tick {\bf lastCommandIssueTime}\label{class_d_r_a_msim_i_i_1_1_channel_84a76f41ec8743a1f2f6de0c624c4909}

\begin{CompactList}\small\item\em the last time a command was executed on this channel \item\end{CompactList}\item 
const {\bf Command} $\ast$ {\bf lastCommand}\label{class_d_r_a_msim_i_i_1_1_channel_15b1e46323837bad21da9414e25415fe}

\begin{CompactList}\small\item\em id of the last accessed rank of this channel \item\end{CompactList}\item 
{\bf TimingSpecification} {\bf timingSpecification}\label{class_d_r_a_msim_i_i_1_1_channel_05d8007116bcfff6b9fb6373543bf173}

\begin{CompactList}\small\item\em the timing specs for this channel \item\end{CompactList}\item 
{\bf Queue}$<$ {\bf Transaction} $>$ {\bf transactionQueue}\label{class_d_r_a_msim_i_i_1_1_channel_eac2d37d1298f9bb4f1e34f50ee5e25d}

\begin{CompactList}\small\item\em transaction queue for the channel \item\end{CompactList}\item 
std::vector$<$ tick $>$ {\bf refreshCounter}\label{class_d_r_a_msim_i_i_1_1_channel_6a0b2f52ccac1da1447e20b9cbae29a3}

\begin{CompactList}\small\item\em holds the next refresh command time for the rank \item\end{CompactList}\item 
const {\bf SystemConfiguration} \& {\bf systemConfig}\label{class_d_r_a_msim_i_i_1_1_channel_c5133db93f637bbbd85872919e778297}

\begin{CompactList}\small\item\em a pointer to common system config values \item\end{CompactList}\item 
{\bf Statistics} \& {\bf statistics}\label{class_d_r_a_msim_i_i_1_1_channel_075b2f3a54ebade3af3e242806259200}

\begin{CompactList}\small\item\em backward pointer to the stats engine \item\end{CompactList}\item 
{\bf PowerConfig} {\bf powerModel}\label{class_d_r_a_msim_i_i_1_1_channel_cbbcf58fdd8d251002465261d2a72873}

\begin{CompactList}\small\item\em the power model for this channel, retains power stats \item\end{CompactList}\item 
unsigned {\bf channelID}\label{class_d_r_a_msim_i_i_1_1_channel_4fdc981bf6ca993921be2e394d852efa}

\begin{CompactList}\small\item\em the ordinal value of this channel (0..n) \item\end{CompactList}\item 
bool {\bf dbReporting}\label{class_d_r_a_msim_i_i_1_1_channel_686a09d238007aac28ad7f790c5489a4}

\begin{CompactList}\small\item\em whether or not to report results to a db \item\end{CompactList}\item 
std::vector$<$ {\bf Rank} $>$ {\bf rank}\label{class_d_r_a_msim_i_i_1_1_channel_d298e9b41a4bc083b4d20d1635c3e829}

\begin{CompactList}\small\item\em vector of the array of ranks \item\end{CompactList}\item 
std::queue$<$ std::pair$<$ unsigned, tick $>$ $>$ {\bf finishedTransactions}\label{class_d_r_a_msim_i_i_1_1_channel_80c78098ea16fcfa2d3099f02c6c37ce}

\begin{CompactList}\small\item\em the transactions finished this time \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
a fully buffered DIMM channel 

\subsection{Member Function Documentation}
\index{DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}!getNextCommand@{getNextCommand}}
\index{getNextCommand@{getNextCommand}!DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}}
\subsubsection[{getNextCommand}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Command} $\ast$ fbdChannel::getNextCommand (const {\bf Command} $\ast$ {\em slotACommand}, \/  const {\bf Command} $\ast$ {\em slotBCommand})\hspace{0.3cm}{\tt  [protected]}}\label{class_d_r_a_msim_i_i_1_1fbd_channel_3d9bc56507f1d873092c6a96bae3db56}


Chooses the command which should be executed next from the given channel Choice is made based on command\_\-ordering\_\-algorithm from system config \doxyref{Command}{p.}{class_d_r_a_msim_i_i_1_1_command} returned has already been removed from the per\_\-bank\_\-command\_\-queue from which it was selected. 

\index{DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}!minProtocolGap@{minProtocolGap}}
\index{minProtocolGap@{minProtocolGap}!DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}}
\subsubsection[{minProtocolGap}]{\setlength{\rightskip}{0pt plus 5cm}tick fbdChannel::minProtocolGap (const {\bf Command} $\ast$ {\em this\_\-c}) const\hspace{0.3cm}{\tt  [protected, virtual]}}\label{class_d_r_a_msim_i_i_1_1fbd_channel_e00da4585914ccdeea1cff8294e9ed69}


find the protocol gap between a command and current system state 



Reimplemented from {\bf DRAMsimII::Channel} \doxyref{}{p.}{class_d_r_a_msim_i_i_1_1_channel_e530764b1ea3144c32f1ee2f15ec9c89}.\index{DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}!readNextCommand@{readNextCommand}}
\index{readNextCommand@{readNextCommand}!DRAMsimII::fbdChannel@{DRAMsimII::fbdChannel}}
\subsubsection[{readNextCommand}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Command} $\ast$ fbdChannel::readNextCommand (const {\bf Command} $\ast$ {\em slotACommand}, \/  const {\bf Command} $\ast$ {\em slotBCommand}) const\hspace{0.3cm}{\tt  [protected]}}\label{class_d_r_a_msim_i_i_1_1fbd_channel_bf9e923f53aba01ec0ff478b6366438d}


Chooses the command which should be executed next from the given channel Choice is made based on command\_\-ordering\_\-algorithm from system config \doxyref{Command}{p.}{class_d_r_a_msim_i_i_1_1_command} returned is not yet removed from the per\_\-bank\_\-command\_\-queue from which it was selected. 



The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
src/fbdChannel.h\item 
src/fbdChannel.cpp\end{CompactItemize}
