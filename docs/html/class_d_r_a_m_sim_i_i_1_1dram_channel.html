<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DRAMSimII: DRAMSimII::dramChannel Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<b>DRAMSimII</b>::<a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html">dramChannel</a></div>
<h1>DRAMSimII::dramChannel Class Reference</h1><!-- doxytag: class="DRAMSimII::dramChannel" -->represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;dramChannel.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for DRAMSimII::dramChannel:</div>
<div class="dynsection">
<p><center><img src="class_d_r_a_m_sim_i_i_1_1dram_channel__inherit__graph.png" border="0" usemap="#_d_r_a_m_sim_i_i_1_1dram_channel__inherit__map" alt="Inheritance graph"></center>
<map name="_d_r_a_m_sim_i_i_1_1dram_channel__inherit__map">
<area shape="rect" href="class_d_r_a_m_sim_i_i_1_1fbd_channel.html" title="a fully buffered DIMM channel" alt="" coords="11,80,171,107"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for DRAMSimII::dramChannel:</div>
<div class="dynsection">
<p><center><img src="class_d_r_a_m_sim_i_i_1_1dram_channel__coll__graph.png" border="0" usemap="#_d_r_a_m_sim_i_i_1_1dram_channel__coll__map" alt="Collaboration graph"></center>
<map name="_d_r_a_m_sim_i_i_1_1dram_channel__coll__map">
<area shape="rect" href="class_d_r_a_m_sim_i_i_1_1power_config.html" title="stores power configuration parameters for this DRAM system necessary to calculate..." alt="" coords="277,6,443,32"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html" title="stores the system configuration options for a dramSystem" alt="" coords="237,56,483,83"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically" alt="" coords="280,107,440,134"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1addresses.html" title="This class logically represents several interpretations of a memory address." alt="" coords="7,107,161,134"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1dram_timing_specification.html" title="contains all the specs for this channel&#39;s DIMMs" alt="" coords="241,158,479,184"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1dram_algorithm.html" title="Algorithm specific data structures should go in here." alt="" coords="271,208,449,235"><area shape="rect" href="class_d_r_a_m_sim_i_i_1_1dram_statistics.html" title="stores statistics about this memory system, primarily relating to counts of transactions/commands..." alt="" coords="271,259,449,286"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_d_r_a_m_sim_i_i_1_1dram_channel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#25fbc7884a5c0828136e9d727384878c">enqueue</a> (<a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enqueue the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> into the transactionQueue  <a href="#25fbc7884a5c0828136e9d727384878c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b2d0565da7b1363e77651018b6cfaf7"></a><!-- doxytag: member="DRAMSimII::dramChannel::isFull" ref="6b2d0565da7b1363e77651018b6cfaf7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#6b2d0565da7b1363e77651018b6cfaf7">isFull</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines whether there is room for more transactions <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ec05928c5b3bc7962028635756512f8"></a><!-- doxytag: member="DRAMSimII::dramChannel::getChannelID" ref="7ec05928c5b3bc7962028635756512f8" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#7ec05928c5b3bc7962028635756512f8">getChannelID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the ordinal of this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#b944151b57e8b653d7c1a1d1be0c55ca">checkForAvailableCommandSlots</a> (const <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *trans) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines if there are enough <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> slots for the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> to be decoded  <a href="#b944151b57e8b653d7c1a1d1be0c55ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#f0bfd23f2eaeeb89e8a0b7deb6f77b42">transaction2commands</a> (<a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">converts a <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> into corresponding commands  <a href="#f0bfd23f2eaeeb89e8a0b7deb6f77b42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d3026d3d3f3a28d838dd84f14c968a31">getNextCommand</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">chooses and dequeues the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> to execute  <a href="#d3026d3d3f3a28d838dd84f14c968a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#0c33c13c0b509b454689b26760e0799d">doPowerCalculation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performs power calculations for this epoch and cumulative  <a href="#0c33c13c0b509b454689b26760e0799d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#858085111517b116cf4bbc0d83ffb5d5">executeCommand</a> (<a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *thisCommand, const int gap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the channel time to what it would be had this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> been executed Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t_faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min_protocol_gap().  <a href="#858085111517b116cf4bbc0d83ffb5d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">tick_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#e99f5571782e60957e4fa13f6c9a94e3">nextTransactionDecodeTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine when the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> in the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> will be decoded  <a href="#e99f5571782e60957e4fa13f6c9a94e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#ba42ea2ba7be4f39772072f565fa76fd">nextTick</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines when the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> is decoded, <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> ready to be executed or next refresh <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> arrives  <a href="#ba42ea2ba7be4f39772072f565fa76fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d219df39009a854f2078c57a28ef569c">readNextCommand</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> which would be chosen to be executed next  <a href="#d219df39009a854f2078c57a28ef569c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#0388ba607f4b4b26f3025090a69a7e89">moveChannelToTime</a> (const tick_t endTime, tick_t *transFinishTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the specified channel to at least the time given.  <a href="#0388ba607f4b4b26f3025090a69a7e89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#629da11d3f3af08daaefa01a3838baf7">minProtocolGap</a> (const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *thisCommand) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the protocol gap between a <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> and current system state  <a href="#629da11d3f3af08daaefa01a3838baf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#0dff30a96a252de8fb413f61d3de1384">earliestExecuteTime</a> (const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *thisCommand) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the soonest time that this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> may execute.  <a href="#0dff30a96a252de8fb413f61d3de1384"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4ac4104d757a069a4bf66ee1666e1e9"></a><!-- doxytag: member="DRAMSimII::dramChannel::getTimingSpecification" ref="a4ac4104d757a069a4bf66ee1666e1e9" args="() const " -->
const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_timing_specification.html">dramTimingSpecification</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#a4ac4104d757a069a4bf66ee1666e1e9">getTimingSpecification</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a reference to access the timing specification <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21f0220576bba0787b4f66c88b695011"></a><!-- doxytag: member="DRAMSimII::dramChannel::getRank" ref="21f0220576bba0787b4f66c88b695011" args="(const unsigned rankNum)" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1rank__c.html">rank_c</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#21f0220576bba0787b4f66c88b695011">getRank</a> (const unsigned rankNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's rank n <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="700236322c377b9e5b584e8ebb7f4be0"></a><!-- doxytag: member="DRAMSimII::dramChannel::getRank" ref="700236322c377b9e5b584e8ebb7f4be0" args="(const unsigned rankNum) const " -->
const <a class="el" href="class_d_r_a_m_sim_i_i_1_1rank__c.html">rank_c</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#700236322c377b9e5b584e8ebb7f4be0">getRank</a> (const unsigned rankNum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a const reference to this channel's rank n <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d9145f1876ab899ab7aaa62e1812438"></a><!-- doxytag: member="DRAMSimII::dramChannel::getRank" ref="8d9145f1876ab899ab7aaa62e1812438" args="()" -->
std::vector&lt; <a class="el" href="class_d_r_a_m_sim_i_i_1_1rank__c.html">rank_c</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#8d9145f1876ab899ab7aaa62e1812438">getRank</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's ranks <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#8601c0847f1b1710f17f7b9f6fc97574">readTransaction</a> (bool) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a64bf05caefb16fbfb887088ff803c6"></a><!-- doxytag: member="DRAMSimII::dramChannel::setStatistics" ref="9a64bf05caefb16fbfb887088ff803c6" args="(dramStatistics *value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#9a64bf05caefb16fbfb887088ff803c6">setStatistics</a> (<a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_statistics.html">dramStatistics</a> *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the statistics pointer to a <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_statistics.html" title="stores statistics about this memory system, primarily relating to counts of transactions/commands...">dramStatistics</a> object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b95c52bf381fec1bad04a24a885ebe4a"></a><!-- doxytag: member="DRAMSimII::dramChannel::setTime" ref="b95c52bf381fec1bad04a24a885ebe4a" args="(tick_t new_time)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#b95c52bf381fec1bad04a24a885ebe4a">setTime</a> (tick_t new_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update the time for this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="129c6142df4274809e57cacdf0c0f27e"></a><!-- doxytag: member="DRAMSimII::dramChannel::setChannelID" ref="129c6142df4274809e57cacdf0c0f27e" args="(const unsigned value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#129c6142df4274809e57cacdf0c0f27e">setChannelID</a> (const unsigned value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the channel ordinal <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe49f12bf3bbe52b0b34767d2e50fbb7"></a><!-- doxytag: member="DRAMSimII::dramChannel::setReadWriteType" ref="fe49f12bf3bbe52b0b34767d2e50fbb7" args="(const int, const int) const " -->
enum transaction_type_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#fe49f12bf3bbe52b0b34767d2e50fbb7">setReadWriteType</a> (const int, const int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine whether a read or write <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> should be generated <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#cdaec331a7930937338e6d13b8a5fafa">dramChannel</a> (const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_settings.html">dramSettings</a> &amp;settings, const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html">dramSystemConfiguration</a> &amp;sysConfig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructs the <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html" title="represents a DRAM channel, has individual timing parameters, ranks, banks, clock...">dramChannel</a> using this settings reference, also makes a reference to the <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html" title="stores the system configuration options for a dramSystem">dramSystemConfiguration</a> object  <a href="#cdaec331a7930937338e6d13b8a5fafa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#3723ed088ee0924079374d418a1c30d6">dramChannel</a> (const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html">dramChannel</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor, reassigns the ordinal to each rank as they are duplicated  <a href="#3723ed088ee0924079374d418a1c30d6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5ea207e8f6ca775f08b738779178b9f"></a><!-- doxytag: member="DRAMSimII::dramChannel::time" ref="d5ea207e8f6ca775f08b738779178b9f" args="" -->
tick_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d5ea207e8f6ca775f08b738779178b9f">time</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">channel time, allow for channel concurrency <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b58c17eaa96327002b14325ce9e14f2"></a><!-- doxytag: member="DRAMSimII::dramChannel::lastRefreshTime" ref="7b58c17eaa96327002b14325ce9e14f2" args="" -->
tick_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#7b58c17eaa96327002b14325ce9e14f2">lastRefreshTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tells me when last refresh was done <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d42b6872d9f1c74087c3fd6e0ece60af"></a><!-- doxytag: member="DRAMSimII::dramChannel::lastRankID" ref="d42b6872d9f1c74087c3fd6e0ece60af" args="" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d42b6872d9f1c74087c3fd6e0ece60af">lastRankID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the last accessed rank of this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca5241f728fec14593390cc04f4d89b5"></a><!-- doxytag: member="DRAMSimII::dramChannel::timingSpecification" ref="ca5241f728fec14593390cc04f4d89b5" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_timing_specification.html">dramTimingSpecification</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#ca5241f728fec14593390cc04f4d89b5">timingSpecification</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the timing specs for this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fde025b97580f33ab6a7249eefce3111"></a><!-- doxytag: member="DRAMSimII::dramChannel::transactionQueue" ref="fde025b97580f33ab6a7249eefce3111" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html">queue</a>&lt; <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#fde025b97580f33ab6a7249eefce3111">transactionQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> for the channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e6f993837a79b013c8b69844fdefe49"></a><!-- doxytag: member="DRAMSimII::dramChannel::refreshCounter" ref="2e6f993837a79b013c8b69844fdefe49" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#2e6f993837a79b013c8b69844fdefe49">refreshCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">holds the next refresh commands <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5a60b4ef57a6bf8b6d6b84974a1eeb6"></a><!-- doxytag: member="DRAMSimII::dramChannel::historyQueue" ref="c5a60b4ef57a6bf8b6d6b84974a1eeb6" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html">queue</a>&lt; <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#c5a60b4ef57a6bf8b6d6b84974a1eeb6">historyQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">what were the last N commands to this channel? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5ff742a1e3f170a56073fdf84af1804"></a><!-- doxytag: member="DRAMSimII::dramChannel::completionQueue" ref="e5ff742a1e3f170a56073fdf84af1804" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html">queue</a>&lt; <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#e5ff742a1e3f170a56073fdf84af1804">completionQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">completed_q, can send status back to memory controller <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1262026f63598d2f81b269f0b2c9c82"></a><!-- doxytag: member="DRAMSimII::dramChannel::systemConfig" ref="d1262026f63598d2f81b269f0b2c9c82" args="" -->
const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html">dramSystemConfiguration</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d1262026f63598d2f81b269f0b2c9c82">systemConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a pointer to common system config values <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="666ac5bdc34b2ecf7ef78d79bceed8da"></a><!-- doxytag: member="DRAMSimII::dramChannel::statistics" ref="666ac5bdc34b2ecf7ef78d79bceed8da" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_statistics.html">dramStatistics</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#666ac5bdc34b2ecf7ef78d79bceed8da">statistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">backward pointer to the stats engine <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="49959a2c6c76f5cd89d5e291b61ec66c"></a><!-- doxytag: member="DRAMSimII::dramChannel::powerModel" ref="49959a2c6c76f5cd89d5e291b61ec66c" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1power_config.html">powerConfig</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#49959a2c6c76f5cd89d5e291b61ec66c">powerModel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the power model for this channel, retains power stats <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd2db461af0f6acfe9c76648986b5d85"></a><!-- doxytag: member="DRAMSimII::dramChannel::algorithm" ref="dd2db461af0f6acfe9c76648986b5d85" args="" -->
<a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_algorithm.html">dramAlgorithm</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#dd2db461af0f6acfe9c76648986b5d85">algorithm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the algorithms used for <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a>, <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a>, etc. ordering <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46dc0a846d3cbcbaae8708d3b1090d2c"></a><!-- doxytag: member="DRAMSimII::dramChannel::channelID" ref="46dc0a846d3cbcbaae8708d3b1090d2c" args="" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#46dc0a846d3cbcbaae8708d3b1090d2c">channelID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the ordinal value of this channel (0..n) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74cb774fccff04075a4c6b53f334266f"></a><!-- doxytag: member="DRAMSimII::dramChannel::rank" ref="74cb774fccff04075a4c6b53f334266f" args="" -->
std::vector&lt; <a class="el" href="class_d_r_a_m_sim_i_i_1_1rank__c.html">rank_c</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#74cb774fccff04075a4c6b53f334266f">rank</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of the array of ranks <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cdaec331a7930937338e6d13b8a5fafa"></a><!-- doxytag: member="DRAMSimII::dramChannel::dramChannel" ref="cdaec331a7930937338e6d13b8a5fafa" args="(const dramSettings &amp;settings, const dramSystemConfiguration &amp;sysConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dramChannel::dramChannel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_settings.html">dramSettings</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html">dramSystemConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sysConfig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructs the <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html" title="represents a DRAM channel, has individual timing parameters, ranks, banks, clock...">dramChannel</a> using this settings reference, also makes a reference to the <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_system_configuration.html" title="stores the system configuration options for a dramSystem">dramSystemConfiguration</a> object 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>settings</em>&nbsp;</td><td>the settings file that defines the number of ranks, refresh policy, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sysConfig</em>&nbsp;</td><td>a const reference is made to this for some functions to grab parameters from </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3723ed088ee0924079374d418a1c30d6"></a><!-- doxytag: member="DRAMSimII::dramChannel::dramChannel" ref="3723ed088ee0924079374d418a1c30d6" args="(const dramChannel &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dramChannel::dramChannel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html">dramChannel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy constructor, reassigns the ordinal to each rank as they are duplicated 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dc</em>&nbsp;</td><td>the <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html" title="represents a DRAM channel, has individual timing parameters, ranks, banks, clock...">dramChannel</a> object to be copied </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="25fbc7884a5c0828136e9d727384878c"></a><!-- doxytag: member="DRAMSimII::dramChannel::enqueue" ref="25fbc7884a5c0828136e9d727384878c" args="(transaction *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dramChannel::enqueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
enqueue the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> into the transactionQueue 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> to be put into the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there was room in the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> for this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> and the algorithm allowed it, false otherwise </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>probably should set the enqueue time = time here </dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>add support for additional <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> ordering algorithms, such as read, instruction, fetch first </dd></dl>

</div>
</div><p>
<a class="anchor" name="b944151b57e8b653d7c1a1d1be0c55ca"></a><!-- doxytag: member="DRAMSimII::dramChannel::checkForAvailableCommandSlots" ref="b944151b57e8b653d7c1a1d1be0c55ca" args="(const transaction *trans) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dramChannel::checkForAvailableCommandSlots           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>trans</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determines if there are enough <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> slots for the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> to be decoded 
<p>
this will ensure that a given <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> can be broken into and inserted as commands in this channel if there is not enough room according to a given algorithm, then it will indicate that this is not possible <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> to be considered </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there is enough room, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="f0bfd23f2eaeeb89e8a0b7deb6f77b42"></a><!-- doxytag: member="DRAMSimII::dramChannel::transaction2commands" ref="f0bfd23f2eaeeb89e8a0b7deb6f77b42" args="(transaction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dramChannel::transaction2commands           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>newTransaction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
converts a <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> into corresponding commands 
<p>
takes a <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> and divides it into a number of commands, depending which row buffer management policy is chosen<br>
 currently will divide it into RAS, CAS, Pre or RAS, CAS+P and insert these commands into the per bank queues<br>
 the CAS <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> will contain a pointer to the host <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> to indicate that a read <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> has available data <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newTransaction</em>&nbsp;</td><td>the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> which is divided up </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> was able to be divided up and put into per bank queues </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3026d3d3f3a28d838dd84f14c968a31"></a><!-- doxytag: member="DRAMSimII::dramChannel::getNextCommand" ref="d3026d3d3f3a28d838dd84f14c968a31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> * dramChannel::getNextCommand           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
chooses and dequeues the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> to execute 
<p>
Chooses the <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> which should be executed next from the given channel Choice is made based on command_ordering_algorithm from system config Command returned has already been removed from the per_bank_command_queue from which it was selected <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c33c13c0b509b454689b26760e0799d"></a><!-- doxytag: member="DRAMSimII::dramChannel::doPowerCalculation" ref="0c33c13c0b509b454689b26760e0799d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dramChannel::doPowerCalculation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
performs power calculations for this epoch and cumulative 
<p>
calculates the power according to Micron technical note TN-47-04<br>
 also does breakdowns of power consumed per channel and per epoch as well as averaged over time <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="858085111517b116cf4bbc0d83ffb5d5"></a><!-- doxytag: member="DRAMSimII::dramChannel::executeCommand" ref="858085111517b116cf4bbc0d83ffb5d5" args="(command *thisCommand, const int gap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dramChannel::executeCommand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *&nbsp;</td>
          <td class="paramname"> <em>thisCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>gap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the channel time to what it would be had this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> been executed Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t_faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min_protocol_gap(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>this_command</em>&nbsp;</td><td>The <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> to execute against the current state</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gap</em>&nbsp;</td><td>The minimum amount of time to delay before executing the <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e99f5571782e60957e4fa13f6c9a94e3"></a><!-- doxytag: member="DRAMSimII::dramChannel::nextTransactionDecodeTime" ref="e99f5571782e60957e4fa13f6c9a94e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick_t dramChannel::nextTransactionDecodeTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determine when the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> in the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> will be decoded 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time when the decoding will be complete </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba42ea2ba7be4f39772072f565fa76fd"></a><!-- doxytag: member="DRAMSimII::dramChannel::nextTick" ref="ba42ea2ba7be4f39772072f565fa76fd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick_t dramChannel::nextTick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determines when the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> is decoded, <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> ready to be executed or next refresh <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> arrives 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time when the next <a class="el" href="class_d_r_a_m_sim_i_i_1_1event.html" title="pending event queue">event</a> happens </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>readTransactionSimple() <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#d219df39009a854f2078c57a28ef569c" title="returns a pointer to the command which would be chosen to be executed next">readNextCommand()</a> <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#0dff30a96a252de8fb413f61d3de1384" title="Returns the soonest time that this command may execute.">earliestExecuteTime()</a> <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#b944151b57e8b653d7c1a1d1be0c55ca" title="determines if there are enough command slots for the transaction to be decoded">checkForAvailableCommandSlots()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d219df39009a854f2078c57a28ef569c"></a><!-- doxytag: member="DRAMSimII::dramChannel::readNextCommand" ref="d219df39009a854f2078c57a28ef569c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> * dramChannel::readNextCommand           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a pointer to the <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> which would be chosen to be executed next 
<p>
chooses a <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> according to the <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> ordering algorithm, tries to choose a <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> which can execute <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> is not actually removed from the per bank queues <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const pointer to the next available <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0388ba607f4b4b26f3025090a69a7e89"></a><!-- doxytag: member="DRAMSimII::dramChannel::moveChannelToTime" ref="0388ba607f4b4b26f3025090a69a7e89" args="(const tick_t endTime, tick_t *transFinishTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * dramChannel::moveChannelToTime           </td>
          <td>(</td>
          <td class="paramtype">const tick_t&nbsp;</td>
          <td class="paramname"> <em>endTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tick_t *&nbsp;</td>
          <td class="paramname"> <em>transFinishTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the specified channel to at least the time given. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endTime</em>&nbsp;</td><td>move the channel until it is at this time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transFinishTime</em>&nbsp;</td><td>the time that this <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> finished </td></tr>
  </table>
</dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>should this switch to use <a class="el" href="class_d_r_a_m_sim_i_i_1_1dram_channel.html#e99f5571782e60957e4fa13f6c9a94e3" title="determine when the next transaction in the queue will be decoded">nextTransactionDecodeTime()</a> ? </dd></dl>

<p>Reimplemented in <a class="el" href="class_d_r_a_m_sim_i_i_1_1fbd_channel.html#00c50e85c0b23eefa8fb69319d66d72e">DRAMSimII::fbdChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="629da11d3f3af08daaefa01a3838baf7"></a><!-- doxytag: member="DRAMSimII::dramChannel::minProtocolGap" ref="629da11d3f3af08daaefa01a3838baf7" args="(const command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dramChannel::minProtocolGap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *&nbsp;</td>
          <td class="paramname"> <em>this_c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the protocol gap between a <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> and current system state 
<p>

<p>Reimplemented in <a class="el" href="class_d_r_a_m_sim_i_i_1_1fbd_channel.html#d24e63bfb96f77bc0c9457a39d32081f">DRAMSimII::fbdChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="0dff30a96a252de8fb413f61d3de1384"></a><!-- doxytag: member="DRAMSimII::dramChannel::earliestExecuteTime" ref="0dff30a96a252de8fb413f61d3de1384" args="(const command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick_t dramChannel::earliestExecuteTime           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html">command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the soonest time that this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> may execute. 
<p>
Looks at all of the timing parameters and decides when the this <a class="el" href="class_d_r_a_m_sim_i_i_1_1command.html" title="represents a DRAM command from the memory controller to the DRAMs">command</a> may soonest execute 
</div>
</div><p>
<a class="anchor" name="8601c0847f1b1710f17f7b9f6fc97574"></a><!-- doxytag: member="DRAMSimII::dramChannel::readTransaction" ref="8601c0847f1b1710f17f7b9f6fc97574" args="(bool) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html">transaction</a> * dramChannel::readTransaction           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bufferDelay</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
read the next available <a class="el" href="class_d_r_a_m_sim_i_i_1_1transaction.html" title="a request to read or write some portion of memory, atomically">transaction</a> for this channel without actually removing it from the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> if bufferDelay is set, then only transactions that have been in the <a class="el" href="class_d_r_a_m_sim_i_i_1_1queue.html" title="the queue template class, a circular queue  push/pop are O(1) operations, while random...">queue</a> long enough to decode are considered 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>src/dramChannel.h<li>src/dramChannel.cpp<li>src/executeCommand.cpp<li>src/getNextCommand.cpp<li>src/minProtocolGap.cpp<li>src/transaction2commands.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 30 01:03:56 2008 for DRAMSimII by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
