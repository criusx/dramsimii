<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DRAMSimII: DRAMsimII::Channel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>DRAMsimII</b>::<a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a>
  </div>
</div>
<div class="contents">
<h1>DRAMsimII::Channel Class Reference</h1><!-- doxytag: class="DRAMsimII::Channel" -->represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Channel.h&gt;</code>
<p>
Inherited by <a class="el" href="class_d_r_a_msim_i_i_1_1fbd_channel.html">DRAMsimII::fbdChannel</a><code> [private]</code>.
<p>
<div class="dynheader">
Collaboration diagram for DRAMsimII::Channel:</div>
<div class="dynsection">
<p><center><img src="class_d_r_a_msim_i_i_1_1_channel__coll__graph.png" border="0" usemap="#_d_r_a_msim_i_i_1_1_channel__coll__map" alt="Collaboration graph"></center>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_d_r_a_msim_i_i_1_1_channel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#14a707920dfcf559abd1c48fad84866a">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_settings.html">Settings</a> &amp;settings, const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;sysConfig, <a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructs the dramChannel using this settings reference, also makes a reference to the dramSystemConfiguration object  <a href="#14a707920dfcf559abd1c48fad84866a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ee673bcc93a9984513a0efb3c42d2d2f">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor, reassigns the ordinal to each rank as they are duplicated  <a href="#ee673bcc93a9984513a0efb3c42d2d2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#45a28d42cc3099f5d967b9a6d298badf">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;rhs, const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;<a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#c5133db93f637bbbd85872919e778297">systemConfig</a>, <a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the copy constructor for building unitialized copies of a channel  <a href="#45a28d42cc3099f5d967b9a6d298badf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#5f15ebd302464069f1a9e3f0ded14482">~Channel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">channel destructor  <a href="#5f15ebd302464069f1a9e3f0ded14482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#da774dec2e706f86d1c3364cb6b8d3bb">enqueue</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enqueue the transaction into the transactionQueue  <a href="#da774dec2e706f86d1c3364cb6b8d3bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="65ae17bc6c997287f6337531ed7ef59b"></a><!-- doxytag: member="DRAMsimII::Channel::isFull" ref="65ae17bc6c997287f6337531ed7ef59b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#65ae17bc6c997287f6337531ed7ef59b">isFull</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines whether there is room for more transactions <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6686ab8add8a9c0fe1a3b3bb029e38b6"></a><!-- doxytag: member="DRAMsimII::Channel::getChannelID" ref="6686ab8add8a9c0fe1a3b3bb029e38b6" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#6686ab8add8a9c0fe1a3b3bb029e38b6">getChannelID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the ordinal of this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0d13f91b788925a91ade7801391568d5">doPowerCalculation</a> (const tick systemTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performs power calculations for this epoch and cumulative  <a href="#0d13f91b788925a91ade7801391568d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#600b15ceb9c7c06e75f26a3cf969577b">nextTick</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines when the next transaction is decoded, command ready to be executed or next refresh command arrives  <a href="#600b15ceb9c7c06e75f26a3cf969577b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7c5c87ed9b458d23a0482410f89536a9">resetToTime</a> (const tick <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#e9426aeb784a6a3fedcf59d8c689a254">time</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset some stats to account for the fact that fast-forwarding has moved time forward significantly  <a href="#7c5c87ed9b458d23a0482410f89536a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#45aa0482ce88a84d0ad46b12aa5f762e">getPendingTransactions</a> (std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return any transactions that finished when <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#86f558398b775ae647115f2de5394563" title="Moves the specified channel to at least the time given.">moveToTime()</a> was called  <a href="#45aa0482ce88a84d0ad46b12aa5f762e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#86f558398b775ae647115f2de5394563">moveToTime</a> (const tick currentTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the specified channel to at least the time given.  <a href="#86f558398b775ae647115f2de5394563"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3010ef141c980c8070206174e27dc6f2"></a><!-- doxytag: member="DRAMsimII::Channel::getTimingSpecification" ref="3010ef141c980c8070206174e27dc6f2" args="() const " -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_timing_specification.html">TimingSpecification</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#3010ef141c980c8070206174e27dc6f2">getTimingSpecification</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a reference to access the timing specification <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c7d8ee5fbf5ca79dd112e3161fe56a1"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="0c7d8ee5fbf5ca79dd112e3161fe56a1" args="(const unsigned rankNum)" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0c7d8ee5fbf5ca79dd112e3161fe56a1">getRank</a> (const unsigned rankNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's rank n <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c9930bd4bc28c8e56712fd36c2a2366"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="6c9930bd4bc28c8e56712fd36c2a2366" args="(const unsigned rankNum) const " -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#6c9930bd4bc28c8e56712fd36c2a2366">getRank</a> (const unsigned rankNum) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a const reference to this channel's rank n <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0bff9dc2207e7d3963d57523220c6eaa"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="0bff9dc2207e7d3963d57523220c6eaa" args="()" -->
std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0bff9dc2207e7d3963d57523220c6eaa">getRank</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's ranks <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="31fdce469dc9e14f2a25d87913b628fd"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="31fdce469dc9e14f2a25d87913b628fd" args="() const " -->
const std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#31fdce469dc9e14f2a25d87913b628fd">getRank</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a const reference to this channel's ranks <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="861366579b98a0c6071612bb8b28d72c"></a><!-- doxytag: member="DRAMsimII::Channel::getTime" ref="861366579b98a0c6071612bb8b28d72c" args="() const " -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#861366579b98a0c6071612bb8b28d72c">getTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the time that this channel is at <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d959ab956cc8ec9853bd097c4100b58"></a><!-- doxytag: member="DRAMsimII::Channel::getLastRankID" ref="6d959ab956cc8ec9853bd097c4100b58" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#6d959ab956cc8ec9853bd097c4100b58">getLastRankID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the last rank id a command was issued to <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfc824e8625764da6d626d49e064fa0f"></a><!-- doxytag: member="DRAMsimII::Channel::getTransactionQueueCount" ref="bfc824e8625764da6d626d49e064fa0f" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#bfc824e8625764da6d626d49e064fa0f">getTransactionQueueCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine how many items are in the transaction completion queue <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1729c7902d94d7107ad1c037ac48c61b"></a><!-- doxytag: member="DRAMsimII::Channel::getTransactionQueueDepth" ref="1729c7902d94d7107ad1c037ac48c61b" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#1729c7902d94d7107ad1c037ac48c61b">getTransactionQueueDepth</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine how large the transaction completion queue is <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aff9e370a63a946599760762979f3763"></a><!-- doxytag: member="DRAMsimII::Channel::setTime" ref="aff9e370a63a946599760762979f3763" args="(tick value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#aff9e370a63a946599760762979f3763">setTime</a> (tick value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update the time for this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6d32458f9e270d265fd478921a50acc"></a><!-- doxytag: member="DRAMsimII::Channel::setChannelID" ref="c6d32458f9e270d265fd478921a50acc" args="(const unsigned value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#c6d32458f9e270d265fd478921a50acc">setChannelID</a> (const unsigned value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the channel ordinal <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Transaction::TransactionType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#270aa3d8611e3f390b9fcde7498f79ea">setReadWriteType</a> (const int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">counts the number of reads and writes so far and returns whichever had more  <a href="#270aa3d8611e3f390b9fcde7498f79ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7e381469d0f4eb86f98877434078a397">operator=</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;rs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the assignment operator, will copy non-key items to this channel  <a href="#7e381469d0f4eb86f98877434078a397"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#857df39abce2ca631a353b01b618fc36">operator==</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;right) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the equality operator, to determine if the channels are equal incomingTransaction value  <a href="#857df39abce2ca631a353b01b618fc36"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#1b45dcd1a06bee01673f50f6b3b3e380">retireCommand</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds this command to the history queue  <a href="#1b45dcd1a06bee01673f50f6b3b3e380"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#311f351c816f6b817e1d9e8439f439fc">checkForAvailableCommandSlots</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *trans) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines if there are enough command slots for the transaction to be decoded  <a href="#311f351c816f6b817e1d9e8439f439fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#c3e345bcc7bbe92151f9369638c18dd8">transaction2commands</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">converts a transaction into corresponding commands  <a href="#c3e345bcc7bbe92151f9369638c18dd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7ccb7a779c25d6eac6c3d6b7bf0d7449">getNextCommand</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *useThisCommand=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">chooses and dequeues the next command to execute  <a href="#7ccb7a779c25d6eac6c3d6b7bf0d7449"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#5476d2960d9e14e5e6481f6d33709df8">getTransaction</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next transaction, whether a refresh transaction or a normal R/W transaction  <a href="#5476d2960d9e14e5e6481f6d33709df8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0cc52c572e890e714452bf9fe7dcf524">getAvailableTransaction</a> (unsigned useThis=UINT_MAX)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes and returns the next decodable transaction  <a href="#0cc52c572e890e714452bf9fe7dcf524"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#11346a2c4a644e97da954e01a2b664fe">readTransaction</a> (bool) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the next transaction to issue to this channel without removing it  <a href="#11346a2c4a644e97da954e01a2b664fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7887227e2915a92fa0e2861f85146600">readAvailableTransaction</a> (bool) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read a transaction that is ready to go, out of order possibly  <a href="#7887227e2915a92fa0e2861f85146600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ad689363a5c222dbcc9cc327d1a382cb">createNextRefresh</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next refresh command and remove it from the queue  <a href="#ad689363a5c222dbcc9cc327d1a382cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#134ad422666cce6800373f85bf349725">readNextRefresh</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the next refresh transaction that's going to be issued to this channel  <a href="#134ad422666cce6800373f85bf349725"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#00ad45bd632d212ded9605f5488ee147">nextRefreshTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next refresh time  <a href="#00ad45bd632d212ded9605f5488ee147"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#d3e2f574c25d524c1bc76b7948b4f1ea">nextTransactionDecodeTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine when the next transaction incomingTransaction the queue will be decoded  <a href="#d3e2f574c25d524c1bc76b7948b4f1ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0e0ba95b7cbf831ee1fda9fd91901906">nextCommandExecuteTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines the next time available for a command to issue  <a href="#0e0ba95b7cbf831ee1fda9fd91901906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#c70faefd9c39af71cb67096c00527331">executeCommand</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the channel time to what it would be had this command been executed.  <a href="#c70faefd9c39af71cb67096c00527331"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#4f4b7e6a327ff6a00713a4a8124d6c89">readNextCommand</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the command which would be chosen to be executed next  <a href="#4f4b7e6a327ff6a00713a4a8124d6c89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#e530764b1ea3144c32f1ee2f15ec9c89">minProtocolGap</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the protocol gap between a command and current system state  <a href="#e530764b1ea3144c32f1ee2f15ec9c89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#4465dd17290100fa458caa6390ae0a0f">earliestExecuteTime</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the soonest time that this command may execute.  <a href="#4465dd17290100fa458caa6390ae0a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#0c8eefcbd0952de5631c22608cc2b7fd">earliestExecuteTimeLog</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the soonest time that this command may execute, tracks the limiting factor.  <a href="#0c8eefcbd0952de5631c22608cc2b7fd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9426aeb784a6a3fedcf59d8c689a254"></a><!-- doxytag: member="DRAMsimII::Channel::time" ref="e9426aeb784a6a3fedcf59d8c689a254" args="" -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#e9426aeb784a6a3fedcf59d8c689a254">time</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">channel time, allow for channel concurrency <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84a76f41ec8743a1f2f6de0c624c4909"></a><!-- doxytag: member="DRAMsimII::Channel::lastCommandIssueTime" ref="84a76f41ec8743a1f2f6de0c624c4909" args="" -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#84a76f41ec8743a1f2f6de0c624c4909">lastCommandIssueTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last time a command was executed on this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15b1e46323837bad21da9414e25415fe"></a><!-- doxytag: member="DRAMsimII::Channel::lastCommand" ref="15b1e46323837bad21da9414e25415fe" args="" -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#15b1e46323837bad21da9414e25415fe">lastCommand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the last accessed rank of this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d8007116bcfff6b9fb6373543bf173"></a><!-- doxytag: member="DRAMsimII::Channel::timingSpecification" ref="05d8007116bcfff6b9fb6373543bf173" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_timing_specification.html">TimingSpecification</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#05d8007116bcfff6b9fb6373543bf173">timingSpecification</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the timing specs for this channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eac2d37d1298f9bb4f1e34f50ee5e25d"></a><!-- doxytag: member="DRAMsimII::Channel::transactionQueue" ref="eac2d37d1298f9bb4f1e34f50ee5e25d" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_queue.html">Queue</a>&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#eac2d37d1298f9bb4f1e34f50ee5e25d">transactionQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transaction queue for the channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a0b2f52ccac1da1447e20b9cbae29a3"></a><!-- doxytag: member="DRAMsimII::Channel::refreshCounter" ref="6a0b2f52ccac1da1447e20b9cbae29a3" args="" -->
std::vector&lt; tick &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#6a0b2f52ccac1da1447e20b9cbae29a3">refreshCounter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">holds the next refresh command time for the rank <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5133db93f637bbbd85872919e778297"></a><!-- doxytag: member="DRAMsimII::Channel::systemConfig" ref="c5133db93f637bbbd85872919e778297" args="" -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#c5133db93f637bbbd85872919e778297">systemConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a pointer to common system config values <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="075b2f3a54ebade3af3e242806259200"></a><!-- doxytag: member="DRAMsimII::Channel::statistics" ref="075b2f3a54ebade3af3e242806259200" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#075b2f3a54ebade3af3e242806259200">statistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">backward pointer to the stats engine <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbbcf58fdd8d251002465261d2a72873"></a><!-- doxytag: member="DRAMsimII::Channel::powerModel" ref="cbbcf58fdd8d251002465261d2a72873" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_power_config.html">PowerConfig</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#cbbcf58fdd8d251002465261d2a72873">powerModel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the power model for this channel, retains power stats <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4fdc981bf6ca993921be2e394d852efa"></a><!-- doxytag: member="DRAMsimII::Channel::channelID" ref="4fdc981bf6ca993921be2e394d852efa" args="" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#4fdc981bf6ca993921be2e394d852efa">channelID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the ordinal value of this channel (0..n) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="686a09d238007aac28ad7f790c5489a4"></a><!-- doxytag: member="DRAMsimII::Channel::dbReporting" ref="686a09d238007aac28ad7f790c5489a4" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#686a09d238007aac28ad7f790c5489a4">dbReporting</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">whether or not to report results to a db <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d298e9b41a4bc083b4d20d1635c3e829"></a><!-- doxytag: member="DRAMsimII::Channel::rank" ref="d298e9b41a4bc083b4d20d1635c3e829" args="" -->
std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#d298e9b41a4bc083b4d20d1635c3e829">rank</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of the array of ranks <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80c78098ea16fcfa2d3099f02c6c37ce"></a><!-- doxytag: member="DRAMsimII::Channel::finishedTransactions" ref="80c78098ea16fcfa2d3099f02c6c37ce" args="" -->
std::queue&lt; std::pair<br class="typebreak">
&lt; unsigned, tick &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#80c78098ea16fcfa2d3099f02c6c37ce">finishedTransactions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the transactions finished this time <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="14a707920dfcf559abd1c48fad84866a"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="14a707920dfcf559abd1c48fad84866a" args="(const Settings &amp;settings, const SystemConfiguration &amp;sysConfig, Statistics &amp;stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_settings.html">Settings</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sysConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructs the dramChannel using this settings reference, also makes a reference to the dramSystemConfiguration object 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>settings</em>&nbsp;</td><td>the settings file that defines the number of ranks, refresh policy, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sysConfig</em>&nbsp;</td><td>a const reference is made to this for some functions to grab parameters from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>a reference to the stats object that will be collecting data </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee673bcc93a9984513a0efb3c42d2d2f"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="ee673bcc93a9984513a0efb3c42d2d2f" args="(const Channel &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy constructor, reassigns the ordinal to each rank as they are duplicated 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>the dramChannel object to be copied </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="45a28d42cc3099f5d967b9a6d298badf"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="45a28d42cc3099f5d967b9a6d298badf" args="(const Channel &amp;rhs, const SystemConfiguration &amp;systemConfig, Statistics &amp;stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>systemConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the copy constructor for building unitialized copies of a channel 
<p>
normal copy constructor <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f15ebd302464069f1a9e3f0ded14482"></a><!-- doxytag: member="DRAMsimII::Channel::~Channel" ref="5f15ebd302464069f1a9e3f0ded14482" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::~Channel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
channel destructor 
<p>
need to remove all the commands in the queues before destructing the channel because some refresh commands are simultaneously in two or more queues and will be duplicated in the command pool if they are not removed properly 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="311f351c816f6b817e1d9e8439f439fc"></a><!-- doxytag: member="DRAMsimII::Channel::checkForAvailableCommandSlots" ref="311f351c816f6b817e1d9e8439f439fc" args="(const Transaction *trans) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::checkForAvailableCommandSlots           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determines if there are enough command slots for the transaction to be decoded 
<p>
this will ensure that a given transaction can be broken into and inserted as commands in this channel if there is not enough room according to a given algorithm, then it will indicate that this is not possible <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>trans the transaction to be considered </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there is enough room, false otherwise </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>switch to iterator arithmetic </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad689363a5c222dbcc9cc327d1a382cb"></a><!-- doxytag: member="DRAMsimII::Channel::createNextRefresh" ref="ad689363a5c222dbcc9cc327d1a382cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::createNextRefresh           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the next refresh command and remove it from the queue 
<p>
returns a pointer to a refresh transaction that represents what the next refresh <br>
 transaction would be. this should not be enqueued as it has not been removed yet <dl class="return" compact><dt><b>Returns:</b></dt><dd>the next possible refresh transaction </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d13f91b788925a91ade7801391568d5"></a><!-- doxytag: member="DRAMsimII::Channel::doPowerCalculation" ref="0d13f91b788925a91ade7801391568d5" args="(const tick systemTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::doPowerCalculation           </td>
          <td>(</td>
          <td class="paramtype">const tick&nbsp;</td>
          <td class="paramname"> <em>systemTime</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
performs power calculations for this epoch and cumulative 
<p>
calculates the power according to Micron technical note TN-47-04<br>
 also does breakdowns of power consumed per channel and per epoch as well as averaged over time <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>actually simulate CKE, per rank </dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>: account for CKE </dd></dl>

</div>
</div><p>
<a class="anchor" name="4465dd17290100fa458caa6390ae0a0f"></a><!-- doxytag: member="DRAMsimII::Channel::earliestExecuteTime" ref="4465dd17290100fa458caa6390ae0a0f" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::earliestExecuteTime           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the soonest time that this command may execute. 
<p>
refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk by Jacob/Wang Looks at all of the timing parameters and decides when the this command may soonest execute 
</div>
</div><p>
<a class="anchor" name="0c8eefcbd0952de5631c22608cc2b7fd"></a><!-- doxytag: member="DRAMsimII::Channel::earliestExecuteTimeLog" ref="0c8eefcbd0952de5631c22608cc2b7fd" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::earliestExecuteTimeLog           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the soonest time that this command may execute, tracks the limiting factor. 
<p>
refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk by Jacob/Wang Looks at all of the timing parameters and decides when the this command may execute soonest 
</div>
</div><p>
<a class="anchor" name="da774dec2e706f86d1c3364cb6b8d3bb"></a><!-- doxytag: member="DRAMsimII::Channel::enqueue" ref="da774dec2e706f86d1c3364cb6b8d3bb" args="(Transaction *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::enqueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
enqueue the transaction into the transactionQueue 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>the transaction to be put into the queue </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there was room incomingTransaction the queue for this command and the algorithm allowed it, false otherwise </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="c70faefd9c39af71cb67096c00527331"></a><!-- doxytag: member="DRAMsimII::Channel::executeCommand" ref="c70faefd9c39af71cb67096c00527331" args="(Command *thisCommand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::executeCommand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>thisCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the channel time to what it would be had this command been executed. 
<p>
Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t_faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min_protocol_gap() <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thisCommand</em>&nbsp;</td><td>the command to execute at this time </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>let each rank figure out if the command is to it or not by combining issueCAS and issueCASother </dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>let each rank figure out if the command is to it or not by combining issueCAS and issueCASother </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cc52c572e890e714452bf9fe7dcf524"></a><!-- doxytag: member="DRAMsimII::Channel::getAvailableTransaction" ref="0cc52c572e890e714452bf9fe7dcf524" args="(unsigned useThis=UINT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::getAvailableTransaction           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>useThis</em> = <code>UINT_MAX</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
removes and returns the next decodable transaction 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7887227e2915a92fa0e2861f85146600" title="read a transaction that is ready to go, out of order possibly">readAvailableTransaction()</a> returns a transaction that can be decoded right now in the same way as <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#7887227e2915a92fa0e2861f85146600" title="read a transaction that is ready to go, out of order possibly">readAvailableTransaction()</a>, but actually removes it </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ccb7a779c25d6eac6c3d6b7bf0d7449"></a><!-- doxytag: member="DRAMsimII::Channel::getNextCommand" ref="7ccb7a779c25d6eac6c3d6b7bf0d7449" args="(const Command *useThisCommand=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> * Channel::getNextCommand           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>useThisCommand</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
chooses and dequeues the next command to execute 
<p>
Chooses the command which should be executed next from the given channel Choice is made based on command_ordering_algorithm from system config <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html" title="represents a DRAM command from the memory controller to the DRAMs">Command</a> returned has already been removed from the per_bank_command_queue from which it was selected <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the next command </dd></dl>

</div>
</div><p>
<a class="anchor" name="45aa0482ce88a84d0ad46b12aa5f762e"></a><!-- doxytag: member="DRAMsimII::Channel::getPendingTransactions" ref="45aa0482ce88a84d0ad46b12aa5f762e" args="(std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::getPendingTransactions           </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>outputQueue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return any transactions that finished when <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#86f558398b775ae647115f2de5394563" title="Moves the specified channel to at least the time given.">moveToTime()</a> was called 
<p>
moves results from the internal queue to the given queue <dl class="return" compact><dt><b>Returns:</b></dt><dd>a queue that has the results in transactionID, finished time pairs </dd></dl>

</div>
</div><p>
<a class="anchor" name="5476d2960d9e14e5e6481f6d33709df8"></a><!-- doxytag: member="DRAMsimII::Channel::getTransaction" ref="5476d2960d9e14e5e6481f6d33709df8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::getTransaction           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the next transaction, whether a refresh transaction or a normal R/W transaction 
<p>
gets the next transaction for this channel and removes it, always returns a transaction that is able to decode <dl class="return" compact><dt><b>Returns:</b></dt><dd>the next transaction for this channel </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="e530764b1ea3144c32f1ee2f15ec9c89"></a><!-- doxytag: member="DRAMsimII::Channel::minProtocolGap" ref="e530764b1ea3144c32f1ee2f15ec9c89" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::minProtocolGap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the protocol gap between a command and current system state 
<p>
old version of the function to check the next available command time, now used to check newer functions and ensure changes don't break timing requirements 
<p>Reimplemented in <a class="el" href="class_d_r_a_msim_i_i_1_1fbd_channel.html#e00da4585914ccdeea1cff8294e9ed69">DRAMsimII::fbdChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="86f558398b775ae647115f2de5394563"></a><!-- doxytag: member="DRAMsimII::Channel::moveToTime" ref="86f558398b775ae647115f2de5394563" args="(const tick currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::moveToTime           </td>
          <td>(</td>
          <td class="paramtype">const tick&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the specified channel to at least the time given. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>issue all events up to and including this time </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>continue until no events are processed, no commands issued, no transactions decoded </dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>verify that this is right </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e0ba95b7cbf831ee1fda9fd91901906"></a><!-- doxytag: member="DRAMsimII::Channel::nextCommandExecuteTime" ref="0e0ba95b7cbf831ee1fda9fd91901906" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextCommandExecuteTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determines the next time available for a command to issue 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the next time an event occurs on this channel </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="00ad45bd632d212ded9605f5488ee147"></a><!-- doxytag: member="DRAMsimII::Channel::nextRefreshTime" ref="00ad45bd632d212ded9605f5488ee147" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextRefreshTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the next refresh time 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time at which the next refresh should be issued for this channel </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="600b15ceb9c7c06e75f26a3cf969577b"></a><!-- doxytag: member="DRAMsimII::Channel::nextTick" ref="600b15ceb9c7c06e75f26a3cf969577b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextTick           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determines when the next transaction is decoded, command ready to be executed or next refresh command arrives 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time when the next event happens </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>readTransactionSimple() <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#4f4b7e6a327ff6a00713a4a8124d6c89" title="returns a pointer to the command which would be chosen to be executed next">readNextCommand()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#4465dd17290100fa458caa6390ae0a0f" title="Returns the soonest time that this command may execute.">earliestExecuteTime()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#311f351c816f6b817e1d9e8439f439fc" title="determines if there are enough command slots for the transaction to be decoded">checkForAvailableCommandSlots()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#00ad45bd632d212ded9605f5488ee147" title="get the next refresh time">nextRefreshTime()</a> </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3e2f574c25d524c1bc76b7948b4f1ea"></a><!-- doxytag: member="DRAMsimII::Channel::nextTransactionDecodeTime" ref="d3e2f574c25d524c1bc76b7948b4f1ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextTransactionDecodeTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determine when the next transaction incomingTransaction the queue will be decoded 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time when the decoding will be complete </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e381469d0f4eb86f98877434078a397"></a><!-- doxytag: member="DRAMsimII::Channel::operator=" ref="7e381469d0f4eb86f98877434078a397" args="(const Channel &amp;rs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp; Channel::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the assignment operator, will copy non-key items to this channel 
<p>
copies the non-reference items over, should be used for deserialization <dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to this channel, for chaining </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="857df39abce2ca631a353b01b618fc36"></a><!-- doxytag: member="DRAMsimII::Channel::operator==" ref="857df39abce2ca631a353b01b618fc36" args="(const Channel &amp;right) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the equality operator, to determine if the channels are equal incomingTransaction value 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the channels are equal </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="7887227e2915a92fa0e2861f85146600"></a><!-- doxytag: member="DRAMsimII::Channel::readAvailableTransaction" ref="7887227e2915a92fa0e2861f85146600" args="(bool) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Channel::readAvailableTransaction           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bufferDelay</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
read a transaction that is ready to go, out of order possibly 
<p>
searches from the head to the end or the decode window to find a transaction that is able to be decoded at the current time <dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the next transaction that can currently be decoded </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f4b7e6a327ff6a00713a4a8124d6c89"></a><!-- doxytag: member="DRAMsimII::Channel::readNextCommand" ref="4f4b7e6a327ff6a00713a4a8124d6c89" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> * Channel::readNextCommand           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a pointer to the command which would be chosen to be executed next 
<p>
chooses a command according to the command ordering algorithm, tries to choose a command which can execute the command returned may not be able to be executed yet, so it is important to check this command is not actually removed from the per bank queues <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a const pointer to the next available command </dd></dl>

</div>
</div><p>
<a class="anchor" name="134ad422666cce6800373f85bf349725"></a><!-- doxytag: member="DRAMsimII::Channel::readNextRefresh" ref="134ad422666cce6800373f85bf349725" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::readNextRefresh           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a pointer to the next refresh transaction that's going to be issued to this channel 
<p>
returns a pointer to a representative object for the next refresh that this channel will see <dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to a representative copy of the next refresh transaction </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="11346a2c4a644e97da954e01a2b664fe"></a><!-- doxytag: member="DRAMsimII::Channel::readTransaction" ref="11346a2c4a644e97da954e01a2b664fe" args="(bool) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::readTransaction           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bufferDelay</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns a pointer to the next transaction to issue to this channel without removing it 
<p>
read the next available transaction for this channel without actually removing it from the queue <br>
 if bufferDelay is set, then only transactions that have been incomingTransaction the queue long enough to decode are considered <dl class="return" compact><dt><b>Returns:</b></dt><dd>the next transaction that should be issued to this channel </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c5c87ed9b458d23a0482410f89536a9"></a><!-- doxytag: member="DRAMsimII::Channel::resetToTime" ref="7c5c87ed9b458d23a0482410f89536a9" args="(const tick time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::resetToTime           </td>
          <td>(</td>
          <td class="paramtype">const tick&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reset some stats to account for the fact that fast-forwarding has moved time forward significantly 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>the time at which the timing model begins </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b45dcd1a06bee01673f50f6b3b3e380"></a><!-- doxytag: member="DRAMsimII::Channel::retireCommand" ref="1b45dcd1a06bee01673f50f6b3b3e380" args="(Command *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::retireCommand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>newestCommand</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
adds this command to the history queue 
<p>
this allows other groups to view a recent history of commands that were issued to decide what to execute next <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="270aa3d8611e3f390b9fcde7498f79ea"></a><!-- doxytag: member="DRAMsimII::Channel::setReadWriteType" ref="270aa3d8611e3f390b9fcde7498f79ea" args="(const int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transaction::TransactionType Channel::setReadWriteType           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rankID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
counts the number of reads and writes so far and returns whichever had more 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rankID</em>&nbsp;</td><td>which rank to look at when determining which transaction type to choose </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3e345bcc7bbe92151f9369638c18dd8"></a><!-- doxytag: member="DRAMsimII::Channel::transaction2commands" ref="c3e345bcc7bbe92151f9369638c18dd8" args="(Transaction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::transaction2commands           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
converts a transaction into corresponding commands 
<p>
takes a transaction and divides it into a number of commands, depending which row buffer management policy is chosen<br>
 currently will divide it into RAS, CAS, Pre or RAS, CAS+P and insert these commands into the per bank queues<br>
 the CAS command will contain a pointer to the host transaction to indicate that a read transaction has available data <dl class="author" compact><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>the transaction which is divided up </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the transaction was able to be divided up and put into per bank queues </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>src/Channel.h<li>src/Channel.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 14 23:56:16 2009 for DRAMSimII by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
