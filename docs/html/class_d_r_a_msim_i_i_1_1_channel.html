<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DRAMSimII: DRAMsimII::Channel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>DRAMsimII</b>::<a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a>
  </div>
</div>
<div class="contents">
<h1>DRAMsimII::Channel Class Reference</h1><!-- doxytag: class="DRAMsimII::Channel" -->
<p>represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Channel.hh&gt;</code></p>

<p>Inherited by <a class="el" href="class_d_r_a_msim_i_i_1_1fbd_channel.html">DRAMsimII::fbdChannel</a><code> [private]</code>.</p>
<div class="dynheader">
Collaboration diagram for DRAMsimII::Channel:</div>
<div class="dynsection">
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_d_r_a_msim_i_i_1_1_channel-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a14a707920dfcf559abd1c48fad84866a">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_settings.html">Settings</a> &amp;settings, const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;sysConfig, <a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;stats)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructs the dramChannel using this settings reference, also makes a reference to the dramSystemConfiguration object  <a href="#a14a707920dfcf559abd1c48fad84866a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#aee673bcc93a9984513a0efb3c42d2d2f">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor, reassigns the ordinal to each rank as they are duplicated  <a href="#aee673bcc93a9984513a0efb3c42d2d2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a45a28d42cc3099f5d967b9a6d298badf">Channel</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;rhs, const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;<a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ac5133db93f637bbbd85872919e778297">systemConfig</a>, <a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;stats)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the copy constructor for building unitialized copies of a channel  <a href="#a45a28d42cc3099f5d967b9a6d298badf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a5f15ebd302464069f1a9e3f0ded14482">~Channel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">channel destructor  <a href="#a5f15ebd302464069f1a9e3f0ded14482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ada774dec2e706f86d1c3364cb6b8d3bb">enqueue</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enqueue the transaction into the transactionQueue  <a href="#ada774dec2e706f86d1c3364cb6b8d3bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65ae17bc6c997287f6337531ed7ef59b"></a><!-- doxytag: member="DRAMsimII::Channel::isFull" ref="a65ae17bc6c997287f6337531ed7ef59b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a65ae17bc6c997287f6337531ed7ef59b">isFull</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines whether there is room for more transactions <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6686ab8add8a9c0fe1a3b3bb029e38b6"></a><!-- doxytag: member="DRAMsimII::Channel::getChannelID" ref="a6686ab8add8a9c0fe1a3b3bb029e38b6" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a6686ab8add8a9c0fe1a3b3bb029e38b6">getChannelID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the ordinal of this channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a600b15ceb9c7c06e75f26a3cf969577b">nextTick</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines when the next transaction is decoded, command ready to be executed or next refresh command arrives  <a href="#a600b15ceb9c7c06e75f26a3cf969577b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7c5c87ed9b458d23a0482410f89536a9">resetToTime</a> (const tick <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ae9426aeb784a6a3fedcf59d8c689a254">time</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset some stats to account for the fact that fast-forwarding has moved time forward significantly  <a href="#a7c5c87ed9b458d23a0482410f89536a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a45aa0482ce88a84d0ad46b12aa5f762e">getPendingTransactions</a> (std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return any transactions that finished when <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a86f558398b775ae647115f2de5394563" title="Moves the specified channel to at least the time given.">moveToTime()</a> was called  <a href="#a45aa0482ce88a84d0ad46b12aa5f762e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a86f558398b775ae647115f2de5394563">moveToTime</a> (const tick currentTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the specified channel to at least the time given.  <a href="#a86f558398b775ae647115f2de5394563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3010ef141c980c8070206174e27dc6f2"></a><!-- doxytag: member="DRAMsimII::Channel::getTimingSpecification" ref="a3010ef141c980c8070206174e27dc6f2" args="() const " -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_timing_specification.html">TimingSpecification</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a3010ef141c980c8070206174e27dc6f2">getTimingSpecification</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a reference to access the timing specification <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c7d8ee5fbf5ca79dd112e3161fe56a1"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="a0c7d8ee5fbf5ca79dd112e3161fe56a1" args="(const unsigned rankNum)" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a0c7d8ee5fbf5ca79dd112e3161fe56a1">getRank</a> (const unsigned rankNum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's rank n <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c9930bd4bc28c8e56712fd36c2a2366"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="a6c9930bd4bc28c8e56712fd36c2a2366" args="(const unsigned rankNum) const " -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a6c9930bd4bc28c8e56712fd36c2a2366">getRank</a> (const unsigned rankNum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a const reference to this channel's rank n <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bff9dc2207e7d3963d57523220c6eaa"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="a0bff9dc2207e7d3963d57523220c6eaa" args="()" -->
std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a0bff9dc2207e7d3963d57523220c6eaa">getRank</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a reference to this channel's ranks <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31fdce469dc9e14f2a25d87913b628fd"></a><!-- doxytag: member="DRAMsimII::Channel::getRank" ref="a31fdce469dc9e14f2a25d87913b628fd" args="() const " -->
const std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a31fdce469dc9e14f2a25d87913b628fd">getRank</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get a const reference to this channel's ranks <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a861366579b98a0c6071612bb8b28d72c"></a><!-- doxytag: member="DRAMsimII::Channel::getTime" ref="a861366579b98a0c6071612bb8b28d72c" args="() const " -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a861366579b98a0c6071612bb8b28d72c">getTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the time that this channel is at <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d959ab956cc8ec9853bd097c4100b58"></a><!-- doxytag: member="DRAMsimII::Channel::getLastRankID" ref="a6d959ab956cc8ec9853bd097c4100b58" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a6d959ab956cc8ec9853bd097c4100b58">getLastRankID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the last rank id a command was issued to <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfc824e8625764da6d626d49e064fa0f"></a><!-- doxytag: member="DRAMsimII::Channel::getTransactionQueueCount" ref="abfc824e8625764da6d626d49e064fa0f" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#abfc824e8625764da6d626d49e064fa0f">getTransactionQueueCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine how many items are in the transaction completion queue <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1729c7902d94d7107ad1c037ac48c61b"></a><!-- doxytag: member="DRAMsimII::Channel::getTransactionQueueDepth" ref="a1729c7902d94d7107ad1c037ac48c61b" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a1729c7902d94d7107ad1c037ac48c61b">getTransactionQueueDepth</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine how large the transaction completion queue is <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaff9e370a63a946599760762979f3763"></a><!-- doxytag: member="DRAMsimII::Channel::setTime" ref="aaff9e370a63a946599760762979f3763" args="(tick value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#aaff9e370a63a946599760762979f3763">setTime</a> (tick value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">update the time for this channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Transaction::TransactionType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a270aa3d8611e3f390b9fcde7498f79ea">setReadWriteType</a> (const int) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">counts the number of reads and writes so far and returns whichever had more  <a href="#a270aa3d8611e3f390b9fcde7498f79ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7e381469d0f4eb86f98877434078a397">operator=</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;rs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the assignment operator, will copy non-key items to this channel  <a href="#a7e381469d0f4eb86f98877434078a397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a857df39abce2ca631a353b01b618fc36">operator==</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;right) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the equality operator, to determine if the channels are equal incomingTransaction value  <a href="#a857df39abce2ca631a353b01b618fc36"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a1b45dcd1a06bee01673f50f6b3b3e380">retireCommand</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds this command to the history queue  <a href="#a1b45dcd1a06bee01673f50f6b3b3e380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a311f351c816f6b817e1d9e8439f439fc">checkForAvailableCommandSlots</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *trans) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines if there are enough command slots for the transaction to be decoded  <a href="#a311f351c816f6b817e1d9e8439f439fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ac3e345bcc7bbe92151f9369638c18dd8">transaction2commands</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">converts a transaction into corresponding commands  <a href="#ac3e345bcc7bbe92151f9369638c18dd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7ccb7a779c25d6eac6c3d6b7bf0d7449">getNextCommand</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *useThisCommand=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">chooses and dequeues the next command to execute  <a href="#a7ccb7a779c25d6eac6c3d6b7bf0d7449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a5476d2960d9e14e5e6481f6d33709df8">getTransaction</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next transaction, whether a refresh transaction or a normal R/W transaction  <a href="#a5476d2960d9e14e5e6481f6d33709df8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a0cc52c572e890e714452bf9fe7dcf524">getAvailableTransaction</a> (unsigned useThis=UINT_MAX)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes and returns the next decodable transaction  <a href="#a0cc52c572e890e714452bf9fe7dcf524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a11346a2c4a644e97da954e01a2b664fe">readTransaction</a> (bool) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the next transaction to issue to this channel without removing it  <a href="#a11346a2c4a644e97da954e01a2b664fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7887227e2915a92fa0e2861f85146600">readAvailableTransaction</a> (bool) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read a transaction that is ready to go, out of order possibly  <a href="#a7887227e2915a92fa0e2861f85146600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#aad689363a5c222dbcc9cc327d1a382cb">createNextRefresh</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next refresh command and remove it from the queue  <a href="#aad689363a5c222dbcc9cc327d1a382cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a134ad422666cce6800373f85bf349725">readNextRefresh</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the next refresh transaction that's going to be issued to this channel  <a href="#a134ad422666cce6800373f85bf349725"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a00ad45bd632d212ded9605f5488ee147">nextRefreshTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the next refresh time  <a href="#a00ad45bd632d212ded9605f5488ee147"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ad3e2f574c25d524c1bc76b7948b4f1ea">nextTransactionDecodeTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine when the next transaction incomingTransaction the queue will be decoded  <a href="#ad3e2f574c25d524c1bc76b7948b4f1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a0e0ba95b7cbf831ee1fda9fd91901906">nextCommandExecuteTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determines the next time available for a command to issue  <a href="#a0e0ba95b7cbf831ee1fda9fd91901906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ac70faefd9c39af71cb67096c00527331">executeCommand</a> (<a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the channel time to what it would be had this command been executed.  <a href="#ac70faefd9c39af71cb67096c00527331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a4f4b7e6a327ff6a00713a4a8124d6c89">readNextCommand</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the command which would be chosen to be executed next  <a href="#a4f4b7e6a327ff6a00713a4a8124d6c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ae530764b1ea3144c32f1ee2f15ec9c89">minProtocolGap</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the protocol gap between a command and current system state  <a href="#ae530764b1ea3144c32f1ee2f15ec9c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a4465dd17290100fa458caa6390ae0a0f">earliestExecuteTime</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the soonest time that this command may execute.  <a href="#a4465dd17290100fa458caa6390ae0a0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a0c8eefcbd0952de5631c22608cc2b7fd">earliestExecuteTimeLog</a> (const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *thisCommand) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the soonest time that this command may execute, tracks the limiting factor.  <a href="#a0c8eefcbd0952de5631c22608cc2b7fd"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9426aeb784a6a3fedcf59d8c689a254"></a><!-- doxytag: member="DRAMsimII::Channel::time" ref="ae9426aeb784a6a3fedcf59d8c689a254" args="" -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ae9426aeb784a6a3fedcf59d8c689a254">time</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">channel time, allow for channel concurrency <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84a76f41ec8743a1f2f6de0c624c4909"></a><!-- doxytag: member="DRAMsimII::Channel::lastCommandIssueTime" ref="a84a76f41ec8743a1f2f6de0c624c4909" args="" -->
tick&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a84a76f41ec8743a1f2f6de0c624c4909">lastCommandIssueTime</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last time a command was executed on this channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b1e46323837bad21da9414e25415fe"></a><!-- doxytag: member="DRAMsimII::Channel::lastCommand" ref="a15b1e46323837bad21da9414e25415fe" args="" -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a15b1e46323837bad21da9414e25415fe">lastCommand</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the last accessed rank of this channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05d8007116bcfff6b9fb6373543bf173"></a><!-- doxytag: member="DRAMsimII::Channel::timingSpecification" ref="a05d8007116bcfff6b9fb6373543bf173" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_timing_specification.html">TimingSpecification</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a05d8007116bcfff6b9fb6373543bf173">timingSpecification</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the timing specs for this channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac2d37d1298f9bb4f1e34f50ee5e25d"></a><!-- doxytag: member="DRAMsimII::Channel::transactionQueue" ref="aeac2d37d1298f9bb4f1e34f50ee5e25d" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_queue.html">Queue</a>&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#aeac2d37d1298f9bb4f1e34f50ee5e25d">transactionQueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transaction queue for the channel <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c87452c47c225b67c046b41feab9479"></a><!-- doxytag: member="DRAMsimII::Channel::refreshCounter" ref="a3c87452c47c225b67c046b41feab9479" args="" -->
std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a3c87452c47c225b67c046b41feab9479">refreshCounter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">holds the next refresh command time for the rank <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5133db93f637bbbd85872919e778297"></a><!-- doxytag: member="DRAMsimII::Channel::systemConfig" ref="ac5133db93f637bbbd85872919e778297" args="" -->
const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ac5133db93f637bbbd85872919e778297">systemConfig</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a pointer to common system config values <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a075b2f3a54ebade3af3e242806259200"></a><!-- doxytag: member="DRAMsimII::Channel::statistics" ref="a075b2f3a54ebade3af3e242806259200" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a075b2f3a54ebade3af3e242806259200">statistics</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">backward pointer to the stats engine <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbbcf58fdd8d251002465261d2a72873"></a><!-- doxytag: member="DRAMsimII::Channel::powerModel" ref="acbbcf58fdd8d251002465261d2a72873" args="" -->
<a class="el" href="class_d_r_a_msim_i_i_1_1_power_config.html">PowerConfig</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#acbbcf58fdd8d251002465261d2a72873">powerModel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the power model for this channel, retains power stats <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fdc981bf6ca993921be2e394d852efa"></a><!-- doxytag: member="DRAMsimII::Channel::channelID" ref="a4fdc981bf6ca993921be2e394d852efa" args="" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a4fdc981bf6ca993921be2e394d852efa">channelID</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the ordinal value of this channel (0..n) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad298e9b41a4bc083b4d20d1635c3e829"></a><!-- doxytag: member="DRAMsimII::Channel::rank" ref="ad298e9b41a4bc083b4d20d1635c3e829" args="" -->
std::vector&lt; <a class="el" href="class_d_r_a_msim_i_i_1_1_rank.html">Rank</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#ad298e9b41a4bc083b4d20d1635c3e829">rank</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of the array of ranks <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80c78098ea16fcfa2d3099f02c6c37ce"></a><!-- doxytag: member="DRAMsimII::Channel::finishedTransactions" ref="a80c78098ea16fcfa2d3099f02c6c37ce" args="" -->
std::queue&lt; std::pair<br class="typebreak"/>
&lt; unsigned, tick &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a80c78098ea16fcfa2d3099f02c6c37ce">finishedTransactions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the transactions finished this time <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>represents a DRAM channel, has individual timing parameters, ranks, banks, clock, etc. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a14a707920dfcf559abd1c48fad84866a"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="a14a707920dfcf559abd1c48fad84866a" args="(const Settings &amp;settings, const SystemConfiguration &amp;sysConfig, Statistics &amp;stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_settings.html">Settings</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sysConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs the dramChannel using this settings reference, also makes a reference to the dramSystemConfiguration object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>settings</em>&nbsp;</td><td>the settings file that defines the number of ranks, refresh policy, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sysConfig</em>&nbsp;</td><td>a const reference is made to this for some functions to grab parameters from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>a reference to the stats object that will be collecting data </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="aee673bcc93a9984513a0efb3c42d2d2f"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="aee673bcc93a9984513a0efb3c42d2d2f" args="(const Channel &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy constructor, reassigns the ordinal to each rank as they are duplicated </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>the dramChannel object to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a45a28d42cc3099f5d967b9a6d298badf"></a><!-- doxytag: member="DRAMsimII::Channel::Channel" ref="a45a28d42cc3099f5d967b9a6d298badf" args="(const Channel &amp;rhs, const SystemConfiguration &amp;systemConfig, Statistics &amp;stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::Channel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_system_configuration.html">SystemConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>systemConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_statistics.html">Statistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the copy constructor for building unitialized copies of a channel </p>
<p>normal copy constructor </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a5f15ebd302464069f1a9e3f0ded14482"></a><!-- doxytag: member="DRAMsimII::Channel::~Channel" ref="a5f15ebd302464069f1a9e3f0ded14482" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Channel::~Channel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>channel destructor </p>
<p>need to remove all the commands in the queues before destructing the channel because some refresh commands are simultaneously in two or more queues and will be duplicated in the command pool if they are not removed properly </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a311f351c816f6b817e1d9e8439f439fc"></a><!-- doxytag: member="DRAMsimII::Channel::checkForAvailableCommandSlots" ref="a311f351c816f6b817e1d9e8439f439fc" args="(const Transaction *trans) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::checkForAvailableCommandSlots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>determines if there are enough command slots for the transaction to be decoded </p>
<p>this will ensure that a given transaction can be broken into and inserted as commands in this channel if there is not enough room according to a given algorithm, then it will indicate that this is not possible </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>trans the transaction to be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is enough room, false otherwise </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>switch to iterator arithmetic </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="aad689363a5c222dbcc9cc327d1a382cb"></a><!-- doxytag: member="DRAMsimII::Channel::createNextRefresh" ref="aad689363a5c222dbcc9cc327d1a382cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::createNextRefresh </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the next refresh command and remove it from the queue </p>
<p>returns a pointer to a refresh transaction that represents what the next refresh <br/>
 transaction would be. this should not be enqueued as it has not been removed yet </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next possible refresh transaction </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a4465dd17290100fa458caa6390ae0a0f"></a><!-- doxytag: member="DRAMsimII::Channel::earliestExecuteTime" ref="a4465dd17290100fa458caa6390ae0a0f" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::earliestExecuteTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the soonest time that this command may execute. </p>
<p>refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk by Jacob/Wang</p>
<p>Looks at all of the timing parameters and decides when the this command may soonest execute </p>

</div>
</div>
<a class="anchor" id="a0c8eefcbd0952de5631c22608cc2b7fd"></a><!-- doxytag: member="DRAMsimII::Channel::earliestExecuteTimeLog" ref="a0c8eefcbd0952de5631c22608cc2b7fd" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::earliestExecuteTimeLog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the soonest time that this command may execute, tracks the limiting factor. </p>
<p>refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk by Jacob/Wang</p>
<p>Looks at all of the timing parameters and decides when the this command may execute soonest </p>

</div>
</div>
<a class="anchor" id="ada774dec2e706f86d1c3364cb6b8d3bb"></a><!-- doxytag: member="DRAMsimII::Channel::enqueue" ref="ada774dec2e706f86d1c3364cb6b8d3bb" args="(Transaction *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enqueue the transaction into the transactionQueue </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>the transaction to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there was room incomingTransaction the queue for this command and the algorithm allowed it, false otherwise </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="ac70faefd9c39af71cb67096c00527331"></a><!-- doxytag: member="DRAMsimII::Channel::executeCommand" ref="ac70faefd9c39af71cb67096c00527331" args="(Command *thisCommand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::executeCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>thisCommand</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the channel time to what it would be had this command been executed. </p>
<p>Updates the rank and bank records of the most recent RAS, CAS, etc. times Enqueues RAS times to allow t_faw to be determined later Updates rank and bank records of CAS, RAS lengths for later calculations in min_protocol_gap() </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thisCommand</em>&nbsp;</td><td>the command to execute at this time </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>let each rank figure out if the command is to it or not by combining issueCAS and issueCASother </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>let each rank figure out if the command is to it or not by combining issueCAS and issueCASother </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a0cc52c572e890e714452bf9fe7dcf524"></a><!-- doxytag: member="DRAMsimII::Channel::getAvailableTransaction" ref="a0cc52c572e890e714452bf9fe7dcf524" args="(unsigned useThis=UINT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::getAvailableTransaction </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>useThis</em> = <code>UINT_MAX</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes and returns the next decodable transaction </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7887227e2915a92fa0e2861f85146600" title="read a transaction that is ready to go, out of order possibly">readAvailableTransaction()</a></dd></dl>
<p>returns a transaction that can be decoded right now in the same way as <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a7887227e2915a92fa0e2861f85146600" title="read a transaction that is ready to go, out of order possibly">readAvailableTransaction()</a>, but actually removes it </p>

</div>
</div>
<a class="anchor" id="a7ccb7a779c25d6eac6c3d6b7bf0d7449"></a><!-- doxytag: member="DRAMsimII::Channel::getNextCommand" ref="a7ccb7a779c25d6eac6c3d6b7bf0d7449" args="(const Command *useThisCommand=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> * Channel::getNextCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>useThisCommand</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>chooses and dequeues the next command to execute </p>
<p>Chooses the command which should be executed next from the given channel Choice is made based on command_ordering_algorithm from system config <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html" title="represents a DRAM command from the memory controller to the DRAMs">Command</a> returned has already been removed from the per_bank_command_queue from which it was selected </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the next command </dd></dl>

</div>
</div>
<a class="anchor" id="a45aa0482ce88a84d0ad46b12aa5f762e"></a><!-- doxytag: member="DRAMsimII::Channel::getPendingTransactions" ref="a45aa0482ce88a84d0ad46b12aa5f762e" args="(std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::getPendingTransactions </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; std::pair&lt; unsigned, tick &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>outputQueue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return any transactions that finished when <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a86f558398b775ae647115f2de5394563" title="Moves the specified channel to at least the time given.">moveToTime()</a> was called </p>
<p>moves results from the internal queue to the given queue </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a queue that has the results in transactionID, finished time pairs </dd></dl>

</div>
</div>
<a class="anchor" id="a5476d2960d9e14e5e6481f6d33709df8"></a><!-- doxytag: member="DRAMsimII::Channel::getTransaction" ref="a5476d2960d9e14e5e6481f6d33709df8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::getTransaction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the next transaction, whether a refresh transaction or a normal R/W transaction </p>
<p>gets the next transaction for this channel and removes it, always returns a transaction that is able to decode </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next transaction for this channel </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="ae530764b1ea3144c32f1ee2f15ec9c89"></a><!-- doxytag: member="DRAMsimII::Channel::minProtocolGap" ref="ae530764b1ea3144c32f1ee2f15ec9c89" args="(const Command *thisCommand) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::minProtocolGap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>currentCommand</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the protocol gap between a command and current system state </p>
<p>old version of the function to check the next available command time, now used to check newer functions and ensure changes don't break timing requirements </p>

<p>Reimplemented in <a class="el" href="class_d_r_a_msim_i_i_1_1fbd_channel.html#ae00da4585914ccdeea1cff8294e9ed69">DRAMsimII::fbdChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a86f558398b775ae647115f2de5394563"></a><!-- doxytag: member="DRAMsimII::Channel::moveToTime" ref="a86f558398b775ae647115f2de5394563" args="(const tick currentTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::moveToTime </td>
          <td>(</td>
          <td class="paramtype">const tick&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the specified channel to at least the time given. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>issue all events up to and including this time </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>continue until no events are processed, no commands issued, no transactions decoded </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>verify that this is right </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a0e0ba95b7cbf831ee1fda9fd91901906"></a><!-- doxytag: member="DRAMsimII::Channel::nextCommandExecuteTime" ref="a0e0ba95b7cbf831ee1fda9fd91901906" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextCommandExecuteTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>determines the next time available for a command to issue </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next time an event occurs on this channel </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a00ad45bd632d212ded9605f5488ee147"></a><!-- doxytag: member="DRAMsimII::Channel::nextRefreshTime" ref="a00ad45bd632d212ded9605f5488ee147" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextRefreshTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the next refresh time </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time at which the next refresh should be issued for this channel </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a600b15ceb9c7c06e75f26a3cf969577b"></a><!-- doxytag: member="DRAMsimII::Channel::nextTick" ref="a600b15ceb9c7c06e75f26a3cf969577b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextTick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>determines when the next transaction is decoded, command ready to be executed or next refresh command arrives </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time when the next event happens </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>readTransactionSimple() <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a4f4b7e6a327ff6a00713a4a8124d6c89" title="returns a pointer to the command which would be chosen to be executed next">readNextCommand()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a4465dd17290100fa458caa6390ae0a0f" title="Returns the soonest time that this command may execute.">earliestExecuteTime()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a311f351c816f6b817e1d9e8439f439fc" title="determines if there are enough command slots for the transaction to be decoded">checkForAvailableCommandSlots()</a> <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html#a00ad45bd632d212ded9605f5488ee147" title="get the next refresh time">nextRefreshTime()</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="ad3e2f574c25d524c1bc76b7948b4f1ea"></a><!-- doxytag: member="DRAMsimII::Channel::nextTransactionDecodeTime" ref="ad3e2f574c25d524c1bc76b7948b4f1ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tick Channel::nextTransactionDecodeTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>determine when the next transaction incomingTransaction the queue will be decoded </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time when the decoding will be complete </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a7e381469d0f4eb86f98877434078a397"></a><!-- doxytag: member="DRAMsimII::Channel::operator=" ref="a7e381469d0f4eb86f98877434078a397" args="(const Channel &amp;rs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp; Channel::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the assignment operator, will copy non-key items to this channel </p>
<p>copies the non-reference items over, should be used for deserialization </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this channel, for chaining </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a857df39abce2ca631a353b01b618fc36"></a><!-- doxytag: member="DRAMsimII::Channel::operator==" ref="a857df39abce2ca631a353b01b618fc36" args="(const Channel &amp;right) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_d_r_a_msim_i_i_1_1_channel.html">Channel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the equality operator, to determine if the channels are equal incomingTransaction value </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the channels are equal </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a7887227e2915a92fa0e2861f85146600"></a><!-- doxytag: member="DRAMsimII::Channel::readAvailableTransaction" ref="a7887227e2915a92fa0e2861f85146600" args="(bool) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Channel::readAvailableTransaction </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bufferDelay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>read a transaction that is ready to go, out of order possibly </p>
<p>searches from the head to the end or the decode window to find a transaction that is able to be decoded at the current time </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the next transaction that can currently be decoded </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4b7e6a327ff6a00713a4a8124d6c89"></a><!-- doxytag: member="DRAMsimII::Channel::readNextCommand" ref="a4f4b7e6a327ff6a00713a4a8124d6c89" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> * Channel::readNextCommand </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to the command which would be chosen to be executed next </p>
<p>chooses a command according to the command ordering algorithm, tries to choose a command which can execute the command returned may not be able to be executed yet, so it is important to check this command is not actually removed from the per bank queues </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a const pointer to the next available command </dd></dl>

</div>
</div>
<a class="anchor" id="a134ad422666cce6800373f85bf349725"></a><!-- doxytag: member="DRAMsimII::Channel::readNextRefresh" ref="a134ad422666cce6800373f85bf349725" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::readNextRefresh </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to the next refresh transaction that's going to be issued to this channel </p>
<p>returns a pointer to a representative object for the next refresh that this channel will see </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a representative copy of the next refresh transaction </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a11346a2c4a644e97da954e01a2b664fe"></a><!-- doxytag: member="DRAMsimII::Channel::readTransaction" ref="a11346a2c4a644e97da954e01a2b664fe" args="(bool) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> * Channel::readTransaction </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bufferDelay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to the next transaction to issue to this channel without removing it </p>
<p>read the next available transaction for this channel without actually removing it from the queue <br/>
 if bufferDelay is set, then only transactions that have been incomingTransaction the queue long enough to decode are considered </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next transaction that should be issued to this channel </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a7c5c87ed9b458d23a0482410f89536a9"></a><!-- doxytag: member="DRAMsimII::Channel::resetToTime" ref="a7c5c87ed9b458d23a0482410f89536a9" args="(const tick time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::resetToTime </td>
          <td>(</td>
          <td class="paramtype">const tick&nbsp;</td>
          <td class="paramname"> <em>time</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>reset some stats to account for the fact that fast-forwarding has moved time forward significantly </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>the time at which the timing model begins </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a1b45dcd1a06bee01673f50f6b3b3e380"></a><!-- doxytag: member="DRAMsimII::Channel::retireCommand" ref="a1b45dcd1a06bee01673f50f6b3b3e380" args="(Command *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Channel::retireCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_command.html">Command</a> *&nbsp;</td>
          <td class="paramname"> <em>newestCommand</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>adds this command to the history queue </p>
<p>this allows other groups to view a recent history of commands that were issued to decide what to execute next </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="a270aa3d8611e3f390b9fcde7498f79ea"></a><!-- doxytag: member="DRAMsimII::Channel::setReadWriteType" ref="a270aa3d8611e3f390b9fcde7498f79ea" args="(const int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transaction::TransactionType Channel::setReadWriteType </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rankID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>counts the number of reads and writes so far and returns whichever had more </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rankID</em>&nbsp;</td><td>which rank to look at when determining which transaction type to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>

</div>
</div>
<a class="anchor" id="ac3e345bcc7bbe92151f9369638c18dd8"></a><!-- doxytag: member="DRAMsimII::Channel::transaction2commands" ref="ac3e345bcc7bbe92151f9369638c18dd8" args="(Transaction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Channel::transaction2commands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_r_a_msim_i_i_1_1_transaction.html">Transaction</a> *&nbsp;</td>
          <td class="paramname"> <em>incomingTransaction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts a transaction into corresponding commands </p>
<p>takes a transaction and divides it into a number of commands, depending which row buffer management policy is chosen<br/>
 currently will divide it into RAS, CAS, Pre or RAS, CAS+P and insert these commands into the per bank queues<br/>
 the CAS command will contain a pointer to the host transaction to indicate that a read transaction has available data </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Joe Gross </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>incomingTransaction</em>&nbsp;</td><td>the transaction which is divided up </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the transaction was able to be divided up and put into per bank queues </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Channel.hh</li>
<li>src/Channel.cc</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Mar 11 22:29:58 2010 for DRAMSimII by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
